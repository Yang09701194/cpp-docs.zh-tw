---
title: ARM64 ABI 慣例概觀
ms.date: 03/27/2019
ms.openlocfilehash: 3a3df475b8f814fcecaf2e67a0a62c7267a0de30
ms.sourcegitcommit: e805200eaef4fe7a65a00051bbd305273af94fe7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2019
ms.locfileid: "74163216"
---
# <a name="overview-of-arm64-abi-conventions"></a>ARM64 ABI 慣例概觀

適用于 Windows 的基本應用程式二進位介面（ABI），會在64位模式（ARMv8 或更新版本的架構）中以 ARM 處理器為基礎進行編譯和執行時，大部分的情況下都會遵循 ARM 的 standard AArch64 EABI。 本文將重點放在 EABI 所記載的一些主要假設和變更。 如需32位 ABI 的詳細資訊，請參閱[ARM ABI 慣例的總覽](overview-of-arm-abi-conventions.md)。 如需標準 ARM EABI 的詳細資訊，請參閱[ARM 架構的應用程式二進位介面（ABI）](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.subset.swdev.abi/index.html) （外部連結）。

## <a name="definitions"></a>定義

隨著64位支援的引進，ARM 已定義數個詞彙：

- **AArch32** –由 ARM 定義的舊版32位指令集架構（ISA），包括 Thumb 模式執行。
- **AArch64** – ARM 所定義的新64位指令集架構（ISA）。
- **ARMv7** –「第7代」 ARM 硬體的規格，其中僅包含對 AArch32 的支援。 此版本的 ARM 硬體是第一個支援 ARM 版本的 Windows。
- **ARMv8** –「第8代」 ARM 硬體的規格，其中包括對 AArch32 和 AArch64 的支援。

Windows 也會使用這些詞彙：

- **ARM** –指的是32位 arm 架構（AArch32），有時也稱為 WoA （WINDOWS on ARM）。
- **ARM32** –與上面的 ARM 相同;為了清楚起見，本檔中使用。
- **ARM64** –指的是64位 ARM 架構（AArch64）。 WoA64 就沒有這樣的東西。

最後，在參考資料類型時，會參考來自 ARM 的下列定義：

- 「**短向量**」–直接以 SIMD 表示的資料類型，這是8個位元組的向量或16個位元組的元素。 其大小會對齊8個位元組或16個位元組，其中每個元素可以是1、2、4或8個位元組。
- **HFA （同質浮點匯總）** –具有2到4個相同浮點成員的資料類型，不論是浮動或雙精度浮點數。
- **HVA （同質的短向量匯總）** –具有2到4個相同短向量成員的資料類型。

## <a name="base-requirements"></a>基本需求

Windows presupposes 的 ARM64 版本，會隨時在 ARMv8 或更新的架構上執行。 浮點和霓虹燈支援都假設在硬體中。

ARMv8 規格描述 AArch32 和 AArch64 的新選擇性加密編譯和 CRC 協助程式 opcode。 其支援目前是選擇性的，但建議使用。 若要利用這些 opcode，應用程式應該先進行執行時間檢查以尋找其是否存在。

## <a name="endianness"></a>位元組序

如同 ARM32 版本的 Windows，ARM64 Windows 上的會以位元組由小到大模式執行。 不需要 AArch64 中的核心模式支援，就能輕易地切換 endian，因此更容易強制執行。

## <a name="alignment"></a>對齊

在 ARM64 上執行的 Windows 可讓 CPU 硬體以透明的方式處理未對齊的存取。 在 AArch32 的改進中，這項支援現在也適用于所有的整數存取（包括多字存取）和浮點存取。

不過，對未快取（裝置）記憶體的存取仍然必須保持一致。 如果程式碼可能會從未快取的記憶體中讀取或寫入未對齊的資料，則必須務必讓所有存取都保持一致。

區域變數的預設版面配置對齊：

| 大小（位元組） | 以位元組為單位對齊 |
| - | - |
| 1 | 1 |
| 2 | 2 |
| 3、4 | 4 |
| > 4 | 8 |

全域和靜態的預設版面配置對齊：

| 大小（位元組） | 以位元組為單位對齊 |
| - | - |
| 1 | 1 |
| 2 - 7 | 4 |
| 8 - 63 | 8 |
| > = 64 | 16 |

## <a name="integer-registers"></a>整數暫存器

AArch64 架構支援32整數暫存器：

| 登錄 | 動態？ | 角色 |
| - | - | - |
| x0 | 動態 | 參數/臨時暫存器1，結果註冊 |
| x1-7 | 動態 | 參數/臨時暫存器2-8 |
| x8-x15 | 動態 | 臨時暫存器 |
| x16-x17 | 動態 | 程式內呼叫的臨時暫存器 |
| x18 | 靜態 | 平臺暫存器：在核心模式中，指向目前處理器的 KPCR;在使用者模式中，指向 TEB |
| x19-x28 | 靜態 | 臨時暫存器 |
| x29/fp | 靜態 | 框架指標 |
| x30/lr | 靜態 | 連結暫存器 |

每個暫存器可以存取為完整64位值（透過 x30）或32位值（透過 w0-w30）。 32-位作業零-將其結果延伸至64位。

如需使用參數暫存器的詳細資訊，請參閱參數傳遞一節。

不同于 AArch32，程式計數器（PC）和堆疊指標（SP）不會編制索引暫存器。 它們的存取方式會受到限制。 另請注意，沒有 x31 註冊。 該編碼會用於特殊用途。

若要與 ETW 和其他服務所使用的快速堆疊流覽相容，則需要框架指標（x29）。 它必須指向堆疊上先前的 {x29，x30} 配對。

## <a name="floating-pointsimd-registers"></a>浮點/SIMD 暫存器

AArch64 架構也支援32浮點/SIMD 暫存器，摘要說明如下：

| 登錄 | 動態？ | 角色 |
| - | - | - |
| v0 | 動態 | 參數/臨時暫存器1，結果註冊 |
| v1-v7 | 動態 | 參數/臨時暫存器2-8 |
| v8-v15 | 靜態 | 臨時暫存器（只有低64位不會變動） |
| v16-v31 | 動態 | 臨時暫存器 |

每個暫存器可以存取為完整128位值（透過 v0-v31 或 q0-q31）。 它可以當作64位值（透過 d0-d31）、32位值（透過 s0-s31）、16位值（透過 h0-h31）或8位值（透過 b0-b31）來存取。 小於128位的存取權只會存取完整128位暫存器的較低位。 除非另有指定，否則不會保留其餘的位。 （AArch64 不同于 AArch32，其中較小的暫存器會封裝在較大的暫存器上方）。

浮點控制暫存器（FPCR）對其內的各種位欄位具有特定需求：

| Bits | 意義 | 動態？ | 角色 |
| - | - | - | - |
| 26 | AHP | 非 Volatile | 替代的半精確度控制項。 |
| 25 | DN | 非 Volatile | 預設的 NaN 模式控制項。 |
| 24 | FZ | 靜態 | 清除為零的模式控制項。 |
| 23-22 | RMode | 靜態 | 進位模式控制項。 |
| 15，12-8 | IDE/IXE/等 | 非 Volatile | 例外狀況設陷啟用 bits，必須一律為0。 |

## <a name="system-registers"></a>系統暫存器

如同 AArch32，AArch64 規格提供三個系統控制的「執行緒識別碼」暫存器：

| 登錄 | 角色 |
| - | - |
| TPIDR_EL0 | 保留的。 |
| TPIDRRO_EL0 | 包含目前處理器的 CPU 數目。 |
| TPIDR_EL1 | 指向目前處理器的 KPCR 結構。 |

## <a name="floating-point-exceptions"></a>浮點例外狀況

對 IEEE 浮點例外狀況的支援在 AArch64 系統上是選擇性的。 對於確實具有硬體浮點例外狀況的處理器變異，Windows 核心會以無訊息模式攔截例外狀況，並在 FPCR 暫存器中隱含停用它們。 此陷阱可確保跨處理器變異的標準化行為。 否則，在沒有例外狀況支援的平臺上開發的程式碼，可能會在支援的平臺上執行時，發現本身會發生非預期的例外狀況。

## <a name="parameter-passing"></a>參數傳遞

對於非 variadic 函式，Windows ABI 會遵循 ARM 針對參數傳遞所指定的規則。 這些規則會直接從 AArch64 架構的程序呼叫標準摘錄自：

### <a name="stage-a--initialization"></a>階段 A –初始化

此階段只會在處理引數開始之前完成一次。

1. 下一個一般用途的暫存器編號（NGRN）會設定為零。

1. 下一個 SIMD 和浮點數暫存器編號（NSRN）設定為零。

1. 下一個堆疊引數位址（NSAA）會設定為目前的堆疊指標值（SP）。

### <a name="stage-b--pre-padding-and-extension-of-arguments"></a>階段 B –引數的預先填補和擴充

針對清單中的每個引數，會套用下列清單中的第一個符合規則。 如果沒有符合的規則，則會使用未修改的引數。

1. 如果引數類型是一種複合類型，其大小無法由呼叫端和被呼叫端以靜態方式決定，則引數會複製到記憶體，而引數會由複本的指標取代。 （C/C++中沒有這類類型，但它們存在於其他語言或語言延伸模組中）。

1. 如果引數類型是 HFA 或 HVA，則會使用未修改的引數。

1. 如果引數類型是大於16個位元組的複合類型，則引數會複製到呼叫端所配置的記憶體，而引數會由複本的指標取代。

1. 如果引數類型是複合類型，則引數的大小會無條件進位到最接近8個位元組的倍數。

### <a name="stage-c--assignment-of-arguments-to-registers-and-stack"></a>階段 C –將引數指派給暫存器和堆疊

針對清單中的每個引數，會依序套用下列規則，直到已配置引數為止。 將引數指派給暫存器時，註冊中任何未使用的位都有未指定的值。 如果將引數指派給堆疊位置，任何未使用的填補位元組都有未指定的值。

1. 如果引數為半、單、雙精度浮點數或四精確度的浮點或短向量類型，且 NSRN 小於8，則引數會配置給 register v\[NSRN] 的最低有效位。 NSRN 會遞增一。 現在已配置引數。

1. 如果引數是 HFA 或 HVA，而且有足夠的未配置 SIMD 和浮點暫存器（NSRN + 成員數目≤8），則引數會配置給 SIMD 和浮點數暫存器，每個 HFA 或 HVA 成員一個暫存器。 NSRN 會以所使用的暫存器數目遞增。 現在已配置引數。

1. 如果引數是 HFA 或 HVA，則 NSRN 會設定為8，而引數的大小會無條件進位到最接近8個位元組的倍數。

1. 如果引數是 HFA、HVA、四精確度浮點或短向量類型，則 NSAA 會無條件進位至較大的8或引數類型的自然對齊。

1. 如果引數是半或單精確度浮點數類型，則引數的大小會設定為8個位元組。 其效果就如同引數已複製到64位暫存器的最低有效位，以及填入未指定值的剩餘位。

1. 如果引數是 HFA、HVA、半形、單精確度浮點數或四精確度浮點或短向量類型，則引數會複製到已調整之 NSAA 的記憶體中。 NSAA 會增加引數的大小。 現在已配置引數。

1. 如果引數是整數或指標類型，則引數的大小小於或等於8個位元組，而 NGRN 小於8，則引數會複製到 x\[NGRN] 中最不重要的位。 NGRN 會遞增一。 現在已配置引數。

1. 如果引數的對齊是16，則 NGRN 會無條件進位到下一個偶數。

1. 如果引數是整數類資料類型，則引數的大小等於16，而 NGRN 小於7，引數會複製到 x\[NGRN] 和 x\[NGRN + 1]。 x\[NGRN] 必須包含引數之記憶體標記法的低定址雙字組。 NGRN 會遞增2。 現在已配置引數。

1. 如果引數是複合類型，且引數的雙單字大小不超過8減去 NGRN，則引數會複製到連續的一般用途暫存器中，從 x\[NGRN] 開始。 引數的傳遞方式就好像已從雙字對齊的位址載入暫存器，以及適當的 LDR 指令序列，可從記憶體載入連續的暫存器。 此標準不會指定任何未使用的暫存器部分內容。 NGRN 會以所使用的暫存器數目遞增。 現在已配置引數。

1. NGRN 會設定為8。

1. NSAA 會進位至較大的8或引數類型的自然對齊。

1. 如果引數是複合類型，則會在已調整的 NSAA 將引數複製到記憶體中。 NSAA 會增加引數的大小。 現在已配置引數。

1. 如果引數的大小小於8個位元組，則引數的大小會設定為8個位元組。 其效果就如同將引數複製到64位暫存器的最低有效位一樣，其餘的位也會填入未指定的值。

1. 引數會以已調整的 NSAA 複製到記憶體中。 NSAA 會增加引數的大小。 現在已配置引數。

### <a name="addendum-variadic-functions"></a>增補： Variadic 函式

採用可變引數數目的函式的處理方式與上述不同，如下所示：

1. 所有複合的處理方式都一樣;HFAs 或 Hva 沒有特殊的處理方式。

1. 不使用 SIMD 和浮點數暫存器。

實際上，它與下列規則相同： C. 12 – C. 15 會將引數配置給虛數堆疊，其中堆疊的前64個位元組會載入至7，而任何剩餘的堆疊引數則會正常放置。

## <a name="return-values"></a>傳回值

整數值會在 x0 中傳回。

浮點值會適當地在 s0、d0 或 v0 中傳回。

HFA 和 HVA 值會適當地在 s0-s3、d0-d3 或 v0 中傳回。

根據值傳回的類型會以不同的方式處理，視它們是否有特定屬性而定。 具有所有這些屬性的類型，

- 它們是由 c + + 14 標準定義進行*匯總*，也就是沒有任何使用者提供的函式、私用或受保護的非靜態資料成員、沒有基類，而且沒有虛擬函式，以及
- 它們具有簡單的複製指派運算子，而
- 它們具有簡單的析構函式，

使用下列傳回樣式：

- 小於或等於8個位元組的類型會在 x0 中傳回。
- 小於或等於16個位元組的類型會以 x0 和 x1 傳回，其中的 x0 包含較低順序的8個位元組。
- 對於大於16個位元組的類型，呼叫端應保留足夠大小和對齊的記憶體區塊來保存結果。 記憶體區塊的位址應以其他引數的形式傳遞至 x8 中的函數。 被呼叫者可能會在執行副程式期間的任何時間點修改結果記憶體區塊。 被呼叫端不需要保留儲存在 x8 中的值。

所有其他類型都使用此慣例：

- 呼叫端應保留足夠大小和對齊的記憶體區塊來保存結果。 在 x0 中，記憶體區塊的位址應當做額外的引數傳遞給函數，如果是以 x0 傳遞 $this，則為 x1。 被呼叫者可能會在執行副程式期間的任何時間點修改結果記憶體區塊。 被呼叫端會傳回 x0 中記憶體區塊的位址。

## <a name="stack"></a>堆疊

在 ARM 後面的 ABI 之後，堆疊必須維持16位元組的一致狀態。 AArch64 包含硬體功能，可在每次 SP 不是16位元組的對齊，而且 SP 相對負載或儲存區完成時，產生堆疊對齊錯誤。 Windows 會在隨時啟用此功能的情況下執行。

配置4k 或更多值得一提堆疊的函式，必須確保最後一頁之前的每一頁都依序觸及。 此動作可確保不會有任何程式碼「超越」 Windows 用來展開堆疊的防護頁面。 這通常是由 `__chkstk` 協助程式完成，其具有自訂呼叫慣例，會傳遞 x15 中的總堆疊配置除以16。

## <a name="red-zone"></a>紅色區域

緊接在目前堆疊指標正下方的16位元組區域會保留供分析和動態修補案例使用。 這個區域可讓您小心產生要插入的程式碼，這會將兩個暫存器儲存在 [sp，#-16] 上，並暫時用於任意用途。 Windows 核心可保證在使用者和核心模式中發生例外狀況或中斷時，不會覆寫這些16個位元組。

## <a name="kernel-stack"></a>核心堆疊

Windows 中的預設核心模式堆疊是六頁（24k）。 以核心模式針對具有大型堆疊緩衝區的函式，特別注意。 不正確的時間間隔可能會有極少的空間，並建立堆疊死機錯誤檢查。

## <a name="stack-walking"></a>堆疊流覽

Windows 中的程式碼會以已啟用的框架指標（[/Oy-](reference/oy-frame-pointer-omission.md)）編譯，以啟用快速堆疊的流覽。 一般來說，x29 （fp）會指向鏈中的下一個連結，也就是 {fp，lr} 組，指出堆疊上的上一個框架和傳回位址的指標。 建議使用協力廠商程式碼來同時啟用框架指標，以提供更佳的分析和追蹤功能。

## <a name="exception-unwinding"></a>例外狀況回溯

在例外狀況處理期間回溯會透過使用回溯代碼來協助。 回溯程式碼是儲存在可執行檔之 .xdata 區段中的位元組序列。 它們會以抽象的方式描述序言和結尾的作業，因此函式序言的影響可以在準備備份至呼叫端的堆疊框架時復原。 如需回溯程式碼的詳細資訊，請參閱[ARM64 例外狀況處理](arm64-exception-handling.md)。

ARM EABI 也會指定使用回溯程式碼的例外狀況回溯模型。 不過，呈現的規格不足以用於 Windows 中的回溯，這必須處理電腦位於函式序言或結尾中間的情況。

動態產生的程式碼應該透過 `RtlAddFunctionTable` 和相關聯的函式來與動態函式資料表一併描述，讓產生的程式碼可以參與例外狀況處理。

## <a name="cycle-counter"></a>Cycle 計數器

所有 ARMv8 的 Cpu 都必須支援迴圈計數器暫存器，這是 Windows 設定為可在任何例外狀況層級讀取的64位暫存器，包括使用者模式。 您可以使用程式碼中的 MSR opcode 或 C/C++ code 中的 `_ReadStatusReg` 內建，透過特殊的 PMCCNTR_EL0 暫存器來存取它。

這裡的 cycle 計數器是一個真正的週期計數器，而不是牆時鐘。 計算頻率會隨著處理器頻率而有所不同。 如果您覺得您必須知道「週期」計數器的頻率，則不應該使用「週期」計數器。 相反地，您會想要測量時鐘時間，您應該使用 `QueryPerformanceCounter`。

## <a name="see-also"></a>請參閱

[Visual C++ ARM 移轉時常見的問題](common-visual-cpp-arm-migration-issues.md)<br/>
[ARM64 例外狀況處理](arm64-exception-handling.md)
