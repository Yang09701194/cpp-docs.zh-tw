---
title: Visual C++ ARM 移轉時常見的問題
ms.date: 11/04/2016
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 6aea623bc9f096265decbe91ccdc5d5f1f6ecef1
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/31/2018
ms.locfileid: "50618503"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ ARM 移轉時常見的問題

在使用 Microsoft Visual c + + (MSVC) 時，相同的 c + + 原始程式碼可能會產生不同的結果，在 ARM 架構上，不一定需要 x86 或 x64 架構上。

## <a name="sources-of-migration-issues"></a>移轉問題的來源

從 x86 或 x64 架構移轉至 ARM 架構的程式碼時，可能會遇到的許多問題都與原始碼建構，可能會叫用未定義、 實作定義，或未指定的行為。

*未定義的行為*是 c + + 標準並未定義的行為，而且所造成的操作都沒有合理的結果： 例如，將浮點值轉換成帶正負號的整數，或移位的位置數的值為負數，或超過在升級後的類型中的位元數。

*實作定義行為*是 c + + 標準需要編譯器廠商，以定義和文件中的行為。 程式可以安全地仰賴實作定義的行為，即使這麼做，可能不是可攜式。 實作定義行為的範例包括內建資料類型和其對齊需求的大小。 作業可能會受影響的實作定義行為的範例存取變數引數清單。

*未指定行為*是 c + + 標準保留刻意不具決定性的行為。 雖然行為會被視為不具決定性，特定的引動過程的未指定的行為會取決於編譯器實作。 不過，編譯器廠商，以預先決定的結果，或是保證一致的行為，可比較的引動過程，之間不需要而且沒有文件的需求。 未指定的範例是行為的子運算式，其中包含函式呼叫的引數，都行為的計算的順序。

其他移轉的問題可歸咎於 ARM 和 x86 或 x64 架構，以不同的方式與 c + + 標準互動的硬體差異。 比方說，x86 和 x64 架構的強式的記憶體模型給`volatile`-限定變數以便特定種類的執行緒間通訊，在過去曾使用的一些其他屬性。 但 ARM 架構的弱式記憶體內部模型中不支援這種使用，也不的 c + + 標準需要它。

> [!IMPORTANT]
>  雖然`volatile`提升可用來在 x86 和 x64，這些額外的屬性上實作受限的形式執行緒間通訊的某些屬性並不足夠實作間執行緒通訊一般。 C + + 標準建議改為使用適當的同步處理原始物件實作，這類通訊。

由於不同的平台可能會以不同方式表示這種行為，因此軟體平台之間移植可能既困難又 bug 容易發生如果它相依於特定的平台的行為。 雖然這種行為的許多可以觀察到，而且可能會出現穩定，依賴它們是至少不可移植，而在未定義或未指定行為的情況下，也是錯誤。 即使本文件中所述的行為不可靠，也可能在未來變更編譯器或 CPU 的實作。

## <a name="example-migration-issues"></a>範例移轉問題

本文件的其餘部分將說明這些 c + + 語言項目不同的行為可以列印文件的產生，請在不同的平台上不同的結果。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>不帶正負號的整數浮點轉換

在 ARM 架構上的浮點值轉換為 32 位元整數飽和到接近可以代表整數的範圍之外的浮點值時，可以代表整數的值。 在 x86 和 x64 架構，則轉換會環繞如果整數是不帶正負號，或如果已簽署的整數設定為-2147483648。 沒有這些架構直接支援浮點值的轉換為較小的整數類型;相反地，32 位元，會進行轉換，結果會截斷成較小的大小。

適用於 ARM 架構，飽和度和截斷的組合表示它飽和的 32 位元整數，但產生的值大於截斷的結果時，轉換成不帶正負號的類型正確飽和較小的帶正負號的類型要使之飽和的完整的 32 位元整數，較小的類型可以表示但太小。 轉換也飽和正確的 32 位元帶正負號的整數，但截斷飽和、 帶正負號的整數會產生正面飽和的值為-1 和負面飽和的值為 0。 較小的帶正負號整數的轉換會產生無法預期的截斷的結果。

適用於 x86 和 x64 架構中，循環的不帶正負號的整數轉換的行為與帶正負號的整數溢位時，截斷，以及的轉換的明確價值的組合進行大部分的排班的結果有無法預期太大。

這些平台上也有不同 NaN (Not a Number) 轉換為整數型別的處理方式。 在 ARM，NaN 將轉換為 0x00000000;在 x86 和 x64 上，它會將轉換為 0x80000000。

浮點轉換只需要上，如果您知道的值是轉換成整數類型的範圍內。

### <a name="shift-operator---behavior"></a>移位運算子 (\< \< >>) 行為

在 ARM 架構中，值可以轉移左或向右達 255 的位元模式開始，重複前。 在 x86 和 x64 架構上的模式，便會重複 32 的每個倍數的來源模式的 64 位元變數中; 除非在此情況下，在 x64 和 x86，其中運用軟體實作的 256 的每個倍數的 64 上的每個多個相同的模式。 比方說，針對 32 位元變數具有 32 的位置向左移位 1 的值，在 ARM 上結果為 0，在 x86 上的結果為 1，且在 x64 上的結果也是 1。 不過，如果值的來源是 64 位元變數，然後所有的三個平台上的結果為 4294967296，而且值不會 「 循環 」 直到它改變了 64 的位置在 x64 或 256 個在 ARM 和 x86。

因為超過來源型別中的位元數的移位運算的結果是未定義，編譯器不需要在所有情況下有一致的行為。 比方說，如果在編譯時期已知的變化，這兩個運算元，編譯器可能會最佳化程式使用內部的常式預先計算的排班的結果，而且然後替代取代移位運算的結果。 如果移位量太大，或負數，內部的例行工作的結果可能不同於相同的 shift 運算式的結果，由 CPU 執行。

### <a name="variable-arguments-varargs-behavior"></a>變數引數 (varargs) 的行為

在 ARM 架構中，從變數引數清單會在堆疊傳遞的參數會受到對齊方式。 比方說，64 位元的參數是在 64 位元界限上對齊。 在 x86 和 x64 上，會在堆疊傳遞的引數不會對齊和組件緊密。 這項差異可能會導致 variadic 函式，例如`printf`讀取記憶體位址所要做為填補字元，在 ARM 上如果預期的變數引數清單的配置不相符，即使它可能會在 x86 上運作的某些值的子集或 x64 架構。 請考量以下範例：

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

在此情況下，可以藉由確定正確的格式規格，使用，因此會被視為引數的對齊方式修正 bug。 此程式碼是正確的：

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>引數的評估順序

因為 ARM，arm、x86 和 x64 處理器不同，因此，它們可以呈現不同的需求，以編譯器的實作，以及不同最佳化的機會。 基於這個原因，以及其他因素，例如呼叫慣例和最佳化設定，編譯器可能會評估不同的順序，在不同的架構或其他因素變更時的函式引數。 這會造成依賴特定評估順序意外地改變應用程式的行為。

函式引數會影響到相同的呼叫中的函式的其他引數的副作用，就會發生這種錯誤。 通常這類相依性是容易避免，但是它可以有時會被遮蔽很難分辨，相依性或運算子多載。 請考慮這個程式碼範例：

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

這會顯示經過明確定義，但若是`->`和`*`不多載的運算子，則此程式碼會轉譯成看起來像這樣：

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

之間的相依性是否`operator->(memory_handle)`和`operator*(p)`、 程式碼可能會依賴特定評估順序，即使原來的程式碼看起來像是沒有任何可能的相依性。

### <a name="volatile-keyword-default-behavior"></a>volatile 關鍵字的預設行為

MSVC 編譯器支援的兩個不同的方式解讀`volatile`您可以使用編譯器參數指定的儲存體限定詞。 [/Volatile: ms](../build/reference/volatile-volatile-keyword-interpretation.md)切換選取 Microsoft 擴充變動性保證強式排序的語意，因為這些架構的強式的記憶體模型已經傳統的情況下，適用於 x86 和 x64。 [/Volatile:iso](../build/reference/volatile-volatile-keyword-interpretation.md)切換選取的嚴格 c + + 標準 volatile 語意，不保證強式的順序。

在 ARM 架構中，預設值是 **/volatile:iso**因為 ARM 處理器需要弱式排序記憶體模型，以及因為 ARM 軟體沒有舊版的信賴憑證者的擴充語意 **/volatile: ms**和通常沒有以便與軟體。 不過，它是仍然有時方便或甚至必須編譯 ARM 程式使用擴充的語意。 比方說，它可能是移植程式以使用 ISO c + + 語意，代價太高，或驅動程式軟體可能要遵守的傳統的語意，才能正確運作。 在這些情況下，您可以使用 **/volatile: ms**交換器; 不過，若要重新建立 ARM 目標上的傳統變動性的語意，編譯器必須插入每個讀取或寫入的周圍的記憶體屏障`volatile`變數，以強制執行強式的順序，這可能對效能造成負面影響。

在 x86 和 x64 架構中，預設值是 **/volatile: ms**因為大部分的軟體，已建立的這些架構使用 MSVC 依賴它們。 當您編譯 x86 和 x64 的程式時，您可以指定 **/volatile:iso**交換器，以協助避免不必要依賴傳統的變動性語意，並提升可攜性。

## <a name="see-also"></a>另請參閱

[針對 ARM 處理器設定 Visual C++](../build/configuring-programs-for-arm-processors-visual-cpp.md)
