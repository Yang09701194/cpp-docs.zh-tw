---
title: Visual C++ ARM 移轉時常見的問題
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 2c29b4ffa5344b309622314970ce52c47a0ebd05
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328802"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ ARM 移轉時常見的問題

使用 Microsoft C++ 編譯器 (MSVC) 時,相同的 C++原始碼在 ARM 體系結構上產生的結果可能與 x86 或 x64 體系結構的結果不同。

## <a name="sources-of-migration-issues"></a>移徙問題的根源

將代碼從 x86 或 x64 體系結構遷移到 ARM 體系結構時可能會遇到許多問題都與可能調用未定義、實現定義或未指定行為的原始碼建構相關。

*未定義的行為*是C++標準未定義的行為,是由沒有合理結果的操作引起的:例如,將浮點值轉換為未簽名整數,或將值按若干位置移動,這些位置為負或超過其升級類型中的位數。

*實現定義的行為*是C++標準要求編譯器供應商定義和記錄的行為。 程式可以安全地依賴於實現定義的行為,即使這樣做可能不是可移植的。 實現定義行為的範例包括內建數據類型的大小及其對齊要求。 可能受實現定義行為影響的操作的一個範例是造訪變數參數清單。

*未指定的行為*是C++標準故意留下非確定性的行為。 儘管該行為被視為非確定性行為,但未指定行為的特定調用由編譯器實現決定。 但是,編譯器供應商不需要預先確定結果或保證可比調用之間的一致行為,也不需要文檔。 未指定行為的一個範例是計算子運算式(包括函數調用的參數)的順序。

其他遷移問題可歸因於 ARM 和 x86 或 x64 體系結構之間的硬體差異,這些體系結構與C++標準交互的方式不同。 例如,x86 和 x64 體系結構的強記憶體`volatile`模型提供了一些附加屬性,這些屬性過去曾用於促進某些類型的線程間通信。 但是 ARM 體系結構的弱記憶體模型不支援此用途,C++標準也不要求它。

> [!IMPORTANT]
> 儘管`volatile`獲得了一些可用於在 x86 和 x64 上實現有限形式的線程間通信的屬性,但這些附加屬性通常不足以實現線程間通信。 C++標準建議使用適當的同步基元來實現此類通信。

由於不同的平臺可能會以不同的方式表達此類行為,因此,如果依賴於特定平台的行為,則在平臺之間移植軟體可能很困難且容易出錯。 儘管可以觀察到許多此類行為,並且可能保持穩定,但依賴它們至少不可移植,在未定義或未指定行為的情況下,也是一個錯誤。 即使本文件中引用的行為也不應依賴,並且將來的編譯器或 CPU 實現可能會發生變化。

## <a name="example-migration-issues"></a>移動問題範例

本文檔的其餘部分介紹這些C++語言元素的不同行為如何在不同的平臺上產生不同的結果。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>將浮點轉換為未簽署整數

在 ARM 體系結構上,將浮點值轉換為 32 位整數飽和到最接近的值,如果浮點值超出整數可以表示的範圍,則整數可以表示該值。 在 x86 和 x64 體系結構上,如果整數未簽名,則轉換將環繞,或者如果對整數進行了簽名,則轉換設置為 -2147483648。 這些體系結構都沒有直接支援將浮點值轉換為較小的整數類型;相反,轉換將執行到 32 位元,結果被截斷為較小的大小。

對於 ARM 體系結構,飽和度和截斷的組合意味著,當 32 位整數飽和時,轉換為未簽名類型會正確飽和較小的無符號類型,但對於大於較小類型可以表示但太小且無法飽和完整 32 位整數的值,將生成截斷結果。 轉換對於 32 位簽名整數也正確飽和,但飽和、已簽名整數的截斷會導致正飽和值為 -1,負飽和值為 0。 轉換為較小的簽名整數會產生不可預知的截斷結果。

對於 x86 和 x64 體系結構,未簽名整數轉換的環繞行為和溢出上簽名整數轉換的明確評估以及截斷相結合,使大多數移位的結果如果太大,則會導致無法預測的結果。

這些平台在處理 NaN(非數位)轉換為整數類型的方式上也有所不同。 在 ARM 上,NaN 轉換為 0x00000000;在 ARM 上,NaN 轉換為 0x00000000;在 x86 和 x64 上,它轉換為 0x800000000。

只有當您知道該值在要轉換為的整數類型範圍內時,才能依賴浮點轉換。

### <a name="shift-operator---behavior"></a>移位作業員\<\<( >>)行為

在 ARM 架構結構上,在模式開始重複之前,可以將值向左或向右移動最多 255 位。 在 x86 和 x64 體系結構上,模式在 32 的每個倍數上重複,除非模式的源是 64 位變數;否則模式的源為 64 位元變數。在這種情況下,模式在 x64 上每 64 個倍數重複,在 x86 上重複每個 256 的倍數,其中使用了軟體實現。 例如,對於值為 1 左移動 32 個位置的 32 位變數,在 ARM 上,結果為 0,在 x86 上,結果為 1,在 x64 上,結果也是 1。 但是,如果值的來源是 64 位變數,則所有三個平臺上的結果為 4294967296,並且該值在 x64 上移動 64 個位置或 ARM 和 x86 上的 256 位置之前不會「環繞」。

由於超過源類型中位數的移位操作的結果未定義,因此編譯器不需要在所有情況下具有一致的行為。 例如,如果在編譯時知道移位的兩個操作數,編譯器可以使用內部例程預先計算移位結果,然後替換結果來代替移位操作來優化程式。 如果移位量過大或負數,則內部例程的結果可能與 CPU 執行的相同移位表達式的結果不同。

### <a name="variable-arguments-varargs-behavior"></a>變數參數(參數)行為

在 ARM 架構結構上,在堆疊上傳遞的變數參數清單中的參數需要對齊。 例如,64 位元參數在64位邊界上對齊。 在 x86 和 x64 上,在堆疊上傳遞的參數不受對齊和打包的約束。 如果變數參數清單的預期佈局不完全匹配,則`printf`此差異可能導致類似於讀取用於 ARM 上的填充的記憶體位址等可變數,即使它可能適用於 x86 或 x64 體系結構上某些值的子集。 請思考此範例：

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will "parse" the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

在這種情況下,可以通過確保使用正確的格式規範來修復 Bug,以便考慮參數的對齊方式。 此代碼正確:

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>參數評看順序

由於 ARM、x86 和 x64 處理器非常不同,因此它們可以為編譯器實現提出不同的要求,也可以提供不同的優化機會。 因此,與調用約定和優化設置等其他因素一起,編譯器可能會在不同的體系結構上或當其他因素發生更改時,以不同順序計算函數參數。 這可能導致依賴於特定評估順序的應用的行為意外更改。

當函數的參數具有影響同一調用中函數的其他參數的副作用時,可能會出現此類錯誤。 通常,這種依賴性很容易避免,但有時可能會被難以識別的依賴項或運算符重載所掩蓋。 請考慮以下代碼範例:

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

這似乎定義良好,但如果`->`和`*`運算元過載,則此代碼將轉換為類似於這種情況的內容:

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

如果`operator->(memory_handle)``operator*(p)`和 之間存在依賴項,則代碼可能依賴於特定的評估順序,即使原始代碼看起來沒有可能的依賴項。

### <a name="volatile-keyword-default-behavior"></a>易失性關鍵字預設行為

MSVC 編譯器支援儲存限定符`volatile`的 兩種不同的解釋,您可以使用編譯器開關來指定這些解釋。 [/volatile:ms](reference/volatile-volatile-keyword-interpretation.md)開關選擇 Microsoft 擴展的易失性語義,保證強大的排序,x86 和 x64 的傳統情況就是一樣,因為這些體系結構上的強記憶體模型。 [/volatile:iso](reference/volatile-volatile-keyword-interpretation.md)開關選擇嚴格C++標準易失性語義,這些語義不能保證強排序。

在 ARM 體系結構上,預設值為 **/volatile:iso,** 因為 ARM 處理器的記憶體模型順序較弱,而且 ARM 軟體沒有依賴 **/volatile:ms**的擴展語義的傳統,並且通常不必與該軟體介面。 但是,編譯 ARM 程式以使用擴展語義有時仍然很方便,甚至需要。 例如,移植程式以使用 ISO C++語義可能成本太高,或者驅動程式軟體可能必須遵守傳統語義才能正常運行。 在這些情況下,可以使用 **/volatile:ms**開關;但是,要在 ARM 目標上重新創建傳統的易失性語義,編譯器`volatile`必須在變數的每個讀取或寫入周圍插入記憶體障礙,以強制實施強排序,這可能會對性能產生負面影響。

在 x86 和 x64 體系結構上,預設值為 **/volatile:ms,** 因為透過使用 MSVC 已經為這些體系結構創建的許多軟體都依賴於它們。 編譯 x86 和 x64 程式時,可以指定 **/volatile:iso**開關,以説明避免不必要地依賴傳統的易失性語義,並促進可移植性。

## <a name="see-also"></a>另請參閱

[針對 ARM 處理器設定 Visual C++](configuring-programs-for-arm-processors-visual-cpp.md)
