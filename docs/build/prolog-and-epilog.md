---
title: x64 初構和終解
ms.date: 12/17/2018
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
ms.openlocfilehash: be6a344b75fdc0cbc1876a250d0cc326bae43ccc
ms.sourcegitcommit: bff17488ac5538b8eaac57156a4d6f06b37d6b7f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/05/2019
ms.locfileid: "57418590"
---
# <a name="x64-prolog-and-epilog"></a>x64 初構和終解

配置堆疊空間，每個函式，呼叫其他函式，將儲存靜態暫存器，或使用例外狀況處理必須初構其位址的限制詳述於個別的函式表項目相關聯的回溯資料。 如需詳細資訊，請參閱 < [x64 例外狀況處理](../build/exception-handling-x64.md)。 初構會儲存在他們的住家地址中的暫存器如有必要，將靜態暫存器堆疊上推入、 區域變數和暫存檔，配置堆疊的固定的部分和選擇性地建立框架指標的引數。 相關聯的回溯資料必須描述初構的動作，而且必須提供要復原的初構程式碼的效果所需的資訊。

超過一頁是否包含在堆疊中的固定的配置 (也就是大於 4096 個位元組)，則堆疊配置可能會一個以上的虛擬記憶體分頁，因此，配置必須檢查之前就會配置。 針對此用途提供特殊的常式，可從初構呼叫，而且這不會終結任何引數暫存器。

正在儲存靜態暫存器的慣用的方法是將它們移至固定的堆疊配置之前，先堆疊。 如果儲存靜態暫存器之前，先執行固定的堆疊配置，則最有可能的 32 位元移動則需要以解決儲存的暫存器區域。 （stage，推入暫存器是最快的速度移動，並應持續下去可預見的未來，儘管推送之間隱含的相依性）。可以依任何順序儲存靜態暫存器。 不過，第一次使用初構中的靜態暫存器必須將它儲存。

## <a name="prolog-code"></a>初構程式碼

可能是一般的初構程式碼：

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    sub    RSP, fixed-allocation-size
    lea    R13, 128[RSP]
    ...
```

本初構會將引數暫存器 RCX 儲存在其所在的位置，將靜態註冊 R13 R15、 配置的堆疊框架，固定的部分，並建立指向 128 個位元組的固定的配置區域的框架指標。 使用位移，可讓多個的固定的配置區域，來處理單位元組位移。

如果固定的配置的大小大於或等於一頁的記憶體，則必須在修改 RSP 之前呼叫的 helper 函式。 此協助程式， `__chkstk`，探查要配置堆疊範圍，以確保會正確地擴充堆疊。 在此情況下前, 一個範例中，初構會改為：

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    mov    RAX,  fixed-allocation-size
    call   __chkstk
    sub    RSP, RAX
    lea    R13, 128[RSP]
    ...
```

`__chkstk`協助程式不會修改任何暫存器 R10、 R11 及條件程式碼除外。 特別是，它將會傳回 RAX 保持不變，並保留所有靜態暫存器和引數傳遞未經修改的暫存器。

## <a name="epilog-code"></a>終解程式碼

終解程式碼存在於每個函式結束。 而沒有通常只有一個的初構，可能會有許多終。 終解程式碼 （如有必要），修剪固定的配置大小的堆疊、 取消配置固定的堆疊配置、 還原靜態暫存器拉出已儲存的值從堆疊，並傳回。

終解程式碼必須遵循一組嚴格的回溯程式碼的規則，才能可靠地回溯例外狀況和插斷。 這些規則減少的回溯資料所需，因為不需要任何額外的資料，來描述每個終解。 相反地，回溯程式碼可以判斷終解正在執行的掃描來識別終解程式碼資料流。

如果沒有框架指標會在函式，則終解必須先解除配置堆疊的固定的部分、 靜態暫存器會彈出，和將控制項傳回給呼叫的函式。 例如，套用至物件的

```MASM
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

如果框架指標會在函式，將堆疊必須修剪成終執行前的固定配置。 此動作是就技術上而言不是終解的一部分。 例如，下列終解無法用來復原先前用過的初構中：

```MASM
    lea      RSP, -128[R13]
    ; epilogue proper starts here
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

在實務上，使用框架指標時，沒有任何理由在兩個步驟中，調整 RSP，因此會改為使用下列的終解：

```MASM
    lea      RSP, fixed-allocation-size - 128[R13]
    pop      R13
    pop      R14
    pop      R15
    ret
```

這些表單是唯一合法的終解。 它必須包含其中一個`add RSP,constant`或是`lea RSP,constant[FPReg]`，後面接著一系列的零或多個 8 位元暫存器 pop 和`return`或`jmp`。 (只有部分`jmp`所允許終解中的陳述式。 子集是專門的類別`jmp`ModRM 記憶體參考其中 ModRM mod 欄位值是 00 的陳述式。 使用`jmp`終解 ModRM 01 或 10 的 mod 欄位值禁止使用中的陳述式。 請參閱 AMD x86 64 架構程式設計人員手動磁碟區 3 中的資料表 A-15:一般用途和系統的指示，如需詳細資訊，可允許 ModRM 參考。）沒有其他程式碼可能會出現。 特別的是，不可以排定在終解，包括傳回值的載入。

不使用框架指標時，必須使用終解`add RSP,constant`解除配置堆疊的固定的部分。 可能不會佔用`lea RSP,constant[RSP]`改。 這項限制存在，所以回溯程式碼有較少的模式，以辨識終搜尋時。

遵循這些規則可讓回溯程式碼來判斷終解目前正在執行，以及模擬，以便重新建立的內容呼叫的函式終解其餘的執行。

## <a name="see-also"></a>另請參閱

[x64 軟體慣例](../build/x64-software-conventions.md)
