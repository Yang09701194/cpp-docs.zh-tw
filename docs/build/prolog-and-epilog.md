---
title: x64 初構和終解
ms.date: 12/17/2018
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
ms.openlocfilehash: d0b7444af6e434a09f6af5f5b1c144b46c79ad56
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328437"
---
# <a name="x64-prolog-and-epilog"></a>x64 初構和終解

配置堆疊空間、呼叫其他函式、儲存非靜態暫存器或使用例外狀況處理的每個函式，都必須有一個初構，其位址限制在與個別函數表專案相關聯的回溯資料中有所描述。 如需詳細資訊，請參閱[x64 例外狀況處理](../build/exception-handling-x64.md)。 初構會在必要時，將引數暫存器儲存在其首頁位址中，將靜態暫存器推送到堆疊上，為區域變數和而暫存物件配置堆疊的固定部分，並選擇性地建立框架指標。 相關聯的回溯資料必須描述初構的動作，而且必須提供復原初構程式碼效果所需的資訊。

如果堆疊中的固定配置是一個以上的頁面（也就是大於4096個位元組），則堆疊配置可能會跨越多個虛擬記憶體頁面，因此必須先檢查配置，然後再進行配置。 可以從初構呼叫的特殊常式，而不會損毀任何引數暫存器以供此用途使用。

儲存非靜態暫存器的慣用方法是在固定堆疊配置之前將它們移至堆疊上。 如果在儲存非靜態暫存器之前執行固定堆疊配置，則最可能需要32位置換來處理已儲存的暫存器區域。 （據傳，暫存器推播的速度會快速移動，而且應該針對可預見的未來，因為推送之間隱含的相依性而保留）。非靜態暫存器可以依任何順序儲存。 不過，第一次在初構中使用非靜態暫存器，必須將它儲存。

## <a name="prolog-code"></a>初構程式碼

一般初構的程式碼可能是：

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    sub    RSP, fixed-allocation-size
    lea    R13, 128[RSP]
    ...
```

這個初構會將引數暫存器 RCX 儲存在其首頁位置、將非靜態暫存器 R13-R15、配置堆疊框架的固定部分，以及建立將128位元組指向固定配置區域的框架指標。 使用位移可讓多個固定配置區域以一個位元組位移來定址。

如果固定配置大小大於或等於一頁的記憶體，則必須先呼叫 helper 函式，才能修改 RSP。 此 helper `__chkstk`會探查要配置的堆疊範圍，以確保正確地擴充堆疊。 在此情況下，先前的初構範例會改為：

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    mov    RAX,  fixed-allocation-size
    call   __chkstk
    sub    RSP, RAX
    lea    R13, 128[RSP]
    ...
```

`__chkstk` Helper 不會修改 R10、R11 和條件碼以外的任何暫存器。 特別是，它會原封不動地傳回 RAX，並保留未修改的所有非靜態暫存器和引數傳遞暫存器。

## <a name="epilog-code"></a>終解程式碼

終解程式碼存在於函式的每個結束處。 但通常只有一個初構，可以有許多 epilogs。 終解程式碼會將堆疊修剪成固定的配置大小（如有必要）、解除配置固定堆疊配置、從堆疊中取出儲存的值來還原非靜態暫存器，然後傳回。

終解程式碼必須遵循一組嚴格的規則，才能透過例外狀況和中斷來可靠地回溯。 這些規則會減少所需的回溯資料量，因為不需要額外的資料來描述每個終解。 相反地，回溯程式碼可以透過程式碼串流向前掃描以識別終，來判斷是否正在執行終解。

如果函式中未使用框架指標，則終解必須先解除配置堆疊的固定部分，而非靜態暫存器會彈出，而控制權會傳回給呼叫的函式。 例如，

```MASM
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

如果在函式中使用框架指標，則必須先將堆疊修剪至其固定配置，然後再執行終。 此動作在技術上並不是終解的一部分。 例如，下列終解可用來復原先前使用的初構：

```MASM
    lea      RSP, -128[R13]
    ; epilogue proper starts here
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

實際上，當使用框架指標時，不會有兩個步驟調整 RSP 的好理由，因此會改用下列終終：

```MASM
    lea      RSP, fixed-allocation-size - 128[R13]
    pop      R13
    pop      R14
    pop      R15
    ret
```

這些表單是終解的唯一合法金鑰。 `add RSP,constant`它必須由`lea RSP,constant[FPReg]`或組成，後面接著一系列零或多個8位元組的暫存器 pop 以及`return`或。 `jmp` （只有`jmp`語句的子集可用於終解。 子集只是具有 ModRM 記憶體參考`jmp`的語句類別，其中 ModRM mod 域值為00。 禁止在 ModRM `jmp` mod 域值為01或10的終中使用語句。 如需可允許 ModRM 參考的詳細資訊，請參閱 AMD x86-64 架構程式設計人員手冊第3卷：一般用途和系統指示中的資料表 A-15。）不會出現其他程式碼。 特別是，無法在終中排程任何內容，包括載入傳回值。

未使用框架指標時，終解必須使用`add RSP,constant`來解除配置堆疊的固定部分。 它可能不`lea RSP,constant[RSP]`會改用。 這種限制存在，因此回溯程式碼在搜尋 epilogs 時，會有較少的模式可辨識。

遵循這些規則可讓回溯程式碼判斷目前正在執行終解，並模擬終餘數的執行，以允許重新建立呼叫函式的內容。

## <a name="see-also"></a>請參閱

[x64 軟體慣例](x64-software-conventions.md)
