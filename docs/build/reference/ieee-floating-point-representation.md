---
title: "IEEE 浮點表示 |Microsoft 文件"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- C++
helpviewer_keywords:
- float keyword
- real*8 value
- floating-point numbers, IEEE representation
- double data type, floating-point representation
- IEEE floating point representation
- real*10 value
- long double
- real*4 value
ms.assetid: 537833e8-fe05-49fc-8169-55fd0314b195
caps.latest.revision: 
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 17fae0cbb16208d5c7e7346f354f3501e4803d96
ms.sourcegitcommit: 9239c52c05e5cd19b6a72005372179587a47a8e4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/16/2018
---
# <a name="ieee-floating-point-representation"></a>IEEE 浮點表示
Microsoft Visual c + + 是 IEEE 數值標準一致。 有三種內部實際數字。 實際\*4 和 real\*8 Visual c + + 中使用。 實際\*4 宣告使用 word **float**。 實際\*使用 word 來宣告 8 **double**。 在 Windows 32 位元程式設計`long double`資料類型會對應至**double**。 沒有，不過，組件語言支援使用真正的計算 * 10 個資料類型。  
  
 值，都會儲存，如下所示：  
  
|值|儲存為|  
|-----------|---------------|  
|real * 4|正負號位元、 8 位元的指數，23 位元尾數|  
|real * 8|正負號位元，11 位元的指數，52 位元尾數|  
|real*10|正負號位元，15 位元的指數，64 位元尾數|  
  
 在真實 * 4 和 real\*8 格式，不會儲存在記憶體中，因此即使儲存只有 23 或 52 位元尾數實際 24 或 53 個位元，則表示尾數中沒有所擔任的前置數字 1。 真正\*10 格式實際儲存此位元。  
  
 指數被偏移了其最大值的一半。 這表示減去此偏移從儲存的指數，若要取得實際的指數。 如果預存的指數小於偏差，則實際上是負指數。  
  
 指數被偏移了，如下所示：  
  
|指數|偏移了|  
|--------------|---------------|  
|8 位元 (real * 4)|127|  
|11 位元 (real * 8)|1023|  
|15 位元 (real * 10)|16383|  
  
 不乘冪的十個; 這些指數。它們是二的次方。 也就是儲存的 8 位元的指數可以是最多為 127。 值 2 * * 127 大約會等於 10\*\*38，也就是真實的實際限制\*4。  
  
 尾數會儲存為二進位格式的小數 1.XXX...。 此分數的值大於或等於 1 且小於 2。 請注意，實際數字會一律儲存在標準化表單;也就是該尾數是向左移位，則表示尾數的高序位位元永遠為 1。 此位元永遠為 1，因為它會假設 （未儲存的） 在 real * 4 和實際\*8 格式。 二進位 （非十進位） 的點會被假設為前置數字 1 的右側。  
  
 格式，然後針對各種大小如下所示：  
  
|格式|BYTE 1|BYTE 2|BYTE 3|位元組 4|...|位元組 n|  
|------------|------------|------------|------------|------------|---------|------------|  
|real * 4|`SXXX XXXX`|`XMMM MMMM`|`MMMM MMMM`|`MMMM MMMM`|||  
|real * 8|`SXXX XXXX`|`XXXX MMMM`|`MMMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
|real*10|`SXXX XXXX`|`XXXX XXXX`|`1MMM MMMM`|`MMMM MMMM`|...|`MMMM MMMM`|  
  
 `S` 表示正負號位元`X`的指數的位元，而`M`的尾數的位元。 請注意，最左邊的位元會假設即時 * 4 和 real\*8 格式，但呈現為"1"中的實際位元組 3\*10 的格式。  
  
 要正確移位二進位的點，您先必須指數然後二進位移到右邊或左適當位元數。  
  
## <a name="examples"></a>範例  
 以下是一些範例即時 * 4 的格式：  
  
-   在下列範例中，正負號位元為零，並儲存的指數是 128 或 100 0000 二進位檔，也就是 127 加 1 中的為 0。 儲存的尾數會 (1)。000 0000 ...具有前置 1 和二進位點，因此實際的尾數是其中一個 0000 0000。  
  
    ```  
                        SXXX XXXX XMMM MMMM ... MMMM MMMM  
    2   =  1  * 2**1  = 0100 0000 0000 0000 ... 0000 0000 = 4000 0000  
    ```  
  
-   與相同 + 2 不同之處在於正負號位元設定。 這是適用於所有 IEEE 浮點數字格式。  
  
    ```  
    -2  = -1  * 2**1  = 1100 0000 0000 0000 ... 0000 0000 = C000 0000  
    ```  
  
-   相同的尾數指數增加一個 （偏的值為 129 或 100 0000 1 二進位檔中。  
  
    ```  
    4  =  1  * 2**2  = 0100 0000 1000 0000 ... 0000 0000 = 4080 0000  
    ```  
  
-   相同的指數，尾數大於一半 — 它 (1)。100 0000...0000 0000，因為這是二進位的分數，這是 1 1/2 （小數位數的值是 1/2、 1/4，1/8，等等）。  
  
    ```  
    6  = 1.5 * 2**2  = 0100 0000 1100 0000 ... 0000 0000 = 40C0 0000  
    ```  
  
-   相同的指數，尾數的其他倍數是少於兩個 127 或以二進位 011 1111年 1。  
  
    ```  
    1  = 1   * 2**0  = 0011 1111 1000 0000 ... 0000 0000 = 3F80 0000  
    ```  
  
-   偏移的指數是 126 011 1111年 0 二進位，則表示尾數，(1)。100 0000 ...0000 0000，為 1 1/2。  
  
    ```  
    .75 = 1.5 * 2**-1 = 0011 1111 0100 0000 ... 0000 0000 = 3F40 0000  
    ```  
  
-   尾數中代表 1/4 位元會完全相同，除了兩個設定。  
  
    ```  
    2.5 = 1.25 * 2**1 = 0100 0000 0010 0000 ... 0000 0000 = 4020 0000  
    ```  
  
-   1/10 是以二進位重複分數。 僅有 1.6，則表示尾數且偏移的指數說明 1.6 是要除以 16 （它是二進位檔，也就是十進位的 123 011 1101年 1）。 True 表示指數為 123-127 =-4，其表示所要相乘的因數為 2**-4 = 1/16。 請注意，儲存的尾數中的最後一個位元會無條件進位 — 嘗試盡量精確地表示無法表示的數字。 (原因 1/10 到 1/100 會以二進位不精確類似於 1/3 不完全無法以十進位的原因。)  
  
    ```  
    0.1 = 1.6 * 2**-4 = 0011 1101 1100 1100 ... 1100 1101 = 3DCC CCCD  
    ```  
  
-   `0  = 1.0 * 2**-128 = all zeros--a special case.`  
  
## <a name="see-also"></a>另請參閱  
 [浮點數會失去精確度的原因](../../build/reference/why-floating-point-numbers-may-lose-precision.md)