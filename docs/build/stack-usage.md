---
title: x64 堆疊使用方式
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: b598c33fbdd56630ca3e5ef0da551f38a73baa26
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/14/2020
ms.locfileid: "81335537"
---
# <a name="x64-stack-usage"></a>x64 堆疊使用方式

RSP 目前位址之外的所有記憶體都被視為易失性:作業系統或調試器可能在使用者調試會話或中斷處理程序期間覆蓋此記憶體。 因此,在嘗試將值讀取或寫入堆疊幀之前,必須始終設置 RSP。

本節討論本地變數的堆疊空間分配和**同法內部。**

## <a name="stack-allocation"></a>堆疊配置

函數的 prolog 負責為本地變數、保存的寄存器、堆疊參數和寄存器參數分配堆疊空間。

參數區域始終位於堆疊的底部(即使`alloca`使用),因此在任何函數調用期間,參數區域始終與返回位址相鄰。 它包含至少四個條目,但始終有足夠的空間來容納任何可能調用的函數所需的所有參數。 請注意,始終為寄存器參數分配空間,即使參數本身永遠不會歸位於堆疊中也是如此;被叫者保證已經為其所有參數分配了空間。 寄存器參數需要主位址,因此在被呼叫的函數需要獲取參數清單(va_list)或單個參數的位址時,可以使用連續區域。 此區域還提供一個方便的位置,以保存寄存器參數在 thunk 執行期間,並作為調試選項(例如,它使參數很容易在調試期間查找,如果它們存儲在其主位址在 prolog 代碼中)。 即使被調用函數的參數少於 4 個,這 4 個堆疊位置實際上也歸被調用函數所有,並且除了保存參數寄存器值之外,被調用函數也可以用於其他目的。  因此,調用方可能不會跨函數調用在此堆疊區域中保存資訊。

如果在函數中動態分配空間`alloca`( ) ),則必須將非易失性寄存器用作幀指標來標記堆疊固定部分的基,並且必須在 prolog 中保存和初始化該寄存器。 請注意,使用`alloca`時,從同一調用方對同一被調用方的呼叫可能具有不同的主位址,以用於其寄存器參數。

堆疊將始終保持 16 位元組對齊,但 prolog 中(例如,在推送返回位址後)以及特定幀函數類[的函數類型](#function-types)中指示的情況除外。

下面是堆疊佈局的示例,其中函數 A 調用非葉函數 B。 函數 A 的 prolog 已經為堆疊底部 B 所需的所有寄存器和堆疊參數分配了空間。 調用推送返回位址,B 的 prolog 為其本地變數、非易失性寄存器分配空間,以及調用函數所需的空間。 如果`alloca`B 使用 ,則在本地變數/非易失寄存器保存區域和參數堆疊區域之間分配空間。

![AMD 轉換範例](../build/media/vcamd_conv_ex_5.png "AMD 轉換範例")

當函數 B 呼叫另一個函數時,傳回位址將推至 RCX 的家庭位址正下方。

## <a name="dynamic-parameter-stack-area-construction"></a>動態參數堆疊區域建構

如果使用幀指標,則存在動態創建參數堆疊區域的選項。 這在 x64 編譯器中目前未完成。

## <a name="function-types"></a>函式類型

基本上有兩種類型的函數。 需要堆疊的函數稱為*Fdecs*的函數稱為 Fdect 。 不需要堆疊的函數稱為*葉函數*。

幀函數是分配堆疊空間、調用其他函數、保存非易失寄存器或使用異常處理的函數。 它還需要一個函數表條目。 幀函數需要序言和分詞。 幀函數可以動態分配堆疊空間,並可以使用幀指標。 幀函數具有此調用標準的全部功能。

如果幀函數不調用其他函數,則不需要對齊堆棧(在剖面[棧分配](#stack-allocation)中引用)。

葉函數是不需要函數表條目的函數。 它無法更改任何非易失性寄存器(包括 RSP),這意味著它無法調用任何函數或分配堆疊空間。 它允許在執行堆疊時保持堆疊未對齊。

## <a name="malloc-alignment"></a>馬婁克對齊

[MALLoc](../c-runtime-library/reference/malloc.md)保證傳回用於存儲具有基本對齊且可放入分配的記憶體的任何物件的適當對齊的記憶體。 *基本對齊*是小於或等於沒有對齊規範的實現支援的最大對齊方式。 (在視覺C++中,這是`double`8 個字節所需的對齊方式。 在以 64 位平台為目標的代碼中,它是 16 位元組。例如,四位元組分配將在支援任何四位元組或較小對象的邊界上對齊。

可視C++允許具有*擴展對齊的類型*,也稱為*過度對齊*類型。 例如,SSE[__m128](../cpp/m128.md)類型`__m256`__m128`__declspec(align( n ))`和 ,使用`n`大於 8 的位置聲明的類型具有擴展對齊方式。 適合需要擴展對齊的對象的邊界上的記憶體對齊不受`malloc`保證。 要為過度對齊的類型分配記憶體,請使用[_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md)和相關函數。

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md)需要 16 位元組對齊,並且還需要使用幀指標。

分配的堆疊需要包括後所調用函數的參數的空間,如[堆疊分配](#stack-allocation)中所述。

## <a name="see-also"></a>另請參閱

[x64 軟體慣例](../build/x64-software-conventions.md)<br/>
[對齊](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
