---
title: "回溯程序 |Microsoft 文件"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-tools
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: 82c5d0ca-70be-4d1a-a306-bfe01c29159f
caps.latest.revision: "11"
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 8b8caa2be1528c26cf374637f3d0357847721de9
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/21/2017
---
# <a name="unwind-procedure"></a>回溯程序
回溯程式碼陣列是以遞減順序排序。 例外狀況發生時，完整的內容會儲存的內容記錄中的作業系統。 例外狀況分派邏輯然後叫用時，它會重複執行下列步驟，以找出例外狀況處理常式。  
  
1.  使用儲存在內容記錄的目前 RIP 搜尋 RUNTIME_FUNCTION 資料表項目，用來描述目前的函式 （或函式的部分，在鏈結 UNWIND_INFO 項目）。  
  
2.  如果不找到任何函式表格項目，則它是分葉函式，位在與 rsp 會直接傳回的指標。 位於 [RSP] 傳回的指標會儲存已更新的內容中模擬的 RSP 8，就會增加，會重複步驟 1。  
  
3.  如果找到函式表格項目，RIP 可以體內） 終解、 b） 在初構中，或是 c） 在可能的例外狀況處理常式所涵蓋的程式碼的三個區域中。  
  
    -   大小寫) 如果 RIP 在終解中，則控制項將離開函式，可以是任何與這個函式，此例外狀況相關聯的例外狀況處理常式，而且必須繼續終解效果，以計算呼叫端函式的內容。 若要判斷是否 RIP 在終解中，從擷取的程式碼資料流上會進行檢查。 如果該程式碼資料流可以配合的尾端部分合法的終解中，則處於終解中，而且模擬的終解其餘部分時，會處理更新為每個指示的內容記錄。 在此之後，請重複步驟 1。  
  
    -   案例 b） 如果 RIP 在序言，則控制項不進入函式可以有任何與這個函式，此例外狀況相關聯的例外狀況處理常式，必須復原的初構效果，以計算呼叫端函式的內容。 如果函式開頭到 RIP 之間的距離小於或等於初構大小編碼的回溯資訊 RIP 位於初構中。 初構的效果是回溯掃描回溯程式碼陣列，一個位移小於或等於從函式開始時，RIP 位移的第一個項目，然後復原回溯程式碼陣列中的所有其餘項目的影響。 然後重複步驟 1。  
  
    -   案例 c)，若 RIP 不在初構或終解和函式內例外狀況處理常式 （UNW_FLAG_EHANDLER 設定），則會呼叫語言特定處理常式。 此處理常式會掃描其資料，並呼叫篩選為適當的函式。 語言特定處理常式可以傳回已處理此例外狀況，或搜尋會繼續執行。 它也可以直接初始化回溯。  
  
4.  如果語言特定處理常式會傳回已處理的狀態，則執行會繼續使用原始的內容記錄。  
  
5.  如果沒有語言特定處理常式或處理常式傳回 「 繼續搜尋 」 的狀態，則內容記錄必須回溯至呼叫端的狀態。 這是由處理所有回溯程式碼陣列項目，並復原每個作用中達成。 然後重複步驟 1。  
  
 當進行鏈結時回溯的相關資訊，仍會遵循以下基本步驟。 唯一的差異是，雖然查核回溯初構的效果，一旦達到陣列結尾回溯程式碼陣列，它會連結至父回溯資訊，並在那裡找到整個回溯程式碼陣列逐步。 此連結會繼續直到到達的回溯資訊不 UNW_CHAINED_INFO 旗標，並完成查核回溯程式碼陣列。  
  
 回溯資料以最小一組為 8 個位元組。 這表示只能配置 128 位元組的堆疊或較少，並可能儲存一個靜態暫存器的函式。 這也是大小鏈結的回溯資訊結構與無回溯程式碼的長度為零初構。  
  
## <a name="see-also"></a>請參閱  
 [例外狀況處理 (x64)](../build/exception-handling-x64.md)