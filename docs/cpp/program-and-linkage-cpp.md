---
title: 翻譯單位和聯絡(C++)
ms.date: 12/11/2019
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
ms.openlocfilehash: 791ec53d4df863b218db463f2b9b9401bf6f466d
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/14/2020
ms.locfileid: "81374321"
---
# <a name="translation-units-and-linkage"></a>編譯單位和連結

在C++程式中,*符號*(例如變數或函數名稱)可以在其範圍內聲明任意次數,但只能定義一次。 此規則是「一個定義規則」(ODR)。 *聲明*將名稱引入(或重新引入)到程式中。 *定義*引入了名稱。 如果名稱表示變數,則定義顯式初始化它。 *函數定義*由簽名和函數體組成。 類定義由類名稱後跟列出所有類成員塊組成。 (成員函數的主體可以選擇在另一個檔中單獨定義。

下面的範例顯示了一些聲明:

```cpp
int i;
int f(int x);
class C;
```

下面的範例顯示了一些定義:

```cpp
int i{42};
int f(int x){ return x * i; }
class C {
public:
   void DoSomething();
};
```

程式由一個或多個*翻譯單元*組成。 翻譯單元由實現檔及其直接或間接包含的所有標頭組成。 實現檔通常具有*cpp*或*cxx*的檔副檔名。 標題檔案通常具有*h*或*hpp*的副檔名。 每個翻譯單元由編譯器獨立編譯。 編譯完成後,連結器將編譯的翻譯單元合併到單個*程式中*。 違反 ODR 規則的行為通常將顯示為連結器錯誤。 當同一名稱在不同的翻譯單元中有兩個不同的定義時,將發生連結器錯誤。

通常,使變數跨多個文件可見的最佳方式是將其放入頭檔中。 然後在每個需要聲明的*cpp*檔中添加#include指令。 通過在標頭內容周圍添加*包含保護,* 可確保聲明的名稱僅定義一次。

在 C++20 中,[模組](modules-cpp.md)被引入作為標頭檔的改進替代方法。

在某些情況下,可能需要在*cpp*檔中聲明全域變數或類。 在這些情況下,您需要一種方法來告訴編譯器和連結器名稱具有什麼樣的*連結*。 連結類型指定物件的名稱是只應用於一個文件還是適用於所有檔。 連結的概念僅適用於全球名稱。 連結的概念不適用於在作用域內聲明的名稱。 作用域由一組封閉大括弧(如函數或類定義)指定。

## <a name="external-vs-internal-linkage"></a>外部與內部聯動

*自由函數*是在全域或命名空間作用域中定義的函數。 預設情況下,非全域變數和自由函數具有*外部連結*;它們從程式中的任何翻譯單元可見。 因此,沒有其他全域物件可以具有該名稱。 具有*內部連結*或*無連結*的符號僅在聲明它的翻譯單元中可見。 當名稱具有內部連結時,其他翻譯單元中可能存在相同的名稱。 使用類定義或函數體聲明的變數沒有連結。

可以通過顯式聲明全域名稱為**靜態**來強制全域名稱具有內部連結。 這將將其可見性限制為聲明它的同一翻譯單元。 在此上下文中,**靜態**表示與應用於局部變數時不同的東西。

預設情況下,以下物件具有內部連結:

- const 物件
- 缺點體物體
- typedefs
- 命名空間範圍內的靜態物件

要為 const 物件外部連結,請將其宣告為**外部連結**並為其分配一個值:

```cpp
extern const int value = 42;
```

有關詳細資訊[,請參閱外部。](extern-cpp.md)

## <a name="see-also"></a>另請參閱

[基本概念](../cpp/basic-concepts-cpp.md)
