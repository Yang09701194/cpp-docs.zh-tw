---
title: 程式和連結 （c + +）
ms.date: 04/09/2018
ms.assetid: a6493ba0-24e2-4c89-956e-9da1dea660cb
ms.openlocfilehash: 4f509979a293f194333e610fbdae7be9d32ec121
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/31/2018
ms.locfileid: "50559851"
---
# <a name="program-and-linkage-c"></a>程式和連結 (C++)

在 c + + 程式中，*符號*，例如變數或函式的名稱，可以宣告任何數目的時間的範圍內，但它一次只能定義。 這是一個定義規則 (ODR)。 A*宣告*導入了 （或重新導入了） 到程式的名稱。 A*定義*引入的名稱，並在變數中，明確地將它初始化。 A*函式定義*簽章加上函式主體所組成。

以下是宣告：

```cpp
int i;
int f(int x);
```

這些是定義：

```cpp
int i{42};
int f(int x){ return x * i; }
```

程式包含一個或多個*轉譯單位*。 在轉譯單位是由實作檔 （.cpp、.cxx 等） 和所有標頭 （.h、.hpp 等），其中包含直接或間接所組成。 每一個轉譯單位在編譯器中之後, 連結器，請合併成單一的編譯的轉譯單位中有不同的編譯獨立*程式*。 ODR 規則的違規情形通常顯示為連結器錯誤時相同的名稱不同轉譯單位中具有兩個不同的定義。

一般情況下，跨多個檔案顯示變數的最佳方式為將它放在標頭檔，並加入 #include 指示詞需要宣告每個.cpp 檔案中。 藉由新增*include 防護*周圍標頭內容中，確定它會宣告的名稱都只會一次的定義。

不過，在某些情況下可能需要宣告全域變數或.cpp 檔案中的類別。 在這些情況下，您需要告訴編譯器和連結器的物件名稱是否適用於只是一個檔案中，或所有檔案的方式。

## <a name="linkage-vs-scope"></a>與範圍的連結

概念*連結*是指所有轉譯單位中的整個全域符號 （例如變數、 型別名稱和函式名稱），在程式內的可見性。 概念*範圍*指的區塊，例如命名空間、 類別或函式主體內宣告的符號。 這類符號會在其定義所在; 的範圍內才可見連結的概念不適用於它們。

## <a name="external-vs-internal-linkage"></a>外部與內部連結

A*可用函式*是函式定義在全域或命名空間範圍。 非 const 的全域變數和預設的免費函式有*外部連結*; 它們是可見的任何轉譯單位的程式。 因此，沒有其他全域物件 （變數、 類別定義等） 可以具有該名稱。 使用的符號*內部連結*或是*無連結*在宣告它的轉譯單位內才可見。 當名稱具有內部連結時，相同的名稱可能會存在於另一個轉譯單位中。 類別定義中宣告變數或函式主體沒有連結。

您可以強制明確宣告為具有內部連結的通用名稱**靜態**。 這會限制其可見宣告它的相同轉譯單位。 請注意，在此情況下，**靜態**意義有些不同時套用至區域變數。

下列物件會依預設具有內部連結：
- const 物件
- constexpr 物件
- typedefs
- 命名空間範圍中的靜態物件

若要讓 const 物件的外部連結，將它宣告為**extern**並將它指派值：

```cpp
extern const int value = 42;
```

請參閱[extern](extern-cpp.md)如需詳細資訊。

## <a name="see-also"></a>另請參閱

[基本概念](../cpp/basic-concepts-cpp.md)