---
title: 編譯器錯誤 C3200 到 C3299
ms.date: 11/17/2017
f1_keywords:
- C3220
- C3221
- C3245
- C3249
- C3250
- C3256
- C3257
- C3258
- C3259
- C3260
- C3261
- C3263
- C3267
- C3281
- C3294
helpviewer_keywords:
- C3220
- C3221
- C3245
- C3249
- C3250
- C3256
- C3257
- C3258
- C3259
- C3260
- C3261
- C3263
- C3267
- C3281
- C3294
ms.assetid: 6b3104f6-63bc-4823-b6f3-b8a16be4b87f
ms.openlocfilehash: e8a9c1db4cba837a5780e51f84035492cd0e9e76
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/31/2018
ms.locfileid: "50490586"
---
# <a name="compiler-errors-c3200-through-c3299"></a>編譯器錯誤 C3200 到 C3299

文件的本節文章會說明編譯器所產生的錯誤訊息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>錯誤訊息

|錯誤|訊息|
|-----------|-------------|
|[編譯器錯誤 C3200](compiler-error-c3200.md)|'*型別*': 樣板參數的無效樣板引數'*參數*'，必須是類別樣板|
|[編譯器錯誤 C3201](compiler-error-c3201.md)|類別樣板的樣板參數清單 '*樣板*'不符合樣板參數清單，範本參數'*參數*'|
|[編譯器錯誤 C3202](compiler-error-c3202.md)|'*識別碼*': 無效的預設引數必須是類別樣板|
|[編譯器錯誤 C3203](compiler-error-c3203.md)|'*識別碼*': 特製化的類別範本/泛型不能作為範本/泛型參數的範本/泛型引數'*參數*'，必須是實數類型|
|[編譯器錯誤 C3204](compiler-error-c3204.md)|'*函式*' 無法從 catch 區塊內呼叫|
|[編譯器錯誤 C3205](compiler-error-c3205.md)|樣板類樣板參數的引數清單 '*識別碼*' 遺漏|
|[編譯器錯誤 C3206](compiler-error-c3206.md)|'*函式*': 無效的範本/泛型引數'*範本*'，遺漏範本/泛型引數清單類別範本/泛型 '*型別*'|
|[編譯器錯誤 C3207](compiler-error-c3207.md)|'*函式*': 無效的樣板引數的'*參數*'，必須是類別樣板|
|[編譯器錯誤 C3208](compiler-error-c3208.md)|'*函式*': 類別樣板的樣板參數清單'*範本*'不符合樣板類樣板參數的樣板參數清單'*參數*'|
|[編譯器錯誤 C3209](compiler-error-c3209.md)|'*型別*': 泛型類別必須是受管理/WinRT 類別|
|[編譯器錯誤 C3210](compiler-error-c3210.md)|'*識別碼*': 存取宣告只可以套用至基底類別成員|
|[編譯器錯誤 C3211](compiler-error-c3211.md)|'*函式*': 明確特製化使用的部分特製化語法，請改為使用 template<>|
|[編譯器錯誤 C3212](compiler-error-c3212.md)|'*函式*': 樣板成員的明確特製化必須是明確的特製化的成員|
|[編譯器錯誤 C3213](compiler-error-c3213.md)|基底類別*類別*'是比存取'*derived_class*'|
|[編譯器錯誤 C3214](compiler-error-c3214.md)|'*引數*': 無效的型別引數的泛型參數'*參數*'屬於泛型'*型別*'，不符合條件約束 '*條件約束*'|
|[編譯器錯誤 C3215](compiler-error-c3215.md)|'*constraint1*': 泛型類型參數已經受到'*constraint2*'|
|[編譯器錯誤 C3216](compiler-error-c3216.md)|條件約束必須不是泛型參數 '*型別*'|
|[編譯器錯誤 C3217](compiler-error-c3217.md)|'*參數*': 泛型參數不可以限制此宣告中|
|[編譯器錯誤 C3218](compiler-error-c3218.md)|'*型別*': 類型不可做為條件約束|
|[編譯器錯誤 C3219](compiler-error-c3219.md)|'*參數*': 泛型參數不可受到多重非介面:'*型別*'|
|編譯器錯誤 C3220|'*介面*': 介面不可以有 progid|
|編譯器錯誤 C3221|'*成員*': 多個 'default' 和 'case' 屬性不允許在成員上|
|[編譯器錯誤 C3222](compiler-error-c3222.md)|'*函式*': 無法宣告預設引數的成員，管理/WinRT 類型的函式或泛型函式|
|[編譯器錯誤 C3223](compiler-error-c3223.md)|'*屬性*': 您無法將 'typeid' 套用至屬性|
|[編譯器錯誤 C3224](compiler-error-c3224.md)|'*型別*': 沒有多載泛型類別接受*數目*' 泛型類型引數|
|[編譯器錯誤 C3225](compiler-error-c3225.md)|泛型型別引數 '*引數*'不能'*型別*'，它必須是實值類型或參考類型的控制代碼|
|[編譯器錯誤 C3226](compiler-error-c3226.md)|泛型宣告內不允許有樣板宣告，必須改為泛型宣告|
|[編譯器錯誤 C3227](compiler-error-c3227.md)|'*型別*': 不能使用'*運算子*' 配置的泛型型別|
|[編譯器錯誤 C3228](compiler-error-c3228.md)|'*函式*': 對泛型類型引數'*引數*'不能'*型別*'，它必須是實值類型或控制代碼類型|
|[編譯器錯誤 C3229](compiler-error-c3229.md)|'*型別*': 不允許在泛型類型參數上的間接取值|
|[編譯器錯誤 C3230](compiler-error-c3230.md)|'*函式*': 樣板類型引數'*引數*'不可包含泛型型別參數:'*型別*'|
|[編譯器錯誤 C3231](compiler-error-c3231.md)|'*型別*': 樣板類型引數不能使用泛型類型參數|
|[編譯器錯誤 C3232](compiler-error-c3232.md)|'*參數*': 泛型類型參數不能在限定名稱|
|[編譯器錯誤 C3233](compiler-error-c3233.md)|'*型別*': 泛型類型參數已經受到條件約束|
|[編譯器錯誤 C3234](compiler-error-c3234.md)|泛型類別不可衍生自泛型類型參數|
|[編譯器錯誤 C3235](compiler-error-c3235.md)|'*特製化*': 不允許泛型類別的明確或部分特製化|
|[編譯器錯誤 C3236](compiler-error-c3236.md)|不能對泛型類別進行明確執行個體化|
|[編譯器錯誤 C3237](compiler-error-c3237.md)|'*類別*': 泛型類別不可為自訂的屬性|
|[編譯器錯誤 C3238](compiler-error-c3238.md)|'*型別*': 具有此名稱的類型已轉送至組件'*組件*'|
|[編譯器錯誤 C3239](compiler-error-c3239.md)|'*型別*': common language runtime 不允許內部 /pin 指標的指標|
|[編譯器錯誤 C3240](compiler-error-c3240.md)|'*識別碼*': 必須為非多載抽象成員函式的'*型別*'|
|[編譯器錯誤 C3241](compiler-error-c3241.md)|'*成員*': 這個方法不由引入'*介面*'|
|[編譯器錯誤 C3242](compiler-error-c3242.md)|'*函式*': 您可以只明確覆寫虛擬函式|
|[編譯器錯誤 C3243](compiler-error-c3243.md)|沒有任何多載函式所導入 '*介面*'|
|[編譯器錯誤 C3244](compiler-error-c3244.md)|'*成員*': 此方法引入的'*interface1*'不是'*interface2*'|
|編譯器錯誤 C3245|'*函式*': 使用變數範本需要範本引數清單|
|[編譯器錯誤 C3246](compiler-error-c3246.md)|'*類別*': 無法繼承自'*base_class*'因為它已經宣告為'*繼承*'|
|[編譯器錯誤 C3247](compiler-error-c3247.md)|'*coclass*': coclass 無法繼承自其他 coclass*base_class*'|
|[編譯器錯誤 C3248](compiler-error-c3248.md)|已過時。 '*函式*': 函式宣告為 'sealed' 無法覆寫'*函式*'|
|編譯器錯誤 C3249|不合法的陳述式或子運算式 'constexpr' 函式|
|編譯器錯誤 C3250|'*宣告*': 'constexpr' 函式主體中不允許宣告|
|[編譯器錯誤 C3251](compiler-error-c3251.md)|無法在實值類型執行個體上叫用基底類別方法|
|[編譯器錯誤 C3252](compiler-error-c3252.md)|'*函式*': 無法縮小 managed/WinRT 類型中的虛擬方法的存取範圍|
|[編譯器錯誤 C3253](compiler-error-c3253.md)|'*函式*': 明確覆寫發生錯誤|
|[編譯器錯誤 C3254](compiler-error-c3254.md)|'*函式*': 類別含有明確覆寫'*函式*'，但不是衍生自包含函式宣告的介面|
|[編譯器錯誤 C3255](compiler-error-c3255.md)|'*型別*': 無法以動態方式配置這個原生堆積上的實值類型物件|
|編譯器錯誤 C3256|'*函式*': 使用變數不會產生常數運算式|
|編譯器錯誤 C3257|已過時。|
|編譯器錯誤 C3258|已過時。|
|編譯器錯誤 C3259|'constexpr' 函式只能有一個傳回陳述式|
|編譯器錯誤 C3260|'*語彙基元*': 略過 lambda 主體之前未預期的權杖|
|編譯器錯誤 C3261|傳回管理/WinRT 陣列的函式必須有陣列括號，宣告的結尾: '*識別碼*（...）[]'|
|[編譯器錯誤 C3262](compiler-error-c3262.md)|無效的陣列編製索引：*數字*已被指定成*數目*-維度 '*型別*'|
|編譯器錯誤 C3263|已過時。|
|[編譯器錯誤 C3264](compiler-error-c3264.md)|'*識別碼*': 類別建構函式不能有傳回型別|
|[編譯器錯誤 C3265](compiler-error-c3265.md)|不能宣告 managed '*managed_construct*'中 unmanaged'*unmanaged_construct*'|
|[編譯器錯誤 C3266](compiler-error-c3266.md)|'*函式*': 類別建構函式必須有 'void' 參數清單|
|編譯器錯誤 C3267|已過時。|
|[編譯器錯誤 C3268](compiler-error-c3268.md)|'*函式*': 泛型函式或泛型類別的成員函式不能有變數參數清單|
|[編譯器錯誤 C3269](compiler-error-c3269.md)|'*函式*': WinRT managed 類型的成員函式不可以宣告使用 '...'|
|[編譯器錯誤 C3270](compiler-error-c3270.md)|'*欄位*': FieldOffset 屬性只可以用於 StructLayout(LayoutKind::Explicit) 的內容|
|[編譯器錯誤 C3271](compiler-error-c3271.md)|'*欄位*': 無效的值'*數目*' 對 FieldOffset 屬性|
|[編譯器錯誤 C3272](compiler-error-c3272.md)|'*符號*': 符號必須有 FieldOffset，因為它是 struct/類別的成員*type_name* StructLayout(LayoutKind::Explicit) 定義|
|[編譯器錯誤 C3273](compiler-error-c3273.md)|'*關鍵字*': 不允許在 c + + try 區塊|
|[編譯器錯誤 C3274](compiler-error-c3274.md)|最後 /&#95;&#95;finally 缺少對應的 try|
|[編譯器錯誤 C3275](compiler-error-c3275.md)|'*識別碼*': 無法使用這個不含限定詞的符號|
|[編譯器錯誤 C3276](compiler-error-c3276.md)|'*關鍵字*': 跳出 finally /&#95;&#95;最後區塊有未定義的行為在終止處理期間|
|[編譯器錯誤 C3277](compiler-error-c3277.md)|無法定義非受控的列舉 '*列舉型別*管理的內部 」*型別*'|
|[編譯器錯誤 C3278](compiler-error-c3278.md)|直接呼叫介面或純方法 '*函式*' 將會在執行階段失敗|
|[編譯器錯誤 C3279](compiler-error-c3279.md)|cli 命名空間中宣告的類別樣板，不允許部分和明確特製化以及明確具現化|
|[編譯器錯誤 C3280](compiler-error-c3280.md)|'*函式*': 成員函式的 managed 型別無法編譯成 unmanaged 函式|
|編譯器錯誤 C3281|'*函式*': 全域運算子不能有受管理/WinRT 類型'*型別*' 簽章中|
|[編譯器錯誤 C3282](compiler-error-c3282.md)|泛型參數清單只能出現在受管理/WinRT 類別、 結構或函式|
|[編譯器錯誤 C3283](compiler-error-c3283.md)|'*介面*': 介面不可以有一個執行個體建構函式|
|[編譯器錯誤 C3284](compiler-error-c3284.md)|對泛型參數條件約束 '*參數*'的函式'*宣告子*'必須符合的條件約束對泛型參數'*參數*'的函式'*宣告子*'|
|[編譯器錯誤 C3285](compiler-error-c3285.md)|針對每個陳述式無法對類型的變數 '*型別*'|
|[編譯器錯誤 C3286](compiler-error-c3286.md)|'*規範*': 反覆運算變數不能有任何儲存類別規範|
|[編譯器錯誤 C3287](compiler-error-c3287.md)|類型 '*型別*' （GetEnumerator 的傳回類型） 必須有適合的公用 MoveNext 成員函式和公用 Current 屬性|
|[編譯器錯誤 C3288](compiler-error-c3288.md)|'*型別*': 不合法取值 （dereference) 的控制代碼類型|
|[編譯器錯誤 C3289](compiler-error-c3289.md)|'*識別碼*': trivial 屬性不可索引|
|[編譯器錯誤 C3290](compiler-error-c3290.md)|'*型別*': trivial 屬性不能有參考類型|
|[編譯器錯誤 C3291](compiler-error-c3291.md)|'default': 不可為 trivial 屬性的名稱|
|[編譯器錯誤 C3292](compiler-error-c3292.md)|無法重新開啟 cli 命名空間|
|[編譯器錯誤 C3293](compiler-error-c3293.md)|'*識別碼*': 使用 'default' 存取類別的預設屬性 （索引子）*類別*'|
|編譯器錯誤 C3294|已過時。|
|[編譯器錯誤 C3295](compiler-error-c3295.md)|'#pragma*規範*' 只可用在全域或命名空間範圍|
|[編譯器錯誤 C3296](compiler-error-c3296.md)|'*識別碼*': 已經有同名的屬性|
|[編譯器錯誤 C3297](compiler-error-c3297.md)|' *constraint2*': 不能使用' *constraint1*'做為條件約束因為' *constraint1*' 具有值條件約束|
|[編譯器錯誤 C3298](compiler-error-c3298.md)|' *constraint1*': 不能使用' *constraint2*'做為條件約束因為' *constraint2*'具有 ref 條件約束和' *constraint1*'具有值條件約束|
|[編譯器錯誤 C3299](compiler-error-c3299.md)|'*函式*': 無法指定條件約束，它們繼承自基底方法|
