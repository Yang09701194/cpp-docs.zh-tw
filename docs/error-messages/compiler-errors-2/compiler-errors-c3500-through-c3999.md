---
title: 編譯器錯誤 C3500 至 C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: eddadeeeb014c6b64376554f7ff025a06e8935c9
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446946"
---
# <a name="compiler-errors-c3500-through-c3999"></a>編譯器錯誤 C3500 至 C3999

本檔的這一節中的文章說明編譯器所產生的錯誤訊息子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>錯誤訊息

|錯誤|訊息|
|-----------|-------------|
|[編譯器錯誤 C3500](compiler-error-c3500.md)|不正確 ProgID '*progid*'|
|[編譯器錯誤 C3501](compiler-error-c3501.md)|沒有為 ProgID '*progid*' 註冊的 typelib|
|編譯器錯誤 C3502|無法取得 ProgID '*progid*' 的 LIBID|
|編譯器錯誤 C3503|原始字串常*值*中不允許字元 ' 0x value '|
|編譯器錯誤 C3504|無法從字串 '*string*' 建立 GUID|
|[編譯器錯誤 C3505](compiler-error-c3505.md)|無法載入類型程式庫 '*library*'|
|[編譯器錯誤 C3506](compiler-error-c3506.md)|沒有針對 LIBID '*library*' 註冊的 typelib|
|[編譯器錯誤 C3507](compiler-error-c3507.md)|ProgID 不能超過39個字元 '*ProgID*';除了 '. ' 以外，也不包含任何標點符號;也不是以數位開頭|
|[編譯器錯誤 C3508](compiler-error-c3508.md)|'*type*'：不是有效的 Automation 類型|
|[編譯器錯誤 C3509](compiler-error-c3509.md)|'*type*'：不正確 Automation 傳回類型;當參數標示為 ' retval ' 時，傳回類型必須是 ' void '、' HRESULT ' 或 ' SCODE '|
|[編譯器錯誤 C3510](compiler-error-c3510.md)|找不到相依的類型程式庫連結*庫*|
|編譯器錯誤 C3511|'*identifier*'：委派函式的呼叫應該是唯一的成員初始化運算式|
|編譯器錯誤 C3512|原始字串常值的分隔字元順序不應超過16個字元|
|編譯器錯誤 C3513|'*string*'：不支援的原始字串常值分隔符號|
|編譯器錯誤 C3514|'*character*' （*值*）：不支援的原始字串常值分隔符號|
|編譯器錯誤 C3515|如果類別樣板的引數部分特製化是套件展開，它應該是最後一個引數|
|編譯器錯誤 C3516|處理原始字串常值時發現非預期的檔案結尾;分隔符號序列 '*string*' 不相符|
|編譯器錯誤 C3517|'*identifier*' 別名宣告不能有包含 ' auto ' 的類型|
|編譯器錯誤 C3518|'*identifier*'：在直接清單初始化內容中，'*type*' 的類型只能從單一初始化運算式運算式推算|
|[編譯器錯誤 C3519](compiler-error-c3519.md)|'*parameter*'： embedded_idl 屬性的參數無效|
|編譯器錯誤 C3520|'*identifier*'：參數套件必須在此內容中展開|
|編譯器錯誤 C3521|'*identifier*' 不是參數套件|
|編譯器錯誤 C3522|'*type*'：無法在此內容中展開參數套件|
|編譯器錯誤 C3523|' sizeof ... '需要做為其引數的未展開參數套件|
|編譯器錯誤 C3524|'*identifier*'： ' sizeof ' 無法套用至參數套件。 您是否表示使用 ' sizeof ... '？|
|編譯器錯誤 C3525|'*parameter*'：如果類別樣板具有樣板參數套件，它必須出現在範本參數清單的結尾|
|編譯器錯誤 C3526|'...'無法套用至 ' this '|
|編譯器錯誤 C3527|'*identifier*' 不是 ' sizeof ... ' 的有效運算元。 您要使用 ' sizeof ' 嗎？|
|編譯器錯誤 C3528|'*identifier1*'：此套件擴充中的元素數目不符合 '*identifier2*' 中的元素數目|
|編譯器錯誤 C3529|'*parameter*'：範本參數套件不能有預設引數|
|[編譯器錯誤 C3530](compiler-error-c3530.md)|'*type*' 無法與任何其他類型規範結合|
|[編譯器錯誤 C3531](compiler-error-c3531.md)|'*identifier*'：其類型包含 '*type*' 的符號必須有初始化運算式|
|[編譯器錯誤 C3532](compiler-error-c3532.md)|陣列的元素類型不能是包含 '*type*' 的類型|
|[編譯器錯誤 C3533](compiler-error-c3533.md)|參數不能有包含 '*type*' 的類型|
|編譯器錯誤 C3534|已過時。|
|[編譯器錯誤 C3535](compiler-error-c3535.md)|無法從 '*type2*' 推算 '*type1*' 的類型|
|[編譯器錯誤 C3536](compiler-error-c3536.md)|'*identifier*'：在初始化之前無法使用|
|[編譯器錯誤 C3537](compiler-error-c3537.md)|您不能轉換成包含 '*type*' 的類型|
|[編譯器錯誤 C3538](compiler-error-c3538.md)|在宣告子清單中，'*type*' 必須一律推算為相同的類型|
|[編譯器錯誤 C3539](compiler-error-c3539.md)|範本引數不可以是包含 '*type*' 的類型|
|[編譯器錯誤 C3540](compiler-error-c3540.md)|sizeof 不能套用至包含 '*type*' 的類型|
|[編譯器錯誤 C3541](compiler-error-c3541.md)|typeid 無法套用至包含 '*type*' 的類型|
|編譯器錯誤 C3542|'*identifier*'：虛擬成員函式不應該有包含 '*type*' 的傳回類型|
|編譯器錯誤 C3543|'*type*'：不包含參數套件|
|編譯器錯誤 C3544|'*parameter*'：參數套件需要類型樣板引數|
|編譯器錯誤 C3545|'*parameter*'：參數套件需要非類型樣板引數|
|編譯器錯誤 C3546|' ... '：沒有可供展開的參數套件|
|編譯器錯誤 C3547|無法使用樣板參數 '*parameter*'，因為它遵循範本參數套件，無法從 '*function*' 的函式參數推算|
|編譯器錯誤 C3548|'*identifier*'：參數套件不能用在此內容中|
|編譯器錯誤 C3549|'*value*'：函式參數套件不能有預設引數|
|[編譯器錯誤 C3550](compiler-error-c3550.md)|此內容中不得有純 'decltype(auto)'|
|[編譯器錯誤 C3551](compiler-error-c3551.md)|如果使用尾端傳回型別，則前置傳回型別應該是單一型別規範 ' auto ' （不是 '*type*'）|
|[編譯器錯誤 C3552](compiler-error-c3552.md)|必須是 ' decltype （auto） '|
|[編譯器錯誤 C3553](compiler-error-c3553.md)|decltype 必須是運算式而不是類型|
|[編譯器錯誤 C3554](compiler-error-c3554.md)|'*type*' 無法與任何其他類型規範結合|
|[編譯器錯誤 C3555](compiler-error-c3555.md)|'decltype' 的引數不正確|
|[編譯器錯誤 C3556](compiler-error-c3556.md)|'*expression*'： ' decltype ' 的引數不正確|
|編譯器錯誤 C3557|已過時。|
|編譯器錯誤 C3558|已過時。|
|編譯器錯誤 C3559|對 '*function*' 的遞迴呼叫：為 concurrency：:p arallel_for_each 編譯呼叫圖形時，偵測到遞迴： '*function*'|
|編譯器錯誤 C3560|'*function*'：編譯 concurrency：:p arallel_for_each 的呼叫圖形時，無法使用 IL： '*function*'|
|編譯器錯誤 C3561|為 concurrency：:p arallel_for_each 編譯呼叫圖形時，在控制流程中找到的磚屏障作業，不是並排顯示的： '*function*'|
|編譯器錯誤 C3562|內建函式 '*function*' 限制為不能有超過*數位*的參數|
|編譯器錯誤 C3563|編譯 concurrency：:p arallel_for_each 的呼叫圖形時，偵測到無限迴圈： '*function*'|
|編譯器錯誤 C3564|編譯 concurrency：:p arallel_for_each 的呼叫圖形時，讀取未初始化的值： '*function*'|
|編譯器錯誤 C3565|編譯 concurrency：:p 的呼叫圖表時，tile_static 記憶體的總數量（*數位*位元組）超過*number*個位元組的限制 arallel_for_each|
|編譯器錯誤 C3566|針對 concurrency：:p arallel_for_each 編譯呼叫圖表時，有副作用的區塊太深： '*function*'|
|編譯器錯誤 C3567|編譯 concurrency：:p arallel_for_each 的呼叫圖形時，偵測到零除或 mod： '*function*'|
|編譯器錯誤 C3568|編譯 concurrency：:p arallel_for_each 的呼叫圖形時，暫存器的總和超過*數位*的限制。 請簡化您的程式|
|編譯器錯誤 C3569|為 concurrency：:p arallel_for_each 編譯呼叫圖形時偵測到競爭條件： '*function*'|
|編譯器錯誤 C3570|以/clr 進行編譯時，不合法使用 amp 限制範圍|
|編譯器錯誤 C3571|'*type*'：不合法的計算網域引數;不是類別類型|
|編譯器錯誤 C3572|'*type*'：不合法的計算網域引數;遺漏公用成員： ' static const int rank ' 或 rank 值為非正數|
|編譯器錯誤 C3573|傳遞給 concurrency：:p arallel_for_each 的 concurrency：： graphics：：取樣的實例數目不能超過*數位*|
|編譯器錯誤 C3574|'*type*'：不合法的磚範圍：必須是正數，（1） Z < =*數位*;（2） Z*Y*X < =*數位*|
|編譯器錯誤 C3575|'*type*'：不合法的計算網域引數;遺漏公用成員： ' concurrency：： index <*number*> _map_index （const concurrency：： index <*number*> &） restrict （amp） '|
|編譯器錯誤 C3576|'*type*'： concurrency：:d etails：： _Parallel_for_each 引數 #*number*具有不支援的類型|
|編譯器錯誤 C3577|concurrency：:p arallel_for_each 核心引數不合法：無法解析成員 ' void operator （）（*類型*） restrict （amp） ' 的呼叫|
|編譯器錯誤 C3578|傳遞至 concurrency：:p arallel_for_each 的函式物件大小不能超過*數位*的位元組|
|編譯器錯誤 C3579|傳遞給 concurrency：:p arallel_for_each 的 concurrency：： array 和 concurrency：： graphics：：材質的唯讀實例數目不能超過*數位*|
|編譯器錯誤 C3580|傳遞給 concurrency：:p arallel_for_each 的 concurrency：： array 和 concurrency：： graphics：：材質的可寫入實例數目不能超過*數位*|
|編譯器錯誤 C3581|'*type*'： amp 限制程式碼中不支援的類型|
|編譯器錯誤 C3582|已過時。|
|編譯器錯誤 C3583|'*identifier*'：變數的大小（*數位*位元組）大於 amp 限制程式碼中支援的大小上限（*數位*位元組）|
|編譯器錯誤 C3584|'*identifier*' 上 tile_static 不支援的使用方式|
|編譯器錯誤 C3585|'*identifier*' 在 amp 限制程式碼中具有不支援的儲存類別|
|編譯器錯誤 C3586|'*identifier*'：在 amp 限制程式碼中不支援使用全域或靜態變數|
|編譯器錯誤 C3587|amp 限制程式碼中不支援 dynamic_cast|
|編譯器錯誤 C3588|在 amp 限制程式碼中不支援從 '*type1*' 轉換為 '*type2*'|
|編譯器錯誤 C3589|'*string*'：在 amp 限制程式碼中不支援使用字串常值|
|編譯器錯誤 C3590|'*token*'：如果 lambda 受到 amp 限制，則會以傳址方式捕捉或 ' this ' 捕捉不受支援|
|編譯器錯誤 C3591|在 amp 限制程式碼中不支援 typeid 運算子|
|編譯器錯誤 C3592|在 amp 限制程式碼中不支援內嵌原生組解碼（' __asm '）|
|編譯器錯誤 C3593|amp 限制程式碼中不支援 ' goto '|
|編譯器錯誤 C3594|在 amp 限制程式碼中不支援例外狀況處理（try、catch、throw 等等）|
|編譯器錯誤 C3595|常數值超出 amp 限制程式碼中支援的範圍|
|編譯器錯誤 C3596|'*parameter*' （'*type*'）： lambda 所捕捉的變數在 amp 限制程式碼中具有不支援的類型|
|編譯器錯誤 C3597|'*parameter*'：如果 lambda 是 amp 限制的，則不允許以傳值方式來捕捉 '*identifier*'|
|編譯器錯誤 C3598|amp 限制程式碼中不支援標籤語句|
|編譯器錯誤 C3599|'*operator*'：在 amp 限制程式碼中，無法對 bool 的指標執行指標算術|
|編譯器錯誤 C3600|'*function*'：在編譯非磚平行存取的呼叫圖形時，偵測到\_靜態記憶體：:p arallel\_for_each 位置： '*function*'|
|編譯器錯誤 C3601|'*type*'：對 amp 診斷函式 '*function*' 而言是不正確引數類型|
|編譯器錯誤 C3602|編譯 concurrency：:p arallel_for_each 的呼叫圖形時，偵測到不受支援的控制流程： '*function*'|
|[編譯器錯誤 C3603](compiler-error-c3603.md)|'*symbol*'：類型 '*type*' 尚未支援|
|編譯器錯誤 C3604|'*identifier*'：只能在 gc 堆積上建立 managed 物件|
|編譯器錯誤 C3605|為 concurrency：:p arallel_for_each 編譯呼叫圖表時，取樣器的總數（已捕捉的*數位* *和預先定義的數位）* 超過*數位*： '*function*'|
|編譯器錯誤 C3606|已過時。|
|編譯器錯誤 C3607|已過時。|
|編譯器錯誤 C3608|已過時。|
|[編譯器錯誤 C3609](compiler-error-c3609.md)|'*identifier*'： ' sealed/final ' 函數必須是虛擬的|
|[編譯器錯誤 C3610](compiler-error-c3610.md)|'*identifier*'：實數值型別必須是 ' 已裝箱 '，才可呼叫方法 '*method*'|
|[編譯器錯誤 C3611](compiler-error-c3611.md)|'*identifier*'：密封的函式不能有純規範|
|[編譯器錯誤 C3612](compiler-error-c3612.md)|'*identifier*'：密封的類別不能有任何純虛擬方法|
|編譯器錯誤 C3613|'-> ' 後面遺漏傳回型別（假設為 ' int '）|
|編譯器錯誤 C3614|相同類別內套件大小的不同值;previous 是「*值*」，新值是 '*value*'|
|[編譯器錯誤 C3615](compiler-error-c3615.md)|constexpr 函數 '*function*' 無法產生常數運算式|
|編譯器錯誤 C3616|已過時。|
|編譯器錯誤 C3617|已過時。|
|[編譯器錯誤 C3618](compiler-error-c3618.md)|'*宣告 '：* 無法定義標記為 DllImport 的方法|
|[編譯器錯誤 C3619](compiler-error-c3619.md)|無法在 managed/WinRT 類型中宣告範本|
|編譯器錯誤 C3620|'*type*'：不允許在 WinRT 類型上設定對齊|
|編譯器錯誤 C3621|'*type*'： WinRT 類型僅允許預設的封裝值（*數位*）|
|[編譯器錯誤 C3622](compiler-error-c3622.md)|*類型*'：無法具現化宣告為 '*關鍵字*' 的類別|
|[編譯器錯誤 C3623](compiler-error-c3623.md)|'*identifier*'： Managed/WinRT 類型中不支援位欄位|
|[編譯器錯誤 C3624](compiler-error-c3624.md)|'*type*'：使用此類型需要元件/模組 '*identifier*' 的參考|
|[編譯器錯誤 C3625](compiler-error-c3625.md)|'*class*'：原生類型不能衍生自 Managed/WinRT 類型 '*type*'|
|[編譯器錯誤 C3626](compiler-error-c3626.md)|'*identifier*'： '*關鍵字*' 關鍵字只能用在 COM 介面、成員函式和屬於委派指標的資料成員上|
|[編譯器錯誤 C3627](compiler-error-c3627.md)|只有實數值型別可以進行裝箱|
|[編譯器錯誤 C3628](compiler-error-c3628.md)|'*class*'： Managed/WinRT 類別僅支援公用繼承|
|編譯器錯誤 C3629|'*token*'：捕捉預設值只能出現在 lambda 捕捉清單的開頭|
|[編譯器錯誤 C3630](compiler-error-c3630.md)|處理權杖 '*token*' 時發生錯誤|
|[編譯器錯誤 C3631](compiler-error-c3631.md)|'*event*'：無法多載 Managed/WinRT 事件|
|[編譯器錯誤 C3632](compiler-error-c3632.md)|'*event*'：*結構*的事件樣式不合法|
|[編譯器錯誤 C3633](compiler-error-c3633.md)|無法將 '*identifier*' 定義為受控 '*class*' 的成員|
|[編譯器錯誤 C3634](compiler-error-c3634.md)|'*member*'：無法定義 Managed/WinRT 類別的抽象方法|
|編譯器錯誤 C3635|'*identifier*'：無法套用至 Managed/WinRT 類別（請改用 '*identifier*'）|
|編譯器錯誤 C3636|'*identifier*'：無法套用至此類型|
|[編譯器錯誤 C3637](compiler-error-c3637.md)|'*function*'： friend 函式定義不能是函數樣板/泛型的特製化|
|[編譯器錯誤 C3638](compiler-error-c3638.md)|'*operator*'：無法重新定義標準的裝箱和取消裝箱轉換運算子|
|編譯器錯誤 C3639|已過時。|
|[編譯器錯誤 C3640](compiler-error-c3640.md)|'*member*'：必須定義區域類別的參考或虛擬成員函式|
|[編譯器錯誤 C3641](compiler-error-c3641.md)|'*function*'：以/clr： pure 或/clr： safe 編譯之函式的呼叫慣例 '*慣例*' 無效|
|[編譯器錯誤 C3642](compiler-error-c3642.md)|'*function*'：無法從機器碼呼叫具有 __clrcall 呼叫慣例的函式|
|編譯器錯誤 C3643|已過時。|
|[編譯器錯誤 C3644](compiler-error-c3644.md)|'*function*'：無法編譯函數來產生 managed 程式碼|
|[編譯器錯誤 C3645](compiler-error-c3645.md)|'*function*'： __clrcall 不能用在編譯為機器碼的函式上|
|[編譯器錯誤 C3646](compiler-error-c3646.md)|'*identifier*'：未知的覆寫規範|
|編譯器錯誤 C3647|已過時。|
|[編譯器錯誤 C3648](compiler-error-c3648.md)|managed 類型不支援這個明確覆寫語法|
|編譯器錯誤 C3649|/ZW 不允許使用此明確覆寫語法|
|[編譯器錯誤 C3650](compiler-error-c3650.md)|'*member*'：不能當做明確覆寫使用，必須是基類的虛擬成員函式|
|[編譯器錯誤 C3651](compiler-error-c3651.md)|'*member*'：不能當做明確覆寫使用，必須是基類的成員|
|[編譯器錯誤 C3652](compiler-error-c3652.md)|'*member*'：明確覆寫的函式必須是虛擬的|
|[編譯器錯誤 C3653](compiler-error-c3653.md)|'*identifier*'：不能當做已命名的覆寫使用：找不到正在覆寫的函式;您忘了使用：： operator 明確命名函式嗎？|
|[編譯器錯誤 C3654](compiler-error-c3654.md)|'*token*'：明確覆寫中的語法錯誤|
|[編譯器錯誤 C3655](compiler-error-c3655.md)|'*member*'：函數已明確覆寫|
|[編譯器錯誤 C3656](compiler-error-c3656.md)|'*關鍵字*'：覆寫規範不能重複|
|[編譯器錯誤 C3657](compiler-error-c3657.md)|無法明確覆寫或明確覆寫析構函式/完成項|
|編譯器錯誤 C3658|已過時。|
|編譯器錯誤 C3659|'*member*'：不支援覆寫規範 '*關鍵字*'|
|編譯器錯誤 C3660|'*member1*'：隱藏繼承的成員 '*member2*'|
|[編譯器錯誤 C3661](compiler-error-c3661.md)|明確覆寫清單找不到任何要覆寫的方法|
|[編譯器錯誤 C3662](compiler-error-c3662.md)|'*member*'：覆寫規範 '*關鍵字*' 只允許用於 managed/WinRT 類別的成員函式|
|編譯器錯誤 C3663|已過時。|
|編譯器錯誤 C3664|'*member*'：不能當做明確覆寫使用，必須有 ' public ' 或 ' protected ' 協助工具|
|[編譯器錯誤 C3665](compiler-error-c3665.md)|'*member*'：在析構函式/完成項上不允許有覆寫規範 '*關鍵字*'|
|[編譯器錯誤 C3666](compiler-error-c3666.md)|'*函數*'：不允許在函式上使用覆寫規範 '*關鍵字*'|
|編譯器錯誤 C3667|'*attribute*'：屬性不支援套件展開|
|[編譯器錯誤 C3668](compiler-error-c3668.md)|'*member*'：具有覆寫規範 ' override ' 的方法並未覆寫任何基類方法|
|[編譯器錯誤 C3669](compiler-error-c3669.md)|'*member*'：在靜態成員函式或函式上不允許有覆寫規範 ' override '|
|[編譯器錯誤 C3670](compiler-error-c3670.md)|'*member*'：無法覆寫無法存取的基類方法 '*member*'|
|[編譯器錯誤 C3671](compiler-error-c3671.md)|'*member*'：函數不會覆寫 '*member*'|
|[編譯器錯誤 C3672](compiler-error-c3672.md)|虛擬析構函式運算式只能當做函式呼叫的一部分使用|
|[編譯器錯誤 C3673](compiler-error-c3673.md)|'*class*'：類別沒有複製-函數|
|編譯器錯誤 C3674|找不到標準程式庫模組 '*module*'|
|[編譯器錯誤 C3675](compiler-error-c3675.md)|'*function*'：已保留，因為已定義 '*property*'|
|編譯器錯誤 C3676|'*class*'： ref 類別和基類具有不相容的屬性 ' [*attribute*] '|
|編譯器錯誤 C3677|' operator ' 後面的字串常值不能有編碼前置詞|
|編譯器錯誤 C3678|' operator ' 後面的字串常值必須是空字串 ' "" "" "|
|編譯器錯誤 C3679|' operator "" "" "後面必須有常值尾碼識別碼|
|編譯器錯誤 C3680|無法串連使用者定義的字串常值與不相符的常值尾碼識別碼|
|編譯器錯誤 C3681|' fallthrough '：屬性只可以出現在封閉式 switch 語句中|
|編譯器錯誤 C3682|' operator *identifier*'：常值運算子/常值運算子範本不能宣告為具有 ' C 連結 '|
|編譯器錯誤 C3683|無法使用相同的常值尾碼識別碼來定義原始常值運算子和常值運算子範本|
|編譯器錯誤 C3684|' operator *identifier*'：常值運算子的宣告具有不正確參數清單|
|編譯器錯誤 C3685|' operator *identifier*'：常值運算子範本不能有函數參數|
|編譯器錯誤 C3686|' operator *identifier*'：常值運算子範本只能有一個參數套件的範本參數|
|編譯器錯誤 C3687|' operator *identifier*'：常值運算子範本必須有類型 ' char ' 的非類型範本參數|
|編譯器錯誤 C3688|不正確常值尾碼 '*尾碼*';找不到常值運算子或常值運算子範本 ' operator *identifier*'|
|編譯器錯誤 C3689|' operator *identifier*'：常值運算子/常值運算子範本必須在全域或命名空間範圍中|
|編譯器錯誤 C3690|必須是字串常值，但卻找到使用者定義的字串常值|
|編譯器錯誤 C3691|不正確常值前置詞 '*prefix*'|
|編譯器錯誤 C3692|已過時。|
|編譯器錯誤 C3693|已過時。|
|編譯器錯誤 C3694|已過時。|
|編譯器錯誤 C3695|已過時。|
|編譯器錯誤 C3696|'*關鍵字*'：不能在 '% ' 上使用這個限定詞|
|[編譯器錯誤 C3697](compiler-error-c3697.md)|'*關鍵字*'：不能在 ' ^ ' 上使用這個限定詞|
|[編譯器錯誤 C3698](compiler-error-c3698.md)|'*type*'：不能使用這個類型做為 '*operator*' 的引數|
|[編譯器錯誤 C3699](compiler-error-c3699.md)|'*operator*'：無法在類型 '*type*' 上使用這個間接取值|
|編譯器錯誤 C3700|已過時。|
|[編譯器錯誤 C3701](compiler-error-c3701.md)|'*function*'：事件來源沒有事件|
|[編譯器錯誤 C3702](compiler-error-c3702.md)|COM 事件需要 ATL|
|[編譯器錯誤 C3703](compiler-error-c3703.md)|'*event_handler*'：事件處理常式方法必須具有與來源 '*event*' 相同的儲存類別|
|[編譯器錯誤 C3704](compiler-error-c3704.md)|'*member*'： vararg 方法無法引發事件|
|[編譯器錯誤 C3705](compiler-error-c3705.md)|'*function*'：找不到事件介面|
|[編譯器錯誤 C3706](compiler-error-c3706.md)|'*function*'：必須是 com 介面，才能引發 com 事件|
|[編譯器錯誤 C3707](compiler-error-c3707.md)|'*member*'：分配介面方法必須有 dispid|
|[編譯器錯誤 C3708](compiler-error-c3708.md)|'*function*'：不正確地使用了 '*關鍵字*';必須是相容事件來源的成員|
|[編譯器錯誤 C3709](compiler-error-c3709.md)|'*function*'：在 __hook/__unhook 中指定事件的語法不正確|
|[編譯器錯誤 C3710](compiler-error-c3710.md)|'*function*'：在 __hook/__unhook 中指定事件處理常式的語法不正確|
|[編譯器錯誤 C3711](compiler-error-c3711.md)|'*event*'：非受控事件來源方法必須傳回 void 或整數類型|
|[編譯器錯誤 C3712](compiler-error-c3712.md)|'*event_handler*'：事件處理常式方法必須傳回與來源 '*event*' 相同的類型|
|[編譯器錯誤 C3713](compiler-error-c3713.md)|'*event_handler*'：事件處理常式方法必須具有與來源 '*event*' 相同的函數參數|
|[編譯器錯誤 C3714](compiler-error-c3714.md)|'*event_handler*'：事件處理常式方法必須與來源 '*event*' 具有相同的呼叫慣例|
|[編譯器錯誤 C3715](compiler-error-c3715.md)|'*指標*'：必須是 '*type*' 的指標|
|編譯器錯誤 C3716|已過時。|
|[編譯器錯誤 C3717](compiler-error-c3717.md)|'*member*'：無法定義引發事件的方法|
|[編譯器錯誤 C3718](compiler-error-c3718.md)|只能在接收類別的成員函式內容中呼叫 ' __*關鍵字*'|
|[編譯器錯誤 C3719](compiler-error-c3719.md)|'*member*'：以介面為基礎的事件來源只能用於 COM 事件|
|編譯器錯誤 C3720|'*type*'：只能在雙重或分配介面上執行 IDispatch|
|[編譯器錯誤 C3721](compiler-error-c3721.md)|'*signature*'：事件的簽章不相容|
|[編譯器錯誤 C3722](compiler-error-c3722.md)|不允許泛型事件|
|[編譯器錯誤 C3723](compiler-error-c3723.md)|'*function*'：無法解析事件|
|[編譯器錯誤 C3724](compiler-error-c3724.md)|必須 #include \<的 windows >，才能使用多執行緒處理事件|
|編譯器錯誤 C3725|已過時。|
|編譯器錯誤 C3726|已過時。|
|[編譯器錯誤 C3727](compiler-error-c3727.md)|'*event*'： managed 事件必須是成員函式，或是委派的指標的資料成員|
|[編譯器錯誤 C3728](compiler-error-c3728.md)|'*event*'：事件沒有 raise 方法|
|編譯器錯誤 C3729|已過時。|
|編譯器錯誤 C3730|已過時。|
|[編譯器錯誤 C3731](compiler-error-c3731.md)|不相容的事件 '*event*' 和處理常式 '*event_handler*';事件來源和事件處理常式必須有相同的事件種類|
|[編譯器錯誤 C3732](compiler-error-c3732.md)|「*介面*」：引發 COM 事件的自訂介面無法從 IDispatch 繼承|
|[編譯器錯誤 C3733](compiler-error-c3733.md)|'*event*'：指定 COM 事件的語法不正確;您忘了 ' __interface ' 嗎？|
|[編譯器錯誤 C3734](compiler-error-c3734.md)|'*class*'： Managed/WinRT 類別不可以是 coclass|
|編譯器錯誤 C3735|已過時。|
|[編譯器錯誤 C3736](compiler-error-c3736.md)|'*member*'：必須是方法，或在 managed 事件的情況下，選擇性地是資料成員|
|[編譯器錯誤 C3737](compiler-error-c3737.md)|'*identifier*'：委派不能有明確的呼叫慣例|
|[編譯器錯誤 C3738](compiler-error-c3738.md)|'*慣例*'：明確具現化的呼叫慣例必須符合要具現化的範本|
|[編譯器錯誤 C3739](compiler-error-c3739.md)|'*class*'：只有在 event_receiver 的 ' layout\_相依 ' 參數為 true 時，才支援語法|
|[編譯器錯誤 C3740](compiler-error-c3740.md)|'*template*'：範本無法來源或接收事件|
|[編譯器錯誤 C3741](compiler-error-c3741.md)|'*class*'：當 event_receiver 的 ' layout\_相依 ' 參數為 true 時，必須是 coclass|
|編譯器錯誤 C3742|'*token1*'： '*attribute*' 的屬性引數中有不對稱的 token 順序，應為 '*token2*'|
|[編譯器錯誤 C3743](compiler-error-c3743.md)|當 event_receiver 的 ' layout_dependent ' 參數為 true 時，只能對整個介面進行攔截/解除掛接|
|[編譯器錯誤 C3744](compiler-error-c3744.md)|__unhook 的 managed 事件必須至少有3個引數|
|[編譯器錯誤 C3745](compiler-error-c3745.md)|'*function*'：只有事件可以是 ' 凸起 '|
|編譯器錯誤 C3746|在屬性清單中，標準屬性 '*identifier*' 最多隻能出現一次|
|[編譯器錯誤 C3747](compiler-error-c3747.md)|遺漏預設範本/泛型參數：參數*編號*|
|[編譯器錯誤 C3748](compiler-error-c3748.md)|「*介面*」：非受控介面可能不會引發事件|
|[編譯器錯誤 C3749](compiler-error-c3749.md)|'*attribute*'：自訂屬性不能用在函式內|
|編譯器錯誤 C3750|'*token*'：屬性清單中有未預期的標記|
|編譯器錯誤 C3751|'*identifier*'：屬性清單中有未預期的識別碼|
|[編譯器錯誤 C3752](compiler-error-c3752.md)|'*attribute*'：無法分類屬性;'*關鍵字*' 不應在此內容中使用|
|[編譯器錯誤 C3753](compiler-error-c3753.md)|不允許泛型屬性|
|[編譯器錯誤 C3754](compiler-error-c3754.md)|委派的函式：無法在類型 '*type*' 的實例上呼叫成員函式 '*member*'|
|[編譯器錯誤 C3755](compiler-error-c3755.md)|'*identifier*'：委派不得定義|
|編譯器錯誤 C3756|已過時。|
|編譯器錯誤 C3757|'*type*'： ' constexpr ' 函式不允許類型|
|編譯器錯誤 C3758|'*member*'：虛擬函式不可宣告為 ' constexpr '|
|編譯器錯誤 C3759|'*member*'：非常數值型別的成員函式不能宣告為 ' constexpr '|
|編譯器錯誤 C3760|請使用 __property 關鍵字來宣告 managed/WinRT '*class*' 中的屬性|
|[編譯器錯誤 C3761](compiler-error-c3761.md)|'*function*'： ' retval ' 只能出現在函數的最後一個引數上|
|[編譯器錯誤 C3762](compiler-error-c3762.md)|無法處理屬性 '*attribute*'|
|[編譯器錯誤 C3763](compiler-error-c3763.md)|'*type*'： ' retval ' 和 ' out ' 只能出現在資料指標類型上|
|[編譯器錯誤 C3764](compiler-error-c3764.md)|'*member*'：無法覆寫基類方法 '*member*'|
|[編譯器錯誤 C3765](compiler-error-c3765.md)|'*event*'：無法在標記為 event_receiver 的類別/結構 '*type*' 中定義事件|
|[編譯器錯誤 C3766](compiler-error-c3766.md)|'*type*' 必須提供介面方法 '*function*' 的執行|
|[編譯器錯誤 C3767](compiler-error-c3767.md)|'*function*'：候選函數無法存取|
|[編譯器錯誤 C3768](compiler-error-c3768.md)|無法在純粹的 managed 程式碼中採用虛擬 vararg 函式的位址|
|[編譯器錯誤 C3769](compiler-error-c3769.md)|'*identifier*'：嵌套類別不能與直接封入類別同名|
|編譯器錯誤 C3770|'*type*'：不是有效的基類|
|[編譯器錯誤 C3771](compiler-error-c3771.md)|'*identifier*'：在最接近的命名空間範圍中找不到 friend 宣告|
|[編譯器錯誤 C3772](compiler-error-c3772.md)|'*identifier*'：不正確 friend 範本宣告|
|編譯器錯誤 C3773|請使用/await 編譯器參數來啟用協同程式|
|編譯器錯誤 C3774|找不到 '*scope*：：*Identifier*'：請包含*標頭*標頭|
|編譯器錯誤 C3775|'*function*' 的傳回類型不應為 '*type*'|
|編譯器錯誤 C3776|無法在具有非 void 最終傳回類型的協同程式中傳回 void 類型的運算式|
|編譯器錯誤 C3777|'*function*'：協同程式無法接受可變引數清單|
|編譯器錯誤 C3778|alloca：無法在協同程式中使用|
|編譯器錯誤 C3779|'*function*'：傳回 '*type*' 的函式在定義之前無法使用|
|編譯器錯誤 C3780|'*function*'：傳回 '*type*' 的轉換函數在定義之前無法使用|
|編譯器錯誤 C3781|'*關鍵字*'：不能在類型 '*type*' 的協同程式中使用。 *關鍵字*或*關鍵字*必須存在於相關聯的 promise_type|
|編譯器錯誤 C3782|*類型*：協同程式的承諾不得同時包含*關鍵字*和*關鍵字*|
|編譯器錯誤 C3783|'*identifier*'：不可以是協同程式|
|編譯器錯誤 C3784|*關鍵字*運算式不能出現在此內容中|
|編譯器錯誤 C3785|' std：： integer_sequence ' 的第一個範本引數必須是整數類型|
|編譯器錯誤 C3786|' std：： make_integer_sequence ' 的第二個樣板引數必須是大於或等於零的整數常數|
|編譯器錯誤 C3787|無法推算此協同程式的傳回類型|
|編譯器錯誤 C3788|已過時。|
|編譯器錯誤 C3789|已過時。|
|編譯器錯誤 C3790|已過時。|
|編譯器錯誤 C3791|已過時。|
|編譯器錯誤 C3792|已過時。|
|編譯器錯誤 C3793|已過時。|
|編譯器錯誤 C3794|已過時。|
|編譯器錯誤 C3795|已過時。|
|編譯器錯誤 C3796|已過時。|
|[編譯器錯誤 C3797](compiler-error-c3797.md)|'*關鍵字*'：事件宣告不能有覆寫規範（應該放在事件新增/移除/引發方法上）|
|[編譯器錯誤 C3798](compiler-error-c3798.md)|'*關鍵字*'：屬性宣告不能有覆寫規範（應該放在屬性 get/set 方法上）|
|[編譯器錯誤 C3799](compiler-error-c3799.md)|已編制索引的屬性不能有空白的參數清單|
|[編譯器錯誤 C3800](compiler-error-c3800.md)|'*宣告 '：* 不能混合屬性和事件|
|編譯器錯誤 C3801|'*attribute*'：屬性不能有引數子句|
|編譯器錯誤 C3802|已過時。|
|[編譯器錯誤 C3803](compiler-error-c3803.md)|'*property*'：屬性具有與它的其中一個存取子 '*存取*子 ' 不相容的類型|
|[編譯器錯誤 C3804](compiler-error-c3804.md)|'*member*'：屬性的存取子方法必須全部為靜態或所有非靜態|
|[編譯器錯誤 C3805](compiler-error-c3805.md)|'*token*'：未預期的標記，必須是 '} ' 或 '，'|
|編譯器錯誤 C3806|'*token*'：未預期的標記，必須是 ' {' 或成員初始化運算式|
|[編譯器錯誤 C3807](compiler-error-c3807.md)|'*type*'：具有 ComImport 屬性的類別無法衍生自 '*type*'，只允許介面實作為|
|[編譯器錯誤 C3808](compiler-error-c3808.md)|'*type*'：具有 ComImport 屬性的類別無法定義成員 '*member*'，只允許 abstract 或 dllimport 函數|
|[編譯器錯誤 C3809](compiler-error-c3809.md)|'*type*'： Managed/WinRT 類型不能有任何 friend 函式/類別/介面|
|編譯器錯誤 C3810|已過時。|
|編譯器錯誤 C3811|已過時。|
|[編譯器錯誤 C3812](compiler-error-c3812.md)|' __property ' 必須是屬性宣告中的第一個 token|
|[編譯器錯誤 C3813](compiler-error-c3813.md)|屬性宣告只能出現在 managed/WinRT 類型的定義中|
|編譯器錯誤 C3814|已過時。|
|[編譯器錯誤 C3815](compiler-error-c3815.md)|方法 '*member*' 的傳回類型必須符合 setter 最後一個參數的類型|
|[編譯器錯誤 C3816](compiler-error-c3816.md)|「類別/結構*成員*」先前已用不同的 Managed/WinRT 修飾詞宣告或定義|
|[編譯器錯誤 C3817](compiler-error-c3817.md)|'*宣告 '：* 屬性只能套用至函數|
|[編譯器錯誤 C3818](compiler-error-c3818.md)|陣列屬性宣告 '*property*' 不應多載索引屬性 '*property*'|
|編譯器錯誤 C3819|已過時。|
|[編譯器錯誤 C3820](compiler-error-c3820.md)|'*identifier*'：初始化運算式必須是受控的|
|[編譯器錯誤 C3821](compiler-error-c3821.md)|'*function*'： managed 類型或函數不能用在非受控函式中|
|編譯器錯誤 C3822|已過時。|
|編譯器錯誤 C3823|已過時。|
|[編譯器錯誤 C3824](compiler-error-c3824.md)|'*type*'：這個類型不能出現在此內容中（函式參數、傳回類型或靜態成員）|
|[編譯器錯誤 C3825](compiler-error-c3825.md)|'*type*'： Managed/winrt 類別只能支援 Managed/winrt 事件|
|編譯器錯誤 C3826|已過時。|
|編譯器錯誤 C3827|標準屬性 ' 已被取代 ' 可能沒有引數或一個字串常值，描述原因|
|[編譯器錯誤 C3828](compiler-error-c3828.md)|無法為類型 '*type*' 的 '*關鍵字*' 運算式指定位置引數|
|編譯器錯誤 C3829|標準屬性 ' noreturn ' 只可套用至函數|
|[編譯器錯誤 C3830](compiler-error-c3830.md)|'*type1*'：無法繼承自 '*type2*'，實數值型別只能繼承自介面類別別|
|[編譯器錯誤 C3831](compiler-error-c3831.md)|'*identifier*'： '*type*' 不能有釘選的資料成員或成員函式傳回釘選指標|
|[編譯器錯誤 C3832](compiler-error-c3832.md)|'*typelib*'：類型程式庫看起來就像是針對32位指標所建立的一樣。請變更 ' ptrsize ' 限定詞|
|[編譯器錯誤 C3833](compiler-error-c3833.md)|'*type*'：*識別碼*的目標型別無效|
|[編譯器錯誤 C3834](compiler-error-c3834.md)|不合法的明確轉換為固定指標;請改用釘選的本機變數|
|編譯器錯誤 C3835|已過時。|
|[編譯器錯誤 C3836](compiler-error-c3836.md)|靜態的函式不能有成員初始化運算式清單|
|編譯器錯誤 C3837|在此內容中不允許屬性|
|[編譯器錯誤 C3838](compiler-error-c3838.md)|無法繼承自 '*type*'|
|[編譯器錯誤 C3839](compiler-error-c3839.md)|無法變更 managed/WinRT 類型中的對齊|
|編譯器錯誤 C3840|已過時。|
|編譯器錯誤 C3841|已過時。|
|[編譯器錯誤 C3842](compiler-error-c3842.md)|'*identifier*'：不支援 Managed/WinRT 類型的成員函式上的 ' const ' 和 ' volatile ' 限定詞|
|編譯器錯誤 C3843|'*identifier*'：不支援 Managed/WinRT 類型的成員函式上的 ref 限定詞|
|編譯器錯誤 C3844|'*identifier*'：無法從 '*source*' 匯入符號：因為在目前的範圍中已經有 '*identifier*'|
|編譯器錯誤 C3845|已過時。|
|[編譯器錯誤 C3846](compiler-error-c3846.md)|'*identifier*'：無法從 '*source*' 匯入符號：因為 '*identifier*' 已從另一個元件 '*assembly*' 匯入|
|編譯器錯誤 C3847|已過時。|
|[編譯器錯誤 C3848](compiler-error-c3848.md)|具有類型 '*type*' 的運算式會遺失某些 const volatile 限定詞，以便呼叫 '*identifier*'|
|[編譯器錯誤 C3849](compiler-error-c3849.md)|類型 '*type*' 之運算式上的函數樣式呼叫會遺失所有可用運算子*多*載的 const 和/或 volatile 限定詞|
|[編譯器錯誤 C3850](compiler-error-c3850.md)|'*token*'：通用字元名稱指定了不正確字元|
|[編譯器錯誤 C3851](compiler-error-c3851.md)|'*token*'：通用字元名稱不能指定基底字元集中的字元|
|[編譯器錯誤 C3852](compiler-error-c3852.md)|'*member*' 具有類型 '*type*'：匯總初始化無法初始化這個成員|
|[編譯器錯誤 C3853](compiler-error-c3853.md)|' = '：透過參考功能重新初始化參考或指派是不合法的|
|[編譯器錯誤 C3854](compiler-error-c3854.md)|' = ' 左邊的運算式會評估為函式。 無法指派給函式（函數不是左值）|
|[編譯器錯誤 C3855](compiler-error-c3855.md)|'*function*'：範本/泛型參數 '*identifier*' 與宣告不相容|
|[編譯器錯誤 C3856](compiler-error-c3856.md)|'*class*'：類別不是類別範本/泛型|
|[編譯器錯誤 C3857](compiler-error-c3857.md)|'*template*'：不允許多個範本/泛型參數清單|
|[編譯器錯誤 C3858](compiler-error-c3858.md)|'*identifier*'：無法在目前的範圍內重新宣告|
|[編譯器錯誤 C3859](compiler-error-c3859.md)|超過 PCH 的虛擬記憶體範圍;請使用 '-Zm*number*' 或更高的命令列選項重新編譯|
|[編譯器錯誤 C3860](compiler-error-c3860.md)|範本/泛型引數清單下列類別樣板/泛型名稱必須以範本/泛型參數清單中使用的順序列出參數|
|[編譯器錯誤 C3861](compiler-error-c3861.md)|'*identifier*'：找不到識別碼|
|[編譯器錯誤 C3862](compiler-error-c3862.md)|'*function*'：無法使用/clr： pure 或/clr： safe 編譯非受控函式|
|編譯器錯誤 C3863|陣列類型 '*type*' 無法指派|
|編譯器錯誤 C3864|已過時。|
|[編譯器錯誤 C3865](compiler-error-c3865.md)|'*關鍵字*'：只能用在原生成員函式上|
|[編譯器錯誤 C3866](compiler-error-c3866.md)|析構函式/完成項呼叫遺漏引數清單|
|[編譯器錯誤 C3867](compiler-error-c3867.md)|'*function*'：非標準語法;使用 ' & ' 來建立成員的指標|
|[編譯器錯誤 C3868](compiler-error-c3868.md)|'*type*'：泛型參數 '*parameter*' 的條件約束與宣告上的限制式不同|
|[編譯器錯誤 C3869](compiler-error-c3869.md)|gcnew 條件約束缺少空的參數清單 ' （） '|
|編譯器錯誤 C3870|'*parameter*'： ' __declspec （*規範*） ' 只能套用至整數類資料類型的參數|
|編譯器錯誤 C3871|'*parameter*'： ' __declspec （guard （溢位）） ' 只有在函式的前64個參數上才支援|
|[編譯器錯誤 C3872](compiler-error-c3872.md)|' 0x*value*'：識別碼中不允許此字元|
|[編譯器錯誤 C3873](compiler-error-c3873.md)|' 0x*value*'：不允許此字元作為識別碼的第一個字元|
|[編譯器錯誤 C3874](compiler-error-c3874.md)|'*identifier*' 的傳回類型應該是 '*type1*'，而不是 '*type2*'|
|編譯器錯誤 C3875|呼叫非靜態成員函式遺漏引數清單|
|編譯器錯誤 C3876|已過時。|
|編譯器錯誤 C3877|已過時。|
|編譯器錯誤 C3878|已過時。|
|編譯器錯誤 C3879|'*member*'：不可以是 initonly 資料成員|
|[編譯器錯誤 C3880](compiler-error-c3880.md)|'*member*'：不可以是常值資料成員|
|編譯器錯誤 C3881|只能從直接基底繼承函式|
|編譯器錯誤 C3882|'*class*'：已經從 '*class*' 繼承了函式|
|編譯器錯誤 C3883|'*member*'： initonly 靜態資料成員必須初始化|
|編譯器錯誤 C3884|'*type*'：未知大小的陣列無法以值初始化|
|編譯器錯誤 C3885|'*type*'：無法使用空的初始化運算式清單初始化未知大小的陣列|
|[編譯器錯誤 C3886](compiler-error-c3886.md)|'*member*'：常值資料成員必須初始化|
|[編譯器錯誤 C3887](compiler-error-c3887.md)|'*member*'：常值資料成員的初始化運算式必須是常數運算式|
|[編譯器錯誤 C3888](compiler-error-c3888.md)|'*member*'： C++/cli 不支援與這個常值資料成員相關聯的 const 運算式|
|編譯器錯誤 C3889|已過時。|
|[編譯器錯誤 C3890](compiler-error-c3890.md)|'*member*'：您無法接受常值資料成員的位址|
|[編譯器錯誤 C3891](compiler-error-c3891.md)|'*member*'：常值資料成員不能用來做為左值|
|[編譯器錯誤 C3892](compiler-error-c3892.md)|'*variable*'：您無法指派給 const 變數|
|[編譯器錯誤 C3893](compiler-error-c3893.md)|'*member*'： initonly 資料成員的左值使用只允許用於類別 '*class*' 的實例構造函式|
|[編譯器錯誤 C3894](compiler-error-c3894.md)|'*member*'： initonly 靜態資料成員的左值使用只允許用於類別 '*class*' 的類別函式|
|[編譯器錯誤 C3895](compiler-error-c3895.md)|'*member*'：*類型*資料成員不可為 ' volatile '|
|[編譯器錯誤 C3896](compiler-error-c3896.md)|'*member*'：不適當的初始化運算式：這個常值資料成員只能以 ' nullptr ' 初始化|
|編譯器錯誤 C3897|已過時。|
|[編譯器錯誤 C3898](compiler-error-c3898.md)|'*member*'：*類型*資料成員只能是 managed 類型的成員|
|[編譯器錯誤 C3899](compiler-error-c3899.md)|'*member*'：不允許在類別 '*class*' 的平列區域中直接使用 initonly 資料成員的左值|
|[編譯器錯誤 C3900](compiler-error-c3900.md)|'*member*'：在目前的範圍中不允許|
|[編譯器錯誤 C3901](compiler-error-c3901.md)|'*function*'：必須有傳回類型 '*type*'|
|[編譯器錯誤 C3902](compiler-error-c3902.md)|'*function*'：最後一個參數的類型必須是 '*type*'|
|[編譯器錯誤 C3903](compiler-error-c3903.md)|'*property*'：沒有 set 或 get 方法|
|[編譯器錯誤 C3904](compiler-error-c3904.md)|'*property*'：必須指定*數位*參數|
|編譯器錯誤 C3905|內部類型 '*type*' 不支援未對齊的存取|
|編譯器錯誤 C3906|內部類型 '*type*' 不是 vararg 或沒有原型函式支援的傳回或引數類型|
|編譯器錯誤 C3907|已過時。|
|[編譯器錯誤 C3908](compiler-error-c3908.md)|存取層級比 '*identifier*' 的限制低|
|[編譯器錯誤 C3909](compiler-error-c3909.md)|managed/WinRT 事件宣告必須發生在 managed/WinRT 類型中|
|[編譯器錯誤 C3910](compiler-error-c3910.md)|'*event*'：必須定義成員 '*member*'|
|[編譯器錯誤 C3911](compiler-error-c3911.md)|'*member*'：函數必須有類型 '*type*'|
|[編譯器錯誤 C3912](compiler-error-c3912.md)|'*event*'：事件的類型必須是委派類型|
|[編譯器錯誤 C3913](compiler-error-c3913.md)|必須為預設屬性編制索引|
|[編譯器錯誤 C3914](compiler-error-c3914.md)|預設屬性不可以是靜態的|
|[編譯器錯誤 C3915](compiler-error-c3915.md)|'*identifier*' 沒有預設索引屬性（類別索引子）|
|編譯器錯誤 C3916|已過時。|
|[編譯器錯誤 C3917](compiler-error-c3917.md)|'*token*'：已淘汰的*結構*聲明樣式（您是否要使用 ' [' '] ' 代替？）|
|[編譯器錯誤 C3918](compiler-error-c3918.md)|使用方式要求 '*identifier*' 必須是資料成員|
|[編譯器錯誤 C3919](compiler-error-c3919.md)|'*function*'：函式必須有類型 '*return_type* （*類型*） '|
|[編譯器錯誤 C3920](compiler-error-c3920.md)|'*operator*'：無法定義後置遞增/遞減 Clr/winrt 運算子呼叫後置 Clr/winrt 運算子將會呼叫對應的前置詞 Clr/winrt 運算子（op_Increment/op_Decrement），但使用後置語義|
|編譯器錯誤 C3921|已過時。|
|編譯器錯誤 C3922|已過時。|
|[編譯器錯誤 C3923](compiler-error-c3923.md)|'*member*'： Managed/WinRT 類別的成員函式中不允許有區域類別、結構或等位定義|
|編譯器錯誤 C3924|引數 #*呼叫 ' 函式 ' 的* *數目*發生錯誤：|
|編譯器錯誤 C3925|在 *' 指示詞 ' 指示*詞後面必須有迴圈（for、while 或 do）|
|編譯器錯誤 C3926|' parallel ' 指示詞中的常數無效|
|編譯器錯誤 C3927|'-> '：不允許在非函式宣告子之後使用尾端傳回類型|
|編譯器錯誤 C3928|'-> '：以括弧括住的宣告子之後，不允許尾端傳回類型|
|編譯器錯誤 C3929|已過時。|
|編譯器錯誤 C3930|'*function*'：沒有任何多載函式具有與環境內容「*內容*」相容的限制規範|
|編譯器錯誤 C3931|'*type*'：無法呼叫具有與環境內容不相容之限制規範的函式|
|編譯器錯誤 C3932|已過時。|
|編譯器錯誤 C3933|'*class*'：析構函式的限制規範必須涵蓋所有函數的限制聯集|
|編譯器錯誤 C3934|任何形式為 ' main ' 的函式不能有限制（cpu）以外的限制規範|
|編譯器錯誤 C3935|'*identifier*'：重複定義;重迭的限制規範|
|編譯器錯誤 C3936|'*identifier*'：無法辨識的限制規範|
|編譯器錯誤 C3937|不允許空的限制規範|
|編譯器錯誤 C3938|'*identifier*'：外部 \042C\042 函數不支援多個限制規範|
|編譯器錯誤 C3939|'*identifier*'：不允許成員函式指標、函式指標、具有 ' amp ' 限制規範的函式參考|
|編譯器錯誤 C3940|'*identifier*'：找不到識別碼-編譯器與程式庫版本之間可能的不相符。 請確定 vccorlib.h 與 c1xx 而防護相符的 vccorlib120。|
|編譯器錯誤 C3941|'*condition*'：需要 '/clr ' 命令列選項|
|編譯器錯誤 C3942|已過時。|
|編譯器錯誤 C3943|已過時。|
|編譯器錯誤 C3944|已過時。|
|編譯器錯誤 C3945|'*type*'：無法擲回或攔截不是衍生自 Platform：： Exception 的 winrt 物件|
|編譯器錯誤 C3946|'*type*'： typeid 無法套用至這個類型|
|編譯器錯誤 C3947|'*typeid*'： typeid 無法套用至套件展開|
|編譯器錯誤 C3948|'*關鍵字*'：套件擴充不能出現在此內容中|
|編譯器錯誤 C3949|套件展開 ' ... ' 不能出現在括弧內的抽象宣告子中|
|編譯器錯誤 C3950|已過時。|
|編譯器錯誤 C3951|無法在預估的 WinRT 類型 '*type*' 中使用成員指標。 請改用委派。|
|編譯器錯誤 C3952|'*type*'： WinRT 不支援 ' in/out ' 陣列。 針對 ' in ' 和 ' WriteOnlyArray\<T > ' 或 ' Array\<T > ^ * '，在公用 Api 上使用 ' const Array\<T > ^ '|
|編譯器錯誤 C3953|無法在 WinRT 模組中使用 managed 類別 '*type*'。|
|編譯器錯誤 C3954|'*type*'：從 WinRT 類型上的已發行方法傳回的陣列必須使用 ' Array\<t > ^ ' 的格式|
|編譯器錯誤 C3955|'*type*'：公用的函式不能包含 ' out ' 參數或 ' WriteOnlyArray\<t > '|
|編譯器錯誤 C3956|'*type*'：類型已標記為 '*Type*' 的專有，無法當做 '*derived_type*' 的基底使用|
|編譯器錯誤 C3957|'*type*'：在 WinRT 類型上無法使用 ' new ';請改用 [ref new]|
|編譯器錯誤 C3958|'*type*'：在 WinRT 類型上無法使用 ' gcnew ';請改用 [ref new]|
|編譯器錯誤 C3959|' ref new ' 只可用來建立具有 WinRT 類型的物件|
|編譯器錯誤 C3960|已過時。|
|編譯器錯誤 C3961|不支援靜態的函式|
|編譯器錯誤 C3962|不支援泛型類別|
|編譯器錯誤 C3963|不支援多維度陣列|
|編譯器錯誤 C3964|不支援不規則陣列|
|編譯器錯誤 C3965|不支援參數陣列|
|編譯器錯誤 C3966|'*function*'：不支援泛型函數|
|編譯器錯誤 C3967|從模組 '*module*' 匯入 '*identifier*' 時發生錯誤|
|編譯器錯誤 C3968|標記 '*token*' 不是有效的模組名稱分隔符號;改為使用句點（'. '）|
|編譯器錯誤 C3969|不一致的模組名稱： '*module1*' 和 '*module1*'|
|編譯器錯誤 C3970|'*identifier*'： '*關鍵字*' 只能套用至全域範圍或命名空間範圍的 ' ref class ' 或 ' ref struct '|
|編譯器錯誤 C3971|'*type*'：部分定義不能出現在完整定義之後|
|編譯器錯誤 C3972|'*type*'： ' partial ' 只能套用至類別宣告或定義|
|編譯器錯誤 C3973|已過時。|
|編譯器錯誤 C3974|已過時。|
|編譯器錯誤 C3975|「類別/結構*識別碼*」先前已使用不同的修飾詞宣告或定義|
|編譯器錯誤 C3976|'*identifier1*' 必須宣告為 ' public ' 才能使用 '*identifier2*'|
|編譯器錯誤 C3977|使用方式需要定義「*識別碼*」之元件的參考|
|編譯器錯誤 C3978|'*identifier*'：不允許使用靜態屬性做為 WinRT 介面或實數值型別的成員|
|編譯器錯誤 C3979|'*type*'：使用屬性 '*attribute*'，而不是 '*value*'|
|編譯器錯誤 C3980|'*type*' 無法發出至中繼資料|
|編譯器錯誤 C3981|'*type*'：實數值型別不能有任何靜態資料成員 '*identifier*'|
|編譯器錯誤 C3982|'*type*'：實數值型別不能有任何非公用資料成員 '*identifier*'|
|編譯器錯誤 C3983|'*type*'：實數值型別不能有任何公用的非資料成員 '*identifier*'|
|編譯器錯誤 C3984|'*type*'：非實數值型別不能有任何公用資料成員 '*identifier*'|
|編譯器錯誤 C3985|'*identifier*'： public 成員的簽章包含私用類型 '*member*'|
|編譯器錯誤則 c3986|'*identifier*'： public 成員的簽章包含原生類型 '*member*'|
|編譯器錯誤 C3987|'*identifier*'： public 成員的簽章包含原生類型 '*type*'|
|編譯器錯誤 C3988|'*type*'：原生類型不能是公用的|
|編譯器錯誤 C3989|'*type*'：巢狀型別不能是公用的|
|編譯器錯誤 C3990|'*type*'：屬性 '*attribute*' 不可以是私用或已嵌套|
|編譯器錯誤 C3991|'*type*'：無法實作為非公用或嵌套介面 '*interface*'|
|編譯器錯誤 C3992|'*identifier*'：公用成員的簽章包含不正確類型 '*type*'|
|編譯器錯誤 C3993|'*type*'：實數值型別必須包含至少一個公用欄位|
|編譯器錯誤 C3994|'*type*'：實數值型別無法實作用介面或具有虛擬函式|
|編譯器錯誤 C3995|'*type*'：實數值型別不能有任何事件成員 '*identifier*'|
|編譯器錯誤 C3996|已過時。|
|編譯器錯誤 C3998|' c + +*版本*' C++ ：不支援的版本;預設為「c + +*版本*」|
|編譯器錯誤 C3999|不明錯誤請選擇視覺效果C++ [說明] 功能表上的 [技術支援] 命令，或開啟技術支援說明檔以取得詳細資訊|

## <a name="see-also"></a>另請參閱

[C/C++編譯器和組建工具的錯誤和警告](../compiler-errors-1/c-cpp-build-errors.md) \
[編譯器錯誤 C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
