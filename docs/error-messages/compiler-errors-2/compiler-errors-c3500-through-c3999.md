---
title: "編譯器錯誤 C3500 c3999 |Microsoft 文件"
ms.date: 11/17/2017
ms.technology:
- cpp-tools
ms.topic: error-reference
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
dev_langs:
- C++
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
author: corob-msft
ms.author: corob
manager: ghogen
ms.workload:
- cplusplus
ms.openlocfilehash: 7a34b3f3fb635cc666b0e9cca079373bb7c5636e
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/21/2017
---
# <a name="compiler-errors-c3500-through-c3999"></a>編譯器錯誤 C3500 c3999

文件的本節文章說明編譯器所產生的錯誤訊息的子集。

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>錯誤訊息

|錯誤|訊息|
|-----------|-------------|
|[編譯器錯誤 C3500](compiler-error-c3500.md)|無效的 ProgID '*progid*'|
|[編譯器錯誤 C3501](compiler-error-c3501.md)|沒有為 ProgID 註冊的 typelib '*progid*'|
|編譯器錯誤 C3502|無法取得 ProgID LIBID '*progid*'|
|編譯器錯誤 C3503|字元 '0 x*值*' 中不允許在原始字串常值|
|編譯器錯誤 C3504|無法從字串建立的 GUID '*字串*'|
|[編譯器錯誤 C3505](compiler-error-c3505.md)|無法載入類型程式庫 '*文件庫*'|
|[編譯器錯誤 C3506](compiler-error-c3506.md)|沒有為 LIBID 註冊的 typelib '*文件庫*'|
|[編譯器錯誤 C3507](compiler-error-c3507.md)|ProgID 可以有超過 39 個字元*progid*'; 也不包含任何標點符號有所區別 '。 '; 或開頭是數字|
|[編譯器錯誤 C3508](compiler-error-c3508.md)|'*類型*': 不是有效的 Automation 類型|
|[編譯器錯誤 C3509](compiler-error-c3509.md)|'*類型*': 無效的 Automation 傳回類型; 當參數標示 'retval' 時，傳回的類型必須是 'void'、 'HRESULT' 或 'SCODE'|
|[編譯器錯誤 C3510](compiler-error-c3510.md)|找不到相依類型程式庫*程式庫*|
|編譯器錯誤 C3511|'*識別碼*': 委派建構函式呼叫都應該是唯一成員初始設定式|
|編譯器錯誤 C3512|原始字串常值分隔字元順序應該有不能超過 16 個字元|
|編譯器錯誤 C3513|'*字串*': 不支援的原始字串常值分隔符號字元|
|編譯器錯誤 C3514|'*字元*' (*值*): 不支援的原始字串常值分隔符號字元|
|編譯器錯誤 C3515|如果類別樣板部分特製化的引數是套件擴充，它必須是最後一個引數|
|編譯器錯誤 C3516|意外的結束的檔案時處理原始字串常值; 發現分隔符號順序 '*字串*' 不相符|
|編譯器錯誤 C3517|'*識別碼*' 別名宣告不能有包含 'auto' 類型|
|編譯器錯誤 C3518|'*識別碼*': 在直接清單初始化內容型別為'*類型*' 只能從單一初始設定式運算式推算|
|[編譯器錯誤 C3519](compiler-error-c3519.md)|'*參數*': 對 embedded_idl 屬性無效的參數|
|編譯器錯誤 C3520|'*識別碼*': 必須在此內容中展開參數封裝|
|編譯器錯誤 C3521|'*識別碼*' 不是參數封裝|
|編譯器錯誤 C3522|'*類型*': 無法在此內容中展開參數封裝|
|編譯器錯誤 C3523|'sizeof...' 的引數必須未展開的參數封裝|
|編譯器錯誤 C3524|'*識別碼*': 'sizeof' 無法套用至參數封裝。 您是否想要使用 'sizeof...'？|
|編譯器錯誤 C3525|'*參數*': 類別樣板有樣板參數封裝，它必須出現在樣板參數清單結尾|
|編譯器錯誤 C3526|'...' 無法套用至 'this'|
|編譯器錯誤 C3527|'*識別碼*' 不是 'sizeof...' 的有效運算元。 您是否想要使用 'sizeof'？|
|編譯器錯誤 C3528|'*identifier1*': 這個封裝展開中的項目數不符合中的項目數'*identifier2*'|
|編譯器錯誤 C3529|'*參數*': 樣板參數封裝不能有預設引數|
|[編譯器錯誤 C3530](compiler-error-c3530.md)|'*類型*' 無法與任何其他類型規範結合|
|[編譯器錯誤 C3531](compiler-error-c3531.md)|'*識別碼*': 型別包含的符號'*類型*' 必須有初始設定式|
|[編譯器錯誤 C3532](compiler-error-c3532.md)|陣列的項目類型不能包含的類型 '*類型*'|
|[編譯器錯誤 C3533](compiler-error-c3533.md)|參數不能有包含的類型 '*類型*'|
|編譯器錯誤 C3534|已過時。|
|[編譯器錯誤 C3535](compiler-error-c3535.md)|無法推算的類型 '*type1*'from'*type2*'|
|[編譯器錯誤 C3536](compiler-error-c3536.md)|'*識別碼*': 無法在初始化之前使用。|
|[編譯器錯誤 C3537](compiler-error-c3537.md)|您無法轉換成此型別包含 '*類型*'|
|[編譯器錯誤 C3538](compiler-error-c3538.md)|宣告子清單中 '*類型*' 必須永遠推算為相同的型別|
|[編譯器錯誤 C3539](compiler-error-c3539.md)|樣板引數不能包含的類型 '*類型*'|
|[編譯器錯誤 C3540](compiler-error-c3540.md)|sizeof 無法套用至包含的類型 '*類型*'|
|[編譯器錯誤 C3541](compiler-error-c3541.md)|typeid 無法套用至包含的類型 '*類型*'|
|編譯器錯誤 C3542|'*識別碼*': 虛擬成員函式不應該有傳回型別包含'*類型*'|
|編譯器錯誤 C3543|'*類型*': 不包含參數封裝|
|編譯器錯誤 C3544|'*參數*': 參數封裝需要類型樣板引數|
|編譯器錯誤 C3545|'*參數*': 參數封裝需要非類型樣板引數|
|編譯器錯誤 C3546|'...': 沒有可展開參數封裝|
|編譯器錯誤 C3547|樣板參數 '*參數*'無法使用，因為它接在樣板參數封裝，而且無法推算的函式參數'*函式*'|
|編譯器錯誤 C3548|'*識別碼*': 參數封裝不能在此內容|
|編譯器錯誤 C3549|'*值*': 函式參數封裝不能有預設引數|
|[編譯器錯誤 C3550](compiler-error-c3550.md)|此內容中不得有純 'decltype(auto)'|
|[編譯器錯誤 C3551](compiler-error-c3551.md)|如果使用尾端傳回型別，則前導傳回類型應該有單一類型規範 'auto' (不 '*類型*')|
|[編譯器錯誤 C3552](compiler-error-c3552.md)|必須是 ' decltype （auto) '|
|[編譯器錯誤 C3553](compiler-error-c3553.md)|decltype 必須是運算式而不是類型|
|[編譯器錯誤 C3554](compiler-error-c3554.md)|'*類型*' 無法與任何其他類型規範結合|
|[編譯器錯誤 C3555](compiler-error-c3555.md)|'decltype' 的引數不正確|
|[編譯器錯誤 C3556](compiler-error-c3556.md)|'*運算式*': 'decltype' 的引數不正確|
|編譯器錯誤 C3557|已過時。|
|編譯器錯誤 C3558|已過時。|
|編譯器錯誤 C3559|遞迴呼叫 '*函式*': 編譯呼叫圖表 parallel_for_each 時偵測到遞迴:'*函式*'|
|編譯器錯誤 C3560|'*函式*': IL 編譯呼叫圖表 parallel_for_each 時則無法使用:'*函式*'|
|編譯器錯誤 C3561|編譯呼叫圖表 parallel_for_each 時不統一並排的控制流程中找到並排屏障作業: '*函式*'|
|編譯器錯誤 C3562|內建函式 '*函式*' 限制為沒有多個*數目*參數|
|編譯器錯誤 C3563|編譯呼叫圖表 parallel_for_each 時偵測到無限迴圈: '*函式*'|
|編譯器錯誤 C3564|編譯呼叫圖表 parallel_for_each 時讀取未初始化的值: '*函式*'|
|編譯器錯誤 C3565|Tile_static 記憶體總數 (*數目*位元組) 超過限制*數目*編譯呼叫圖表 concurrency:: parallel_for_each 的位元組|
|編譯器錯誤 C3566|具有副作用的區塊巢狀結構太深 parallel_for_each 當編譯呼叫圖表: '*函式*'|
|編譯器錯誤 C3567|除以 0 或除以零編譯呼叫圖表 parallel_for_each 時偵測到的餘數: '*函式*'|
|編譯器錯誤 C3568|暫存器的總和超過*數目*編譯 concurrency:: parallel_for_each 呼叫圖表時。 請簡化您的程式|
|編譯器錯誤 C3569|編譯呼叫圖表 parallel_for_each 時偵測到競爭情形: '*函式*'|
|編譯器錯誤 C3570|以 /clr 編譯時，不合法使用 amp 限制範圍|
|編譯器錯誤 C3571|'*類型*': 不合法的計算網域引數; 不是類別類型|
|編譯器錯誤 C3572|'*類型*': 不合法的計算網域引數; 遺漏 public 成員: 'static const int rank' 或順位值是非正數|
|編譯器錯誤 C3573|傳遞給 concurrency:: parallel_for_each 的 graphics:: sampler 執行個體數目不能超過*數目*|
|編譯器錯誤 C3574|'*類型*': 並排範圍不合法： 必須為正數且 (1) Z < =*數目*;（2) Z*Y*X < =*數目*|
|編譯器錯誤 C3575|'*類型*': 不合法的計算網域引數; 遺漏 public 成員:' concurrency:: index< <*數目*> _map_index (const concurrency:: index< <*數目*>（& s)) restrict （amp) '|
|編譯器錯誤 C3576|'*類型*': _parallel_for_each 引數 #*數目*具有不支援的型別|
|編譯器錯誤 C3577|concurrency:: parallel_for_each 核心引數不合法： 無法解析呼叫成員 ' void operator （) (*類型*) restrict （amp) '|
|編譯器錯誤 C3578|傳遞給 concurrency:: parallel_for_each 的函式物件大小不能超過*數目*位元組|
|編譯器錯誤 C3579|Array 和 concurrency::graphics::texture 傳遞給 concurrency:: parallel_for_each 的唯讀執行個體數目不能超過*數目*|
|編譯器錯誤 C3580|Array 和 concurrency::graphics::texture 傳遞給 concurrency:: parallel_for_each 的可寫入的執行個體數目不能超過*數目*|
|編譯器錯誤 C3581|'*類型*': 不支援的型別在 amp 限制程式碼|
|編譯器錯誤 C3582|已過時。|
|編譯器錯誤 C3583|'*識別碼*': 變數的大小 (*數目*位元組) 超過最大大小 (*數目*位元組) amp 限制程式碼中支援|
|編譯器錯誤 C3584|在不支援 tile_static 的使用方式 '*識別碼*'|
|編譯器錯誤 C3585|'*識別碼*' 具有不支援的儲存類別在 amp 限制程式碼|
|編譯器錯誤 C3586|'*識別碼*': 使用全域或靜態變數在 amp 限制程式碼中不支援|
|編譯器錯誤 C3587|在 amp 限制程式碼中不支援 dynamic_cast|
|編譯器錯誤 C3588|從轉型 '*type1*'to'*type2*' 在 amp 限制程式碼中不支援|
|編譯器錯誤 C3589|'*字串*': 不支援的使用方式的字串常值在 amp 限制程式碼|
|編譯器錯誤 C3590|'*語彙基元*': 傳址方式擷取或 'this' 擷取時，不支援 lambda 是 amp 限制|
|編譯器錯誤 C3591|在 amp 限制程式碼中不支援 typeid 運算子|
|編譯器錯誤 C3592|Amp 限制程式碼中不支援內嵌原生組譯碼 ('__asm')|
|編譯器錯誤 C3593|amp 限制程式碼中不支援 'goto'|
|編譯器錯誤 C3594|amp 限制程式碼中不支援例外狀況處理 （try、 catch、 throw 等）|
|編譯器錯誤 C3595|常數值超出 amp 限制程式碼中支援的範圍|
|編譯器錯誤 C3596|'*參數*' ('*類型*'): 由 lambda 擷取變數具有不支援在 amp 限制程式碼中的型別|
|編譯器錯誤 C3597|'*參數*':'*識別碼*' 不允許如果 lambda 是 amp 限制要擷取的值|
|編譯器錯誤 C3598|amp 限制程式碼中不支援 label 陳述式|
|編譯器錯誤 C3599|'*運算子*': 無法為 bool amp 限制程式碼中的指標上執行指標算術|
|編譯器錯誤 C3600|'*函式*': 使用圖格\_編譯非並排 concurrency::parallel 呼叫圖表時偵測到的靜態記憶體\_在 for_each:'*函式*'|
|編譯器錯誤 C3601|'*類型*': 是 amp 診斷函式無效的引數類型'*函式*'|
|編譯器錯誤 C3602|不支援編譯呼叫圖表 parallel_for_each 時偵測到的控制流程: '*函式*'|
|[編譯器錯誤 C3603](compiler-error-c3603.md)|'*符號*': 類型'*類型*' 尚不支援|
|編譯器錯誤 C3604|'*識別碼*': 只能在 gc 堆積上建立受管理的物件|
|編譯器錯誤 C3605|樣本總數 (*數目*擷取和*數目*預先定義) 超出*數目*時編譯呼叫圖表 parallel_for_each: '*函式*'|
|編譯器錯誤 C3606|已過時。|
|編譯器錯誤 C3607|已過時。|
|編譯器錯誤 C3608|已過時。|
|[編譯器錯誤 C3609](compiler-error-c3609.md)|'*識別碼*':' 密封/final ' 函式必須為虛擬|
|[編譯器錯誤 C3610](compiler-error-c3610.md)|'*識別碼*': 實值型別必須 'boxed' 方法之前'*方法*' 可以呼叫|
|[編譯器錯誤 C3611](compiler-error-c3611.md)|'*識別碼*': 密封函式不能有純規範|
|[編譯器錯誤 C3612](compiler-error-c3612.md)|'*識別碼*': 密封的類別不能有任何純虛擬方法|
|編譯器錯誤 C3613|缺少傳回型別之後 '->' ('int' 假設)|
|編譯器錯誤 C3614|不同的套件大小，在相同的類別; 中的值先前是 '*值*'，新的值是'*值*'|
|[編譯器錯誤 C3615](compiler-error-c3615.md)|constexpr 函式 '*函式*' 不能產生常數運算式|
|編譯器錯誤 C3616|已過時。|
|編譯器錯誤 C3617|已過時。|
|[編譯器錯誤 C3618](compiler-error-c3618.md)|'*宣告*': 無法定義標記為 DllImport 的方法|
|[編譯器錯誤 C3619](compiler-error-c3619.md)|無法管理/WinRT 類型中宣告樣板|
|編譯器錯誤 C3620|'*類型*': WinRT 類型上不允許設定記憶體對齊|
|編譯器錯誤 C3621|'*類型*': 封裝值的預設值 (*數目*) 適用於 WinRT 類型|
|[編譯器錯誤 C3622](compiler-error-c3622.md)|*型別*': 類別宣告為 '*關鍵字*' 無法具現化|
|[編譯器錯誤 C3623](compiler-error-c3623.md)|'*識別碼*': managed/WinRT 類型中不支援位元欄位|
|[編譯器錯誤 C3624](compiler-error-c3624.md)|'*類型*': 使用這個型別需要的參考組件/模組'*識別碼*'|
|[編譯器錯誤 C3625](compiler-error-c3625.md)|'*類別*': 原生類型不能衍生自 managed/WinRT 類型'*類型*'|
|[編譯器錯誤 C3626](compiler-error-c3626.md)|'*識別碼*':'*關鍵字*' 關鍵字只能用於 COM 介面、 成員函式和是委派指標的資料成員|
|[編譯器錯誤 C3627](compiler-error-c3627.md)|只有實值類型可以成為 boxed|
|[編譯器錯誤 C3628](compiler-error-c3628.md)|'*類別*': managed/WinRT 類別僅支援公用繼承|
|編譯器錯誤 C3629|'*語彙基元*': 擷取預設只可以出現在 lambda 擷取清單的開頭|
|[編譯器錯誤 C3630](compiler-error-c3630.md)|處理語彙基元時發生錯誤 '*語彙基元*'|
|[編譯器錯誤 C3631](compiler-error-c3631.md)|'*事件*': 無法多載 managed/WinRT 事件|
|[編譯器錯誤 C3632](compiler-error-c3632.md)|'*事件*': 不合法的事件樣式*建構*|
|[編譯器錯誤 C3633](compiler-error-c3633.md)|無法定義 '*識別碼*'as 受管理的成員'*類別*'|
|[編譯器錯誤 C3634](compiler-error-c3634.md)|'*成員*': 無法定義 managed/WinRT 類別的抽象方法|
|編譯器錯誤 C3635|'*識別碼*': 無法套用至 managed/WinRT 類別 (使用'*識別碼*' 改為)|
|編譯器錯誤 C3636|'*識別碼*': 無法套用至此類型|
|[編譯器錯誤 C3637](compiler-error-c3637.md)|'*函式*': friend 函式定義不能特製化的函式範本/泛型|
|[編譯器錯誤 C3638](compiler-error-c3638.md)|'*運算子*': 無法重新定義標準的 boxing 和 unboxing 轉換運算子|
|編譯器錯誤 C3639|已過時。|
|[編譯器錯誤 C3640](compiler-error-c3640.md)|'*成員*': 必須定義區域類別的參考或虛擬成員函式|
|[編譯器錯誤 C3641](compiler-error-c3641.md)|'*函式*': 無效的呼叫慣例'*慣例*' 以 /clr 編譯的函式： pure 或 /clr: safe|
|[編譯器錯誤 C3642](compiler-error-c3642.md)|'*函式*': 無法以 __clrcall 呼叫慣例，從機器碼呼叫的函式|
|編譯器錯誤 C3643|已過時。|
|[編譯器錯誤 C3644](compiler-error-c3644.md)|'*函式*': 無法編譯要產生 managed 程式碼的函式|
|[編譯器錯誤 C3645](compiler-error-c3645.md)|'*函式*': __clrcall 不可使用於編譯為原生程式碼的函式|
|[編譯器錯誤 C3646](compiler-error-c3646.md)|'*識別碼*': 未知的覆寫規範|
|編譯器錯誤 C3647|已過時。|
|[編譯器錯誤 C3648](compiler-error-c3648.md)|managed 類型不支援此明確覆寫語法|
|編譯器錯誤 C3649|此明確覆寫語法不允許有 /ZW|
|[編譯器錯誤 C3650](compiler-error-c3650.md)|'*成員*': 不可當成明確覆寫，必須是基底類別虛擬成員函式|
|[編譯器錯誤 C3651](compiler-error-c3651.md)|'*成員*': 不可當成明確覆寫，必須是基底類別的成員|
|[編譯器錯誤 C3652](compiler-error-c3652.md)|'*成員*': 明確覆寫的函式必須為虛擬|
|[編譯器錯誤 C3653](compiler-error-c3653.md)|'*識別碼*': 不能當做具名覆寫： 函式覆寫未找到; 您是否忘記指明此函式明確地使用 a:: 運算子？|
|[編譯器錯誤 C3654](compiler-error-c3654.md)|'*語彙基元*': 明確覆寫中的語法錯誤|
|[編譯器錯誤 C3655](compiler-error-c3655.md)|'*成員*': 函式已被明確覆寫|
|[編譯器錯誤 C3656](compiler-error-c3656.md)|'*關鍵字*': 覆寫規範不可重複|
|[編譯器錯誤 C3657](compiler-error-c3657.md)|解構函式/完成項不能明確覆寫或被明確覆寫|
|編譯器錯誤 C3658|已過時。|
|編譯器錯誤 C3659|'*成員*': 覆寫規範'*關鍵字*' 不支援|
|編譯器錯誤 C3660|'*member1*': 隱藏繼承的成員'*member2*'|
|[編譯器錯誤 C3661](compiler-error-c3661.md)|明確覆寫清單找不到要覆寫任何方法|
|[編譯器錯誤 C3662](compiler-error-c3662.md)|'*成員*': 覆寫規範'*關鍵字*' 只允許在受管理/WinRT 類別的成員函式|
|編譯器錯誤 C3663|已過時。|
|編譯器錯誤 C3664|'*成員*': 不可當成明確覆寫，必須有 'public' 或 'protected' 存取範圍|
|[編譯器錯誤 C3665](compiler-error-c3665.md)|'*成員*': 覆寫規範'*關鍵字*' 不允許解構函式/完成項|
|[編譯器錯誤 C3666](compiler-error-c3666.md)|'*建構函式*': 覆寫規範'*關鍵字*' 不允許在建構函式|
|編譯器錯誤 C3667|'*屬性*': 屬性不支援封裝展開|
|[編譯器錯誤 C3668](compiler-error-c3668.md)|'*成員*': 具有覆寫規範 'override' 方法不會覆寫任何基底類別方法|
|[編譯器錯誤 C3669](compiler-error-c3669.md)|'*成員*': 覆寫的規範 'override' 不允許在靜態成員函式或建構函式|
|[編譯器錯誤 C3670](compiler-error-c3670.md)|'*成員*': 無法覆寫無法存取基底類別方法'*成員*'|
|[編譯器錯誤 C3671](compiler-error-c3671.md)|'*成員*': 函式不會覆寫'*成員*'|
|[編譯器錯誤 C3672](compiler-error-c3672.md)|虛擬解構函式運算式只能做為函式呼叫的一部分|
|[編譯器錯誤 C3673](compiler-error-c3673.md)|'*類別*': 類別沒有複製建構函式|
|編譯器錯誤 C3674|找不到標準程式庫模組 '*模組*'|
|[編譯器錯誤 C3675](compiler-error-c3675.md)|'*函式*': 已保留，因為'*屬性*' 定義|
|編譯器錯誤 C3676|'*類別*': ref 類別和基底類別有不相容的屬性' [*屬性*]'|
|編譯器錯誤 C3677|'operator' 不能有編碼前置字元後面的字串常值|
|編譯器錯誤 C3678|'operator' 必須是空的字串之後的字串常值 '"""'|
|編譯器錯誤 C3679|必須有常值後置字元識別項之後 ' 運算子"""'|
|編譯器錯誤 C3680|無法串連使用者定義的字串常值不相符的常值後置字元識別項|
|編譯器錯誤 C3681|'fallthrough': 屬性只會在封入的 switch 陳述式中|
|編譯器錯誤 C3682|' 運算子*識別碼*': 常值的運算子/常值運算子樣板不能宣告為擁有 'C 連結'|
|編譯器錯誤 C3683|無法定義原始常值運算子和常值運算子樣板具有相同的常值後置字元識別項|
|編譯器錯誤 C3684|' 運算子*識別碼*': 常值運算子的宣告具有無效的參數清單|
|編譯器錯誤 C3685|' 運算子*識別碼*': 常值運算子樣板不能有函式參數|
|編譯器錯誤 C3686|' 運算子*識別碼*': 常值運算子範本必須剛好只有一個是參數封裝的範本參數|
|編譯器錯誤 C3687|' 運算子*識別碼*': 常值運算子範本必須擁有類型 'char' 的非類型樣板參數|
|編譯器錯誤 C3688|無效的常值後置詞 '*尾碼*'; 常值運算子或常值運算子範本' 運算子*識別碼*' 找不到|
|編譯器錯誤 C3689|' 運算子*識別碼*': 常值的運算子/常值運算子樣板必須是全域或命名空間範圍中|
|編譯器錯誤 C3690|必須是字串常值，但找到使用者定義的字串常值改為|
|編譯器錯誤 C3691|無效的常值前置詞 '*前置詞*'|
|編譯器錯誤 C3692|已過時。|
|編譯器錯誤 C3693|已過時。|
|編譯器錯誤 C3694|已過時。|
|編譯器錯誤 C3695|已過時。|
|編譯器錯誤 C3696|'*關鍵字*': 無法在 '%' 上使用此限定詞|
|[編譯器錯誤 C3697](compiler-error-c3697.md)|'*關鍵字*': 不能使用這個限定詞上' ^'|
|[編譯器錯誤 C3698](compiler-error-c3698.md)|'*類型*': 無法使用此類型做為引數'*運算子*'|
|[編譯器錯誤 C3699](compiler-error-c3699.md)|'*運算子*': 無法在類型上使用這個間接取值'*類型*'|
|編譯器錯誤 C3700|已過時。|
|[編譯器錯誤 C3701](compiler-error-c3701.md)|'*函式*': 事件來源沒有任何事件|
|[編譯器錯誤 C3702](compiler-error-c3702.md)|ATL 是必要的 COM 事件|
|[編譯器錯誤 C3703](compiler-error-c3703.md)|'*event_handler*': 事件處理常式方法必須有相同的儲存類別做為來源'*事件*'|
|[編譯器錯誤 C3704](compiler-error-c3704.md)|'*成員*': vararg 方法無法引發事件|
|[編譯器錯誤 C3705](compiler-error-c3705.md)|'*函式*': 找不到事件介面|
|[編譯器錯誤 C3706](compiler-error-c3706.md)|'*函式*': 必須是 COM 介面來引發 COM 事件|
|[編譯器錯誤 C3707](compiler-error-c3707.md)|'*成員*': dispinterface 方法必須有 dispid|
|[編譯器錯誤 C3708](compiler-error-c3708.md)|'*函式*': 不當使用'*關鍵字*'; 必須是相容的事件來源的成員|
|[編譯器錯誤 C3709](compiler-error-c3709.md)|'*函式*': 在 __hook/__unhook 中指定事件的不適當的語法|
|[編譯器錯誤 C3710](compiler-error-c3710.md)|'*函式*': 在 __hook/__unhook 中指定事件處理常式不適當的語法|
|[編譯器錯誤 C3711](compiler-error-c3711.md)|'*事件*': unmanaged 事件來源方法必須傳回 void 或整數型別|
|[編譯器錯誤 C3712](compiler-error-c3712.md)|'*event_handler*': 事件處理常式方法必須傳回相同的類型做為來源'*事件*'|
|[編譯器錯誤 C3713](compiler-error-c3713.md)|'*event_handler*': 事件處理常式方法必須有相同的函式參數做為來源'*事件*'|
|[編譯器錯誤 C3714](compiler-error-c3714.md)|'*event_handler*': 事件處理常式方法必須有相同的呼叫慣例，做為來源'*事件*'|
|[編譯器錯誤 C3715](compiler-error-c3715.md)|'*指標*': 必須是指向'*類型*'|
|編譯器錯誤 C3716|已過時。|
|[編譯器錯誤 C3717](compiler-error-c3717.md)|'*成員*': 無法定義引發事件的方法|
|[編譯器錯誤 C3718](compiler-error-c3718.md)|可以只呼叫 '__*關鍵字*' 接收類別成員函式的內容中|
|[編譯器錯誤 C3719](compiler-error-c3719.md)|'*成員*': 介面基底的事件來源只能用於 COM 事件|
|編譯器錯誤 C3720|'*類型*': 只能在 dual 或 dispinterface 上實作 IDispatch|
|[編譯器錯誤 C3721](compiler-error-c3721.md)|'*簽章*': 事件不相容的簽章|
|[編譯器錯誤 C3722](compiler-error-c3722.md)|不允許泛型事件|
|[編譯器錯誤 C3723](compiler-error-c3723.md)|'*函式*': 無法解析事件|
|[編譯器錯誤 C3724](compiler-error-c3724.md)|以多執行緒模式使用事件需要在程式碼中加入 #include <windows.h>|
|編譯器錯誤 C3725|已過時。|
|編譯器錯誤 C3726|已過時。|
|[編譯器錯誤 C3727](compiler-error-c3727.md)|'*事件*': managed 的事件必須是成員函式或是委派指標的資料成員|
|[編譯器錯誤 C3728](compiler-error-c3728.md)|'*事件*': 事件沒有引發方法|
|編譯器錯誤 C3729|已過時。|
|編譯器錯誤 C3730|已過時。|
|[編譯器錯誤 C3731](compiler-error-c3731.md)|不相容的事件 '*事件*'和處理常式'*event_handler*'; 事件來源和事件處理常式必須有相同的事件類型|
|[編譯器錯誤 C3732](compiler-error-c3732.md)|'*介面*': 引發 COM 事件的自訂介面無法繼承自 IDispatch|
|[編譯器錯誤 C3733](compiler-error-c3733.md)|'*事件*': 不適當的語法指定 COM 事件; 您是否忘記 '__interface'？|
|[編譯器錯誤 C3734](compiler-error-c3734.md)|'*類別*': managed/WinRT 類別不能是 coclass|
|編譯器錯誤 C3735|已過時。|
|[編譯器錯誤 C3736](compiler-error-c3736.md)|'*成員*': 必須是方法，或如果是 managed 事件，您可以選擇的資料成員|
|[編譯器錯誤 C3737](compiler-error-c3737.md)|'*識別碼*': 委派不能宣告明確的呼叫慣例|
|[編譯器錯誤 C3738](compiler-error-c3738.md)|'*慣例*': 明確具現化的呼叫慣例，必須符合要具現化的範本|
|[編譯器錯誤 C3739](compiler-error-c3739.md)|'*類別*': 只是語法時，支援' 配置\_相依 ' event_receiver 參數為 true|
|[編譯器錯誤 C3740](compiler-error-c3740.md)|'*範本*': 無法為來源或接收的事件範本|
|[編譯器錯誤 C3741](compiler-error-c3741.md)|'*類別*': 必須為 coclass 時' 配置\_相依 ' event_receiver 參數為 true|
|編譯器錯誤 C3742|'*token1*': 不對稱的語彙基元序列中的屬性引數'*屬性*'必須有，'*token2*'|
|[編譯器錯誤 C3743](compiler-error-c3743.md)|可以只攔截/取消攔截整個介面當 event_receiver 的 'layout_dependent' 參數為 true 時|
|[編譯器錯誤 C3744](compiler-error-c3744.md)|__unhook 必須有至少 3 的引數，對 managed 事件|
|[編譯器錯誤 C3745](compiler-error-c3745.md)|'*函式*': 只有事件可以 'raised'|
|編譯器錯誤 C3746|標準屬性 '*識別碼*' 可能會在屬性清單中最多一次出現|
|[編譯器錯誤 C3747](compiler-error-c3747.md)|遺漏預設範本/泛型參數： 參數*數目*|
|[編譯器錯誤 C3748](compiler-error-c3748.md)|'*介面*': unmanaged 的介面不能引起事件|
|[編譯器錯誤 C3749](compiler-error-c3749.md)|'*屬性*': 自訂屬性不能在函式|
|編譯器錯誤 C3750|'*語彙基元*': 屬性清單中未預期的語彙基元|
|編譯器錯誤 C3751|'*識別碼*': 屬性清單中未預期的識別項|
|[編譯器錯誤 C3752](compiler-error-c3752.md)|'*屬性*': 無法區分屬性;'*關鍵字*' 無法用於此內容|
|[編譯器錯誤 C3753](compiler-error-c3753.md)|不允許泛型屬性。|
|[編譯器錯誤 C3754](compiler-error-c3754.md)|委派建構函式： 成員函式 '*成員*'上無法呼叫類型的執行個體'*類型*'|
|[編譯器錯誤 C3755](compiler-error-c3755.md)|'*識別碼*': 不可定義委派|
|編譯器錯誤 C3756|已過時。|
|編譯器錯誤 C3757|'*類型*': 不允許 'constexpr' 函式的類型|
|編譯器錯誤 C3758|'*成員*': 虛擬函式不得宣告 'constexpr'|
|編譯器錯誤 C3759|'*成員*': 'constexpr' 無法宣告非常值型別成員函式|
|編譯器錯誤 C3760|請使用 __property 關鍵字來宣告在 managed/WinRT 屬性 '*類別*'|
|[編譯器錯誤 C3761](compiler-error-c3761.md)|'*函式*': 'retval' 只可以出現在函式的最後一個引數|
|[編譯器錯誤 C3762](compiler-error-c3762.md)|無法處理屬性 '*屬性*'|
|[編譯器錯誤 C3763](compiler-error-c3763.md)|'*類型*': 'retval' 和 'out' 只能出現在資料指標類型|
|[編譯器錯誤 C3764](compiler-error-c3764.md)|'*成員*': 無法覆寫基底類別方法'*成員*'|
|[編譯器錯誤 C3765](compiler-error-c3765.md)|'*事件*': 無法在類別/結構中定義事件'*類型*' 標記為 event_receiver|
|[編譯器錯誤 C3766](compiler-error-c3766.md)|'*類型*'必須提供介面方法的實作'*函式*'|
|[編譯器錯誤 C3767](compiler-error-c3767.md)|'*函式*': 無法存取候選函式|
|[編譯器錯誤 C3768](compiler-error-c3768.md)|無法取得純 managed 程式碼中的虛擬 vararg 函式的位址|
|[編譯器錯誤 C3769](compiler-error-c3769.md)|'*識別碼*': 巢狀的類別不能有相同的名稱為立即封入類別|
|編譯器錯誤 C3770|'*類型*': 不是有效的基底類別|
|[編譯器錯誤 C3771](compiler-error-c3771.md)|'*識別碼*': 在最接近的命名空間範圍中找不到 friend 宣告|
|[編譯器錯誤 C3772](compiler-error-c3772.md)|'*識別碼*': 無效的 friend 樣板宣告|
|編譯器錯誤 C3773|請使用 /await 編譯器參數啟用協同程式|
|編譯器錯誤 C3774|找不到 '*範圍*::*識別碼*': 請附上*標頭*標頭|
|編譯器錯誤 C3775|傳回型別 '*函式*'不能'*類型*'|
|編譯器錯誤 C3776|無法傳回 void 具有非 void 最終傳回型別的協同程式中的型別透過|
|編譯器錯誤 C3777|'*函式*': 協同程式不能使用變數引數清單|
|編譯器錯誤 C3778|alloca： 不可在協同程式|
|編譯器錯誤 C3779|'*函式*': 傳回的函式'*類型*' 無法在定義之前使用|
|編譯器錯誤 C3780|'*函式*': 轉換函式，傳回*類型*' 無法在定義之前使用|
|編譯器錯誤 C3781|'*關鍵字*': 不可為型別的協同程式中使用'*類型*'。 任一*關鍵字*或*關鍵字*相關聯的 promise_type 中必須要有|
|編譯器錯誤 C3782|*型別*： 協同程式的承諾不可同時包含*關鍵字*和*關鍵字*|
|編譯器錯誤 C3783|'*識別碼*': 不可為協同程式|
|編譯器錯誤 C3784|*關鍵字*運算式不能出現在此內容中|
|編譯器錯誤 C3785|'std:: integer_sequence' 的第一個樣板引數必須是整數類型|
|編譯器錯誤 C3786|'std::make_integer_sequence' 的第二個範本引數必須是大於或等於零的整數常數|
|編譯器錯誤 C3787|無法推算此協同程式的傳回型別|
|編譯器錯誤 C3788|已過時。|
|編譯器錯誤 C3789|已過時。|
|編譯器錯誤 C3790|已過時。|
|編譯器錯誤 C3791|已過時。|
|編譯器錯誤 C3792|已過時。|
|編譯器錯誤 C3793|已過時。|
|編譯器錯誤 C3794|已過時。|
|編譯器錯誤 C3795|已過時。|
|編譯器錯誤 C3796|已過時。|
|[編譯器錯誤 C3797](compiler-error-c3797.md)|'*關鍵字*': 事件宣告不能有覆寫規範 （應該置於事件新增/移除/引發方法改用）|
|[編譯器錯誤 C3798](compiler-error-c3798.md)|'*關鍵字*': 屬性宣告不能有覆寫規範 （應該置於屬性 get/set 方法）|
|[編譯器錯誤 C3799](compiler-error-c3799.md)|索引的屬性不能有空參數清單|
|[編譯器錯誤 C3800](compiler-error-c3800.md)|'*宣告*': 不能混合屬性和事件|
|編譯器錯誤 C3801|'*屬性*': 屬性可能沒有引數子句|
|編譯器錯誤 C3802|已過時。|
|[編譯器錯誤 C3803](compiler-error-c3803.md)|'*屬性*': 屬性有與其中一個存取子不相容的型別*存取子*'|
|[編譯器錯誤 C3804](compiler-error-c3804.md)|'*成員*': 存取子方法的屬性必須是全部靜態或全部非靜態|
|[編譯器錯誤 C3805](compiler-error-c3805.md)|*語彙基元*': 非預期的語彙基元，必須是 '} 'or '、 '|
|編譯器錯誤 C3806|'*語彙基元*': 非預期的語彙基元，必須是' {' 或成員初始設定式|
|[編譯器錯誤 C3807](compiler-error-c3807.md)|'*類型*': 具有 ComImport 屬性的類別不可衍生自'*類型*'，允許只介面實作|
|[編譯器錯誤 C3808](compiler-error-c3808.md)|'*類型*': 具有 ComImport 屬性的類別不可定義成員'*成員*'、 只抽象或 dllimport 函式允許|
|[編譯器錯誤 C3809](compiler-error-c3809.md)|'*類型*': managed/WinRT 類型不能有任何的 friend 函式/類別/介面|
|編譯器錯誤 C3810|已過時。|
|編譯器錯誤 C3811|已過時。|
|[編譯器錯誤 C3812](compiler-error-c3812.md)|'__property' 必須是屬性宣告中的第一個語彙基元|
|[編譯器錯誤 C3813](compiler-error-c3813.md)|在屬性宣告只可出現在受管理/WinRT 類型的定義|
|編譯器錯誤 C3814|已過時。|
|[編譯器錯誤 C3815](compiler-error-c3815.md)|方法的傳回型別 '*成員*' 必須符合 setter 最後一個參數的型別|
|[編譯器錯誤 C3816](compiler-error-c3816.md)|'類別/結構*成員*' 先前已宣告或定義與不同的 managed/WinRT 修飾詞|
|[編譯器錯誤 C3817](compiler-error-c3817.md)|'*宣告*': 屬性只能套用至函式|
|[編譯器錯誤 C3818](compiler-error-c3818.md)|陣列屬性宣告 '*屬性*'不應多載索引屬性'*屬性*'|
|編譯器錯誤 C3819|已過時。|
|[編譯器錯誤 C3820](compiler-error-c3820.md)|'*識別碼*': 初始設定式必須 managed|
|[編譯器錯誤 C3821](compiler-error-c3821.md)|'*函式*': managed 的類型或函式不能在 unmanaged 函式|
|編譯器錯誤 C3822|已過時。|
|編譯器錯誤 C3823|已過時。|
|[編譯器錯誤 C3824](compiler-error-c3824.md)|'*類型*': 這個類型不能出現在此內容 （函式參數、 傳回型別或靜態成員）|
|[編譯器錯誤 C3825](compiler-error-c3825.md)|'*類型*': managed/WinRT 類別只能支援 managed/WinRT 事件|
|編譯器錯誤 C3826|已過時。|
|編譯器錯誤 C3827|標準屬性 'deprecated' 可能沒有引數或一個字串常值來描述原因|
|[編譯器錯誤 C3828](compiler-error-c3828.md)|位置引數不能指定 '*關鍵字*'運算式的型別'*類型*'|
|編譯器錯誤 C3829|標準屬性 'noreturn' 只能套用至函式|
|[編譯器錯誤 C3830](compiler-error-c3830.md)|'*type1*': 無法繼承自'*type2*'，實值類型只能繼承自介面類別|
|[編譯器錯誤 C3831](compiler-error-c3831.md)|'*識別碼*':'*類型*' 不能有固定的資料成員或成員函式傳回 pin 指標|
|[編譯器錯誤 C3832](compiler-error-c3832.md)|'*typelib*': 類型程式庫看來好像它已針對 32 位元指標建置; 請變更 'ptrsize' 限定詞|
|[編譯器錯誤 C3833](compiler-error-c3833.md)|'*類型*': 的目標類型無效*識別碼*|
|[編譯器錯誤 C3834](compiler-error-c3834.md)|明確轉換成 pin 的指標; 不合法請改用 pin 的區域變數|
|編譯器錯誤 C3835|已過時。|
|[編譯器錯誤 C3836](compiler-error-c3836.md)|靜態建構函式不可以有成員初始設定式清單|
|編譯器錯誤 C3837|在此內容中不允許屬性|
|[編譯器錯誤 C3838](compiler-error-c3838.md)|無法繼承自 '*類型*'|
|[編譯器錯誤 C3839](compiler-error-c3839.md)|無法變更 managed/WinRT 類型中的對齊方式|
|編譯器錯誤 C3840|已過時。|
|編譯器錯誤 C3841|已過時。|
|[編譯器錯誤 C3842](compiler-error-c3842.md)|'*識別碼*': 不支援的 managed/WinRT 類型的成員函式的 'const' 和 'volatile' 限定詞|
|編譯器錯誤 C3843|'*識別碼*': 不支援 managed/WinRT 類型的成員函式的 ref 限定詞|
|編譯器錯誤 C3844|'*識別碼*': 無法匯入從符號'*來源*': 為*識別碼*' 已經存在於目前的範圍|
|編譯器錯誤 C3845|已過時。|
|[編譯器錯誤 C3846](compiler-error-c3846.md)|'*識別碼*': 無法匯入從符號'*來源*': 為*識別碼*'匯入了另一個組件'*組件*'|
|編譯器錯誤 C3847|已過時。|
|[編譯器錯誤 C3848](compiler-error-c3848.md)|運算式具有類型 '*類型*'將會遺失某些 const-volatile 限定詞才能呼叫'*識別碼*'|
|[編譯器錯誤 C3849](compiler-error-c3849.md)|類型的運算式上的函式樣式呼叫 '*類型*' 會失去所有的 const 及/或 volatile 限定詞*數目*可用運算子多載|
|[編譯器錯誤 C3850](compiler-error-c3850.md)|'*語彙基元*': 通用字元名稱指定了無效的字元|
|[編譯器錯誤 C3851](compiler-error-c3851.md)|'*語彙基元*': 通用字元名稱不能指定基礎字元集中的字元|
|[編譯器錯誤 C3852](compiler-error-c3852.md)|'*成員*'具有類型'*類型*': 彙總初始化無法初始化這個成員|
|[編譯器錯誤 C3853](compiler-error-c3853.md)|'=': 重新初始化參考或透過函式參考的指派是不合法|
|[編譯器錯誤 C3854](compiler-error-c3854.md)|'=' 左方的運算式評估的函式。 無法指派給函式 （函式不是左值）|
|[編譯器錯誤 C3855](compiler-error-c3855.md)|'*函式*': 範本/泛型參數'*識別碼*' 與宣告不相容|
|[編譯器錯誤 C3856](compiler-error-c3856.md)|'*類別*': 不是類別範本/泛型類別。|
|[編譯器錯誤 C3857](compiler-error-c3857.md)|'*範本*': 不允許多個範本/泛型參數清單|
|[編譯器錯誤 C3858](compiler-error-c3858.md)|'*識別碼*': 無法在目前範圍中重新宣告|
|[編譯器錯誤 C3859](compiler-error-c3859.md)|超出; PCH 的虛擬記憶體範圍請重新編譯的命令列選項 '-Zm*數目*' 或更高|
|[編譯器錯誤 C3860](compiler-error-c3860.md)|下列類別範本/泛型名稱的範本/泛型引數清單必須列出範本/泛型參數清單中使用的順序中的參數|
|[編譯器錯誤 C3861](compiler-error-c3861.md)|'*識別碼*': 找不到識別項|
|[編譯器錯誤 C3862](compiler-error-c3862.md)|'*函式*': 無法編譯 unmanaged 函式以 /clr: pure 或 /clr: safe|
|編譯器錯誤 C3863|陣列類型 '*類型*' 指派給|
|編譯器錯誤 C3864|已過時。|
|[編譯器錯誤 C3865](compiler-error-c3865.md)|'*關鍵字*': 只用於原生成員函式|
|[編譯器錯誤 C3866](compiler-error-c3866.md)|解構函式/finalizer 呼叫遺漏引數清單|
|[編譯器錯誤 C3867](compiler-error-c3867.md)|'*函式*': 非標準語法; 請使用 '&' 建立成員的指標|
|[編譯器錯誤 C3868](compiler-error-c3868.md)|'*類型*': 泛型參數條件約束'*參數*' 所宣告的不同|
|[編譯器錯誤 C3869](compiler-error-c3869.md)|gcnew 條件約束遺漏空參數清單 '（）'|
|編譯器錯誤 C3870|'*參數*':' __declspec (*規範*)' 只能套用至整數類資料類型的參數|
|編譯器錯誤 C3871|'*參數*': '__declspec(guard(overflow))' 僅支援前 64 個函式參數|
|[編譯器錯誤 C3872](compiler-error-c3872.md)|' 0 x*值*': 不允許此字元在識別項|
|[編譯器錯誤 C3873](compiler-error-c3873.md)|' 0 x*值*': 不允許此字元作為識別項的第一個字元|
|[編譯器錯誤 C3874](compiler-error-c3874.md)|傳回型別 '*識別碼*'應該是'*type1*' 而不是 '*type2*'|
|編譯器錯誤 C3875|遺漏引數清單的非靜態成員函式的呼叫|
|編譯器錯誤 C3876|已過時。|
|編譯器錯誤 C3877|已過時。|
|編譯器錯誤 C3878|已過時。|
|編譯器錯誤 C3879|'*成員*': 不可為 initonly 資料成員|
|[編譯器錯誤 C3880](compiler-error-c3880.md)|'*成員*': 不可以是常值資料成員|
|編譯器錯誤 C3881|只能從直接基底繼承建構函式|
|編譯器錯誤 C3882|'*類別*': 建構函式具有繼承自'*類別*'|
|編譯器錯誤 C3883|'*成員*': initonly 靜態資料成員必須初始化|
|編譯器錯誤 C3884|'*類型*': 大小未知的陣列無法以值初始化|
|編譯器錯誤 C3885|'*類型*': 未知大小的陣列無法以空的初始設定式清單初始化|
|[編譯器錯誤 C3886](compiler-error-c3886.md)|'*成員*': 必須初始化常值資料成員|
|[編譯器錯誤 C3887](compiler-error-c3887.md)|'*成員*': 常值資料成員初始設定式必須是常數運算式|
|[編譯器錯誤 C3888](compiler-error-c3888.md)|'*成員*': 這個常值資料成員與相關聯的常數運算式不支援 C + CLI|
|編譯器錯誤 C3889|已過時。|
|[編譯器錯誤 C3890](compiler-error-c3890.md)|'*成員*': 您無法取得常值資料成員的位址|
|[編譯器錯誤 C3891](compiler-error-c3891.md)|'*成員*': 常值資料成員不能做為左值|
|[編譯器錯誤 C3892](compiler-error-c3892.md)|'*變數*': 您無法指派給是 const 變數|
|[編譯器錯誤 C3893](compiler-error-c3893.md)|'*成員*': initonly 資料成員的左值使用只允許在類別的執行個體建構函式*類別*'|
|[編譯器錯誤 C3894](compiler-error-c3894.md)|'*成員*': initonly 靜態資料成員的左值使用只允許在類別建構函式的類別*類別*'|
|[編譯器錯誤 C3895](compiler-error-c3895.md)|'*成員*':*類型*資料成員不可為 'volatile'|
|[編譯器錯誤 C3896](compiler-error-c3896.md)|'*成員*': 不正確的初始設定式： 這個常值資料成員只能與 'nullptr' 初始化|
|編譯器錯誤 C3897|已過時。|
|[編譯器錯誤 C3898](compiler-error-c3898.md)|'*成員*':*類型*資料成員只能是 managed 類型的成員|
|[編譯器錯誤 C3899](compiler-error-c3899.md)|'*成員*': initonly 資料成員的左值使用不允許直接放在類別中的平行區域內*類別*'|
|[編譯器錯誤 C3900](compiler-error-c3900.md)|'*成員*': 不允許在目前範圍內|
|[編譯器錯誤 C3901](compiler-error-c3901.md)|'*函式*': 必須有傳回型別'*類型*'|
|[編譯器錯誤 C3902](compiler-error-c3902.md)|'*函式*': 最後一個參數類型必須是'*類型*'|
|[編譯器錯誤 C3903](compiler-error-c3903.md)|'*屬性*': 沒有 set 或 get 方法|
|[編譯器錯誤 C3904](compiler-error-c3904.md)|'*屬性*': 必須指定*數目*參數|
|編譯器錯誤 C3905|未對齊的存取不支援內建型別 '*類型*'|
|編譯器錯誤 C3906|內建型別 '*類型*' 不是 vararg 或 unprototyped 函式的支援的傳回或引數類型|
|編譯器錯誤 C3907|已過時。|
|[編譯器錯誤 C3908](compiler-error-c3908.md)|存取層級限制少於的 '*識別碼*'|
|[編譯器錯誤 C3909](compiler-error-c3909.md)|managed/WinRT 事件宣告必須發生在受管理/WinRT 類型|
|[編譯器錯誤 C3910](compiler-error-c3910.md)|'*事件*': 必須定義成員'*成員*'|
|[編譯器錯誤 C3911](compiler-error-c3911.md)|'*成員*': 函式必須有類型'*類型*'|
|[編譯器錯誤 C3912](compiler-error-c3912.md)|'*事件*': 事件類型必須是委派類型|
|[編譯器錯誤 C3913](compiler-error-c3913.md)|預設屬性必須具備索引|
|[編譯器錯誤 C3914](compiler-error-c3914.md)|預設屬性不可為靜態|
|[編譯器錯誤 C3915](compiler-error-c3915.md)|'*識別碼*' 沒有預設值已索引屬性 （類別索引子）|
|編譯器錯誤 C3916|已過時。|
|[編譯器錯誤 C3917](compiler-error-c3917.md)|'*語彙基元*': 過時*建構*宣告樣式 (這表示您要使用' [' ']' 改為？)|
|[編譯器錯誤 C3918](compiler-error-c3918.md)|使用方式必須有 '*識別碼*' 是資料成員|
|[編譯器錯誤 C3919](compiler-error-c3919.md)|'*函式*': 函式必須有類型'*return_type* (*類型*)'|
|[編譯器錯誤 C3920](compiler-error-c3920.md)|'*運算子*': 無法定義後置遞增/遞減 CLR/WinRT 運算子呼叫後置 CLR/WinRT 運算子將會呼叫對應的前置詞 CLR/WinRT 運算子 (op_Increment/op_Decrement)，但是會具有後置語意|
|編譯器錯誤 C3921|已過時。|
|編譯器錯誤 C3922|已過時。|
|[編譯器錯誤 C3923](compiler-error-c3923.md)|'*成員*': 區域類別、 結構或等位定義不允許的 managed/WinRT 類別的成員函式|
|編譯器錯誤 C3924|引數中的錯誤 #*數目*委派建構函式呼叫的 '*建構函式*':|
|編譯器錯誤 C3925|預期迴圈 (，時，或不要) 下列 '*指示詞*' 指示詞|
|編譯器錯誤 C3926|'parallel' 指示詞中有無效的常數|
|編譯器錯誤 C3927|'->': 尾端傳回類型不允許非函式宣告子之後|
|編譯器錯誤 C3928|'->': 尾端傳回類型不允許的括號括住宣告子之後|
|編譯器錯誤 C3929|已過時。|
|編譯器錯誤 C3930|'*函式*': 沒有多載函式具有與環境內容相容的限制規範'*內容*'|
|編譯器錯誤 C3931|'*類型*': 無法呼叫具有與環境內容不相容的限制規範的函式|
|編譯器錯誤 C3932|已過時。|
|編譯器錯誤 C3933|'*類別*': 解構函式的限制規範必須涵蓋所有建構函式的限制的等位|
|編譯器錯誤 C3934|是以任何形式的 'main' 函式不能有非 restrict （cpu） 的限制規範|
|編譯器錯誤 C3935|'*識別碼*': 重複定義; 重疊限制規範|
|編譯器錯誤 C3936|'*識別碼*': 無法辨認的限制規範|
|編譯器錯誤 C3937|不允許空白的限制規範|
|編譯器錯誤 C3938|'*識別碼*': extern \042C\042 函式上不支援多重限制規範|
|編譯器錯誤 C3939|'*識別碼*': 成員函式，函式指標的指標不允許參考至 'amp' 限制規範的函式|
|編譯器錯誤 C3940|'*識別碼*': 找不到-編譯器和程式庫版本可能不相符的識別碼。 請確定 vccorlib.h/.lib、 vccorlib120.dll 和 c1xx.dll 相符項目|
|編譯器錯誤 C3941|'*條件*': 需要' / clr' 命令列選項|
|編譯器錯誤 C3942|已過時。|
|編譯器錯誤 C3943|已過時。|
|編譯器錯誤 C3944|已過時。|
|編譯器錯誤 C3945|'*類型*': 無法擲回或攔截不是衍生自 platform:: exception 的 winrt 物件|
|編譯器錯誤 C3946|'*類型*': typeid 無法套用至此類型|
|編譯器錯誤 C3947|'*typeid*': typeid 無法套用至封裝展開|
|編譯器錯誤 C3948|'*關鍵字*': 封裝展開不可出現在此內容|
|編譯器錯誤 C3949|封裝展開 '...'，不能出現在括號括住的抽象宣告子|
|編譯器錯誤 C3950|已過時。|
|編譯器錯誤 C3951|無法在預計的 WinRT 類型中使用成員指標 '*類型*'。 請改用委派。|
|編譯器錯誤 C3952|'*類型*': WinRT 不支援' in/out' 陣列。 使用 'const 陣列<T>^' 的 'in' 和' WriteOnlyArray<T>'或' 陣列<T>^ *' 代表 'out' 的公用 Api 上|
|編譯器錯誤 C3953|無法使用 managed 的類別*類型*' 在 WinRT 模組中。|
|編譯器錯誤 C3954|'*類型*': WinRT 類型上，從已發行方法傳回的陣列必須使用格式' 陣列<T>^'|
|編譯器錯誤 C3955|'*類型*': 公用建構函式不能包含 'out' 參數或' WriteOnlyArray<T>'|
|編譯器錯誤 C3956|'*類型*': 類型標示為獨佔至'*類型*'，無法當成的基底'*derived_type 更難以*'|
|編譯器錯誤 C3957|'*類型*': 不能使用 'new' 在 WinRT 類型; 請改用 'ref new'|
|編譯器錯誤 C3958|'*類型*': 無法用 'gcnew' 上在 WinRT 類型; 請改用 'ref new'|
|編譯器錯誤 C3959|'ref new' 只可用來建立具有 WinRT 類型的物件|
|編譯器錯誤 C3960|已過時。|
|編譯器錯誤 C3961|不支援靜態建構函式|
|編譯器錯誤 C3962|不支援泛型類別|
|編譯器錯誤 C3963|不支援多維陣列|
|編譯器錯誤 C3964|不支援不規則的陣列|
|編譯器錯誤 C3965|不支援參數陣列|
|編譯器錯誤 C3966|'*函式*': 不支援泛型函式|
|編譯器錯誤 C3967|匯入時發生錯誤 '*識別碼*'從模組'*模組*'|
|編譯器錯誤 C3968|語彙基元 '*語彙基元*' 不是有效模組名稱分隔符號，使用句點 ('。 ') 改為|
|編譯器錯誤 C3969|不一致的模組名稱: '*module1*'和'*module1*'|
|編譯器錯誤 C3970|'*識別碼*':'*關鍵字*' 只可以套用至 'ref class' 或 'ref struct' 在全域範圍或命名空間範圍|
|編譯器錯誤 C3971|'*類型*': 部分定義不能出現在完整定義之後|
|編譯器錯誤 C3972|'*類型*': 'partial' 只能套用至類別宣告或定義|
|編譯器錯誤 C3973|已過時。|
|編譯器錯誤 C3974|已過時。|
|編譯器錯誤 C3975|'類別/結構*識別碼*' 先前已宣告或定義與不同的修飾詞|
|編譯器錯誤 C3976|'*identifier1*'必須宣告為 'public' 才能使用'*identifier2*'|
|編譯器錯誤 C3977|使用方式需要參考，以定義組件 '*識別碼*'|
|編譯器錯誤 C3978|'*識別碼*': 靜態屬性不允許做為 WinRT 介面或實值類型的成員|
|編譯器錯誤 C3979|'*類型*': 使用屬性'*屬性*'而不是'*值*'|
|編譯器錯誤 C3980|'*類型*' 無法發出至中繼資料|
|編譯器錯誤 C3981|'*類型*': 實值類型不能有任何靜態資料成員*識別碼*'|
|編譯器錯誤 C3982|'*類型*': 實值類型不能有任何非公用資料成員*識別碼*'|
|編譯器錯誤 C3983|'*類型*': 實值類型不能有任何公用非資料成員*識別碼*'|
|編譯器錯誤 C3984|'*類型*': 非實值類型不可以有公用資料成員*識別碼*'|
|編譯器錯誤 C3985|'*識別碼*': public 成員的簽章包含私用類型'*成員*'|
|編譯器錯誤 C3986|'*識別碼*': public 成員的簽章包含原生類型'*成員*'|
|編譯器錯誤 C3987|'*識別碼*': public 成員的簽章包含原生類型'*類型*'|
|編譯器錯誤 C3988|'*類型*': 原生類型不能是公用|
|編譯器錯誤 C3989|'*類型*': 巢狀的類型不能是公用|
|編譯器錯誤 C3990|'*類型*': 屬性'*屬性*' 不可為私用或巢狀|
|編譯器錯誤 C3991|'*類型*': 無法實作非公用或巢狀介面'*介面*'|
|編譯器錯誤 C3992|'*識別碼*': public 成員的簽章包含無效的類型'*類型*'|
|編譯器錯誤 C3993|'*類型*': 實值類型必須包含至少一個公用欄位|
|編譯器錯誤 C3994|'*類型*': 實值類型無法實作介面或具有虛擬函式|
|編譯器錯誤 C3995|'*類型*': 實值類型不能有任何事件成員*識別碼*'|
|編譯器錯誤 C3996|已過時。|
|編譯器錯誤 C3998|'c + +*版本*': 不支援 c + + 版本; 預設為' c + +*版本*'|
|編譯器錯誤 C3999|未知錯誤，請選擇 Visual c + + 說明 功能表上的技術支援 命令或開啟技術支援說明檔，如需詳細資訊|
