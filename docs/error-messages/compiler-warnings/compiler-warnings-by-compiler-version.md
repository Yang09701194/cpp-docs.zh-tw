---
title: 編譯器警告的編譯器版本 |Microsoft 文件
ms.custom: ''
ms.date: 01/31/2018
ms.technology:
- devlang-cpp
ms.topic: error-reference
dev_langs:
- C++
helpviewer_keywords:
- warnings, by compiler version
- cl.exe compiler, setting warning options
author: corob-msft
ms.author: corob
ms.workload:
- cplusplus
ms.openlocfilehash: 789121e3adb42cb74087339bb33bb82cb7604a10
ms.sourcegitcommit: 76b7653ae443a2b8eb1186b789f8503609d6453e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
---
# <a name="compiler-warnings-by-compiler-version"></a>編譯器警告的編譯器版本

編譯器可以隱藏導入後的版本，您可以使用指定的警告[/Wv](../../build/reference/compiler-option-warning-level.md)編譯器選項。 這是適合用來管理您的建置程序，當您引入新的工具組版本，並想要暫時隱藏新的警告。 這個選項不會隱藏新的錯誤訊息。 我們不建議您隱藏所有的新警告永久 ！ 我們建議您一律在最高規則的警告層級編譯 __/W4__，並移除 __/Wv__儘速在您的組建選項。 

這些版本的編譯器導入新的警告：

| 產品 | 編譯器版本號碼 |
|-|-|
| Visual c + + 2002 | 13.00.9466 |
| Visual c + + 2003 | 13.10.3077 |
| Visual C++ 2005 | 14.00.50727.762 |
| Visual C++ 2008 | 15.00.21022.08 |
| Visual C++ 2010 | 16.00.40219.01 |
| Visual c + + 2012 | 17.00.51106.1 |
| Visual c + + 2013 | 18.00.21005.1 |
| Visual c + + 2015 RTM | 19.00.23026.0 |
| Visual c + + 2015 Update 1 | 19.00.23506.0 |
| Visual c + + 2015 Update 2 | 19.00.23918.0 |
| Visual c + + 2015 Update 3 | 19.00.24215.1 |
| Visual c + + 2017 RTM | 19.10.24903.0 |
| Visual c + + 2017 版本 15.1 | 19.10.25017.0 |
| Visual c + + 2017 版本 15.3 | 19.11.25506.0 |
| Visual c + + 2017 版本 15.5 | 19.12.25827.0 |

您可以指定只有主要版本號碼、 主要和次要的數字或主要、 次要、 和組建編號 __/Wv__選項。 編譯器會報告所有警告符合指定的數目，以開始的版本，且會抑制版本大於指定的數字的所有警告。 例如， __/Wv:17__報告導入，或任何版本的 Visual Studio 2012 之前的所有警告，且會抑制任何編譯器，從 Visual Studio 2013 （18 版） 或更新版本所導入的所有警告。 隱藏警告導入在 Visual Studio 2015 update 2 和更新版本中，您可以使用 __/Wv:19.00.23506__。 使用 __/Wv:19.11__報告所有警告導入了在任何版本 Visual Studio 2017 版本 15.5 之前, 的 Visual Studio 中，但是會隱藏在 Visual Studio 2017 15.5 和更新版本中導入的警告。

下列章節會列出您可以藉由使用隱藏的 Visual c + + 的每個版本所導入的警告 __/Wv__編譯器選項。 __/Wv__選項無法隱藏警告不會列出，自封指定的版本的編譯器。

## <a name="warnings-introduced-in-visual-c-2017-version-155-compiler-version-1912258270"></a>Visual c + + 2017 15.5 （編譯器版本 19.12.25827.0） 版本中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:19.11__。

|||
|-|-|
C5044|命令列選項的引數*選項*指向的路徑 '*路徑*' 不存在

## <a name="warnings-introduced-in-visual-c-2017-version-153-compiler-version-1911255060"></a>Visual c + + 2017 15.3 （編譯器版本 19.11.25506.0） 版本中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:19.10__。

|||
|-|-|
C4843|'*type1*': 陣列或函式類型之參考的例外狀況處理常式無法連線，請使用'*type2*' 改為
C4844|' 匯出模組*適於*;' 已宣告模組介面的慣用的語法
C5039|'*函式*': 指標或參考可能會擲回函式傳遞至下-/ehc extern C 函式。 如果此函式會擲回的例外狀況，可能會發生未定義的行為。
C5040|動態例外狀況規格是有效的只有在 C + + 14 和舊版中;視為 noexcept
C5041|'*定義*': 不需要 constexpr 靜態資料成員的行外定義，而且已被取代的 C + + 17
C5042|'*宣告*': 在區塊範圍函式宣告不能指定 'inline' 標準 c + + 中，移除 'inline' 規範
C5043|'*規格*': 例外狀況規格與上一個宣告不符

## <a name="warnings-introduced-in-visual-c-2017-version-151-compiler-version-1910250170"></a>Visual c + + 2017 15.1 （編譯器版本 19.10.25017.0） 版本中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:19.10.24903__。

|||
|-|-|
C4597|未定義的行為：*描述*
C4604|'*類型*': 引數傳值方式傳遞原生和 managed 界限之間需要有效的複製建構函式。 否則執行階段行為未定義
C4749|有條件地支援：*描述*
C4768|就會忽略 __declspec 屬性之前連結規格
C4834|捨棄具有 'nodiscard' 屬性的函式傳回值
C4841|使用非標準擴充：*延伸模組*
C4842|'offsetof' 套用至使用多重繼承類型的結果不保證編譯器版本之間保持一致
C4869|'nodiscard' 只能套用至類別、 列舉和函式具有非 void 傳回型別
C5033|'*儲存類別*' 不再支援的存放裝置類別
C5034|使用內建函式 '*內建*' 函式會導致*函式*編譯為客體程式碼
C5035|使用功能 '*功能*' 函式會導致*函式*編譯為客體程式碼
C5036|varargs 函式的指標轉換時使用 /hybrid:x86arm64 編譯 '*type1*'to'*type2*'
C5037|'*成員函式*': 類別樣板的成員的行外定義不能有預設引數
C5038|資料成員 '*member1*'將初始化資料成員之後'*member2*'

## <a name="warnings-introduced-in-visual-c-2017-rtm-compiler-version-191024903"></a>在 Visual c + + 2017 RTM （編譯器版本 19.10.24903） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:19.00__。

|||
|-|-|
C4468|'fallthrough': 屬性後面必須接著 case 標籤或預設標籤
C4698|'*功能*' 已評估之用，並可能有所變更或移除在未來的更新。
C4839|類別使用非標準*類別*' 當做 variadic 函式的引數
C4840|類別不可移植使用*類別*' 當做 variadic 函式的引數

## <a name="warnings-introduced-in-visual-c-2015-update-3-compiler-version-1900242151"></a>Visual c + + 2015 Update 3 （編譯器版本 19.00.24215.1） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:19.00.23918__。

|||
|-|-|
C4467|ATL 屬性用法已被取代
C4596|'*名稱*': 成員宣告中不合法的限定的名稱
C4598|' #include \<*標頭*\>': 標頭數目*數目*中*來源*不符*來源*看它位置
C4599|'*引數*':*來源*引數數目*數目*不符*來源*

## <a name="warnings-introduced-in-visual-c-2015-update-2-compiler-version-1900239180"></a>Visual c + + 2015 Update 2 （編譯器版本 19.00.23918.0） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:19.00.23506__。

|||
|-|-|
C4466|無法執行協同程式堆積省略
C4595|'*類別*': 非成員運算子 new 或 delete 函式不可宣告為內嵌
C4828|檔案包含位移 0 處開始的字元 x*值*，是在目前的來源字元集中不合法 (字碼頁*數目*)。
C4868|編譯器不會強制執行括號初始設定式清單中的左到右評估順序

## <a name="warnings-introduced-in-visual-c-2015-update-1-compiler-version-1900235060"></a>Visual c + + 2015 Update 1 （編譯器版本 19.00.23506.0） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:19.00.23026__。

|||
|-|-|
C4426|包含標頭，可能是因為 #pragma optimize （） 之後變更的最佳化旗標
C4654|先行編譯標頭包含放在之前的程式碼行都會被忽略。 程式碼加入先行編譯標頭。
C5031|#pragma warning （pop): 可能不相符，快顯警告狀態推入不同的檔案
C5032|偵測到任何對應 「 #pragma warning （pop 的) #pragma warning

## <a name="warnings-introduced-in-visual-c-2015-rtm-compiler-version-1900230260"></a>在 Visual c + + 2015 RTM （編譯器版本 19.00.23026.0） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:18__。

|||
|-|-|
C4427|'*錯誤*': 常數相除，未定義的行為溢位
C4438|'*類型*': 無法在中安全地呼叫 /await: clrcompat 模式。 如果 '*類型*' 呼叫 CLR，可能會導致 CLR 標頭損毀
C4455|' 運算子*名稱*': 不會啟動底線的常值後置字元識別項保留
C4456|宣告的 '*名稱*' 會隱藏先前的區域宣告
C4457|宣告的 '*名稱*' 會隱藏函式參數
C4458|宣告的 '*名稱*' 會隱藏類別成員
C4459|宣告的 '*名稱*' 會隱藏全域宣告
C4462|'*類型*': 無法判斷類型的 GUID。 程式可能在執行階段失敗。
C4463|溢位。指派*值*只能保留值的位元欄位*值*至*值*
C4473|'*函式*': 沒有足夠的引數傳遞給格式字串
C4474|'*函式*': 太多引數傳遞給格式字串
C4475|'*函式*': 長度修飾詞'*修飾詞*'不能與型別欄位字元'*字元*' 格式規範中
C4476|'*函式*': 未知的型別欄位字元'*字元*' 格式規範中
C4477|'*函式*': 格式字串'*字串*'需要類型的引數'*類型*'，但 variadic 引數*數目*具有類型 '*類型*'
C4478|'*函式*': 無法在相同的格式字串中混合位置和非位置的預留位置
C4494|'*類型*': 忽略 __declspec （allocator），因為函式傳回型別不是指標或參考
C4495|使用非標準擴充 ' __super ': 取代為明確的基底類別名稱
C4496|使用非標準擴充 'for each': 取代為 ranged-for 陳述式
C4497|使用非標準擴充 'sealed': 取代為 'final'
C4498|使用非標準擴充: '*延伸*'
C4499|'*特製化*': 明確特製化不能有儲存類別 （忽略）
C4576|後面接著以初始設定式清單是括號括住類型為非標準的明確類型轉換語法
C4577|任何例外狀況處理模式指定; 使用 ' noexcept'不保證終止的例外狀況。 指定 /EHsc
C4578|'abs': 從 '*類型*'to'*類型*'，可能導致資料遺失 (您是否想要呼叫'*名稱*' 或 #include <cmath>？)
C4582|'*類型*': 未隱含呼叫建構函式
C4583|'*類型*': 未隱含呼叫解構函式
C4587|'*類型*': 行為變更： 不再隱含呼叫建構函式
C4588|'*類型*': 行為變更： 不再隱含呼叫解構函式
C4589|抽象類別的建構函式*類型*'會忽略虛擬基底類別初始設定式'*類型*'
C4591|'constexpr' 呼叫深度限制*數目*超過 (/: depth<n><NUMBER>)
C4592|'*類型*': 符號將會動態初始化 （實作限制）
C4593|'*類型*': 'constexpr' 呼叫評估步驟限制*值*超過; 使用 /constexpr:<NUMBER>以提高的限制
C4647|行為變更： __is_pod (*類型*) 在舊版中有不同的值
C4648|忽略標準的屬性 '未以 carries_dependency'
C4649|在此內容中就會忽略屬性
C4753|找不到指標的界限;忽略 MPX 內建函式
C4771|您必須使用簡單的指標; 建立界限忽略 MPX 內建函式
C4774|'*描述*': 格式字串引數中必須要有*數目*不是字串常值
C4775|在格式字串中使用非標準擴充 '*字串*'的函式'*函式*'
C4776|' %*字元*'中不允許函式的格式字串'*函式*'
C4777|'*描述*': 格式字串'*字串*'需要類型的引數'*類型*'，但 variadic 引數*數目*具有類型 '*類型*'
C4778|'*描述*': 有未結束的格式字串'*字串*'
C4838|從轉換 '*類型*'to'*類型*' 必須是縮小轉換
C5022|'*類型*': 多個移動建構函式指定
C5023|'*類型*': 指定多個 move 指派運算子
C5024|'*宣告*': move 建構函式已隱含定義為已刪除
C5025|'*宣告*': move 指派運算子已隱含定義為已刪除
C5026|'*類型*': move 建構函式已隱含定義為已刪除
C5027|'*類型*': move 指派運算子已隱含定義為已刪除
C5028|'*名稱*': 在先前的宣告中指定的對齊方式 (*數目*) 定義中未指定
C5029|使用非標準擴充： c + + 中的對齊屬性的變數、 資料成員及標記類型只適用於
C5030|屬性 '*屬性*' 無法辨識

## <a name="warnings-introduced-in-visual-c-2013-compiler-version-1800210051"></a>在 Visual c + + 2013 （編譯器版本 18.00.21005.1） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:17__。

|||
|-|-|
C4301|'*類型*': 覆寫虛擬函式只能與'*宣告*' const/volatile 限定詞
C4316|'*類型*': 在堆積上配置的物件可能未對齊*數目*
C4380|'*類型*': 預設建構函式不能被取代
C4388|'*語彙基元*': signed/unsigned 不相符
C4423|'std:: bad_alloc': 攔截到類別 ('*類型*') 的一行*數目*
C4424|攔截的 '*類型*'前面加上'*類型*' 列上*數目*; 無法預期的行為可能會造成擲回 'std:: bad_alloc'
C4425|SAL 註釋不能套用至 '...'
C4464|相對 include 路徑包含 '..'
C4575|'__vectorcall' 不以 '/ /clr' 選項： 將轉換為 '__stdcall'
C4609|'*類型*'衍生自預設介面'*類型*'type' 上*類型*'。 使用不同的預設介面 '*類型*'，或中斷基底/衍生關聯性。
C4754|在比較中有算術運算的轉換規則*描述*(*數目*) 表示一個分支無法執行。 轉換 '*類型*'to'*類型*' (或類似的類型*數目*位元組為單位)。
C4755|在比較中有算術運算的轉換規則*描述*(*數目*) 表示一個分支無法執行中的內嵌函式。 轉換 '*類型*'to'*類型*' (或類似的類型*數目*位元組為單位)。
C4767|區段名稱 '*名稱*' 超過 8 個字元，將由連結器截斷
C4770|部分驗證的列舉 '*名稱*' 做為索引
C4827|具有 0 個參數的公用 'ToString' 方法應該標記為 virtual，並覆寫
C4882|將具有非常數呼叫運算子函式傳遞給 concurrency:: parallel_for_each 已被取代
C4973|'*類型*': 標記為已被取代
C4974|'*類型*': 標記為已被取代
C4981|Warbird： 函式 '*宣告*' 標記為 __forceinline 無法內嵌，因為它包含例外狀況語意
C4990|Warbird:*訊息*
C4991|Warbird： 函式 '*宣告*' 標記為 __forceinline 無法內嵌，因為被內嵌者的保護層級大於父代
C4992|Warbird： 函式 '*宣告*' 標記為 __forceinline 無法內嵌，因為它包含內嵌組譯碼無法保護

## <a name="warnings-introduced-in-visual-c-2012-compiler-version-1700511061"></a>在 Visual c + + 2012 （編譯器版本 17.00.51106.1） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:16__。

|||
|-|-|
C4330|屬性 '*屬性*'針對 section'*區段*' 忽略
C4415|重複的 __declspec (code_seg ('*名稱*'))
C4416|__declspec(code_seg(...)) 包含空字串： 忽略
C4417|明確樣板具現化不能有 __declspec(code_seg(...))： 忽略
C4418|__declspec(code_seg(...)) 忽略列舉
C4419|'*名稱*'時沒有任何作用套用至私用 ref 類別'*類型*'。
C4435|'*類型*': /vd2 底下的物件配置將因虛擬基底而變更'*類型*'
C4436|從虛擬基底 dynamic_cast '*類型*'to'*類型*' 建構函式或解構函式失敗，但是部分建構的物件
C4437|從虛擬基底 dynamic_cast '*類型*'to'*類型*' 某些內容中可能會失敗
C4443|pragma 參數必須為 '0'、 '1' 或 '2'
C4446|'*類型*': 無法將對應的成員'*名稱*' 至此類型，因為型別名稱發生衝突。 方法已重新命名為 '*名稱*'
C4447|發現沒有執行緒模型的 'main' 簽章。 請考慮使用 ' int main (platform:: array\<platform:: string ^ > ^ args)'。
C4448|'*類型*' 並沒有中繼資料中指定的預設介面。 挑選: '*類型*'，這可能會在執行階段失敗。
C4449|'*類型*' 非密封的類型應標記為 '[WebHostHidden]'
C4450|'*類型*'應該標記為 '[WebHostHidden]' 因為其衍生自'*類型*'
C4451|'*類型*': ref 類別的使用方式*類型*' 在此內容可能會導致不正確的封送處理物件跨內容
C4452|'*類型*': 公用類型不能在全域範圍。 它必須是輸出.winmd 檔案名稱的子節點的命名空間中。
C4453|'*類型*': '[WebHostHidden]' 類型不應之已發行介面上的公用型別不是 '[WebHostHidden]'
C4454|'*類型*' 多個輸入參數數目所多載 [defaultoverload] 指定。 挑選 '*宣告*' 為預設多載
C4471|'*名稱*': 不限範圍列舉的向前宣告必須含有基礎類型 (假設為 int)
C4472|'*名稱*' 是原生列舉： 新增存取規範 (private/public) 以便宣告 managed/WinRT 列舉
C4492|'*類型*': 符合基底 ref 類別方法'*類型*'，但未標記為 'override'
C4493|刪除運算式沒有任何作用的解構函式為 '*類型*' 沒有 'public' 可及性
C4585|'*類型*': WinRT 'public ref class' 必須密封或衍生自現有的未密封類別
C4586|'*類型*': 無法在名稱為 'Windows' 的最上層命名空間宣告的公用型別
C4695|#pragma execution_character_set: '*引數*' 不是支援的引數： 目前只支援 'utf-8' 支援
C4703|可能未初始化的本機指標變數 '*名稱*' 使用
C4728|/Yl-選項忽略，因為 PCH 參考是必要
C4745|暫時性存取 '*名稱*' 不能接受，因為它的大小
C4746|暫時性存取 '*名稱*' 受限於 /volatile:\<iso\|ms > 設定; 請考慮使用 __iso_volatile_load/store 內建函式
C4872|浮點除數為零編譯呼叫圖表 parallel_for_each 時偵測到: '*描述*'
C4880|從轉型 '*類型*'to'*類型*': 轉型常數性的指標或參考可能會導致未定義的行為在 amp 限制函式
C4881|建構函式和 （或） 解構函式將不會叫用 tile_static 變數 '*類型*'
C4966|'*描述*' 有 __code_seg 註釋不支援的區段名稱、 註釋已忽略
C4988|'*類型*': 變數宣告為類別/函式範圍外
C4989|'*描述*': 類型含有衝突的定義。

## <a name="warnings-introduced-in-visual-c-2010-compiler-version-16004021901"></a>在 Visual c + + 2010 （編譯器版本 16.00.40219.01） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:15__。

|||
|-|-|
C4352|'*名稱*': 已經定義的內建函式
C4573|使用 '*類型*' 需要編譯器擷取 'this'，但目前的預設擷取模式不允許使用它
C4574|'*名稱*'定義為' 0': 您是否想要使用 ' #if*名稱*'？
C4689|'*字元*': #pragma detect_mismatch 中不支援的字元，則會忽略 #pragma
C4751|intel （) Streaming SIMD Extensions 內嵌 ASM 中，則不適用 /arch AVX 旗標
C4752|找到 intel （) Advanced Vector Extensions;請考慮使用適當的 /arch AVX 旗標
C4837|偵測到的三併詞: '？*字元*'取代'*字元*'
C4986|'*宣告*': 例外狀況規格與上一個宣告不符
C4987|使用非標準的擴充：'throw (...)'

## <a name="warnings-introduced-in-visual-c-2008-compiler-version-15002102208"></a>Visual c + + 2008 （編譯器版本 15.00.21022.08） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:14__。

|||
|-|-|
C4396|'*類型*': friend 宣告參考函式樣板的特製化時，不能使用內嵌規範
C4413|'*宣告*': 參考成員已初始化成建構函式結束之後，就不存在的暫存
C4491|'*描述*': 不合法的 IDL 版本格式
C4603|'*名稱*': 巨集未定義或定義是不同，在使用先行編譯標頭之後
C4627|'*描述*': 尋找先行編譯標頭使用時略過
C4750|'*描述*': 函式有 _alloca （） 內嵌成迴圈
C4910|'*類型*': '__declspec （dllexport）' 和 'extern' 不相容的明確具現化
C4985|'*宣告*': 屬性不存在先前的宣告。

## <a name="warnings-introduced-in-visual-c-2005-compiler-version-140050727762"></a>Visual c + + 2005 （編譯器版本 14.00.50727.762） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:13__。

|||
|-|-|
C4000|未知警告，請選擇 Visual c + + 說明 功能表上的技術支援 命令或開啟技術支援說明檔，如需詳細資訊
C4272|'*類型*': __declspec （dllimport） 標示為; 匯入函式時，必須指定原生呼叫慣例。
C4333|'*運算式*': 向右位移量太大，資料遺失
C4334|'*運算式*': 32 位元移位的結果以隱含方式轉換為 64 位元 （為 64 位元位移？）
C4335|偵測到 Mac 檔案格式： 請將原始程式檔轉換為 DOS 或 UNIX 格式
C4342|行為變更: '*類型*' 呼叫，但在舊版中被呼叫的是成員運算子
C4350|行為變更: '*宣告*'呼叫而不是'*宣告*'
C4357|委派的型式引數清單中找到的 param 陣列引數 '*宣告*'產生時，忽略'*類型*'
C4358|'*運算式*': 組合委派的傳回類型不是 'void'，則傳回的值會是未定義
C4359|'*類型*': 對齊規範小於實際對齊 (*數目*)，且會被忽略。
C4362|'*類型*': CLR 不支援大於 8 個位元組的對齊方式
C4364|#using 組件 '*名稱*' 先前看過在*描述*(*數目*) 沒有 as_friend 屬性，as_friend 不套用
C4365|'*運算式*': 從'*類型*'to'*類型*'，signed/unsigned 不相符
C4366|一元的結果 '*運算子*' 運算子可能未對齊
C4367|從轉換 '*類型*'to'*類型*' 可能會造成資料類型對齊錯誤例外狀況
C4368|無法定義 '*名稱*'as 受管理的成員'*類型*': 不支援混合的類型
C4369|'*類型*': 列舉值'*數目*'無法表示為'*類型*'，值為'*數目*'
C4374|'*宣告*': 非虛擬方法不會實作介面方法'*宣告*'
C4375|非公用方法 '*宣告*'不會覆寫'*宣告*'
C4376|存取規範 '*規範*:' 不再支援： 請使用'*規範*:' 改為
C4377|原生型別為私用的預設值;-d1PrivateNativeTypes 已被取代
C4378|必須取得函式指標才能執行初始設定式;請考慮 System::ModuleHandle::ResolveMethodHandle
C4379|版本*版本*的 common language runtime 不支援此編譯器。 使用這個版本可能會造成非預期的結果
C4381|'*宣告*': 非公用方法將不會實作介面方法'*宣告*'
C4382|擲回 '*類型*': 具有 __clrcall 解構函式或複製建構函式的型別只會攔截在 /clr: pure 模組
C4383|'*類型*': 控制代碼取值的意義可以變更、 使用者定義'*運算子*' 運算子存在，則將這個運算子撰寫運算元的明確宣告靜態函式
C4384|#pragma '*指示詞*' 應該只用在全域範圍
C4393|'*類型*': const 對*描述*資料成員; 忽略
C4394|'*類型*': per-appdomain 符號不可標示以 __declspec (*值*)
C4395|'*類型*': initonly 資料成員的複本將會叫用成員函式'*類型*'
C4397|會忽略 DefaultCharSetAttribute
C4398|'*類型*': 處理序專屬全域物件可能無法使用多重 appdomain 正確運作，請考慮使用 __declspec(appdomain)
C4399|'*類型*': 處理序專屬符號不會標示 __declspec (*值*) 時以 /clr 編譯： pure
C4400|'*類型*': 不支援此類型的 const/volatile 限定詞
C4412|'*宣告*': 函式簽章含有類型'*類型*';C + + 物件是純程式碼之間傳遞的不安全與混合或原生。
C4429|可能不完整或格式不正確通用字元名稱
C4430|遺漏類型規範 - 假設為 int。 注意： C + + 不支援 default-int
C4431|遺漏類型規範 - 假設為 int。 注意: C 已不再支援 default-int
C4434|靜態建構函式必須具有私用存取範圍;變更為私用存取
C4439|'*類型*': 函式簽章中有 managed 類型的定義必須有 __clrcall 呼叫慣例
C4441|呼叫慣例 '*慣例*' 忽略;'*慣例*' 代替
C4445|'*宣告*': managed/WinRT 類型中的虛擬方法不可為私用
C4460|CLR/WinRT 運算子 '*類型*'，具有參考所傳遞參數。 CLR/WinRT 運算子 '*運算子*'具有來自 c + + 運算子的不同語意'*運算子*'，您是否想要傳值方式傳遞？
C4461|'*類型*': 這個類別具有完成項' ！*型別*'，但沒有解構函式 ' ~*類型*'
C4470|浮點控制 pragma 在 /clr 下會忽略
C4480|使用非標準擴充： 指定列舉的基礎型別 '*類型*'
C4481|使用非標準擴充： 覆寫規範 '*規範*'
C4482|使用非標準擴充： 列舉 '*類型*' 限定名稱中使用
C4483|語法錯誤： 必須是 c + + 關鍵字
C4484|'*類型*': 符合基底 ref 類別方法'*類型*'，但未標記為 'virtual'、 ' new' override';'new' （而非 'virtual'） 會假設
C4485|'*類型*': 符合基底 ref 類別方法'*類型*'，但不是 '標示為 new' override';'new' （和 'virtual'） 會假設
C4486|'*類型*': ref 類別或實值類別的私用虛擬方法標記為 'sealed'
C4487|'*類型*': 符合繼承非虛擬方法'*類型*'，但未明確標記為 'new'
C4488|'*類型*': 需要'*關鍵字*'關鍵字來實作介面方法'*類型*'
C4489|'*關鍵字*': 不允許在介面方法'*名稱*'; 覆寫規範只允許在 ref 類別和實值類別方法
C4490|'*關鍵字*': 覆寫規範; 的用法不正確'*類型*' 不符合基底 ref 類別方法
C4538|'*類型*': 不支援此類型的 const/volatile 限定詞
C4559|'*類型*': 重複定義; 函式取得 __declspec (*值*)
C4565|'*類型*': 重複定義; 符號先前已宣告為 __declspec (*值*)
C4566|通用字元名稱所代表的字元 '*字元*' 無法在目前的字碼頁中 (*數目*)
C4568|'*類型*': 沒有任何成員符合明確覆寫的簽章
C4569|'*類型*': 沒有任何成員符合明確覆寫的簽章
C4570|'*類型*': 未明確宣告為抽象，但是擁有抽象函式
C4571|Visual c + + 7.1; 以來變更的告知性： catch 語意不再攔截結構化例外狀況 (SEH)
C4572|/Clr 底下的 [ParamArray] 屬性已被取代，請使用 '...' 改為
C4580|[attribute] 已被取代。請改為指定*指定*Attribute 做為基底類別
C4581|已被取代的行為: '"*名稱*"' 取代 '*名稱*' 處理序屬性
C4606|#pragma 警告: '*數目*' 忽略;程式碼分析警告不會支援警告層級產生關聯
C4631|MSXML 或 XPath 無法使用，將不會處理 XML 文件註解。 *description*
C4632|XML 文件註解：*描述*-拒絕存取：*描述*
C4633|XML 文件註解*描述*： 錯誤：*描述*
C4634|XML 文件註解*描述*： 無法套用：*描述*
C4635|XML 文件註解*描述*: XML 格式錯誤：*描述*
C4636|XML 文件註解*描述*： 標記必須是非空白 '*描述*' 屬性。
C4637|XML 文件註解*描述*:<include>標記已捨棄。 *description*
C4638|XML 文件註解*描述*： 未知的符號參考 '*描述*'。
C4639|MSXML 錯誤，將不會處理註解的 XML 文件。 *description*
C4641|XML 文件註解有模稜兩可的交互參考： 
C4678|基底類別*宣告*'是比存取'*名稱*'
C4679|'*描述*': 無法匯入成員
C4687|'*類型*': 密封抽象類別不能實作介面'*類型*'
C4688|'*名稱*': 條件約束清單含有組件私用類型'*宣告*'
C4690|[ emitidl ( pop ) ]: pop
C4691|'*類型*': 參考類型中，必須有參考*模組*'*描述*'，而是會使用目前的轉譯單位中定義的型別
C4692|'*名稱*': 非私用成員簽章含有組件私用原生類型'*宣告*'
C4693|'*類型*': 密封抽象類別不能有任何執行個體成員*名稱*'
C4694|'*類型*': 密封抽象類別不能有基底類別'*類型*'
C4720|內嵌組合語言報告: '*描述*'
C4721|'*描述*': 無法當做內建
C4722|'*描述*': 解構函式從未返回，可能發生記憶體流失的問題
C4726|ARM arch4/4T 僅支援 ' < cpsr_f > 或 < spsr_f >' 具有即時運算值
C4727|名為的 PCH*名稱*位於相同的時間戳記*名稱*和*名稱*。  使用第一個 PCH。
C4729|依據 flow graph 產生的警告，發現函式太大
C4730|'*描述*': 混合 _m64 和浮點運算式可能會導致不正確的程式碼
C4731|'*描述*': 框架指標暫存器'*註冊*' 修改內嵌組譯碼
C4732|內建函式 '*內建*' 不支援以這種架構
C4733|內嵌 asm 指定給 'Fs: 0': 未註冊為安全的處理常式的處理常式
C4734|超過 64k 行號 COFF 偵錯資訊 區段中;停止產生 COFF 偵錯行號模組 '*模組*'
C4738|在記憶體中儲存 32 位元浮點結果，可能會損失效能
C4739|變數的參考 '*變數*' 超過它的儲存空間
C4740|進出內嵌組譯程式碼的流程會隱藏全域最佳化
C4742|'*變數*'有不同的對齊'*位置*'和'*位置*':*數目*和*數目*
C4743|'*名稱*'有不同的大小'*位置*'和'*位置*':*數目*和*數目*位元組
C4744|'*名稱*'有不同的型別'*位置*'和'*位置*':'*類型*'和'*類型*'
C4747|呼叫 managed '*類型*': Managed 程式碼不會執行載入器鎖定，包括 DLL 進入點和從 DLL 進入點到達的呼叫下
C4761|引數; 中的整數大小不符提供轉換
C4764|無法對齊超過 16 位元組的攔截物件
C4788|'*識別碼*': 識別項被截斷成'*數目*' 字元
C4789|緩衝區 '*名稱*' 大小的*數目*位元組會溢位。*數目*將起始於位移寫入位元組*數目*
C4801|由參考傳回值無法驗證：*描述*
C4819|檔案包含無法在目前的字碼頁中表示的字元 (*數目*)。 若要避免資料遺失 Unicode 格式儲存檔案
C4826|從轉換 '*類型*'to'*類型*' 是帶正負號擴充。 這可能導致意外發生執行階段行為。
C4829|函式 main 的參數可能不正確。 請考慮 ' int main (platform:: array\<platform:: string ^ > ^ argv)'
C4835|'*類型*': 匯出資料的初始設定式將不會執行，直到主機組件中第一次執行受管理的程式碼
C4867|'*類型*': 非標準語法; 請使用 '&' 建立成員的指標
C4936|以 /clr 或 /clr:pure 編譯時才支援這個 __declspec
C4937|'*名稱*'和'*名稱*'是否為引數'*選項*'
C4938|'*類型*': 浮點削減變數可能會造成不一致的結果，在 /fp: strict 或 #pragma fenv_access 之下
C4939|#pragma vtordisp 已被取代，在未來的 Visual C++ 發行版本中將會移除
C4947|'*類型*': 標記為過時
C4949|pragma 'managed' 和 'unmanaged' 時才有意義的編譯 ' / /clr [: 選項]'
C4950|'*類型*': 標記為過時
C4955|'*描述*': 匯入已忽略; 已經從匯入'*來源*'
C4956|'*類型*': 這個類型不是可驗證
C4957|'*運算式*': 明確的轉換，從'*類型*'to'*類型*' 不是可驗證
C4958|'*運算式*': 指標算術不是可驗證
C4959|無法定義 unmanaged*類別*'*類型*' /clr: safe 中因為存取它的成員會產生無法驗證程式碼
C4960|'*描述*' 太大而無法分析
C4961|沒有任何分析資料合併到 '*位置*'，特性指引最佳化已停用
C4962|'*描述*': 特性指引最佳化已停用，因為最佳化導致分析資料變成不一致
C4963|'*描述*': 找不到分析資料; 檢測建置中使用了不同的編譯器選項
C4964|不指定任何最佳化選項;將不會收集設定檔資訊
C4965|隱含 box 的整數 0;請使用 nullptr 或明確轉換
C4970|委派建構函式： 目標物件會忽略，因為 '*宣告*' 是靜態的
C4971|引數的順序：\<目標物件 >，\<目標函式 > 委派建構函式已被取代，請使用\<目標函式 >，\<目標物件 >
C4972|直接修改或將 Unbox 作業的結果視為左值，將無法驗證

## <a name="warnings-introduced-in-visual-c-2003-compiler-version-13103077"></a>在 Visual c + + 2003 中 （編譯器版本 13.10.3077） 導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:13.00.9466__。

|||
|-|-|
C4343|#pragma 最佳化 (*描述*、 設為 off) 覆寫了 /Og 選項
C4344|行為變更： 使用明確樣板引數會導致呼叫 '*宣告*'
C4346|'*類型*': 相依名稱不是型別
C4348|'*宣告*': 重複定義的預設參數： 參數*數目*
C4356|'*類型*': 無法透過衍生類別初始化靜態資料成員
C4408|匿名*結構*沒有宣告任何資料成員
C4544|'*宣告*': 預設會忽略這個樣板宣告上的樣板引數
C4545|逗號之前的運算式判斷值為遺漏引數清單的函式
C4546|逗號之前的函式呼叫遺漏引數清單
C4547|'*運算式*': 運算子逗號之前無效; 必須是具有副作用的運算子
C4548|逗號之前的運算式無效; 必須是具有副作用的運算式
C4549|'*運算式*': 逗號之前的運算子無效; 您是否想'*運算式*' 嗎？
C4628|不支援使用 -Ze 的雙拼詞。 字元順序 '*順序*'沒有解譯為替代語彙基元'*語彙基元*'
C4629|使用了雙拼詞，字元順序 '*順序*'被解譯為語彙基元'*語彙基元*' （如果這是不是您所要插入的兩個字元之間的空格）
C4671|'*描述*': 複製建構函式是無法存取
C4676|'*描述*': 解構函式是無法存取
C4677|'*名稱*': 非私用成員簽章含有組件私用類型'*宣告*'
C4686|'*類型*': 行為可能變更，在 UDT 傳回呼叫慣例
C4812|過時的宣告樣式： 請使用 '*類型*::*名稱*' 改為
C4813|'*類型*': 區域類別的 friend 函式必須先前已宣告
C4821|無法判斷 Unicode 編碼類型，請使用簽章 (BOM) 儲存檔案
C4822|'*類型*': 區域類別成員函式沒有主體
C4823|'*類型*': 使用 pin 指標但回溯語意不會啟用。 請考慮使用 /EHa
C4913|使用者定義的二進位運算子 ',' 存在，但沒有多載可以轉換所有的運算元，使用預設的內建二進位運算子 ','
C4948|傳回型別 '*宣告*' 不符合對應 setter 的最後一個參數類型
C4951|'*描述*' 已經編輯，因為已收集的分析資料，未使用的函式分析資料
C4952|'*描述*': 沒有任何分析資料在程式資料庫中找到'*描述*'
C4953|內嵌項 '*描述*' 已經編輯，因為已收集的分析資料，未使用分析資料
C4954|'*描述*': 未分析 （包含 __int64 switch 運算式）

## <a name="warnings-introduced-in-visual-c-2002-compiler-version-13009466"></a>Visual c + + 2002 （編譯器版本 13.00.9466） 中導入的警告

使用編譯器選項會抑制這些警告和更新版本中的所有警告 __/Wv:12__。

|||
|-|-|
C4096|'*類型*': 介面不是 COM 介面; 不會發出到 IDL
C4097|pragma 參數必須為 'restore' 或 'off'
C4165|正在 'HRESULT' 轉換為 'bool';確定這是您想要？
C4183|'*名稱*': 遺漏傳回類型; 假設是傳回 'int' 的成員函式
C4199|*description*
C4255|'*名稱*': 未提供的函式原型： 轉換為 '(void)' 的' （）'
C4256|'*宣告*': 具有虛擬基底類別建構函式有 '...'; 呼叫可能無法與舊版的 Visual c + + 相容
C4258|'*名稱*': 從定義迴圈會忽略; 使用封閉範圍定義
C4263|'*宣告*': 成員函式不會覆寫任何基底類別虛擬成員函式
C4264|'*宣告*': 沒有覆寫的基底虛擬成員函式'*類別*'; 函式已隱藏
C4265|'*類型*': 類別有虛擬函式，但不是虛擬解構函式的這個類別執行個體可能無法正確解構
C4266|'*宣告*': 沒有覆寫的基底虛擬成員函式'*類別*'; 函式已隱藏
C4267|'*運算式*': 將 'size_t' 來轉換'*類型*'，資料可能遺失
C4274|#ident 忽略;請參閱 #pragma 註解 （exestr，'string'） 的文件
C4277|匯入項目 '*類型*::*名稱*' 存在做為資料成員和函式成員; 已忽略資料成員
C4278|'*名稱*': 類型程式庫中的識別項'*描述*' 已經是巨集; 使用 'rename' 限定詞
C4279|'*名稱*': 類型程式庫中的識別項'*描述*' 是關鍵字; 使用 'rename' 限定詞
C4287|'*運算式*': unsigned 和負常數不相符
C4288|使用非標準擴充: '*名稱*': for 迴圈範圍外使用 for-loop 中所宣告的迴圈控制變數; 它與外部範圍中宣告衝突
C4289|使用非標準擴充: '*名稱*': for 迴圈範圍外使用 for-loop 中所宣告的迴圈控制變數
C4293|'*運算式*': 移位計數為負數或太大，未定義的行為
C4295|'*類型*': 陣列是太小無法包含結束的 null 字元
C4296|'*運算式*': 運算式永遠是*值*
C4297|'*類型*': 函式預設不會擲回的例外狀況，但不會
C4298|'*名稱*': 類型程式庫中的識別項'*描述*'已經是巨集; 重新命名為' __*名稱*'
C4299|'*名稱*': 類型程式庫中的識別項'*描述*'是關鍵字; 重新命名為' __*名稱*'
C4302|'*運算式*': 從截斷'*類型*'to'*類型*'
C4303|*轉換*從 '*類型*'to'*類型*' 是已被取代，使用 static_cast、 __try_cast 或是 dynamic_cast
C4314|pragma 參數必須為 '32' 或 '64'
C4315|'*類型*': 成員 'this' 指標'*類型*' 可能未對齊*數目*如預期般的建構函式
C4318|將常數零當做長度傳遞至 memset
C4319|'*運算式*': 零擴充'*類型*'to'*類型*' 更大的
C4321|自動產生介面的 IID '*類型*'
C4322|自動產生類別的 CLSID*類型*'
C4323|重複使用的已登錄 CLSID 類別*類型*'
C4324|'*類型*': 因為對齊規範而獲得填補的結構
C4325|忽略標準區段 '*描述*' 忽略
C4326|傳回型別 '*名稱*'應該是'*類型*' 而不是 '*類型*'
C4327|'*運算式*': LHS 的間接取值對齊 (*數目*) 大於 RHS (*數目*)
C4328|'*描述*': 型式參數的間接取值對齊*數目*(*數目*) 大於實質引數的對齊方式 (*數目*)
C4329|列舉時會忽略對齊規範
C4336|匯入交互參考的類型程式庫 '*文件庫*' 匯入之前'*描述*'
C4337|交互參考的類型程式庫 '*文件庫*'in'*描述*' 會自動匯入
C4338|#pragma*描述*： 標準區段 '*區段*' 使用
C4339|'*類型*': 未定義的類型使用中偵測到 CLR/WinRT 中繼資料-使用這個型別可能會導致執行階段例外狀況
C4353|使用非標準擴充： 常數 0 當做函式運算式。  請改用 '__noop' 函式內建函式
C4370|'*宣告*': 類別配置已從舊版編譯器因為更好的封裝
C4371|'*宣告*': 類別配置可能已從舊版編譯器因為的成員有更好的封裝'*成員*'
C4373|'*類型*': 虛擬函式覆寫*宣告*'，舊版的編譯器不會覆寫當參數差異只不同時 const/volatile 限定詞
C4387|'*描述*': 已被視為
C4389|'*運算式*': signed/unsigned 不相符
C4391|'*宣告*': 內建函式，必須是函式的傳回類型不正確'*類型*'
C4392|'*宣告*': 內建函式，必須是函式的引數數目不正確'*數目*' 引數
C4407|不同成員指標表示法之間的轉換，編譯器可能會產生不正確的程式碼
C4420|'*名稱*': 無法使用運算子，使用'*名稱*' 代替; 執行階段檢查可能無法執行
C4440|呼叫慣例的重複定義從 '*描述*'to'*描述*' 忽略
C4442|__annotation 引數中的內嵌 null 結束字元。  值會被截斷。
C4444|'*名稱*': 這個內容中不會實作最上層 '__unaligned'
C4526|'*類型*': 靜態成員函式不能覆寫虛擬函式'*宣告*' 覆寫被忽略，將會隱藏虛擬函式
C4531|C + + 例外狀況處理 Windows CE 上無法使用。 使用結構化例外狀況處理
C4532|'*描述*': 跳出*最後*區塊有未定義的行為在終止處理期間
C4533|初始化 '*宣告*' 會被略過 ' goto*宣告*'
C4534|'*宣告*' 將不會針對預設建構函式*類別*'*類型*' 由於預設引數
C4535|呼叫 _set_se_translator() 需要 /EHa
C4536|'*描述*': 類型名稱超出中繼資料的限制'*數目*' 字元
C4537|'*宣告*': '。' 套用至非 UDT 類型
C4542|正在略過合併插入的文字檔案產生無法寫入*類型*檔案: '*filename*':*錯誤*
C4543|插入文字隱藏的屬性 ' 沒有\_injected_text'
C4555|運算式無效; 必須是具有副作用的運算式
C4557|'__assume' 包含作用 '*效果*'
C4558|運算元的值 '*數目*'超出範圍'*數目* - *數目*'
C4561|'__fastcall' 不以 '/ /clr' 選項： 將轉換為 '__stdcall'
C4562|完全原型函式是必要項目 '/ /clr' 選項： 轉換為 '(void)' 的 ' （）'
C4564|方法 '*名稱*' 的*類別*'*類型*'定義不支援的預設參數'*參數*'
C4584|'*類型*': 基底類別'*宣告*'已經的基底類別'*宣告*'
C4608|初始化等位的多個成員: '*類型*'和'*類型*'
C4619|#pragma 警告： 沒有警告編號 '*數目*'
C4623|'*類型*': 預設建構函式已隱含定義為刪除
C4624|'*類型*': 解構函式已隱含定義為刪除
C4625|'*類型*': 複製建構函式已隱含定義為刪除
C4626|'*類型*': 指派運算子已隱含定義為刪除
C4645|使用 'noreturn' 宣告的函式具有 return 陳述式
C4646|使用 'noreturn' 宣告的函式具有非 void 傳回型別
C4659|#pragma '*描述*': 使用保留的區段'*名稱*' 有未定義的行為，使用 #pragma 註解 (linker，...)
C4667|'*宣告*': 沒有函式樣板定義符合強制具現化
C4668|'*名稱*'未定義成前置處理器巨集，以 '0' 取代'*值*'
C4669|'*運算式*': 不安全的轉換:'*類型*' 是 managed/WinRT 型別物件
C4674|'*名稱*' 必須宣告為 'static'，而且只能有一個參數
C4680|'*類型*': coclass 不指定的預設介面。
C4681|'*類型*': coclass 不指定為事件來源的預設介面
C4682|'*類型*': 沒有方向參數屬性指定，預設為 [in]
C4683|'*宣告*': 事件來源有 'out' 的參數; 當攔截多個事件處理常式時警告
C4684|'*描述*': 警告!! 屬性可能造成無效的程式碼產生： 請謹慎使用
C4685|剖析樣板參數時需要 '> >'，但卻找到 '>>'
C4700|未初始化的區域變數 '*名稱*' 使用
C4701|可能未初始化的區域變數 '*名稱*' 使用
C4702|無法連線到程式碼
C4711|函式 '*名稱*' 選取為自動內嵌展開
C4714|函式 '*宣告*' 標記為 __forceinline 無法內嵌
C4715|'*函式*': 不是所有控制路徑都傳回值
C4716|'*函式*': 必須傳回值
C4717|'*函式*': 在所有控制路徑上的遞迴，函式會導致執行階段堆疊溢位
C4718|'*函式*': 遞迴呼叫沒有任何副作用，刪除
C4719|指定 Qfast-使用 'f' 當做字尾以單精確度時，找到雙精度浮點常數
C4723|可能除以 0
C4724|MOD 的模數可能為 0
C4725|指令在一些 Pentium 上可能不正確
C4757|註標是大型 unsigned 的值，您要使用負的常數？
C4772|#import 參考型別從遺漏的類型程式庫。'*描述*' 做為預留位置
C4792|函式 '*函式*' 宣告使用 sysimport 宣告並參考從原生程式碼; 匯入程式庫需要連結
C4794|執行緒區域儲存區變數的區段 '*名稱*'已從'*區段*'to'*區段*'
C4798|p-code 函式所產生的原生程式碼 '*名稱*' 與例外狀況處理常式或回溯語意
C4799|函式 '*名稱*' 沒有 EMMS 指令
C4803|'*宣告*': 產生的方法具有不同的儲存類別，從該事件中，'*宣告*'
C4810|pragma pack （show） 的值 = =*數目*
C4811|pragma conform 的值 (forScope，show) = =*值*
C4820|'*類型*':'*數目*'位元組填補已加之後*類型*'*類型*'
C4905|寬字串常值轉換成 '*類型*'
C4906|字串常值轉換成 '*類型*'
C4912|'*屬性*': 屬性有未定義的巢狀 UDT 上的行為
C4916|為了有 dispid，'*類型*': 必須由介面引入
C4917|'*類型*': GUID 僅能與類別、 介面或命名空間相關聯
C4918|'*字元*': 在 pragma 最佳化清單中有無效的字元
C4920|列舉*名稱*成員*名稱*=*數目*已出現在 enum*名稱*為*名稱*=*數目*
C4921|'*名稱*': 屬性值'*值*' 不應多次指定
C4925|'*宣告*': 無法從指令碼呼叫 dispinterface 方法
C4926|'*宣告*': 已定義符號： 忽略屬性
C4927|不合法的轉換。已經隱含套用一個以上的使用者定義轉換
C4928|不合法的 copy-initialization; 已經隱含套用一個以上的使用者定義的轉換
C4929|'*描述*': 類型程式庫包含一個等位; 忽略 'embedded_idl' 限定詞
C4930|'*宣告*': 未呼叫原型函式 （是變數定義？）
C4931|我們假設已針對建置類型程式庫*數目*-位元指標
C4932|__identifier (*描述*) 和 __identifier (*描述*) 無法分辨
C4934|'__delegate(multicast)' 已被取代，請使用 '__delegate' 改為
C4935|從組件存取規範修改 '*描述*'
C4944|'*名稱*': 無法匯入從符號'*來源*': 為*宣告*' 已經存在於目前的範圍
C4945|'*名稱*': 無法匯入從符號'*來源*': 為*宣告*'匯入了另一個組件'*來源*'
C4946|相關類別之間使用的 reinterpret_cast: '*宣告*'和'*宣告*'
C4995|'*名稱*': 名稱被標示為已被取代的 #pragma
C4996|'*問題*':*描述*
C4997|'*類型*': coclass 未實作 COM 介面或虛擬介面
C4998|預期失敗：*描述*(*數目*)

## <a name="see-also"></a>另請參閱
[/Wv 編譯器選項](../../build/reference/compiler-option-warning-level.md)
[都預設為關閉的編譯器警告](../../preprocessor/compiler-warnings-that-are-off-by-default.md)
[警告](../../preprocessor/warning.md)
