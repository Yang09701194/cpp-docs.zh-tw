---
title: CBasePane 類別
ms.date: 11/06/2018
f1_keywords:
- CBasePane
- AFXBASEPANE/CBasePane
- AFXBASEPANE/CBasePane::AccNotifyObjectFocusEvent
- AFXBASEPANE/CBasePane::AddPane
- AFXBASEPANE/CBasePane::AdjustDockingLayout
- AFXBASEPANE/CBasePane::AdjustLayout
- AFXBASEPANE/CBasePane::CalcFixedLayout
- AFXBASEPANE/CBasePane::CanAcceptPane
- AFXBASEPANE/CBasePane::CanAutoHide
- AFXBASEPANE/CBasePane::CanBeAttached
- AFXBASEPANE/CBasePane::CanBeClosed
- AFXBASEPANE/CBasePane::CanBeDocked
- AFXBASEPANE/CBasePane::CanBeResized
- AFXBASEPANE/CBasePane::CanBeTabbedDocument
- AFXBASEPANE/CBasePane::CanFloat
- AFXBASEPANE/CBasePane::CanFocus
- AFXBASEPANE/CBasePane::CopyState
- AFXBASEPANE/CBasePane::CreateDefaultMiniframe
- AFXBASEPANE/CBasePane::CreateEx
- AFXBASEPANE/CBasePane::DockPane
- AFXBASEPANE/CBasePane::DockPaneUsingRTTI
- AFXBASEPANE/CBasePane::DockToFrameWindow
- AFXBASEPANE/CBasePane::DoesAllowDynInsertBefore
- AFXBASEPANE/CBasePane::EnableDocking
- AFXBASEPANE/CBasePane::EnableGripper
- AFXBASEPANE/CBasePane::FloatPane
- AFXBASEPANE/CBasePane::get_accHelpTopic
- AFXBASEPANE/CBasePane::get_accSelection
- AFXBASEPANE/CBasePane::GetCaptionHeight
- AFXBASEPANE/CBasePane::GetControlBarStyle
- AFXBASEPANE/CBasePane::GetCurrentAlignment
- AFXBASEPANE/CBasePane::GetDockingMode
- AFXBASEPANE/CBasePane::GetDockSiteFrameWnd
- AFXBASEPANE/CBasePane::GetEnabledAlignment
- AFXBASEPANE/CBasePane::GetMFCStyle
- AFXBASEPANE/CBasePane::GetPaneIcon
- AFXBASEPANE/CBasePane::GetPaneRow
- AFXBASEPANE/CBasePane::GetPaneStyle
- AFXBASEPANE/CBasePane::GetParentDockSite
- AFXBASEPANE/CBasePane::GetParentMiniFrame
- AFXBASEPANE/CBasePane::GetParentTabbedPane
- AFXBASEPANE/CBasePane::GetParentTabWnd
- AFXBASEPANE/CBasePane::GetRecentVisibleState
- AFXBASEPANE/CBasePane::HideInPrintPreviewMode
- AFXBASEPANE/CBasePane::InsertPane
- AFXBASEPANE/CBasePane::IsAccessibilityCompatible
- AFXBASEPANE/CBasePane::IsAutoHideMode
- AFXBASEPANE/CBasePane::IsDialogControl
- AFXBASEPANE/CBasePane::IsDocked
- AFXBASEPANE/CBasePane::IsFloating
- AFXBASEPANE/CBasePane::IsHorizontal
- AFXBASEPANE/CBasePane::IsInFloatingMultiPaneFrameWnd
- AFXBASEPANE/CBasePane::IsMDITabbed
- AFXBASEPANE/CBasePane::IsPaneVisible
- AFXBASEPANE/CBasePane::IsPointNearDockSite
- AFXBASEPANE/CBasePane::IsResizable
- AFXBASEPANE/CBasePane::IsRestoredFromRegistry
- AFXBASEPANE/CBasePane::IsTabbed
- AFXBASEPANE/CBasePane::IsVisible
- AFXBASEPANE/CBasePane::LoadState
- AFXBASEPANE/CBasePane::MoveWindow
- AFXBASEPANE/CBasePane::OnAfterChangeParent
- AFXBASEPANE/CBasePane::OnBeforeChangeParent
- AFXBASEPANE/CBasePane::OnDrawCaption
- AFXBASEPANE/CBasePane::OnMovePaneDivider
- AFXBASEPANE/CBasePane::OnPaneContextMenu
- AFXBASEPANE/CBasePane::OnRemoveFromMiniFrame
- AFXBASEPANE/CBasePane::OnSetAccData
- AFXBASEPANE/CBasePane::PaneFromPoint
- AFXBASEPANE/CBasePane::RecalcLayout
- AFXBASEPANE/CBasePane::RemovePaneFromDockManager
- AFXBASEPANE/CBasePane::SaveState
- AFXBASEPANE/CBasePane::SelectDefaultFont
- AFXBASEPANE/CBasePane::SetControlBarStyle
- AFXBASEPANE/CBasePane::SetDockingMode
- AFXBASEPANE/CBasePane::SetPaneAlignment
- AFXBASEPANE/CBasePane::SetPaneStyle
- AFXBASEPANE/CBasePane::SetWindowPos
- AFXBASEPANE/CBasePane::ShowPane
- AFXBASEPANE/CBasePane::StretchPane
- AFXBASEPANE/CBasePane::UndockPane
- AFXBASEPANE/CBasePane::DoPaint
helpviewer_keywords:
- CBasePane [MFC], AccNotifyObjectFocusEvent
- CBasePane [MFC], AddPane
- CBasePane [MFC], AdjustDockingLayout
- CBasePane [MFC], AdjustLayout
- CBasePane [MFC], CalcFixedLayout
- CBasePane [MFC], CanAcceptPane
- CBasePane [MFC], CanAutoHide
- CBasePane [MFC], CanBeAttached
- CBasePane [MFC], CanBeClosed
- CBasePane [MFC], CanBeDocked
- CBasePane [MFC], CanBeResized
- CBasePane [MFC], CanBeTabbedDocument
- CBasePane [MFC], CanFloat
- CBasePane [MFC], CanFocus
- CBasePane [MFC], CopyState
- CBasePane [MFC], CreateDefaultMiniframe
- CBasePane [MFC], CreateEx
- CBasePane [MFC], DockPane
- CBasePane [MFC], DockPaneUsingRTTI
- CBasePane [MFC], DockToFrameWindow
- CBasePane [MFC], DoesAllowDynInsertBefore
- CBasePane [MFC], EnableDocking
- CBasePane [MFC], EnableGripper
- CBasePane [MFC], FloatPane
- CBasePane [MFC], get_accHelpTopic
- CBasePane [MFC], get_accSelection
- CBasePane [MFC], GetCaptionHeight
- CBasePane [MFC], GetControlBarStyle
- CBasePane [MFC], GetCurrentAlignment
- CBasePane [MFC], GetDockingMode
- CBasePane [MFC], GetDockSiteFrameWnd
- CBasePane [MFC], GetEnabledAlignment
- CBasePane [MFC], GetMFCStyle
- CBasePane [MFC], GetPaneIcon
- CBasePane [MFC], GetPaneRow
- CBasePane [MFC], GetPaneStyle
- CBasePane [MFC], GetParentDockSite
- CBasePane [MFC], GetParentMiniFrame
- CBasePane [MFC], GetParentTabbedPane
- CBasePane [MFC], GetParentTabWnd
- CBasePane [MFC], GetRecentVisibleState
- CBasePane [MFC], HideInPrintPreviewMode
- CBasePane [MFC], InsertPane
- CBasePane [MFC], IsAccessibilityCompatible
- CBasePane [MFC], IsAutoHideMode
- CBasePane [MFC], IsDialogControl
- CBasePane [MFC], IsDocked
- CBasePane [MFC], IsFloating
- CBasePane [MFC], IsHorizontal
- CBasePane [MFC], IsInFloatingMultiPaneFrameWnd
- CBasePane [MFC], IsMDITabbed
- CBasePane [MFC], IsPaneVisible
- CBasePane [MFC], IsPointNearDockSite
- CBasePane [MFC], IsResizable
- CBasePane [MFC], IsRestoredFromRegistry
- CBasePane [MFC], IsTabbed
- CBasePane [MFC], IsVisible
- CBasePane [MFC], LoadState
- CBasePane [MFC], MoveWindow
- CBasePane [MFC], OnAfterChangeParent
- CBasePane [MFC], OnBeforeChangeParent
- CBasePane [MFC], OnDrawCaption
- CBasePane [MFC], OnMovePaneDivider
- CBasePane [MFC], OnPaneContextMenu
- CBasePane [MFC], OnRemoveFromMiniFrame
- CBasePane [MFC], OnSetAccData
- CBasePane [MFC], PaneFromPoint
- CBasePane [MFC], RecalcLayout
- CBasePane [MFC], RemovePaneFromDockManager
- CBasePane [MFC], SaveState
- CBasePane [MFC], SelectDefaultFont
- CBasePane [MFC], SetControlBarStyle
- CBasePane [MFC], SetDockingMode
- CBasePane [MFC], SetPaneAlignment
- CBasePane [MFC], SetPaneStyle
- CBasePane [MFC], SetWindowPos
- CBasePane [MFC], ShowPane
- CBasePane [MFC], StretchPane
- CBasePane [MFC], UndockPane
- CBasePane [MFC], DoPaint
ms.assetid: 8163dd51-d7c7-4def-9c74-61f8ecdfad82
ms.openlocfilehash: 1de59e4404960ed99dedaadfa576168bc31da444
ms.sourcegitcommit: b032daf81cb5fdb1f5a988277ee30201441c4945
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/15/2018
ms.locfileid: "51694786"
---
# <a name="cbasepane-class"></a>CBasePane 類別

MFC 中的所有窗格的基底類別。

## <a name="syntax"></a>語法

```
class CBasePane : public CWnd
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|`CBasePane::CBasePane`|預設建構函式。|
|`CBasePane::~CBasePane`|解構函式。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|`CBasePane::accHitTest`|由架構呼叫以擷取畫面中給定點的子項目或子物件。 (覆寫[CWnd::accHitTest](../../mfc/reference/cwnd-class.md#acchittest)。)|
|`CBasePane::accLocation`|由架構呼叫以擷取目前的畫面位置指定的物件。 (覆寫[CWnd::accLocation](../../mfc/reference/cwnd-class.md#acclocation)。)|
|[CBasePane::AccNotifyObjectFocusEvent](#accnotifyobjectfocusevent)|`CBasePane` 不使用這個方法。|
|`CBasePane::accSelect`|由架構呼叫以修改選取或移動指定物件的鍵盤焦點。 (覆寫[CWnd::accSelect](../../mfc/reference/cwnd-class.md#accselect)。)|
|[CBasePane::AddPane](#addpane)|將停駐的管理員窗格。|
|[Cbasepane:: Adjustdockinglayout](#adjustdockinglayout)|將重新導向呼叫停駐的管理員，以調整停駐的配置。|
|[Cbasepane:: Adjustlayout](#adjustlayout)|當 [] 窗格應該調整其內部的版面配置時由架構呼叫。|
|[Cbasepane:: Calcfixedlayout](#calcfixedlayout)|計算的控制列的水平大小。|
|[Cbasepane:: Canacceptpane](#canacceptpane)|判斷另一個窗格是否可以停駐窗格。|
|[CBasePane::CanAutoHide](#canautohide)|判斷窗格是否支援自動隱藏模式。|
|[CBasePane::CanBeAttached](#canbeattached)|判斷窗格是否可以停駐到另一個窗格。|
|[Cbasepane:: Canbeclosed](#canbeclosed)|判斷是否可以關閉窗格。|
|[CBasePane::CanBeDocked](#canbedocked)|判斷窗格是否可以停駐到另一個窗格。|
|[CBasePane::CanBeResized](#canberesized)|判斷是否可以調整窗格的大小。|
|[CBasePane::CanBeTabbedDocument](#canbetabbeddocument)|指定窗格是否可以轉換成 MDI 索引標籤式文件。|
|[CBasePane::CanFloat](#canfloat)|判斷是否可以浮動窗格。|
|[CBasePane::CanFocus](#canfocus)|指定是否可以取得焦點。|
|[CBasePane::CopyState](#copystate)|將複製給定窗格的狀態。|
|[CBasePane::CreateDefaultMiniframe](#createdefaultminiframe)|如果窗格可以浮動，會建立迷你框架視窗。|
|[Cbasepane:: Createex](#createex)|建立窗格控制項。|
|[Cbasepane:: Dockpane](#dockpane)|另一個窗格或框架視窗停駐窗格。|
|[CBasePane::DockPaneUsingRTTI](#dockpaneusingrtti)|使用執行階段類型資訊固定窗格。|
|[CBasePane::DockToFrameWindow](#docktoframewindow)|可停駐窗格停駐於框架。|
|[Cbasepane:: Doesallowdyninsertbefore](#doesallowdyninsertbefore)|判斷是否可以此窗格與父框架之間動態插入另一個窗格。|
|[CBasePane::EnableDocking](#enabledocking)|可停駐窗格的回主框架。|
|[CBasePane::EnableGripper](#enablegripper)|啟用或停用移駐夾。 如果已啟用的移駐夾，使用者可以將它拖曳至調整窗格的位置。|
|`CBasePane::FillWindowRect`|在內部使用。|
|[CBasePane::FloatPane](#floatpane)|浮動窗格。|
|`CBasePane::get_accChild`|由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。 (覆寫[CWnd::get_accChild](../../mfc/reference/cwnd-class.md#get_accchild)。)|
|`CBasePane::get_accChildCount`|由架構呼叫以擷取屬於這個物件的子系數目。 (覆寫[CWnd::get_accChildCount](../../mfc/reference/cwnd-class.md#get_accchildcount)。)|
|`CBasePane::get_accDefaultAction`|由架構呼叫以擷取字串，描述物件的預設動作。 (覆寫[CWnd::get_accDefaultAction](../../mfc/reference/cwnd-class.md#get_accdefaultaction)。)|
|`CBasePane::get_accDescription`|由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。 (覆寫[CWnd::get_accDescription](../../mfc/reference/cwnd-class.md#get_accdescription)。)|
|`CBasePane::get_accFocus`|由架構呼叫以擷取具有鍵盤焦點的物件。 (覆寫[CWnd::get_accFocus](../../mfc/reference/cwnd-class.md#get_accfocus)。)|
|`CBasePane::get_accHelp`|由架構呼叫以擷取物件的 Help 屬性字串。 (覆寫[CWnd::get_accHelp](../../mfc/reference/cwnd-class.md#get_acchelp)。)|
|[CBasePane::get_accHelpTopic](#get_acchelptopic)|由架構呼叫以擷取與指定的物件相關聯的 WinHelp 檔案的完整路徑和該檔案中適切主題的識別碼。 (覆寫[CWnd::get_accHelpTopic](../../mfc/reference/cwnd-class.md#get_acchelptopic)。)|
|`CBasePane::get_accKeyboardShortcut`|由架構呼叫以擷取物件指定的快速鍵。 (覆寫[CWnd::get_accKeyboardShortcut](../../mfc/reference/cwnd-class.md#get_acckeyboardshortcut)。)|
|`CBasePane::get_accName`|由架構呼叫以擷取指定物件的名稱。 (覆寫[CWnd::get_accName](../../mfc/reference/cwnd-class.md#get_accname)。)|
|`CBasePane::get_accParent`|由架構呼叫以擷取`IDispatch`介面物件的父系。 (覆寫[CWnd::get_accParent](../../mfc/reference/cwnd-class.md#get_accparent)。)|
|`CBasePane::get_accRole`|由架構呼叫以擷取含有指定物件的角色描述資訊。 (覆寫[CWnd::get_accRole](../../mfc/reference/cwnd-class.md#get_accrole)。)|
|[CBasePane::get_accSelection](#get_accselection)|由架構呼叫以擷取此物件的選取子物件。 (覆寫[CWnd::get_accSelection](../../mfc/reference/cwnd-class.md#get_accselection)。)|
|`CBasePane::get_accState`|由架構呼叫以擷取指定物件的目前狀態。 (覆寫[CWnd::get_accState](../../mfc/reference/cwnd-class.md#get_accstate)。)|
|`CBasePane::get_accValue`|由架構呼叫以擷取指定物件的值。 (覆寫[CWnd::get_accValue](../../mfc/reference/cwnd-class.md#get_accvalue)。)|
|[Cbasepane:: Getcaptionheight](#getcaptionheight)|傳回標題高度。|
|[CBasePane::GetControlBarStyle](#getcontrolbarstyle)|傳回的控制列的樣式。|
|[CBasePane::GetCurrentAlignment](#getcurrentalignment)|傳回目前的窗格對齊方式。|
|[Cbasepane:: Getdockingmode](#getdockingmode)|傳回目前停駐窗格的模式。|
|[CBasePane::GetDockSiteFrameWnd](#getdocksiteframewnd)|讓指標回到視窗，也就是 [] 窗格的停駐站台。|
|[CBasePane::GetEnabledAlignment](#getenabledalignment)|傳回套用至 「 窗格 CBRS_ALIGN_ 樣式。|
|[CBasePane::GetMFCStyle](#getmfcstyle)|傳回特定的窗格樣式至 MFC。|
|[CBasePane::GetPaneIcon](#getpaneicon)|傳回窗格圖示的控制代碼。|
|`CBasePane::GetPaneRect`|在內部使用。|
|[CBasePane::GetPaneRow](#getpanerow)|將指標傳回至[CDockingPanesRow](../../mfc/reference/cdockingpanesrow-class.md)窗格停駐的位置的物件。|
|[CBasePane::GetPaneStyle](#getpanestyle)|傳回的窗格樣式。|
|[CBasePane::GetParentDockSite](#getparentdocksite)|讓指標回到父停駐站台。|
|[CBasePane::GetParentMiniFrame](#getparentminiframe)|傳回父迷你框架視窗的指標。|
|[CBasePane::GetParentTabbedPane](#getparenttabbedpane)|傳回父系的索引標籤式窗格的指標。|
|[CBasePane::GetParentTabWnd](#getparenttabwnd)|傳回位於索引標籤中的父視窗的指標。|
|[CBasePane::GetRecentVisibleState](#getrecentvisiblestate)|當窗格從封存還原時，架構會呼叫這個方法。|
|[CBasePane::HideInPrintPreviewMode](#hideinprintpreviewmode)|指定是否在預覽列印中隱藏窗格。|
|[CBasePane::InsertPane](#insertpane)|停駐的管理員會向指定的窗格。|
|[CBasePane::IsAccessibilityCompatible](#isaccessibilitycompatible)|指定窗格是否支援 Active Accessibility。|
|[CBasePane::IsAutoHideMode](#isautohidemode)|決定是否自動隱藏模式中的窗格。|
|[CBasePane::IsDialogControl](#isdialogcontrol)|指定的對話方塊控制項是否包含的窗格。|
|[CBasePane::IsDocked](#isdocked)|決定是否要停駐窗格。|
|[CBasePane::IsFloating](#isfloating)|決定是否浮動窗格。|
|[CBasePane::IsHorizontal](#ishorizontal)|決定是否要水平固定窗格。|
|[CBasePane::IsInFloatingMultiPaneFrameWnd](#isinfloatingmultipaneframewnd)|指定是否在多窗格框架視窗中窗格。|
|[CBasePane::IsMDITabbed](#ismditabbed)|判斷是否已新增為索引標籤式文件的 MDI 子視窗窗格。|
|[CBasePane::IsPaneVisible](#ispanevisible)|指定是否要將 WS_VISIBLE 旗標設定窗格。|
|[CBasePane::IsPointNearDockSite](#ispointneardocksite)|判斷指定的點是否停駐位置附近。|
|[Cbasepane:: Isresizable](#isresizable)|判斷是否可以調整窗格的大小。|
|[CBasePane::IsRestoredFromRegistry](#isrestoredfromregistry)|決定是否從登錄還原 [] 窗格。|
|[CBasePane::IsTabbed](#istabbed)|判斷是否已插入索引標籤控制項的索引標籤式視窗窗格。|
|`CBasePane::IsTooltipTopmost`|在內部使用。|
|[CBasePane::IsVisible](#isvisible)|判斷窗格是否可見。|
|[CBasePane::LoadState](#loadstate)|從登錄載入窗格的狀態。|
|[Movewindow](#movewindow)|將窗格移。|
|[CBasePane::OnAfterChangeParent](#onafterchangeparent)|已變更窗格的父代時，由架構呼叫。|
|[CBasePane::OnBeforeChangeParent](#onbeforechangeparent)|[] 窗格中變更其父視窗之前由架構呼叫。|
|[CBasePane::OnDrawCaption](#ondrawcaption)|繪製標題時，架構會呼叫這個方法。|
|[CBasePane::OnMovePaneDivider](#onmovepanedivider)|目前未使用這個方法。|
|[CBasePane::OnPaneContextMenu](#onpanecontextmenu)|建置一個功能表，並有一份窗格時，由架構呼叫。|
|[CBasePane::OnRemoveFromMiniFrame](#onremovefromminiframe)|從其父迷你框架視窗中移除一個窗格時，由架構呼叫。|
|[Cbasepane:: Onsetaccdata](#onsetaccdata)|`CBasePane` 不使用這個方法。|
|`CBasePane::OnUpdateCmdUI`|在內部使用。|
|[CBasePane::PaneFromPoint](#panefrompoint)|傳回包含指定的點的窗格。|
|`CBasePane::PreTranslateMessage`|[CWinApp](../../mfc/reference/cwinapp-class.md) 類別用來轉譯分派至 [TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage) 和 [DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函式之前的視窗訊息。 (覆寫 [CWnd::PreTranslateMessage](../../mfc/reference/cwnd-class.md#pretranslatemessage)。)|
|[CBasePane::RecalcLayout](#recalclayout)|`CBasePane` 不使用這個方法。|
|[CBasePane::RemovePaneFromDockManager](#removepanefromdockmanager)|取消註冊窗格，並從停駐的管理員在清單中移除。|
|[CBasePane::SaveState](#savestate)|將窗格的狀態儲存至登錄。|
|[CBasePane::SelectDefaultFont](#selectdefaultfont)|選取指定的裝置內容的預設字型。|
|`CBasePane::Serialize`|從封存中讀取或寫入此物件。 (覆寫 [CObject::Serialize](../../mfc/reference/cobject-class.md#serialize)。)|
|[CBasePane::SetControlBarStyle](#setcontrolbarstyle)|將控制列的樣式設定。|
|[CBasePane::SetDockingMode](#setdockingmode)|將窗格停駐的模式設定。|
|`CBasePane::SetMDITabbed`|在內部使用。|
|[CBasePane::SetPaneAlignment](#setpanealignment)|設定 [] 窗格中的對齊方式。|
|`CBasePane::SetPaneRect`|在內部使用。|
|[CBasePane::SetPaneStyle](#setpanestyle)|設定窗格的樣式。|
|`CBasePane::SetRestoredFromRegistry`|在內部使用。|
|[CBasePane::SetWindowPos](#setwindowpos)|變更大小、 位置和疊置順序的窗格。|
|[CBasePane::ShowPane](#showpane)|顯示或隱藏窗格。|
|[Cbasepane:: Stretchpane](#stretchpane)|垂直或水平伸展窗格。|
|[CBasePane::UndockPane](#undockpane)|移除 [] 窗格從停駐位置、 預設滑桿或它目前停駐位置的迷你框架視窗。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[CBasePane::DoPaint](#dopaint)|填滿窗格的背景。|

## <a name="remarks"></a>備註

如果您想要建立支援的 MFC 中的可用的擴充停駐功能窗格類別，您必須衍生從中`CBasePane`或從[CPane 類別](../../mfc/reference/cpane-class.md)。

## <a name="customization-tips"></a>自訂秘訣

下列自訂秘訣屬於`CBasePane Class`以及任何繼承自它的類別：

- 當您建立一個窗格時，您可以套用數個新的樣式：

  - AFX_CBRS_FLOAT 讓窗格浮動。

  - AFX_CBRS_AUTOHIDE 啟用自動隱藏模式。

  - AFX_CBRS_CLOSE 啟用 [關閉 （隱藏）] 窗格。

  這些是您可以結合的位元 OR 運算的旗標。

`CBasePane` 實作下列虛擬布林方法，以反映這些旗標： [cbasepane:: Canbeclosed](#canbeclosed)， [CBasePane::CanAutoHide](#canautohide)， [CBasePane::CanFloat](#canfloat)。 您可以在 衍生的類別，以自訂其行為來覆寫這些設定。

- 您可以藉由覆寫自訂的停駐行為[cbasepane:: Canacceptpane](#canacceptpane)。 具有您窗格，以防止另一個窗格停駐，這個方法傳回 FALSE。

- 如果您想要建立靜態窗格中，不能浮動，可防止任何其他窗格停駐之前 （類似於 Outlook 功能區 OutlookDemo 範例中）、 將其建立為非浮動和覆寫[cbasepane:: Doesallowdyninsertbefore](#doesallowdyninsertbefore)傳回 FALSE。 如果窗格在建立時未 AFX_CBRS_FLOAT 樣式，則預設實作會傳回 FALSE。

- 建立具有識別碼的所有窗格，-1 以外。

- 若要判斷窗格可見性，請使用[CBasePane::IsVisible](#isvisible)。 它可正確處理的可見性狀態中的索引標籤，自動隱藏模式。

- 如果您想要建立非浮動的可調整大小窗格中，建立不含 AFX_CBRS_FLOAT 樣式和呼叫[CFrameWnd::DockControlBar](../../mfc/reference/cframewnd-class.md#dockcontrolbar)。

- 若要排除窗格從停駐的配置，或移除其停駐列中的工具列，呼叫[CBasePane::UndockPane](#undockpane)。 請勿呼叫這個方法，自動隱藏模式中的窗格，或位於索引標籤式視窗的索引標籤的窗格。

- 如果您想要的 float 或取消停駐窗格是 自動隱藏模式中，您必須呼叫[CDockablePane::SetAutoHideMode](../../mfc/reference/cdockablepane-class.md#setautohidemode)以 FALSE 做為第一個引數，然後再呼叫[CBasePane::FloatPane](#floatpane)或[CBasePane::UndockPane](#undockpane)。

## <a name="example"></a>範例

下例示範如何在 `CBasePane` 類別中使用各種方法。 此範例示範如何擷取從窗格`CFrameWndEx`類別以及如何設定固定的模式、 窗格對齊和窗格樣式。 程式碼取自[Wordpad 範例](../../visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_WordPad#2](../../mfc/reference/codesnippet/cpp/cbasepane-class_1.cpp)]

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWnd](../../mfc/reference/cwnd-class.md)

[CBasePane](../../mfc/reference/cbasepane-class.md)

## <a name="requirements"></a>需求

**標頭：** afxbasepane.h

##  <a name="accnotifyobjectfocusevent"></a>  CBasePane::AccNotifyObjectFocusEvent

`CBasePane` 不使用這個方法。

```
virtual void AccNotifyObjectFocusEvent(int);
```

### <a name="parameters"></a>參數

*int*<br/>
[in]不使用。

##  <a name="addpane"></a>  CBasePane::AddPane

將停駐的管理員窗格。

```
void AddPane(CBasePane* pBar);
```

### <a name="parameters"></a>參數

*pBar*<br/>
[in]窗格中加入指標。

### <a name="remarks"></a>備註

這是很便利的方法，將加上一個窗格停駐的管理員。 使用此方法，讓您不必撰寫程式碼，可用來分析父框架的類型。

如需詳細資訊，請參閱 < [CDockingManager Class](../../mfc/reference/cdockingmanager-class.md)並[CMDIFrameWndEx::AddPane](../../mfc/reference/cmdiframewndex-class.md#addpane)。

##  <a name="adjustdockinglayout"></a>  Cbasepane:: Adjustdockinglayout

將重新導向呼叫停駐的管理員，以調整停駐的配置。

```
virtual void AdjustDockingLayout(HDWP hdwp=NULL);
```

### <a name="parameters"></a>參數

*hdwp*<br/>
[out]此結構包含多個視窗位置控制代碼。

### <a name="remarks"></a>備註

這是很便利的方法調整停駐的配置。 使用此方法，讓您不必撰寫程式碼，可用來分析父框架的類型。

如需詳細資訊，請參閱[CDockingManager::AdjustDockingLayout](../../mfc/reference/cdockingmanager-class.md#adjustdockinglayout)

##  <a name="adjustlayout"></a>  Cbasepane:: Adjustlayout

由架構呼叫以調整窗格的內部配置。

```
virtual void AdjustLayout();
```

### <a name="remarks"></a>備註

調整其內部的版面配置窗格時，架構會呼叫這個方法。 基底實作沒有任何作用。

##  <a name="calcfixedlayout"></a>  Cbasepane:: Calcfixedlayout

計算的控制列的水平大小。

```
virtual CSize CalcFixedLayout(
    BOOL bStretch,
    BOOL bHorz);
```

### <a name="parameters"></a>參數

*bStretch*<br/>
[in]指出軸是否應該自動縮放以框架的大小。 *BStretch*列 （不適用於停駐） 的停駐列並不是 0 停駐或浮動時 （適用於停駐） 時，參數為非零值。

*bHorz*<br/>
[in]指出軸是水平或垂直方向。 *BHorz*參數為非零值，如果列是水平方向，而是 0，如果是垂直方向。

### <a name="return-value"></a>傳回值

控制列的大小，單位為像素的`CSize`物件。

### <a name="remarks"></a>備註

請參閱 < 備註 > 一節中[CControlBar::CalcFixedLayout](../../mfc/reference/ccontrolbar-class.md#calcfixedlayout)

##  <a name="canacceptpane"></a>  Cbasepane:: Canacceptpane

判斷另一個窗格是否可以停駐窗格。

```
virtual BOOL CanAcceptPane(const CBasePane* pBar) const;
```

### <a name="parameters"></a>參數

*pBar*<br/>
[in]若要停駐窗格的指標。

### <a name="return-value"></a>傳回值

如果可以接受另一個窗格;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

架構會呼叫這個方法之前所指定窗格停駐於*pBar*到目前的窗格。

使用這個方法，而[CBasePane::CanBeDocked](#canbedocked)方法，以控制您的應用程式中的其他窗格如何停駐窗格。

預設實作會傳回 FALSE。

##  <a name="canautohide"></a>  CBasePane::CanAutoHide

判斷窗格是否支援自動隱藏模式。

```
virtual BOOL CanAutoHide() const;
```

### <a name="return-value"></a>傳回值

如果此窗格支援自動隱藏模式，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

架構會呼叫此函式可判斷窗格是否支援自動隱藏模式。

在建構期間，您可以藉由傳遞 AFX_CBRS_AUTOHIDE 旗標，來設定這項功能[cbasepane:: Createex](#createex)。

預設實作會檢查 AFX_CBRS_AUTOHIDE 旗標。 若要自訂此行為在衍生類別中的，這個方法會覆寫。

##  <a name="canbeattached"></a>  CBasePane::CanBeAttached

判斷窗格是否可以停駐到另一個窗格或框架視窗。

```
virtual BOOL CanBeAttached() const;
```

### <a name="return-value"></a>傳回值

如果另一個窗格或框架視窗，可以停駐窗格中，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

預設實作會傳回 FALSE。 若要啟用或停用的功能，而不需呼叫停駐在衍生類別中置換此方法[CBasePane::EnableDocking](#enabledocking)。

##  <a name="canbeclosed"></a>  Cbasepane:: Canbeclosed

判斷是否可以關閉窗格。

```
virtual BOOL CanBeClosed() const;
```

### <a name="return-value"></a>傳回值

如果窗格可以關閉;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

架構會呼叫這個方法，以判斷是否可以關閉窗格。 方法會傳回 TRUE，如果**關閉**按鈕會新增至窗格的標題列或浮動窗格，窗格的迷你框架的標題列。

在建構期間，您可以藉由傳遞 AFX_CBRS_CLOSE 旗標，來設定這項功能[cbasepane:: Createex](#createex)。

預設實作會檢查 AFX_CBRS_CLOSE 旗標。

##  <a name="canbedocked"></a>  CBasePane::CanBeDocked

判斷窗格是否可以停駐到另一個窗格。

```
virtual BOOL CanBeDocked(CBasePane* pDockBar) const;
```

### <a name="parameters"></a>參數

*pDockBar*<br/>
[in]指標，另一個窗格。

### <a name="return-value"></a>傳回值

如果另一個窗格，可以停駐此窗格中，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

架構會呼叫這個方法之前所指定窗格停駐於*pDockBar*到目前的窗格。

使用這個方法，而[cbasepane:: Canacceptpane](#canacceptpane)方法，以控制您的應用程式中的其他窗格如何停駐窗格。

預設實作會傳回 FALSE。

##  <a name="canberesized"></a>  CBasePane::CanBeResized

判斷是否可以調整窗格的大小。

```
virtual BOOL CanBeResized() const;
```

### <a name="return-value"></a>傳回值

如果可以調整窗格的大小;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

這個方法會檢查 AFX_CBRS_RESIZE 旗標，指定預設會在`CBasePane::OnCreate`。 如果未指定此旗標，停駐的管理員旗標在內部為產業，而不是讓它停駐窗格。

##  <a name="canbetabbeddocument"></a>  CBasePane::CanBeTabbedDocument

指定窗格是否可以轉換成 MDI 索引標籤式文件。

```
virtual BOOL CanBeTabbedDocument() const;
```

### <a name="return-value"></a>傳回值

如果窗格可以轉換成索引標籤式文件，則為 TRUE。否則為 FALSE。 `CBasePane::CanBeTabbedDocument` 一律會傳回 FALSE。

### <a name="remarks"></a>備註

唯一物件的特定`CBasePane`-衍生類型，例如[CDockablePane 類別](../../mfc/reference/cdockablepane-class.md)，可以轉換成索引標籤式文件。

##  <a name="canfloat"></a>  CBasePane::CanFloat

判斷是否可以浮動窗格。

```
virtual BOOL CanFloat() const;
```

### <a name="return-value"></a>傳回值

如果可以浮動窗格;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

架構會呼叫這個方法，以判斷是否可以浮動窗格。

在建構期間，您可以藉由傳遞 AFX_CBRS_FLOAT 旗標，來設定這項功能[cbasepane:: Createex](#createex)。

> [!NOTE]
>  此架構假設非浮動窗格是靜態的而且無法變更其停駐狀態。 因此，此架構不會儲存非浮動窗格的停駐狀態。

預設實作會檢查 AFX_CBRS_FLOAT 樣式。

##  <a name="canfocus"></a>  CBasePane::CanFocus

指定是否可以取得焦點。

```
virtual BOOL CanFocus() const;
```

### <a name="return-value"></a>傳回值

如果窗格可以接收焦點，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

覆寫此方法來控制焦點在衍生類別中。 比方說，工具列無法接收焦點，因為這個方法會傳回 FALSE 工具列物件上呼叫時。

架構會嘗試以停駐或浮動窗格時，將輸入的焦點。

##  <a name="copystate"></a>  CBasePane::CopyState

將複製給定窗格的狀態。

```
virtual void CopyState(CBasePane* pOrgBar);
```

### <a name="parameters"></a>參數

*pOrgBar*<br/>
[in]指標，另一個窗格。

### <a name="remarks"></a>備註

這個方法會複製狀態從*pOrgBar*到這個窗格。

##  <a name="createdefaultminiframe"></a>  CBasePane::CreateDefaultMiniframe

如果窗格可以浮動，這個方法會為它建立迷你框架視窗。

```
virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial);
```

### <a name="parameters"></a>參數

*rectInitial*<br/>
[in]指定迷你框架視窗的起始的座標。

### <a name="return-value"></a>傳回值

新的迷你框架視窗或如果建立失敗，則為 NULL 指標。

### <a name="remarks"></a>備註

當窗格切換至浮動狀態時，架構會呼叫這個方法。 方法會建立迷你框架視窗，並附加到這個視窗的窗格。

預設實作會傳回 NULL。

##  <a name="createex"></a>  Cbasepane:: Createex

建立窗格控制項。

```
virtual BOOL CreateEx(
    DWORD dwStyleEx,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    DWORD dwControlBarStyle=0,
    CCreateContext* pContext=NULL);
```

### <a name="parameters"></a>參數

*dwStyleEx*<br/>
[in]延伸的樣式 (請參閱[CWnd::CreateEx](../../mfc/reference/cwnd-class.md#createex)如需詳細資訊)。

*lpszClassName*<br/>
[in]視窗類別名稱。

*lpszWindowName*<br/>
[in]視窗名稱。

*cheaderctrl:: Create*<br/>
[in]視窗樣式 (請參閱[CWnd::CreateEx](../../mfc/reference/cwnd-class.md#createex))。

*rect*<br/>
[in]初始的矩形。

*pParentWnd*<br/>
[in]父視窗的指標。

*nID*<br/>
[in]指定窗格識別碼。 必須是唯一的。

*dwControlBarStyle*<br/>
[in]窗格的樣式旗標。

*pContext*<br/>
[in]指標 `CcreateContext`

### <a name="return-value"></a>傳回值

如果成功，建立 [] 窗格中，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

建立類別的視窗`lpszClassName`。 如果您指定 WS_CAPTION，這個方法會清除 WS_CAPTION 樣式位元，並設定`CBasePane::m_bHasCaption`設為 TRUE，因為程式庫不支援含有標題的窗格。

您可以使用子視窗的樣式和 MFC 控制列 (CBRS_) 樣式的任意組合。

程式庫會新增數個新的樣式窗格。 下表描述新的樣式：

|樣式|描述|
|-----------|-----------------|
|AFX_CBRS_FLOAT|可以在浮動窗格。|
|AFX_CBRS_AUTOHIDE|[] 窗格支援自動隱藏模式|
|AFX_CBRS_RESIZE|可以調整窗格的大小。 **重要事項：** 未實作此樣式。|
|AFX_CBRS_CLOSE|可以關閉窗格。|
|AFX_CBRS_AUTO_ROLLUP|它會浮動時，窗格可以彙總。|
|AFX_CBRS_REGULAR_TABS|當一個窗格停駐於另一個窗格中，具有此樣式時，會建立一般的索引標籤式的視窗。 (如需詳細資訊，請參閱 < [CTabbedPane 類別](../../mfc/reference/ctabbedpane-class.md)。)|
|AFX_CBRS_OUTLOOK_TABS|當一個窗格停駐於另一個窗格中，具有此樣式時，會建立 Outlook 樣式索引標籤式的視窗。 (如需詳細資訊，請參閱 < [CMFCOutlookBar 類別](../../mfc/reference/cmfcoutlookbar-class.md)。)|

若要使用新的樣式，指定在*dwControlBarStyle*。

##  <a name="dockpane"></a>  Cbasepane:: Dockpane

另一個窗格或框架視窗停駐窗格。

```
virtual BOOL DockPane(
    CBasePane* pDockBar,
    LPCRECT lpRect,
    AFX_DOCK_METHOD dockMethod);
```

### <a name="parameters"></a>參數

*pDockBar*<br/>
[in]指標，另一個窗格。

*lpRect*<br/>
[in]指定目的地矩形。

*dockMethod*<br/>
[in]指定的停駐的方法。

### <a name="return-value"></a>傳回值

如果已順利停駐控制列，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

呼叫此函式可將窗格停駐到另一個窗格或 停駐列 ( [CDockSite 類別](../../mfc/reference/cdocksite-class.md))，由*pDockBar*，或主要畫面格如果*pDockBar*是 NULL。

*dockMethod*指定如何停駐窗格。 請參閱[CPane::DockPane](../../mfc/reference/cpane-class.md#dockpane)取得一份可能的值。

##  <a name="dockpaneusingrtti"></a>  CBasePane::DockPaneUsingRTTI

使用執行階段類型資訊固定窗格。

```
void DockPaneUsingRTTI(BOOL bUseDockSite);
```

### <a name="parameters"></a>參數

*bUseDockSite*<br/>
[in]如果為 TRUE，停駐至停駐的站台。 如果為 FALSE，停駐在父框架。

##  <a name="docktoframewindow"></a>  CBasePane::DockToFrameWindow

可停駐窗格停駐於框架。

```
virtual BOOL DockToFrameWindow(
    DWORD dwAlignment,
    LPCRECT lpRect = NULL,
    DWORD dwDockFlags = DT_DOCK_LAST,
    CBasePane* pRelativeBar = NULL,
    int nRelativeIndex = -1,
    BOOL bOuterEdge = FALSE);
```

### <a name="parameters"></a>參數

*dwAlignment*<br/>
[in]您想要停駐窗格的父框架的側邊。

*lpRect*<br/>
[in]所需的大小。

*dwDockFlags*<br/>
[in]略過。

*pRelativeBar*<br/>
[in]略過。

*nRelativeIndex*<br/>
[in]略過。

*bOuterEdge*<br/>
[in]如果為 true，則有不會和其他方所指定的可停駐窗格*dwAlignment*，窗格即停駐以外其他窗格，更接近的父框架邊緣。 如果為 FALSE，窗格即停駐更接近到工作區的中心。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

如果窗格分割線，此方法就會失敗 ( [CPaneDivider 類別](../../mfc/reference/cpanedivider-class.md)) 無法建立。 否則，它一律會傳回 TRUE。

##  <a name="doesallowdyninsertbefore"></a>  Cbasepane:: Doesallowdyninsertbefore

判斷是否可以此窗格與父框架之間動態插入另一個窗格。

```
virtual BOOL DoesAllowDynInsertBefore() const;
```

### <a name="return-value"></a>傳回值

如果使用者可以插入另一個窗格;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

架構會呼叫這個方法，以判斷使用者是否可以動態地插入之前此窗格的窗格。

例如，假設您的應用程式會建立停駐在框架 （例如 Outlook 功能區） 的左下方的窗格。 若要防止使用者在另一個窗格的停駐的第一個窗格的左邊，覆寫這個方法並傳回 FALSE。

我們建議您覆寫這個方法，並傳回 FALSE，非浮動窗格衍生自[CDockablePane 類別](../../mfc/reference/cdockablepane-class.md)。

預設實作會傳回 TRUE。

##  <a name="dopaint"></a>  CBasePane::DoPaint

填滿窗格的背景。

```
virtual void DoPaint(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
[in]裝置內容指標。

### <a name="remarks"></a>備註

預設實作會呼叫目前的視覺化管理員，以填滿背景 ( [CMFCVisualManager::OnFillBarBackground](../../mfc/reference/cmfcvisualmanager-class.md#onfillbarbackground))。

##  <a name="enabledocking"></a>  CBasePane::EnableDocking

可停駐窗格的回主框架。

```
virtual void EnableDocking(DWORD dwAlignment);
```

### <a name="parameters"></a>參數

*dwAlignment*<br/>
[in]指定要啟用的停駐對齊。

### <a name="remarks"></a>備註

呼叫這個方法，以啟用回主框架的停駐對齊方式。 您可以傳遞 CBRS_ALIGN_ 旗標的組合 (如需詳細資訊，請參閱 < [CControlBar::EnableDocking](../../mfc/reference/ccontrolbar-class.md#enabledocking))。

`EnableDocking` 設定內部的旗標`CBasePane::m_dwEnabledAlignment`和停駐窗格時，架構會檢查此旗標。

呼叫[CBasePane::GetEnabledAlignment](#getenabledalignment)來判斷一個窗格的停駐對齊方式。

##  <a name="enablegripper"></a>  CBasePane::EnableGripper

啟用或停用移駐夾。 如果已啟用的移駐夾，使用者可以將它拖曳至調整窗格的位置。

```
virtual void EnableGripper(BOOL bEnable);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
[in]若要啟用的移駐夾;，則為 TRUE如果為 false，則將它停用。

### <a name="remarks"></a>備註

架構會使用這個方法，以便移駐夾，而不是使用 WS_CAPTION 樣式。

##  <a name="floatpane"></a>  CBasePane::FloatPane

浮動窗格。

```
virtual BOOL FloatPane(
    CRect rectFloat,
    AFX_DOCK_METHOD dockMethod=DM_UNKNOWN,
    bool bShow=true);
```

### <a name="parameters"></a>參數

*rectFloat*<br/>
[in]指定 [浮動] 窗格中的出現位置的螢幕座標。

*dockMethod*<br/>
[in]指定用以浮動窗格的停駐方法。

*bShow*<br/>
[in]指定浮動窗格是否可見 (TRUE) 或隱藏 (FALSE)。

### <a name="return-value"></a>傳回值

如果已成功; 浮動窗格，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

呼叫這個方法，以將所指定螢幕位置的窗格*rectFloat*。

##  <a name="get_acchelptopic"></a>  CBasePane::get_accHelpTopic

架構會呼叫這個方法，以擷取的完整路徑**WinHelp**與指定的物件和該檔案中適切主題的識別項相關聯的檔案。

```
virtual HRESULT get_accHelpTopic(
    BSTR* pszHelpFile,
    VARIANT varChild,
    long* pidTopic);
```

### <a name="parameters"></a>參數

*pszHelpFile*<br/>
[in]位址接收的完整路徑的 BSTR **WinHelp**相關聯檔案，以指定的物件，如果有的話。

*varChild*<br/>
[in]指定是否要擷取的 [說明] 主題的物件或其中一個物件的子項目。 這個參數可以是 CHILDID_SELF （若要取得之物件的 [說明] 主題） 或 （若要取得說明主題的其中一個子物件的項目） 的子系識別碼。

*pidTopic*<br/>
[in]識別**協助**檔主題與指定的物件相關聯。

### <a name="return-value"></a>傳回值

`CBasePane` 未實作這個方法。 因此，`CBasePane::get_accHelpTopic`一律會傳回 S_FALSE。

### <a name="remarks"></a>備註

此函式是 MFC 中的 Active Accessibility 支援的一部分。 在衍生的類別，以提供您物件的說明資訊中此函式會覆寫。

##  <a name="get_accselection"></a>  CBasePane::get_accSelection

架構會呼叫這個方法來擷取這個物件選取的子系。

```
virtual HRESULT get_accSelection(VARIANT* pvarChildren);
```

### <a name="parameters"></a>參數

*pvarChildren*<br/>
[in]接收識別的選取的子物件的資訊。

### <a name="return-value"></a>傳回值

`CBasePane` 未實作這個方法。 如果*pvarChildren*是 NULL，這個方法會傳回 E_INVALIDARG。 否則，這個方法會傳回 DISP_E_MEMBERNOTFOUND。

### <a name="remarks"></a>備註

此函式是 MFC 中的 Active Accessibility 支援的一部分。 如果您有無視窗的 ActiveX 控制項以外的非視窗型使用者介面項目，請覆寫衍生類別中的此函式。

##  <a name="getcaptionheight"></a>  Cbasepane:: Getcaptionheight

傳回標題高度。

```
virtual int GetCaptionHeight() const;
```

### <a name="return-value"></a>傳回值

標題高度。

##  <a name="getcontrolbarstyle"></a>  CBasePane::GetControlBarStyle

傳回的控制列的樣式。

```
virtual DWORD GetControlBarStyle() const
```

### <a name="return-value"></a>傳回值

AFX_CBRS_ 旗標的位元 OR 組合。

### <a name="remarks"></a>備註

傳回值是以下的可能值的組合。

|樣式|描述|
|-----------|-----------------|
|AFX_CBRS_FLOAT|可讓控制列浮點數。|
|AFX_CBRS_AUTOHIDE|啟用自動隱藏模式。|
|AFX_CBRS_RESIZE|可調整大小的控制列。 當設定這個旗標時，控制列可以放在可停駐窗格。|
|AFX_CBRS_CLOSE|可讓隱藏的控制列。|

##  <a name="getcurrentalignment"></a>  CBasePane::GetCurrentAlignment

傳回目前的窗格對齊方式。

```
virtual DWORD GetCurrentAlignment() const;
```

### <a name="return-value"></a>傳回值

控制列的目前對齊方式。 下表顯示可能的值：

|值|對齊|
|-----------|---------------|
|CBRS_ALIGN_LEFT|靠左的對齊。|
|CBRS_ALIGN_RIGHT|靠右對齊。|
|CBRS_ALIGN_TOP|靠上對齊。|
|CBRS_ALIGN_BOTTOM|靠下對齊。|

##  <a name="getdockingmode"></a>  Cbasepane:: Getdockingmode

傳回目前停駐窗格的模式。

```
virtual AFX_DOCK_TYPE GetDockingMode() const;
```

### <a name="return-value"></a>傳回值

如果拖曳窗格 DT_STANDARD 代表在螢幕上拖曳矩形。 DT_IMMEDIATE 如果拖曳窗格的內容。

### <a name="remarks"></a>備註

架構會呼叫這個方法，以判斷目前停駐窗格的模式。

如果`CBasePane::m_dockMode`是未定義的 (DT_UNDEFINED)，則固定模式會取得從全域停駐模式 (`AFX_GLOBAL_DATA::m_dockModeGlobal`)。

藉由設定*m_dockMode*或覆寫`GetDockingMode`您可以控制每個窗格的停駐模式。

##  <a name="getdocksiteframewnd"></a>  CBasePane::GetDockSiteFrameWnd

將指標傳回至[CDockingPanesRow](../../mfc/reference/cdockingpanesrow-class.md)窗格停駐的位置的物件。

```
virtual CWnd* GetDockSiteFrameWnd() const;
```

### <a name="return-value"></a>傳回值

到窗格的停駐位置的指標。

### <a name="remarks"></a>備註

呼叫這個方法來擷取到窗格的停駐位置的指標。 如果窗格浮動窗格停駐於主框架中，如果主框架視窗或迷你框架視窗可以是停駐位置。

##  <a name="getenabledalignment"></a>  CBasePane::GetEnabledAlignment

傳回套用至 「 窗格 CBRS_ALIGN_ 樣式。

```
virtual DWORD GetEnabledAlignment() const;
```

### <a name="return-value"></a>傳回值

CBRS_ALIGN_ 樣式的組合。 下表顯示可能的樣式：

|旗標|已啟用的對齊方式|
|----------|-----------------------|
|CBRS_ALIGN_LEFT|左邊。|
|CBRS_ALIGN_RIGHT|權限。|
|CBRS_ALIGN_TOP|最上方。|
|CBRS_ALIGN_BOTTOM|底部。|
|CBRS_ALIGN_ANY|所有的旗標的組合。|

### <a name="remarks"></a>備註

呼叫這個方法來判斷已啟用的對齊方式的窗格。 已啟用的對齊方式表示側邊窗格停駐於主框架視窗。

使用啟用停駐對齊[CBasePane::EnableDocking](#enabledocking)。

##  <a name="getmfcstyle"></a>  CBasePane::GetMFCStyle

傳回特定 MFC 的窗格樣式。

```
virtual DWORD GetMFCStyle() const;
```

### <a name="return-value"></a>傳回值

程式庫的特定 (AFX_CBRS_) 窗格樣式的組合。

##  <a name="getpaneicon"></a>  CBasePane::GetPaneIcon

傳回窗格圖示的控制代碼。

```
virtual HICON GetPaneIcon(BOOL bBigIcon);
```

### <a name="parameters"></a>參數

*bBigIcon*<br/>
[in]指定 32 像素 32 像素圖示，如果為 TRUE;指定的 16 像素 16 像素圖示，如果為 FALSE。

### <a name="return-value"></a>傳回值

窗格圖示控制代碼。 如果不成功，會傳回 NULL。

### <a name="remarks"></a>備註

預設實作會呼叫[CWnd::GetIcon](../../mfc/reference/cwnd-class.md#geticon)。

##  <a name="getpanerow"></a>  CBasePane::GetPaneRow

將指標傳回至[CDockingPanesRow](../../mfc/reference/cdockingpanesrow-class.md)窗格停駐的位置的物件。

```
CDockingPanesRow* GetPaneRow();
```

### <a name="return-value"></a>傳回值

指標`CDockingPanesRow`停駐，則為 NULL，如果它浮動窗格時。

### <a name="remarks"></a>備註

呼叫這個方法來存取窗格停駐的位置的資料列。 例如，若要排列窗格中的特定資料列，呼叫`GetPaneRow`，然後呼叫[CDockingPanesRow::ArrangePanes](../../mfc/reference/cdockingpanesrow-class.md#arrangepanes)。

##  <a name="getpanestyle"></a>  CBasePane::GetPaneStyle

傳回的窗格樣式。

```
virtual DWORD GetPaneStyle() const;
```

### <a name="return-value"></a>傳回值

控制列的樣式 （包括 CBRS_ 樣式） 所設定的組合[CBasePane::SetPaneStyle](#setpanestyle)在建立時的方法。

##  <a name="getparentdocksite"></a>  CBasePane::GetParentDockSite

讓指標回到父停駐站台。

```
virtual CDockSite* GetParentDockSite() const;
```

### <a name="return-value"></a>傳回值

父停駐站台。

##  <a name="getparentminiframe"></a>  CBasePane::GetParentMiniFrame

傳回父迷你框架視窗的指標。

```
virtual CPaneFrameWnd* GetParentMiniFrame(BOOL bNoAssert=FALSE) const;
```

### <a name="parameters"></a>參數

*bNoAssert*<br/>
[in]如果為 TRUE，這個方法不會檢查無效的指標。 如果您的應用程式結束時，您就會呼叫這個方法，將這個參數設定為 TRUE。

### <a name="return-value"></a>傳回值

有效的指標，如果浮動窗格; 時，父迷你框架視窗否則為 NULL。

### <a name="remarks"></a>備註

呼叫此函式可擷取父迷你框架視窗的指標。 這個方法會逐一查看所有的父代，並檢查物件衍生自[CPaneFrameWnd 類別](../../mfc/reference/cpaneframewnd-class.md)。

使用`GetParentMiniFrame`來判斷是否浮動窗格。

##  <a name="getparenttabbedpane"></a>  CBasePane::GetParentTabbedPane

傳回父系的索引標籤式窗格的指標。

```
CBaseTabbedPane* GetParentTabbedPane() const;
```

### <a name="return-value"></a>傳回值

如果有的話，父索引標籤式窗格的指標否則為 NULL。

##  <a name="getparenttabwnd"></a>  CBasePane::GetParentTabWnd

傳回位於索引標籤中的父視窗的指標。

```
CMFCBaseTabCtrl* GetParentTabWnd(HWND& hWndTab) const;
```

### <a name="parameters"></a>參數

*hWndTab*<br/>
[out]如果傳回的值不是 NULL，則此參數會包含父索引標籤式視窗的控制代碼。

### <a name="return-value"></a>傳回值

父索引標籤式的視窗或 NULL 的有效指標。

### <a name="remarks"></a>備註

您可以使用此函式來擷取父索引標籤式視窗的指標。 有時候它尚不足以呼叫`GetParent`，因為窗格可能會在停駐的包裝函式 ( [CDockablePaneAdapter 類別](../../mfc/reference/cdockablepaneadapter-class.md)) 或窗格配接器內 ( [CDockablePaneAdapter 類別](../../mfc/reference/cdockablepaneadapter-class.md))。 使用`GetParentTabWnd`您將能夠擷取有效的指標，在這些情況下 （假設上層索引標籤式的視窗）。

##  <a name="getrecentvisiblestate"></a>  CBasePane::GetRecentVisibleState

當窗格從封存還原時，架構會呼叫這個方法。

```
virtual BOOL GetRecentVisibleState() const;
```

### <a name="return-value"></a>傳回值

BOOL，指定新的可見狀態。 如果為 TRUE，窗格就會是序列化，而且應該會顯示時還原時才會顯示。 如果為 FALSE，當序列化和還原時，應該隱藏時，就是會隱藏窗格。

##  <a name="hideinprintpreviewmode"></a>  CBasePane::HideInPrintPreviewMode

指定是否在預覽列印中隱藏窗格。

```
virtual BOOL HideInPrintPreviewMode() const;
```

### <a name="return-value"></a>傳回值

如果窗格不會顯示在預覽列印，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

基底窗格不會顯示在預覽列印中。 因此，此方法一律會傳回 TRUE。

##  <a name="insertpane"></a>  CBasePane::InsertPane

停駐的管理員會向指定的窗格。

```
BOOL InsertPane(
    CBasePane* pControlBar,
    CBasePane* pTarget,
    BOOL bAfter = TRUE);
```

### <a name="parameters"></a>參數

*pControlBar*<br/>
[in]指向 [插入] 窗格的指標。

*pTarget*<br/>
[in]指標，相鄰的窗格。

*bAfter*<br/>
[in]如果為 TRUE， *pControlBar*後面插入*pTarget*。 如果為 FALSE， *pControlBar*之前插入*pTarget*。

### <a name="return-value"></a>傳回值

如果方法成功，FALSE 否則，則為 TRUE。

##  <a name="isaccessibilitycompatible"></a>  CBasePane::IsAccessibilityCompatible

指定窗格是否支援 Active Accessibility。

```
virtual BOOL IsAccessibilityCompatible();
```

### <a name="return-value"></a>傳回值

如果窗格支援 Active Accessibility;，則為 TRUE。否則為 FALSE。

##  <a name="isautohidemode"></a>  CBasePane::IsAutoHideMode

決定是否自動隱藏模式中的窗格。

```
virtual BOOL IsAutoHideMode() const;
```

### <a name="return-value"></a>傳回值

如果窗格為自動隱藏模式，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

基底窗格無法自動隱藏。 這個方法一律會傳回 FALSE。

##  <a name="isdialogcontrol"></a>  CBasePane::IsDialogControl

指定的對話方塊控制項是否包含的窗格。

```
BOOL IsDialogControl() const;
```

### <a name="return-value"></a>傳回值

如果窗格為對話方塊控制項;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

架構會使用這個方法可確保所有窗格的配置一致性。

##  <a name="isdocked"></a>  CBasePane::IsDocked

決定是否要停駐窗格。

```
virtual BOOL IsDocked() const;
```

### <a name="return-value"></a>傳回值

如果窗格的父代不是迷你框架，或具有; 的另一個窗格的迷你框架中窗格浮動，則為 TRUE。否則為 FALSE。

##  <a name="isfloating"></a>  CBasePane::IsFloating

決定是否浮動窗格。

```
virtual BOOL IsFloating() const;
```

### <a name="return-value"></a>傳回值

如果浮動窗格;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

這個方法傳回的值相反[CBasePane::IsDocked](#isdocked)。

##  <a name="ishorizontal"></a>  CBasePane::IsHorizontal

決定是否要水平固定窗格。

```
virtual BOOL IsHorizontal() const;
```

### <a name="return-value"></a>傳回值

如果水平; 停駐窗格，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

預設實作會檢查 CBRS_ORIENT_HORZ 目前停駐對齊方式。

##  <a name="isinfloatingmultipaneframewnd"></a>  CBasePane::IsInFloatingMultiPaneFrameWnd

指定是否在多窗格框架視窗窗格 ( [CMultiPaneFrameWnd 類別](../../mfc/reference/cmultipaneframewnd-class.md))。

```
virtual BOOL IsInFloatingMultiPaneFrameWnd() const;
```

### <a name="return-value"></a>傳回值

如果窗格為多窗格框架視窗; 中，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

只可停駐窗格可以多窗格框架視窗中浮動。 因此，`CBasePane::IsInFloatingMultiPaneFrameWnd`一律會傳回 FALSE。

##  <a name="ismditabbed"></a>  CBasePane::IsMDITabbed

判斷是否已新增為索引標籤式文件的 MDI 子視窗窗格。

```
virtual BOOL IsMDITabbed() const;
```

### <a name="return-value"></a>傳回值

如果窗格已加入至做為索引標籤式文件的 MDI 子視窗，則為 TRUE。否則為 FALSE。

##  <a name="ispanevisible"></a>  CBasePane::IsPaneVisible

指定是否要將 WS_VISIBLE 旗標設定窗格。

```
BOOL IsPaneVisible() const;
```

### <a name="return-value"></a>傳回值

如果設定 WS_VISIBLE;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

使用[CBasePane::IsVisible](#isvisible)以判斷窗格可見性。

##  <a name="ispointneardocksite"></a>  CBasePane::IsPointNearDockSite

判斷指定的點是否停駐位置附近。

```
BOOL IsPointNearDockSite(
    CPoint point,
    DWORD& dwBarAlignment,
    BOOL& bOuterEdge) const;
```

### <a name="parameters"></a>參數

*點*<br/>
[in]指定的點。

*dwBarAlignment*<br/>
[out]指定的點是附近的邊緣。 可能的值為 CBRS_ALIGN_LEFT、 CBRS_ALIGN_RIGHT、 CBRS_ALIGN_TOP 和 CBRS_ALIGN_BOTTOM

*bOuterEdge*<br/>
[out]如果 point 為附近的停駐站台，其外部框線，則為 TRUE。FALSE 否則。

### <a name="return-value"></a>傳回值

如果 point 為附近的停駐網站;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

停駐位置附近的重點是，在停駐的管理員中設定的敏感度內時。 預設的敏感度是 15 像素為單位。

##  <a name="isresizable"></a>  Cbasepane:: Isresizable

判斷是否可以調整窗格的大小。

```
virtual BOOL IsResizable() const;
```

### <a name="return-value"></a>傳回值

如果使用者，可以調整窗格的大小，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

窗格[CDockablePane 類別](../../mfc/reference/cdockablepane-class.md)可以調整大小。

[狀態] 列 ( [CMFCStatusBar 類別](../../mfc/reference/cmfcstatusbar-class.md)) 和停駐列 ( [CDockSite 類別](../../mfc/reference/cdocksite-class.md)) 無法調整大小。

##  <a name="isrestoredfromregistry"></a>  CBasePane::IsRestoredFromRegistry

決定是否從登錄還原 [] 窗格。

```
virtual BOOL IsRestoredFromRegistry() const;
```

### <a name="return-value"></a>傳回值

如果從登錄; 還原 [] 窗格中，則為 TRUE。否則為 FALSE。

##  <a name="istabbed"></a>  CBasePane::IsTabbed

判斷是否已插入索引標籤控制項的索引標籤式視窗窗格。

```
virtual BOOL IsTabbed() const;
```

### <a name="return-value"></a>傳回值

如果在索引標籤的索引標籤式視窗中，插入控制列，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

此方法會擷取直屬父指標，並判斷是否在父系的執行階段類別[CMFCBaseTabCtrl 類別](../../mfc/reference/cmfcbasetabctrl-class.md)。

##  <a name="isvisible"></a>  CBasePane::IsVisible

判斷窗格是否可見。

```
virtual BOOL IsVisible() const;
```

### <a name="return-value"></a>傳回值

如果窗格為可見;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

使用此方法來決定可見性窗格。 請勿使用 `::IsWindowVisible`。

如果不索引標籤式窗格 (請參閱[CBasePane::IsTabbed](#istabbed))，這個方法會檢查 WS_VISIBLE 樣式。 如果索引標籤式窗格中，這個方法會檢查父索引標籤式視窗的可見性。 如果父視窗為可見的函式會檢查窗格索引標籤使用的可視性[CMFCBaseTabCtrl::IsTabVisible](../../mfc/reference/cmfcbasetabctrl-class.md#istabvisible)。

##  <a name="loadstate"></a>  CBasePane::LoadState

從登錄載入窗格的狀態。

```
virtual BOOL LoadState(
    LPCTSTR lpszProfileName=NULL,
    int nIndex=-1,
    UINT uiID=(UINT)-1);
```

### <a name="parameters"></a>參數

*lpszProfileName*<br/>
[in]設定檔名稱。

*nIndex*<br/>
[in]設定檔的索引。

*uiID*<br/>
[in]窗格中的識別碼。

### <a name="return-value"></a>傳回值

如果窗格狀態載入成功，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

架構會呼叫這個方法，以從登錄載入窗格的狀態。 載入所儲存的其他資訊在衍生類別中覆寫它[CBasePane::SaveState](#savestate)。

##  <a name="movewindow"></a>  Movewindow

將窗格移。

```
virtual HDWP MoveWindow(
    CRect& rect,
    BOOL bRepaint = TRUE,
    HDWP hdwp = NULL);
```

### <a name="parameters"></a>參數

*rect*<br/>
[in]矩形，指定新的位置和窗格的大小。

*bRepaint*<br/>
[in]如果為 TRUE，則會重新繪製的窗格。 如果為 FALSE，窗格不會重新繪製。

*hdwp*<br/>
[in]延後的視窗位置結構的控制代碼。

### <a name="return-value"></a>傳回值

延後的視窗位置結構，或 NULL 控制代碼。

### <a name="remarks"></a>備註

如果您傳遞 NULL 做*hdwp*參數，這個方法通常移動的視窗。 如果您傳遞的控制代碼，這個方法會執行以延後的視窗的移動。 您可以藉由呼叫來取得控制代碼[BeginDeferWindowPos](/windows/desktop/api/winuser/nf-winuser-begindeferwindowpos)或將儲存的先前呼叫這個方法傳回的值。

##  <a name="onafterchangeparent"></a>  CBasePane::OnAfterChangeParent

在窗格的父代變更之後，由架構呼叫。

```
virtual void OnAfterChangeParent(CWnd* pWndOldParent);
```

### <a name="parameters"></a>參數

*pWndOldParent*<br/>
[in]先前的父代指標。

### <a name="remarks"></a>備註

窗格的父代變更時，通常是因為停駐或浮動作業之後，架構會呼叫這個方法。

預設實作不做任何動作。

##  <a name="onbeforechangeparent"></a>  CBasePane::OnBeforeChangeParent

[] 窗格中變更其父視窗之前由架構呼叫。

```
virtual void OnBeforeChangeParent(
    CWnd* pWndNewParent,
    BOOL bDelay=FALSE);
```

### <a name="parameters"></a>參數

*pWndNewParent*<br/>
[in]新的父視窗的指標。

*bDelay*<br/>
[in]指定是否必須延遲版面配置調整。

### <a name="remarks"></a>備註

Framework 之前呼叫這個方法只窗格的父代變更時，通常是因為停駐、 浮動或自動隱藏作業。

預設實作不做任何動作。

##  <a name="ondrawcaption"></a>  CBasePane::OnDrawCaption

繪製標題時，架構會呼叫這個方法。

```
virtual void OnDrawCaption();
```

### <a name="remarks"></a>備註

這個方法有沒有功能`CBasePane`類別。

##  <a name="onmovepanedivider"></a>  CBasePane::OnMovePaneDivider

目前未使用這個方法。

```
virtual void OnMovePaneDivider(CPaneDivider* /* unused */);
```

### <a name="parameters"></a>參數

*未使用*<br/>
[in]不使用。

##  <a name="onpanecontextmenu"></a>  CBasePane::OnPaneContextMenu

建置一個功能表，並有一份窗格時，由架構呼叫。

```
virtual void OnPaneContextMenu(
    CWnd* pParentFrame,
    CPoint point);
```

### <a name="parameters"></a>參數

*pParentFrame*<br/>
[in]父框架指標。

*點*<br/>
[in]指定的快顯功能表的位置。

### <a name="remarks"></a>備註

`OnPaneContextMenu` 呼叫停駐的管理員會維護屬於目前的框架視窗的窗格的清單。 這個方法將窗格的名稱加入至捷徑功能表，並顯示它。 在功能表上的命令會顯示或隱藏個別的窗格。

覆寫這個方法以自訂此行為。

##  <a name="onremovefromminiframe"></a>  CBasePane::OnRemoveFromMiniFrame

從其父迷你框架視窗中移除一個窗格時，由架構呼叫。

```
virtual void OnRemoveFromMiniFrame(CPaneFrameWnd* pMiniFrame);
```

### <a name="parameters"></a>參數

*pMiniFrame*<br/>
[in]移除 [] 窗格的迷你框架視窗指標。

### <a name="remarks"></a>備註

從其父迷你框架視窗 （由於停駐，比方說） 中移除窗格時，架構會呼叫這個方法。

預設實作不做任何動作。

##  <a name="onsetaccdata"></a>  Cbasepane:: Onsetaccdata

`CBasePane` 不使用這個方法。

```
virtual BOOL OnSetAccData(long lVal);
```

### <a name="parameters"></a>參數

*lVal*<br/>
[in]不使用。

### <a name="return-value"></a>傳回值

此方法一律會傳回 TRUE。

### <a name="remarks"></a>備註

##  <a name="panefrompoint"></a>  CBasePane::PaneFromPoint

傳回包含指定的點的窗格。

```
CBasePane* PaneFromPoint(
    CPoint point,
    int nSensitivity,
    bool bExactBar = false,
    CRuntimeClass* pRTCBarType = NULL) const;
```

### <a name="parameters"></a>參數

*點*<br/>
[in]指定的點，若要檢查的螢幕座標。

*nSensitivity*<br/>
[in]搜尋區域增加此數量。 如果指定的點落在增加的區域，窗格才符合搜尋準則。

*bExactBar*<br/>
[in]TRUE 表示忽略*nSensitivity*參數; 否則為 FALSE。

*pRTCBarType*<br/>
[in]如果不是 NULL，則該方法會搜尋窗格指定的型別。

### <a name="return-value"></a>傳回值

`CBasePane`-衍生的物件，其中包含指定的點，則為 NULL，如果找不到任何窗格。

##  <a name="recalclayout"></a>  CBasePane::RecalcLayout

`CBasePane` 不使用這個方法。

```
virtual void RecalcLayout();
```

##  <a name="removepanefromdockmanager"></a>  CBasePane::RemovePaneFromDockManager

取消註冊窗格，並從停駐的管理員在清單中移除。

```
void RemovePaneFromDockManager(
    CBasePane* pBar,
    BOOL bDestroy = TRUE,
    BOOL bAdjustLayout = FALSE,
    BOOL bAutoHide = FALSE,
    CBasePane* pBarReplacement = NULL);
```

### <a name="parameters"></a>參數

*pBar*<br/>
[in]指標，要移除的窗格。

*bDestroy*<br/>
[in]如果為 TRUE，就會終結移除的窗格。

*bAdjustLayout*<br/>
[in]如果為 TRUE，請立即調整停駐的配置。

*bAutoHide*<br/>
[in]如果為 TRUE，停駐的配置與相關的自動隱藏列清單。 如果為 FALSE，停駐的配置與相關規則窗格的清單。

*pBarReplacement*<br/>
[in]指標，會取代 [移除] 窗格的窗格。

##  <a name="savestate"></a>  CBasePane::SaveState

將窗格的狀態儲存至登錄。

```
virtual BOOL SaveState(
    LPCTSTR lpszProfileName=NULL,
    int nIndex=-1,
    UINT uiID=(UINT)-1);
```

### <a name="parameters"></a>參數

*lpszProfileName*<br/>
[in]設定檔名稱。

*nIndex*<br/>
[in]設定檔的索引。

*uiID*<br/>
[in]窗格中的識別碼。

### <a name="return-value"></a>傳回值

如果已成功; 儲存狀態，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

它會將窗格的狀態儲存至登錄時，架構會呼叫這個方法。 覆寫`SaveState`儲存其他資訊在衍生類別中。

##  <a name="selectdefaultfont"></a>  CBasePane::SelectDefaultFont

選取指定的裝置內容的預設字型。

```
CFont* SelectDefaultFont(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
[in]裝置內容。

### <a name="return-value"></a>傳回值

預設值的指標[CFont 類別](../../mfc/reference/cfont-class.md)物件。

##  <a name="setcontrolbarstyle"></a>  CBasePane::SetControlBarStyle

將控制列的樣式設定。

```
virtual void SetControlBarStyle(DWORD dwNewStyle);
```

### <a name="parameters"></a>參數

*dwNewStyle*<br/>
[in]下列可能值的位元 OR 組合。

|樣式|描述|
|-----------|-----------------|
|AFX_CBRS_FLOAT|可讓控制列浮點數。|
|AFX_CBRS_AUTOHIDE|啟用自動隱藏模式。|
|AFX_CBRS_RESIZE|可調整大小的控制列。 當設定這個旗標時，控制列可以放在可停駐窗格。|
|AFX_CBRS_CLOSE|可讓隱藏的控制列。|

##  <a name="setdockingmode"></a>  CBasePane::SetDockingMode

將窗格停駐的模式設定。

```
void SetDockingMode(AFX_DOCK_TYPE dockModeNew);
```

### <a name="parameters"></a>參數

*dockModeNew*<br/>
[in]指定新的停駐模式的窗格。

### <a name="remarks"></a>備註

「 架構 」 支援兩種停駐的模式： 標準和即時運算。

在標準的停駐模式中，窗格和迷你框架視窗會移動使用拖曳矩形。 在即時運算的停駐模式中，控制列和迷你框架視窗會移立即連同其內容。

一開始，固定的模式全球的定義[CDockingManager::m_dockModeGlobal](../../mfc/reference/cdockingmanager-class.md#m_dockmodeglobal)。 您可以設定個別使用每個窗格的停駐模式`SetDockingMode`方法。

##  <a name="setpanealignment"></a>  CBasePane::SetPaneAlignment

設定 [] 窗格中的對齊方式。

```
virtual void SetPaneAlignment(DWORD dwAlignment);
```

### <a name="parameters"></a>參數

*dwAlignment*<br/>
[in]指定新的對齊方式。

### <a name="remarks"></a>備註

通常，架構會呼叫這個方法時的窗格從一方的主框架停駐於另一個。

下表顯示可能的值為*dwAlignment*:

|值|對齊|
|-----------|---------------|
|CBRS_ALIGN_LEFT|靠左的對齊。|
|CBRS_ALIGN_RIGHT|靠右對齊。|
|CBRS_ALIGN_TOP|靠上對齊。|
|CBRS_ALIGN_BOTTOM|靠下對齊。|

##  <a name="setpanestyle"></a>  CBasePane::SetPaneStyle

設定窗格的樣式。

```
virtual void SetPaneStyle(DWORD dwNewStyle);
```

### <a name="parameters"></a>參數

*dwNewStyle*<br/>
[in]指定新的樣式設定。

### <a name="remarks"></a>備註

這個方法可用來設定任一 CBRS_ 樣式在 afxres.h 中定義。 因為窗格樣式和窗格對齊方式會儲存在一起，設定新的樣式結合目前的對齊方式，如下所示。

`pPane->SetPaneStyle (pPane->GetCurrentAlignment() | CBRS_TOOLTIPS);`

##  <a name="setwindowpos"></a>  CBasePane::SetWindowPos

變更大小、 位置和疊置順序的窗格。

```
virtual HDWP SetWindowPos(
    const CWnd* pWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT nFlags,
    HDWP hdwp = NULL);
```

### <a name="parameters"></a>參數

*pWndInsertAfter*<br/>
[in]識別`CWnd`物件，前面這`CWnd`疊置順序中的物件。 如需詳細資訊，請參閱 < [CWnd::SetWindowPos](../../mfc/reference/cwnd-class.md#setwindowpos)。

*x*<br/>
[in]指定的視窗左側的位置。

*y*<br/>
[in]指定視窗頂端的位置。

*cx*<br/>
[in]指定視窗的寬度。

*cy*<br/>
[in]指定視窗的高度。

*nFlags*<br/>
[in]指定的大小和位置選項。 如需詳細資訊，請參閱 < [CWnd::SetWindowPos](../../mfc/reference/cwnd-class.md#setwindowpos)。

*hdwp*<br/>
[in]結構，其中包含一個或多個視窗的大小和位置資訊的控制代碼。

### <a name="return-value"></a>傳回值

更新後的延後的視窗位置結構或 NULL 控制代碼。

### <a name="remarks"></a>備註

如果*pWndInsertAfter*是 NULL，這個方法會呼叫[CWnd::SetWindowPos](../../mfc/reference/cwnd-class.md#setwindowpos)。 如果*pWndInsertAfter*是不是 NULL，這個方法會呼叫`DeferWindowPos`。

##  <a name="showpane"></a>  CBasePane::ShowPane

顯示或隱藏窗格。

```
virtual void ShowPane(
    BOOL bShow,
    BOOL bDelay,
    BOOL bActivate);
```

### <a name="parameters"></a>參數

*bShow*<br/>
[in]指定是否要顯示 (TRUE) 或隱藏 (FALSE) 窗格。

*bDelay*<br/>
[in]如果為 TRUE，將重新計算停駐的配置會延遲。

*bActivate*<br/>
[in]如果為 TRUE，則窗格為作用中時顯示。

### <a name="remarks"></a>備註

這個方法會顯示或隱藏窗格。 使用這個方法，而不是`ShowWindow`因為這個方法會通知相關的變更窗格的可見性的相關停駐的管理員。

使用[CBasePane::IsVisible](#isvisible)以判斷目前的可見性窗格。

##  <a name="stretchpane"></a>  Cbasepane:: Stretchpane

垂直或水平伸展窗格。

```
virtual CSize StretchPane(
    int nLength,
    BOOL bVert);
```

### <a name="parameters"></a>參數

*nLength*<br/>
[in]用來拉長窗格長度。

*bVert*<br/>
[in]如果為 TRUE，垂直伸展窗格。 如果為 FALSE，水平伸展窗格。

### <a name="return-value"></a>傳回值

[延伸] 窗格的大小。

##  <a name="undockpane"></a>  CBasePane::UndockPane

移除 [] 窗格從停駐位置、 預設滑桿或它目前停駐位置的迷你框架視窗。

```
virtual void UndockPane(BOOL bDelay=FALSE);
```

### <a name="parameters"></a>參數

*bDelay*<br/>
如果為 TRUE，是不立即計算停駐的配置。

### <a name="remarks"></a>備註

呼叫這個方法來操作窗格的狀態，或排除的停駐配置的窗格。

如果您想要繼續使用此窗格中，呼叫[cbasepane:: Dockpane](#dockpane)或是[CBasePane::FloatPane](#floatpane)之前呼叫這個方法。

## <a name="see-also"></a>另請參閱

[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[類別](../../mfc/reference/mfc-classes.md)<br/>
[CPane](../../mfc/reference/cbasepane-class.md)<br/>
[CWnd 類別](../../mfc/reference/cwnd-class.md)
