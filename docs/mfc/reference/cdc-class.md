---
title: "CDC 類別 |Microsoft 文件"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
dev_langs: C++
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
caps.latest.revision: "21"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: cplusplus
ms.openlocfilehash: 9e8424638311cd6fdbe220bfd98bb27409ee670e
ms.sourcegitcommit: 8fa8fdf0fbb4f57950f1e8f4f9b81b4d39ec7d7a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/21/2017
---
# <a name="cdc-class"></a>CDC 類別
定義裝置內容物件的類別。  
  
## <a name="syntax"></a>語法  
  
```  
class CDC : public CObject  
```  
  
## <a name="members"></a>成員  
  
### <a name="public-constructors"></a>公用建構函式  
  
|名稱|描述|  
|----------|-----------------|  
|[CDC::CDC](#cdc)|建構 `CDC` 物件。|  
  
### <a name="public-methods"></a>公用方法  
  
|名稱|描述|  
|----------|-----------------|  
|[CDC::AbortDoc](#abortdoc)|終止目前的列印工作，清除所有項目自上次呼叫的應用程式寫入至裝置`StartDoc`成員函式。|  
|[CDC::AbortPath](#abortpath)|關閉並捨棄任何裝置內容中的路徑。|  
|[CDC::AddMetaFileComment](#addmetafilecomment)|將註解緩衝區中複製到指定的格式增強型中繼檔。|  
|[CDC::AlphaBlend](#alphablend)|顯示具有透明或半透明的像素的點陣圖。|  
|[CDC::AngleArc](#anglearc)|繪製的直線線段和弧線，並將目前位置移到弧形結束點。|  
|[CDC::Arc](#arc)|繪製橢圓形弧線。|  
|[CDC::ArcTo](#arcto)|繪製橢圓形弧線。此函式是類似於`Arc`，不同之處在於會更新目前的位置。|  
|[CDC::Attach](#attach)|將 Windows 裝置內容附加至這個`CDC`物件。|  
|[Cdc:: beginpath](#beginpath)|裝置內容中開啟的路徑括號。|  
|[Cdc:: bitblt](#bitblt)|複製點陣圖，從指定的裝置內容。|  
|[CDC::Chord](#chord)|繪製套索鍵 （橢圓形和直線線段的交集所繫結到封閉的圖表）。|  
|[CDC::CloseFigure](#closefigure)|關閉開放的圖表，在路徑中。|  
|[CDC::CreateCompatibleDC](#createcompatibledc)|建立與另一個裝置內容的記憶體裝置內容。 您可以使用它來準備映像，在記憶體中。|  
|[CDC::CreateDC](#createdc)|建立特定裝置的裝置內容。|  
|[CDC::CreateIC](#createic)|建立特定裝置的資訊內容。 這會提供一個快速方式來取得裝置的相關資訊，而建立的裝置內容。|  
|[CDC::DeleteDC](#deletedc)|刪除與此相關聯的 Windows 裝置內容`CDC`物件。|  
|[CDC::DeleteTempMap](#deletetempmap)|由呼叫`CWinApp`閒置時間處理常式，以刪除任何暫存`CDC`所建立的物件`FromHandle`。 也會一併中斷裝置內容。|  
|[CDC::Detach](#detach)|卸離 Windows 裝置內容，從這個`CDC`物件。|  
|[CDC::DPtoHIMETRIC](#dptohimetric)|將轉換成裝置單位**HIMETRIC**單位。|  
|[CDC::DPtoLP](#dptolp)|將裝置單位轉換成邏輯單元。|  
|[CDC::Draw3dRect](#draw3drect)|繪製三維的矩形。|  
|[CDC::DrawDragRect](#drawdragrect)|清除並重新繪製矩形，如拖曳。|  
|[CDC::DrawEdge](#drawedge)|繪製矩形邊緣。|  
|[CDC::DrawEscape](#drawescape)|繪圖功能的視訊顯示無法直接使用透過圖形裝置介面 (GDI) 的存取。|  
|[CDC::DrawFocusRect](#drawfocusrect)|用來表示焦點樣式中繪製的矩形。|  
|[CDC::DrawFrameControl](#drawframecontrol)|繪製框架控制項。|  
|[CDC::DrawIcon](#drawicon)|繪製圖示。|  
|[CDC::DrawState](#drawstate)|顯示影像，並套用視覺效果來表示狀態。|  
|[CDC::DrawText](#drawtext)|繪製格式化文字中指定的矩形。|  
|[CDC::DrawTextEx](#drawtextex)|繪製格式化文字，使用其他格式指定的矩形中。|  
|[CDC::Ellipse](#ellipse)|繪製橢圓形。|  
|[CDC::EndDoc](#enddoc)|結束所啟動的列印工作`StartDoc`成員函式。|  
|[CDC::EndPage](#endpage)|通知頁面即將結束的裝置驅動程式。|  
|[CDC::EndPath](#endpath)|關閉路徑括號，並選取放入裝置內容的 在括號所定義的路徑。|  
|[Cdc:: enumobjects](#enumobjects)|列舉畫筆和筆刷在裝置內容中使用。|  
|[CDC::Escape](#escape)|允許應用程式存取無法直接使用來自特定裝置透過 GDI 的設備。 也可讓 Windows 逸出功能的存取權。 逸出呼叫應用程式所轉譯，並傳送至裝置驅動程式。|  
|[CDC::ExcludeClipRect](#excludecliprect)|建立新的裁剪區域所組成的現有的裁剪區域減去指定的矩形。|  
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|從裁剪區域排除在視窗中的更新的區域，以防止無效的視窗區域內的繪圖。|  
|[CDC::ExtFloodFill](#extfloodfill)|使用目前的筆刷，填滿區域。 提供更大的彈性比[CDC::FloodFill](#floodfill)成員函式。|  
|[CDC::ExtTextOut](#exttextout)|寫入使用目前選取的字型的矩形區域中的字元字串。|  
|[CDC::FillPath](#fillpath)|關閉目前路徑中的任何開放圖形，並使用目前的筆刷和多邊形填滿模式，填滿路徑的內部。|  
|[CDC::FillRect](#fillrect)|使用特定的筆刷填滿指定的矩形。|  
|[CDC::FillRgn](#fillrgn)|使用指定的筆刷，填滿的特定區域。|  
|[CDC::FillSolidRect](#fillsolidrect)|使用純色，填滿的矩形。|  
|[CDC::FlattenPath](#flattenpath)|轉換到目前的裝置內容中，選取的路徑中任何曲線，並將每個曲線轉換成一連串的行。|  
|[CDC::FloodFill](#floodfill)|使用目前的筆刷，填滿區域。|  
|[CDC::FrameRect](#framerect)|繪製矩形周圍的框線。|  
|[CDC::FrameRgn](#framergn)|使用筆刷的特定區域周圍繪製框線。|  
|[CDC::FromHandle](#fromhandle)|將指標傳回至`CDC`物件時指定的裝置內容控制代碼。 如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。|  
|[CDC::GetArcDirection](#getarcdirection)|傳回目前弧形方向之裝置內容。|  
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|擷取目前的長寬比篩選條件的設定。|  
|[CDC::GetBkColor](#getbkcolor)|擷取目前的背景色彩。|  
|[CDC::GetBkMode](#getbkmode)|擷取背景模式。|  
|[CDC::GetBoundsRect](#getboundsrect)|傳回指定之裝置內容的目前累積週框矩形。|  
|[CDC::GetBrushOrg](#getbrushorg)|擷取目前的筆刷的原點。|  
|[CDC::GetCharABCWidths](#getcharabcwidths)|擷取的寬度，以邏輯單位，指定的範圍從目前的字型中的連續字元。|  
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|擷取的寬度，以邏輯單位，從目前的 TrueType 字型在指定範圍中的連續圖像索引。|  
|[CDC::GetCharacterPlacement](#getcharacterplacement)|擷取各種類型的字元字串的詳細資訊。|  
|[CDC::GetCharWidth](#getcharwidth)|擷取目前的字型顯示小數給定範圍中的連續字元的寬度。|  
|[CDC::GetCharWidthI](#getcharwidthi)|擷取的寬度，以邏輯座標，從目前的字型的指定範圍內的連續圖像索引。|  
|[CDC::GetClipBox](#getclipbox)|擷取目前裁剪邊界周圍 tightest 週框矩形的維度。|  
|[CDC::GetColorAdjustment](#getcoloradjustment)|擷取裝置內容的色彩調整值。|  
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|讓指標回到目前所選`CBitmap`物件。|  
|[CDC::GetCurrentBrush](#getcurrentbrush)|讓指標回到目前所選`CBrush`物件。|  
|[CDC::GetCurrentFont](#getcurrentfont)|讓指標回到目前所選`CFont`物件。|  
|[CDC::GetCurrentPalette](#getcurrentpalette)|讓指標回到目前所選`CPalette`物件。|  
|[CDC::GetCurrentPen](#getcurrentpen)|讓指標回到目前所選`CPen`物件。|  
|[CDC::GetCurrentPosition](#getcurrentposition)|擷取目前的畫筆位置 （以邏輯座標表示）。|  
|[CDC::GetDCBrushColor](#getdcbrushcolor)|擷取目前的筆刷色彩。|  
|[CDC::GetDCPenColor](#getdcpencolor)|擷取目前的畫筆顏色。|  
|[Rastercaps](#getdevicecaps)|擷取指定的特定的顯示裝置的功能相關的裝置特定資訊種類。|  
|[CDC::GetFontData](#getfontdata)|擷取可調式字型檔案中的字型度量資訊。 指定位移至字型檔案，以及要傳回的資訊來識別要擷取之資訊。|  
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|傳回指定的顯示內容的目前選取字型的相關資訊。|  
|[CDC::GetGlyphOutline](#getglyphoutline)|擷取大綱曲線或點陣圖的外框字元，在目前的字型。|  
|[CDC::GetGraphicsMode](#getgraphicsmode)|擷取指定之裝置內容的目前圖形模式。|  
|[CDC::GetHalftoneBrush](#gethalftonebrush)|筆刷半色調。|  
|[CDC::GetKerningPairs](#getkerningpairs)|擷取的字元間距組指定的裝置內容中目前選取的字型。|  
|[CDC::GetLayout](#getlayout)|擷取裝置內容 (DC) 的配置。 配置可以是保留到右 （預設值） 或由右至左 （鏡像）。|  
|[CDC::GetMapMode](#getmapmode)|擷取目前的對應模式。|  
|[CDC::GetMiterLimit](#getmiterlimit)|傳回裝置內容的斜接角限制。|  
|[CDC::GetNearestColor](#getnearestcolor)|擷取最接近的邏輯色彩至指定的邏輯色彩時，可以表示給定的裝置。|  
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|擷取 TrueType 字型的字型度量資訊。|  
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|使用輸出的裝置內容的目前字型會擷取在連續的字元群組中的個別字元的寬度。|  
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|計算字元字串的輸出裝置內容的高度與寬度。|  
|[CDC::GetOutputTextExtent](#getoutputtextextent)|計算使用來決定維度的目前字型的輸出裝置內容上的文字行高度與寬度。|  
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|擷取輸出裝置內容中的目前字型度量資訊。|  
|[CDC::GetPath](#getpath)|擷取定義的線條端點和的曲線選入裝置內容的路徑中找到的控點的座標。|  
|[CDC::GetPixel](#getpixel)|擷取位於指定點的像素的 RGB 色彩值。|  
|[CDC::GetPolyFillMode](#getpolyfillmode)|擷取目前的多邊形填滿模式。|  
|[CDC::GetROP2](#getrop2)|擷取目前的繪圖模式。|  
|[CDC::GetSafeHdc](#getsafehdc)|傳回[CDC::m_hDC](#m_hdc)，輸出裝置內容。|  
|[CDC::GetStretchBltMode](#getstretchbltmode)|擷取目前的點陣圖自動縮放模式。|  
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|計算的寬度和高度屬性裝置內容上的字元字串。|  
|[CDC::GetTextAlign](#gettextalign)|擷取的文字對齊方式的旗標。|  
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|擷取 intercharacter 距離的目前設定。|  
|[CDC::GetTextColor](#gettextcolor)|擷取目前的文字色彩。|  
|[CDC::GetTextExtent](#gettextextent)|計算來決定維度使用目前的字型屬性裝置內容上的文字行高度與寬度。|  
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|擷取指定的空間可容納和陣列填入每個字元的文字範圍的指定字串中的字元數目。|  
|[CDC::GetTextExtentPointI](#gettextextentpointi)|擷取指定之圖像索引陣列的高度與寬度。|  
|[CDC::GetTextFace](#gettextface)|將目前的字型的字體名稱複製到緩衝區中，以 null 結束的字串。|  
|[CDC::GetTextMetrics](#gettextmetrics)|擷取屬性的裝置內容中的目前字型度量資訊。|  
|[CDC::GetViewportExt](#getviewportext)|擷取，x-與 y-範圍的檢視區。|  
|[CDC::GetViewportOrg](#getviewportorg)|擷取捲動檢視區原點 x 和 y 座標。|  
|[CDC::GetWindow](#getwindow)|傳回顯示裝置內容相關聯的視窗。|  
|[CDC::GetWindowExt](#getwindowext)|擷取，x-與 y-範圍的相關聯的視窗。|  
|[CDC::GetWindowOrg](#getwindoworg)|擷取相關聯的視窗原點 x 和 y 座標。|  
|[CDC::GetWorldTransform](#getworldtransform)|擷取目前分頁空間轉換到全球的空間。|  
|[CDC::GradientFill](#gradientfill)|矩形和三角形結構填入 gradating 色彩。|  
|[Cdc:: graystring](#graystring)|繪製呈暗灰色 （灰色） 在指定位置的文字。|  
|[CDC::HIMETRICtoDP](#himetrictodp)|將轉換**HIMETRIC**成裝置單位的單位。|  
|[CDC::HIMETRICtoLP](#himetrictolp)|將轉換**HIMETRIC**成邏輯單元的單位。|  
|[CDC::IntersectClipRect](#intersectcliprect)|建立新的裁剪區域所形成的目前地區和矩形的交集。|  
|[CDC::InvertRect](#invertrect)|反轉矩形的內容。|  
|[CDC::InvertRgn](#invertrgn)|反轉一個區域中的色彩。|  
|[CDC::IsPrinting](#isprinting)|決定是否正在使用的裝置內容進行列印。|  
|[CDC::LineTo](#lineto)|從目前的位置，但不是包括、 點繪製的線條。|  
|[CDC::LPtoDP](#lptodp)|將邏輯單元轉換成裝置單位。|  
|[CDC::LPtoHIMETRIC](#lptohimetric)|將轉換成邏輯單元**HIMETRIC**單位。|  
|[CDC::MaskBlt](#maskblt)|結合使用給定的遮罩和點陣作業的來源和目的地點陣圖的色彩資料。|  
|[CDC::ModifyWorldTransform](#modifyworldtransform)|變更裝置內容中使用指定的模式的自然轉換。|  
|[CDC::MoveTo](#moveto)|移動目前的位置。|  
|[CDC::OffsetClipRgn](#offsetcliprgn)|移動指定的裝置之裁剪區域。|  
|[CDC::OffsetViewportOrg](#offsetviewportorg)|修改檢視區原點，相對於目前的檢視區原點的座標。|  
|[CDC::OffsetWindowOrg](#offsetwindoworg)|修改視窗原點，相對於目前視窗原點的座標。|  
|[CDC::PaintRgn](#paintrgn)|選取的筆刷填滿區域。|  
|[CDC::PatBlt](#patblt)|建立一個位元模式。|  
|[CDC::Pie](#pie)|繪製派形的楔形。|  
|[CDC::PlayMetaFile](#playmetafile)|指定的裝置上播放內容的指定中繼檔。 增強型的版本`PlayMetaFile`顯示儲存在給定的格式增強型中繼檔中的圖片。 中繼檔就可以播放次數。|  
|[CDC::PlgBlt](#plgblt)|在來源裝置內容中指定的矩形的色彩資料位元的位元區塊傳輸，執行至指定的裝置內容中指定的平行四邊形中。|  
|[CDC::PolyBezier](#polybezier)|繪製一或多個 Bzier 曲線。 尚未使用或更新目前的位置。|  
|[CDC::PolyBezierTo](#polybezierto)|繪製一或多個 Bzier 曲線，並將目前位置移至最後一個 Bzier 曲線的結束點。|  
|[CDC::PolyDraw](#polydraw)|繪製一組直線線段和 Bzier 曲線。 此函式會更新目前的位置。|  
|[CDC::Polygon](#polygon)|繪製多邊形，其包含兩個或多個點 （端點） 透過線路連線。|  
|[CDC::Polyline](#polyline)|繪製一組連接的指定的點之直線線段。|  
|[CDC::PolylineTo](#polylineto)|繪製一或多個直線和目前的位置移至之結束點的最後一行。|  
|[CDC::PolyPolygon](#polypolygon)|建立兩個或多個使用目前的多邊形填滿模式會填滿的多邊形。 多邊形可能不相鄰，或可能會重疊。|  
|[CDC::PolyPolyline](#polypolyline)|繪製連接的直線線段的多個數列。 目前的位置是使用都更新此函式。|  
|[CDC::PtVisible](#ptvisible)|指定內的裁剪區域是否為指定的點。|  
|[CDC::RealizePalette](#realizepalette)|將目前的邏輯調色盤中的調色盤項目對應至系統調色盤。|  
|[CDC::Rectangle](#rectangle)|使用目前的畫筆繪製矩形，並填滿它使用目前的筆刷。|  
|[CDC::RectVisible](#rectvisible)|判斷指定的任何的矩形部分是否之內的裁剪區域。|  
|[CDC::ReleaseAttribDC](#releaseattribdc)|版本`m_hAttribDC`，屬性的裝置內容。|  
|[CDC::ReleaseOutputDC](#releaseoutputdc)|版本`m_hDC`，輸出裝置內容。|  
|[CDC::ResetDC](#resetdc)|更新`m_hAttribDC`裝置內容。|  
|[CDC::RestoreDC](#restoredc)|裝置內容還原至先前的狀態，以儲存`SaveDC`。|  
|[CDC::RoundRect](#roundrect)|繪製具有圓角使用目前的畫筆並使用目前的筆刷填滿的矩形。|  
|[CDC::SaveDC](#savedc)|儲存裝置內容的目前狀態。|  
|[CDC::ScaleViewportExt](#scaleviewportext)|修改檢視區範圍相對於目前的值。|  
|[CDC::ScaleWindowExt](#scalewindowext)|修改視窗範圍相對於目前的值。|  
|[CDC::ScrollDC](#scrolldc)|水平和垂直捲動的位元的矩形。|  
|[CDC::SelectClipPath](#selectclippath)|選取目前的路徑做為裝置內容中，使用指定的模式結合具有任何現有的裁剪區域的新區域的裁剪區域。|  
|[CDC::SelectClipRgn](#selectcliprgn)|使用指定的模式會結合為目前裁剪區域與給定的區域。|  
|[Cdc:: selectobject](#selectobject)|選取 GDI 繪製的物件，例如畫筆。|  
|[CDC::SelectPalette](#selectpalette)|選取邏輯色板。|  
|[CDC::SelectStockObject](#selectstockobject)|選取其中一個預先定義的內建畫筆、 筆刷或由 Windows 提供的字型。|  
|[Cdc:: setabortproc](#setabortproc)|設定 Windows 會呼叫如果必須中止列印工作的程式設計人員提供的回呼函式。|  
|[CDC::SetArcDirection](#setarcdirection)|設定要用於弧線和矩形函式的繪圖方向。|  
|[CDC::SetAttribDC](#setattribdc)|設定`m_hAttribDC`，屬性的裝置內容。|  
|[CDC::SetBkColor](#setbkcolor)|設定目前的背景色彩。|  
|[CDC::SetBkMode](#setbkmode)|設定背景模式。|  
|[CDC::SetBoundsRect](#setboundsrect)|控制累積的週框矩形指定之裝置內容的資訊。|  
|[CDC::SetBrushOrg](#setbrushorg)|指定下一步選取放入裝置內容的筆刷的原點。|  
|[CDC::SetColorAdjustment](#setcoloradjustment)|設定彩色調整值之裝置內容，使用指定的值。|  
|[CDC::SetDCBrushColor](#setdcbrushcolor)|設定目前的筆刷色彩。|  
|[CDC::SetDCPenColor](#setdcpencolor)|設定目前的畫筆顏色。|  
|[CDC::SetGraphicsMode](#setgraphicsmode)|設定指定之裝置內容的目前圖形模式。|  
|[CDC::SetLayout](#setlayout)|裝置內容 (DC) 的配置變更。|  
|[CDC::SetMapMode](#setmapmode)|將目前的對應模式設定。|  
|[CDC::SetMapperFlags](#setmapperflags)|更改時則會對應至實體字型的邏輯字型的字型對應程式所使用的演算法。|  
|[CDC::SetMiterLimit](#setmiterlimit)|設定斜接角聯結之裝置內容的長度限制。|  
|[CDC::SetOutputDC](#setoutputdc)|設定`m_hDC`，輸出裝置內容。|  
|[CDC::SetPixel](#setpixel)|在指定的色彩最接近的指定點中設定像素。|  
|[CDC::SetPixelV](#setpixelv)|以指定的色彩最接近的指定座標上設定像素。 `SetPixelV`速度比`SetPixel`因為不需要傳回實際繪製點的色彩值。|  
|[CDC::SetPolyFillMode](#setpolyfillmode)|將多邊形填滿模式設定。|  
|[CDC::SetROP2](#setrop2)|設定目前的繪圖模式。|  
|[CDC::SetStretchBltMode](#setstretchbltmode)|設定點陣圖縮放模式。|  
|[CDC::SetTextAlign](#settextalign)|設定文字對齊方式的旗標。|  
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|設定 intercharacter 的間距數量。|  
|[CDC::SetTextColor](#settextcolor)|設定文字色彩。|  
|[CDC::SetTextJustification](#settextjustification)|分行符號字元，在字串中加上空格。|  
|[CDC::SetViewportExt](#setviewportext)|設定 x-與 y-範圍的檢視區。|  
|[CDC::SetViewportOrg](#setviewportorg)|設定檢視區原點。|  
|[CDC::SetWindowExt](#setwindowext)|設定 x-和 y-範圍相關聯的視窗。|  
|[CDC::SetWindowOrg](#setwindoworg)|設定裝置內容的視窗原點。|  
|[CDC::SetWorldTransform](#setworldtransform)|設定目前的世界空間分頁空間轉換。|  
|[CDC::StartDoc](#startdoc)|正在啟動新的列印工作的裝置驅動程式就會通知。|  
|[CDC::StartPage](#startpage)|通知裝置驅動程式正在啟動新的頁面。|  
|[CDC::StretchBlt](#stretchblt)|將點陣圖從來源矩形和裝置移到目的地矩形，延伸或壓縮點陣圖，必要時以符合目的地矩形的維度。|  
|[CDC::StrokeAndFillPath](#strokeandfillpath)|關閉任何開啟的圖形路徑中，使用目前的畫筆，萬一外框的路徑並填滿其內部使用目前的筆刷。|  
|[CDC::StrokePath](#strokepath)|使用目前的畫筆來呈現指定的路徑。|  
|[CDC::TabbedTextOut](#tabbedtextout)|將指定的位置，並展開索引標籤的定位停駐點位置陣列中指定的值在字元字串。|  
|[CDC::TextOut](#textout)|將使用目前選取的字型的指定位置的字元字串。|  
|[CDC::TransparentBlt](#transparentblt)|從指定的來源裝置內容的色彩資料位元區塊傳輸到目的地裝置內容中，呈現透明在傳送指定的色彩中。|  
|[CDC::UpdateColors](#updatecolors)|更新裝置內容比對目前的工作區中工作區，以像素 x 像素為基礎的系統調色盤的色彩。|  
|[CDC::WidenPath](#widenpath)|如果路徑圖案使用目前選取的裝置內容到畫筆會繪製的區域來重新定義的目前路徑。|  
  
### <a name="public-operators"></a>公用運算子  
  
|名稱|描述|  
|----------|-----------------|  
|[CDC::operator HDC](#operator_hdc)|擷取裝置內容的控制代碼。|  
  
### <a name="public-data-members"></a>公用資料成員  
  
|名稱|描述|  
|----------|-----------------|  
|[CDC::m_hAttribDC](#m_hattribdc)|所使用的屬性裝置內容`CDC`物件。|  
|[CDC::m_hDC](#m_hdc)|所使用的輸出裝置內容`CDC`物件。|  
  
## <a name="remarks"></a>備註  
 `CDC`物件提供成員函式 視窗的工作區相關聯的顯示內容所使用的裝置內容，例如顯示或印表機，以及成員使用。  
  
 執行所有的繪圖，透過成員函式的`CDC`物件。 類別提供成員函式的裝置內容的作業，使用繪圖工具，安全類型的圖形裝置介面 (GDI) 物件選取項目，和使用的色彩與調色盤。 它也提供用於取得及設定的繪圖屬性對應，檢視區，使用視窗範圍、 轉換座標、 使用區域、 裁剪、 繪圖線條和繪圖的簡單圖形，省略符號所使用的成員函式和多邊形。 成員函式也會提供繪製文字，使用字型、 使用印表機逸出字元、 向下捲動，以及播放中繼檔。  
  
 若要使用`CDC`物件，來建構它，然後呼叫其成員函式的平行使用裝置內容的 Windows 函式。  
  
> [!NOTE]
>  在 Windows 95/98，所有的螢幕座標皆會限制為 16 位元。 因此，`int`傳遞至`CDC`成員函式必須介於-32768 到 32767 之間。  
  
 針對特定用途，Microsoft Foundation 類別庫提供數個類別衍生自`CDC`。 `CPaintDC`封裝呼叫`BeginPaint`和`EndPaint`。 `CClientDC`管理視窗的工作區相關聯的顯示內容。 `CWindowDC`管理整個視窗，包括其框架與控制項相關聯的顯示內容。 `CMetaFileDC`關聯中繼檔裝置內容。  
  
 `CDC`提供兩個成員函式， [GetLayout](#getlayout)和[SetLayout](#setlayout)，為反轉的裝置內容，不會繼承其配置從視窗版面配置。 這類由右至左的方向是必要的文化特性，例如阿拉伯文或希伯來文字元配置並不在歐洲的標準所撰寫的應用程式。  
  
 `CDC`包含兩種裝置內容， [m_hDC](#m_hdc)和[m_hAttribDC](#m_hattribdc)，它會在建立`CDC`物件，參考到相同的裝置。 `CDC`將所有輸出 GDI 呼叫都導向`m_hDC`和大部分屬性 GDI 呼叫`m_hAttribDC`。 (屬性呼叫的範例是`GetTextColor`，雖然`SetTextColor`是輸出呼叫。)  
  
 比方說，架構會使用以下兩種裝置內容實作`CMetaFileDC`會將輸出傳送到中繼檔讀取從實體裝置的屬性時的物件。 預覽列印中的 framework 中類似的方式實作。 您也可以使用兩個裝置內容類似的方式，在特定應用程式程式碼中。  
  
 有時候當您需要同時從文字度量資訊`m_hDC`和`m_hAttribDC`裝置內容。 下列函式的括號提供這項功能：  
  
|使用 m_hAttribDC|使用 m_hDC|  
|-----------------------|-----------------|  
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|  
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|  
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|  
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|  
  
 如需有關`CDC`，請參閱[裝置內容](../../mfc/device-contexts.md)。  
  
## <a name="inheritance-hierarchy"></a>繼承階層  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDC`  
  
## <a name="requirements"></a>需求  
 **標題:** afxwin.h  
  
##  <a name="abortdoc"></a>CDC::AbortDoc  
 結束目前的列印工作，並清除所有項目自上次呼叫應用程式寫入至裝置[Cdc](#startdoc)成員函式。  
  
```  
int AbortDoc();
```  
  
### <a name="return-value"></a>傳回值  
 當發生的錯誤為負值或大於或等於 0，如果成功的值。 下列清單顯示常見的錯誤值和其意義：  
  
- **SP_ERROR**一般錯誤。  
  
- **SP_OUTOFDISK**足夠的磁碟空間是目前可供多工緩衝處理，且沒有更多的空間會變成可用。  
  
- **SP_OUTOFMEMORY**沒有足夠的記憶體可用於多工緩衝處理。  
  
- **SP_USERABORT**使用者終止列印管理員工作。  
  
### <a name="remarks"></a>備註  
 此成員函式取代`ABORTDOC`印表機逸出。  
  
 **AbortDoc**應該用來終止下列：  
  
-   未指定中止函式使用的列印作業[SetAbortProc](#setabortproc)。  
  
-   列印作業尚未到達其第一個**NEWFRAME**或**NEXTBAND**逸出呼叫。  
  
 如果應用程式發生列印錯誤或已取消的列印作業時，它必須不會嘗試使用終止作業[EndDoc](#enddoc)或**AbortDoc** 類別成員函式`CDC`. GDI 自動終止之前傳回錯誤值的作業。  
  
 如果應用程式顯示對話方塊，讓使用者取消列印作業，則必須呼叫**AbortDoc**之前終結對話方塊。  
  
 如果列印管理員用來開始列印工作，則呼叫**AbortDoc**清除整個多工緩衝處理作業，印表機會收到 nothing。 如果列印管理員不用來開始列印工作，資料可能已傳送至印表機之前**AbortDoc**呼叫。 在此情況下，印表機驅動程式會重設印表機 （自動），和已關閉的列印工作。  
  
### <a name="example"></a>範例  
  請參閱範例的[CDC::StartDoc](#startdoc)。  
  
##  <a name="abortpath"></a>CDC::AbortPath  
 關閉並捨棄任何裝置內容中的路徑。  
  
```  
BOOL AbortPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 如果在裝置內容中沒有開啟路徑括號，路徑括號會關閉，而路徑會被捨棄。 如果在裝置內容中沒有已關閉的路徑，路徑會被捨棄。  
  
##  <a name="addmetafilecomment"></a>CDC::AddMetaFileComment  
 將註解緩衝區中複製到指定的格式增強型中繼檔。  
  
```  
BOOL AddMetaFileComment(
    UINT nDataSize,  
    const BYTE* pCommentData);
```  
  
### <a name="parameters"></a>參數  
 *nDataSize*  
 指定的註解緩衝區長度，以位元組為單位。  
  
 *pCommentData*  
 指向包含註解的緩衝區。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 註解可能包含任何私人資訊 — 例如，圖片和日期的來源建立。 註解開頭應該是應用程式簽章，後面接著資料。 註解不應包含位置特定資料。 位置特定資料指定位置的記錄，以及它應該不會包含因為一個中繼檔可能會內嵌在另一個中繼檔。 此函式只可以搭配增強型中繼檔。  
  
##  <a name="alphablend"></a>CDC::AlphaBlend  
 呼叫此成員函式，以顯示具有透明或半透明的像素的點陣圖。  
  
```  
BOOL AlphaBlend(
    int xDest,  
    int yDest,  
    int nDestWidth,  
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    BLENDFUNCTION blend);
```  
  
### <a name="parameters"></a>參數  
 `xDest`  
 指定邏輯的單位，目的地矩形左上角的 x 軸座標。  
  
 `yDest`  
 指定邏輯的單位，目的地矩形左上角的 y 軸座標。  
  
 `nDestWidth`  
 指定邏輯單元，目的矩形的寬度。  
  
 `nDestHeight`  
 指定邏輯單元，目的矩形的高度。  
  
 `pSrcDC`  
 來源裝置內容的指標。  
  
 `xSrc`  
 指定邏輯單元，來源矩形左上角的 x 軸座標。  
  
 `ySrc`  
 指定邏輯單元，來源矩形左上角的 y 座標。  
  
 `nSrcWidth`  
 指定邏輯單元，來源矩形的寬度。  
  
 `nSrcHeight`  
 指定邏輯單元，來源矩形的高度。  
  
 *blend*  
 指定[BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393)結構。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果成功，否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 請參閱[AlphaBlend](http://msdn.microsoft.com/library/windows/desktop/dd183351)如需詳細資訊的 Windows SDK 中。  
  
##  <a name="anglearc"></a>CDC::AngleArc  
 繪製的直線線段與圓弧。  
  
```  
BOOL AngleArc(
    int x,  
    int y,  
    int nRadius,  
    float fStartAngle,  
    float fSweepAngle);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定邏輯的圓形中心的 x 座標。  
  
 *y*  
 指定邏輯的圓形中心的 y 座標。  
  
 *nRadius*  
 指定圓形的半徑，以邏輯單位表示。 此值必須是正數。  
  
 *fStartAngle*  
 指定的開始角度，以度為單位的相對 x 軸。  
  
 *fSweepAngle*  
 指定的掃掠角度，以度為單位的相對的開始角度。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 弧線的開頭會從目前的位置繪製直線線段。繪製弧形沿著指定的 radius 與管理中心圓形的周邊。 由給定的開始和掃掠角度定義的弧形的長度。  
  
 `AngleArc`將目前位置移到弧形結束點。這個函式所繪製弧線似乎橢圓形，根據目前的轉換和對應模式而定。 繪製弧形之前, 此函式會繪製直線線段，從目前位置弧線的開頭。藉由建構繞著指定的中心點的指定半徑虛數圓形繪製弧形。 以逆時針方向從圓形的 x 軸測量的開始角度的度數數目取決於弧線的起點。 結束點同樣位於的測量以逆時針方向從起點的掃掠角度度數。  
  
 如果掃掠角度為 360 度大於弧線是清理多次。 此函式會使用目前的畫筆繪製線條。 此圖不會填滿。  
  
##  <a name="arc"></a>CDC::Arc  
 繪製橢圓形弧線。  
  
```  
BOOL Arc(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Arc(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示），這個周框左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示），這個周框左上角的 y 座標。  
  
 `x2`  
 指定 （以邏輯單位表示），這個周框的右下角的 x 座標。  
  
 `y2`  
 指定 （以邏輯單位表示），這個周框的右下角的 y 座標。  
  
 *x3*  
 指定定義弧形的點的 x 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `y3`  
 指定定義弧形的點的 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `x4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 x 座標。 此時沒有完全位於弧線。  
  
 `y4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 y 座標。 此時沒有完全位於弧線。  
  
 `lpRect`  
 指定的周框 （以邏輯單位表示）。 您可以傳遞`LPRECT`或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `ptStart`  
 指定定義弧形的點 x 和 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
 `ptEnd`  
 指定定義的弧形結束點 （以邏輯單位表示） 的點 x 和 y 座標。 此時沒有完全位於弧線。您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 使用此函式來繪製弧線是所指定的周框定義橢圓形的一個區段。  
  
 弧線的實際的起點是取自 < 透過指定的起點，這個周框 center 光線與交集橢圓形的點。 弧線的實際結束點是取自 < 透過指定的結束點，這個周框 center 光線與交集橢圓形的點。 以逆時針方向繪製弧形。 弧線不是封閉的圖表，因為它未填入。 寬度和矩形的高度必須大於 2 的單位和小於 32,767 個單位。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  
  
##  <a name="arcto"></a>CDC::ArcTo  
 繪製橢圓形弧線。  
  
```  
BOOL ArcTo(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL ArcTo(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示），這個周框左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示），這個周框左上角的 y 座標。  
  
 `x2`  
 指定 （以邏輯單位表示），這個周框的右下角的 x 座標。  
  
 `y2`  
 指定 （以邏輯單位表示），這個周框的右下角的 y 座標。  
  
 *x3*  
 指定定義弧形的點的 x 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `y3`  
 指定定義弧形的點的 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `x4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 x 座標。 此時沒有完全位於弧線。  
  
 `y4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 y 座標。 此時沒有完全位於弧線。  
  
 `lpRect`  
 指定的周框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](../../mfc/reference/rect-structure1.md)資料結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `ptStart`  
 指定定義弧形的點 x 和 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。您可以傳遞[點](../../mfc/reference/point-structure1.md)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
 `ptEnd`  
 指定定義的弧形結束點 （以邏輯單位表示） 的點 x 和 y 座標。 此時沒有完全位於弧線。您可以傳遞**點**資料結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式是類似於`CDC::Arc`，不同之處在於會更新目前的位置。 點 ( `x1`， `y1`) 和 ( `x2`， `y2`) 指定的周框。 所指定的周框的橢圓形定義曲線的弧線。弧線以逆時針方向延伸 （預設弧形方向） 從它交集星形行至週框的中心點 ( *x3*， `y3`)。 它與相交，這個周框到中央的星形行弧形結束 ( `x4`， `y4`)。 如果的起點和終點是相同的則會完整橢圓形繪製。  
  
 線條會繪製弧線的起點從目前的位置。如果沒有發生錯誤，目前的位置會設定為弧線的終點。使用目前的畫筆; 繪製弧形未填入。  
  
##  <a name="attach"></a>CDC::Attach  
 使用此成員函式來附加`hDC`至`CDC`物件。  
  
```  
BOOL Attach(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 Windows 裝置內容。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 `hDC`會儲存在同時`m_hDC`，輸出裝置內容中，然後在`m_hAttribDC`，屬性的裝置內容。  
  
##  <a name="beginpath"></a>Cdc:: beginpath  
 裝置內容中開啟的路徑括號。  
  
```  
BOOL BeginPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 開啟路徑括號後，應用程式可以開始呼叫 GDI 繪製函式定義之間的點的路徑中。 應用程式可以藉由呼叫關閉開啟的路徑括號`EndPath`成員函式。 當應用程式呼叫`BeginPath`，會捨棄任何先前的路徑。  
  
 請參閱[BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363) Windows SDK 的路徑中定義點繪圖函式的清單中。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  
  
##  <a name="bitblt"></a>Cdc:: bitblt  
 將點陣圖從來源裝置內容複製到這個目前的裝置內容。  
  
```  
BOOL BitBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定目的地矩形的左上角的邏輯 x 座標。  
  
 *y*  
 指定目的地矩形的左上角的邏輯 y 座標。  
  
 `nWidth`  
 指定目的地矩形和來源點陣圖的寬度 （以邏輯單位表示）。  
  
 `nHeight`  
 指定目的地矩形和來源點陣圖的高度 （以邏輯單位表示）。  
  
 `pSrcDC`  
 指標`CDC`識別點陣圖會複製來源裝置內容的物件。 它必須是**NULL**如果*dwRop*指定不包含來源點陣作業。  
  
 `xSrc`  
 指定邏輯來源點陣圖的左上角的 x 座標。  
  
 `ySrc`  
 指定的來源點陣圖的左上角的邏輯 y 座標。  
  
 *dwRop*  
 指定待執行的點陣作業。 點陣作業程式碼定義 GDI 結合在輸出作業牽涉到目前的筆刷、 可能的來源點陣圖和目的地點陣圖中色彩的方式。 請參閱[BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370)的點陣作業程式碼清單的 Windows SDK 中*dwRop*及其描述  
  
 如需完整的點陣作業程式碼清單，請參閱[點陣作業程式碼有關](http://msdn.microsoft.com/library/windows/desktop/dd162892)Windows SDK 中。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 應用程式可以在 windows 或工作區，確保位元組界限上的對齊`BitBlt`位元組對齊矩形上發生的作業。 (設定**CS_BYTEALIGNWINDOW**或**CS_BYTEALIGNCLIENT**旗標，當您註冊視窗類別。)  
  
 `BitBlt`位元組對齊矩形上的作業會比 new-object 快得`BitBlt`上繪製的矩形，不是位元組對齊的作業。 如果您想要指定類別樣式，例如您自己的裝置內容的位元組對齊，您必須註冊視窗類別而不需依賴 Microsoft Foundation classes，為您執行。 使用全域函式[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。  
  
 GDI 轉換`nWidth`和`nHeight`、 一次使用目的地裝置內容，以及一次使用 來源裝置內容。 如果不相符結果的範圍，GDI 就會使用 Windows`StretchBlt`来壓縮還是要延伸的來源點陣圖，視函式。  
  
 如果目的地、 來源和模式點陣圖沒有相同的色彩格式`BitBlt`函式轉換來源和模式點陣圖以符合目的地。 轉換中使用的前景和背景色彩的目的地點陣圖。  
  
 當`BitBlt`函式會將單色點陣圖轉換成色彩、 將白色位元 (1) 的背景色彩與黑色的位元 (0) 的前景色彩。 可用的目的地裝置內容的前景和背景色彩。 若要將色彩轉換為單色，`BitBlt`將符合背景色彩為白色像素，並將其他所有像素設為黑色。 `BitBlt`若要將色彩轉換為單色，會使用彩色裝置內容的前景和背景色彩。  
  
 請注意，並非所有的裝置內容支援`BitBlt`。 若要檢查是否支援給定的裝置內容`BitBlt`，使用`GetDeviceCaps`成員函式，並指定**cdc:: GETDEVICECAPS**索引。  
  
### <a name="example"></a>範例  
  請參閱範例的[CDC::CreateCompatibleDC](#createcompatibledc)。  
  
##  <a name="cdc"></a>CDC::CDC  
 建構 `CDC` 物件。  
  
```  
CDC();
```  
  
##  <a name="chord"></a>CDC::Chord  
 繪製套索鍵 （橢圓形和直線線段的交集所繫結到封閉的圖表）。  
  
```  
BOOL Chord(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Chord(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定弦左上角 x 座標之週框 （以邏輯單位表示）。  
  
 `y1`  
 指定弦左上角 y 座標之週框 （以邏輯單位表示）。  
  
 `x2`  
 指定弦右下角的 x 座標之週框 （以邏輯單位表示）。  
  
 `y2`  
 指定弦右下角的 y 座標之週框 （以邏輯單位表示）。  
  
 *x3*  
 指定定義弦點的 x 座標的起點 （以邏輯單位表示）。  
  
 `y3`  
 指定定義弦點的 y 座標的起點 （以邏輯單位表示）。  
  
 `x4`  
 指定定義套索鍵端點 （以邏輯單位表示） 的點的 x 座標。  
  
 `y4`  
 指定定義套索鍵端點 （以邏輯單位表示） 的點的 y 座標。  
  
 `lpRect`  
 指定的周框 （以邏輯單位表示）。 您可以傳遞`LPRECT`或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `ptStart`  
 指定定義弦點 x 和 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弦。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
 `ptEnd`  
 指定定義套索鍵的結束點 （以邏輯單位表示） 的點 x 和 y 座標。 此時沒有完全位於弦。 您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 ( `x1`， `y1`) 和 ( `x2`， `y2`) 參數的左上角和右下角，分別指定週框是個套索鍵一部分的橢圓形的矩形。 ( *X3*， `y3`) 和 ( `x4`， `y4`) 參數指定的行之交集橢圓形的端點。 弦會使用所選的畫筆來繪製，並使用選取的筆刷填滿。  
  
 所繪製的圖`Chord`函式最多至延伸，但不包含右側和底部的座標。 這表示圖的高度是`y2`  -  `y1`圖的寬度，且`x2`  -  `x1`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  
  
##  <a name="closefigure"></a>CDC::CloseFigure  
 關閉開放的圖表，在路徑中。  
  
```  
BOOL CloseFigure();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 函式會關閉此圖中繪製一條線從目前位置的第一個圖中點 (通常會將最新的呼叫所指定的點`MoveTo`成員函式) 並連接所使用的線條聯結樣式的行。 如果關閉圖形時使用`LineTo`成員函式，而不是`CloseFigure`，端點會用來建立而不是聯結的角。 `CloseFigure`只能呼叫如果在裝置內容中開啟路徑括號。  
  
 在路徑中的圖形會開啟，除非它已明確關閉使用此函式。 （即使目前點和圖的起點是相同的圖可以是開啟）。任何線條或曲線加入路徑後`CloseFigure`開始新的圖形。  
  
##  <a name="createcompatibledc"></a>CDC::CreateCompatibleDC  
 建立記憶體裝置內容與所指定的裝置相容`pDC`。  
  
```  
BOOL CreateCompatibleDC(CDC* pDC);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 裝置內容的指標。 如果`pDC`是**NULL**，函式會建立與系統顯示記憶體裝置內容。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 記憶體裝置內容是記憶體的表示顯示介面區塊。 它可以用來準備記憶體中的映像，然後再將它們複製到相容的裝置的實際裝置介面。  
  
 建立記憶體裝置內容時，GDI 會自動為它選取 1-1 的單色股票點陣圖。 GDI 輸出函式可以搭配記憶體裝置內容，只有當已建立並選取放入該內容的點陣圖。  
  
 此函式只可以用於建立支援點陣作業的裝置相容的裝置內容。 請參閱[cdc:: bitblt](#bitblt)成員函式，如需有關裝置內容之間的位元區塊傳輸。 若要判斷裝置內容是否支援點陣作業，請參閱**RC_BITBLT**點陣成員函式中的功能`CDC::GetDeviceCaps`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  
  
##  <a name="createdc"></a>CDC::CreateDC  
 建立指定之裝置的裝置內容。  
  
```  
BOOL CreateDC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>參數  
 `lpszDriverName`  
 指向以 null 終止的字串，指定裝置驅動程式 (例如，"EPSON") 的檔名 （不含副檔名）。 您也可以傳遞`CString`這個參數的物件。  
  
 `lpszDeviceName`  
 指向以 null 終止的字串，指定必須支援特定裝置 （例如，"EPSON FX-80"） 的名稱。 `lpszDeviceName`如果模組支援多個裝置，會使用參數。 您也可以傳遞`CString`這個參數的物件。  
  
 `lpszOutput`  
 指向以 null 終止的字串，指定實體輸出媒介 （檔或輸出連接埠） 的檔案或裝置名稱。 您也可以傳遞`CString`這個參數的物件。  
  
 `lpInitData`  
 指向`DEVMODE`包含裝置驅動程式的特定裝置的初始化資料結構。 Windows **DocumentProperties**函式會擷取指定裝置自動填入這個結構。 `lpInitData`參數必須是**NULL**裝置驅動程式是否使用使用者已透過控制台所指定的預設初始化 （如果有的話）。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 列印。如果 H 標頭檔，則需要[DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565)使用結構。  
  
 裝置名稱遵循下列慣例： 結束的冒號 （:），建議使用，但並非必要。 Windows 會去除終止的冒號，裝置名稱結尾冒號會對應至連接埠與不含冒號相同的名稱相同。 驅動程式和連接埠的名稱不能包含開頭或尾端空格。 GDI 輸出函式不能與內容資訊。  
  
##  <a name="createic"></a>CDC::CreateIC  
 建立指定之裝置的資訊內容。  
  
```  
BOOL CreateIC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>參數  
 `lpszDriverName`  
 指向以 null 終止的字串，指定裝置驅動程式 (例如，"EPSON") 的檔名 （不含副檔名）。 您可以傳遞`CString`這個參數的物件。  
  
 `lpszDeviceName`  
 指向以 null 終止的字串，指定必須支援特定裝置 （例如，"EPSON FX-80"） 的名稱。 `lpszDeviceName`如果模組支援多個裝置，會使用參數。 您可以傳遞`CString`這個參數的物件。  
  
 `lpszOutput`  
 指向以 null 終止的字串，指定實體輸出媒介 （檔案或連接埠） 的檔案或裝置名稱。 您可以傳遞`CString`這個參數的物件。  
  
 `lpInitData`  
 裝置驅動程式的特定裝置的初始化資料點。 `lpInitData`參數必須是**NULL**裝置驅動程式是否使用使用者已透過控制台所指定的預設初始化 （如果有的話）。 請參閱`CreateDC`裝置專屬的初始化資料格式。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 資訊內容提供可快速取得裝置的相關資訊，而建立的裝置內容。  
  
 裝置名稱遵循下列慣例： 結束的冒號 （:），建議使用，但並非必要。 Windows 會去除終止的冒號，裝置名稱結尾冒號會對應至連接埠與不含冒號相同的名稱相同。 驅動程式和連接埠的名稱不能包含開頭或尾端空格。 GDI 輸出函式不能與內容資訊。  
  
##  <a name="deletedc"></a>CDC::DeleteDC  
 一般情況下，請勿呼叫此函式。解構函式會替您完成。  
  
```  
BOOL DeleteDC();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則為非零否則便是 0。  
  
### <a name="remarks"></a>備註  
 `DeleteDC`成員函式會刪除相關聯的 Windows 裝置內容`m_hDC`在目前`CDC`物件。 如果這個`CDC`物件是最後一個作用中的裝置內容指定的裝置、 裝置就會通知並釋放所有裝置使用的儲存體與系統資源。  
  
 應用程式不應該呼叫`DeleteDC`若已選取的物件放入裝置內容。 於刪除之前物件必須先選取完裝置內容。  
  
 應用程式就不能刪除裝置內容控制代碼的取得方式呼叫[cwnd:: Getdc](../../mfc/reference/cwnd-class.md#getdc)。 相反地，它必須呼叫[cwnd:: Releasedc](../../mfc/reference/cwnd-class.md#releasedc)釋放裝置內容。 [CClientDC](../../mfc/reference/cclientdc-class.md)和[CWindowDC](../../mfc/reference/cwindowdc-class.md)類別，可將這項功能。  
  
 `DeleteDC`函式通常用來刪除裝置內容，以建立[CreateDC](#createdc)， [CreateIC](#createic)，或[CreateCompatibleDC](#createcompatibledc)。  
  
### <a name="example"></a>範例  
  請參閱範例的[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。  
  
##  <a name="deletetempmap"></a>CDC::DeleteTempMap  
 自動呼叫`CWinApp`閒置時間處理常式，`DeleteTempMap`刪除任何暫存`CDC`所建立的物件`FromHandle`，但不會終結裝置內容控制代碼 ( `hDC`s) 相關聯暫時`CDC`物件。  
  
```  
static void PASCAL DeleteTempMap();
```  
  
##  <a name="detach"></a>CDC::Detach  
 呼叫此函式可卸離`m_hDC`（輸出裝置內容） 從`CDC`物件，並請同時設定`m_hDC`和`m_hAttribDC`至**NULL**。  
  
```  
HDC Detach();
```  
  
### <a name="return-value"></a>傳回值  
 Windows 裝置內容。  
  
##  <a name="dptohimetric"></a>CDC::DPtoHIMETRIC  
 使用此函式，當您授與**HIMETRIC**至 OLE，轉換至的像素為單位的大小**HIMETRIC**。  
  
```  
void DPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 裝置內容物件的對應模式是否`MM_LOENGLISH`， `MM_HIENGLISH`， `MM_LOMETRIC`，或`MM_HIMETRIC`，則轉換會根據實體英吋的像素數目。 如果對應模式是一種其他非限制模式 (例如`MM_TEXT`)，然後轉換為基礎的邏輯英吋的像素數目。  
  
##  <a name="dptolp"></a>CDC::DPtoLP  
 將裝置單位轉換成邏輯單元。  
  
```  
void DPtoLP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
 `nCount`  
 陣列中的點數目。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 這個參數會用於簡單的情況下，將一個矩形從裝置點轉換為邏輯點。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 函式會在每個點的座標或維度的大小，從裝置座標系統到 GDI 的邏輯座標系統的對應。 轉換取決於目前的對應模式和來源的範圍，以及裝置的視窗和檢視區的設定。  
  
##  <a name="draw3drect"></a>CDC::Draw3dRect  
 呼叫此成員函式，來繪製三維的矩形。  
  
```  
void Draw3dRect(
    LPCRECT lpRect,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);

 
void Draw3dRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指定的周框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 *clrTopLeft*  
 指定三維矩形上方和左方側邊的色彩。  
  
 `clrBottomRight`  
 指定底部的色彩和三維矩形左右兩側。  
  
 *x*  
 指定邏輯三維矩形左上角的 x 座標。  
  
 *y*  
 指定邏輯三維矩形左上角的 y 座標。  
  
 /cx  
 指定三維矩形的寬度。  
  
 cy  
 指定三維矩形的高度。  
  
### <a name="remarks"></a>備註  
 搭配線上方和左側中所指定的色彩繪製矩形*clrTopLeft*下方和右側中所指定的色彩`clrBottomRight`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  
  
##  <a name="drawdragrect"></a>CDC::DrawDragRect  
 呼叫此成員函式重複重繪拖曳矩形。  
  
```  
void DrawDragRect(
    LPCRECT lpRect,  
    SIZE size,  
    LPCRECT lpRectLast,  
    SIZE sizeLast,  
    CBrush* pBrush = NULL,  
    CBrush* pBrushLast = NULL);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定矩形的邏輯座標 — 在此情況下，重新繪製的矩形的結束位置。  
  
 `size`  
 會指定從左上角的外框左上角的矩形內部的框線 （也就是框線的粗細）。  
  
 `lpRectLast`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定矩形的位置的邏輯座標 — 在此情況下，重新繪製的矩形的原始位置。  
  
 *sizeLast*  
 會指定從左上角的外框左上角的原始重新繪製的矩形內部的框線 （也就是框線的粗細）。  
  
 `pBrush`  
 筆刷物件指標。 設定為**NULL**使用預設半色調筆刷。  
  
 *pBrushLast*  
 使用的最後一筆刷物件指標。 設定為**NULL**使用預設半色調筆刷。  
  
### <a name="remarks"></a>備註  
 以呼叫它在迴圈中您才能將提供的視覺化回饋取樣滑鼠位置。 當您呼叫`DrawDragRect`，先前的矩形會被清除，而且新繪製。 例如，以使用者的身分在畫面上中, 拖曳矩形`DrawDragRect`會清除原始矩形，然後重繪其新位置中的新建一個。 根據預設，`DrawDragRect`消除閃爍，並建立順暢移動矩形的外觀，使用半色調筆刷繪製的矩形。  
  
 第一次呼叫`DrawDragRect`、`lpRectLast`參數應該是**NULL**。  
  
##  <a name="drawedge"></a>CDC::DrawEdge  
 呼叫此成員函式，來繪製指定的型別和樣式的矩形邊緣。  
  
```  
BOOL DrawEdge(
    LPRECT lpRect,  
    UINT nEdge,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指標**RECT**結構，其中包含矩形的邏輯座標。  
  
 *nEdge*  
 指定要繪製的內部和外部邊緣類型。 這個參數必須是一個內部框線旗標和一個外框旗標的組合。 請參閱[DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477) Windows SDK 的參數類型的資料表中。  
  
 `nFlags`  
 指定要繪製的框線類型的旗標。 請參閱`DrawEdge`Windows SDK 中針對該參數的值的資料表。 如斜**BF_RECT**旗標指定的結束點的矩形參數所限定的向量。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
##  <a name="drawescape"></a>CDC::DrawEscape  
 繪圖功能的視訊顯示無法直接使用透過圖形裝置介面 (GDI) 的存取。  
  
```  
int DrawEscape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData);
```  
  
### <a name="parameters"></a>參數  
 `nEscape`  
 指定要執行的逸出函數。  
  
 `nInputSize`  
 指定的資料所指向的位元組數目`lpszInputData`參數。  
  
 `lpszInputData`  
 指定的逸出所需的輸入結構的點。  
  
### <a name="return-value"></a>傳回值  
 指定函式的結果。 小於或等於零，如果成功，除了**QUERYESCSUPPORT**繪製逸出的檢查執行; 或如果未實作逸出; 或小於零的錯誤如果發生。  
  
### <a name="remarks"></a>備註  
 當應用程式呼叫`DrawEscape`，所識別的資料`nInputSize`和`lpszInputData`直接傳遞至指定的顯示驅動程式。  
  
##  <a name="drawfocusrect"></a>CDC::DrawFocusRect  
 用來表示矩形具有焦點的樣式繪製的矩形。  
  
```  
void DrawFocusRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定要繪製矩形的邏輯座標。  
  
### <a name="remarks"></a>備註  
 由於這是布林值 XOR 函式，呼叫這個函式的第二次相同的矩形在顯示中移除矩形。 無法捲動此函式所繪製的矩形。 若要捲動包含此函式所繪製的矩形區域，請先呼叫`DrawFocusRect`從顯示中移除矩形，然後捲動區域，然後呼叫`DrawFocusRect`即可在新的位置繪製矩形。  
  
> [!CAUTION]
> `DrawFocusRect`只適用於`MM_TEXT`模式。 在其他模式中，此函式不能正確地繪製焦點矩形，但它不會傳回錯誤值。  
  
##  <a name="drawframecontrol"></a>CDC::DrawFrameControl  
 呼叫此成員函式可繪製框架控制項的指定型別和樣式。  
  
```  
BOOL DrawFrameControl(
    LPRECT lpRect,  
    UINT nType,  
    UINT nState);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指標**RECT**結構，其中包含矩形的邏輯座標。  
  
 `nType`  
 指定要繪製的畫面格控制項類型。 請參閱*uType*中的參數[DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480) Windows SDK 中針對此參數的可能值的清單。  
  
 `nState`  
 指定框架控制的初始的狀態。 可以是下列一或多個值所述，對*uState*中的參數`DrawFrameControl`Windows SDK 中。 使用`nState`值**DFCS_ADJUSTRECT**調整排除按鈕的周圍邊緣的周框。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 在數個情況下，`nState`取決於`nType`參數。 下列清單顯示四個之間的關聯性`nType`值和`nState`:  
  
- **DFC_BUTTON**  
  
    - **DFCS_BUTTON3STATE**三態按鈕  
  
    - **DFCS_BUTTONCHECK**核取方塊  
  
    - **DFCS_BUTTONPUSH**按鈕  
  
    - **DFCS_BUTTONRADIO**選項按鈕  
  
    - **DFCS_BUTTONRADIOIMAGE**選項按鈕的影像 （非方形需要映像）  
  
    - **DFCS_BUTTONRADIOMASK**選項按鈕的遮罩 （非方形必須遮罩）  
  
- **DFC_CAPTION**  
  
    - **DFCS_CAPTIONCLOSE** [關閉] 按鈕  
  
    - **DFCS_CAPTIONHELP**說明 按鈕  
  
    - **DFCS_CAPTIONMAX**最大化 按鈕  
  
    - **DFCS_CAPTIONMIN**最小化按鈕  
  
    - **DFCS_CAPTIONRESTORE**還原按鈕  
  
- **DFC_MENU**  
  
    - **DFCS_MENUARROW**子功能表箭號  
  
    - **DFCS_MENUBULLET**項目符號  
  
    - **DFCS_MENUCHECK**核取記號  
  
- **DFC_SCROLL**  
  
    - **DFCS_SCROLLCOMBOBOX**下拉式方塊捲軸  
  
    - **DFCS_SCROLLDOWN**向下捲軸的箭號  
  
    - **DFCS_SCROLLLEFT**捲軸向左箭號  
  
    - **DFCS_SCROLLRIGHT**捲軸上的向右箭號  
  
    - **DFCS_SCROLLSIZEGRIP**視窗的右下角調整大小底框  
  
    - **DFCS_SCROLLUP**向上捲軸的箭號  
  
### <a name="example"></a>範例  
 此程式碼繪製大小移駐夾視窗的右下角。 適用於`OnPaint`的對話方塊，其中有沒有樣式，且通常不包含其他控制項 （例如 [狀態] 列中），可能會讓它大小移駐夾的處理常式。  
  
 [!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  
  
##  <a name="drawicon"></a>CDC::DrawIcon  
 代表目前的裝置上繪製圖示`CDC`物件。  
  
```  
BOOL DrawIcon(
    int x,  
    int y,  
    HICON hIcon);

 
BOOL DrawIcon(
    POINT point,  
    HICON hIcon);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定邏輯圖示的左上角的 x 座標。  
  
 *y*  
 指定邏輯圖示的左上角的 y 座標。  
  
 `hIcon`  
 識別要繪製圖示的控制代碼。  
  
 `point`  
 指定邏輯 x 和 y 座標的左上角的圖示。 您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則為非零否則便是 0。  
  
### <a name="remarks"></a>備註  
 此函式會在所指定的位置放置圖示的左上角*x*和*y*。 位置受限於目前的裝置內容的對應模式。  
  
 圖示資源必須先前已載入使用的函式`CWinApp::LoadIcon`， `CWinApp::LoadStandardIcon`，或`CWinApp::LoadOEMIcon`。 `MM_TEXT`必須使用此函式之前選取的對應模式。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic)。  
  
##  <a name="drawstate"></a>CDC::DrawState  
 呼叫此成員函式，來顯示影像，並套用視覺效果來指示狀態，例如已停用或預設狀態。  
  
> [!NOTE]
>  所有`nFlag`狀態除了**DSS_NORMAL**，視覺效果套用之前，將會轉換為單色的映像。  
  
```  
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HBITMAP hBitmap,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    CBitmap* pBitmap,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    CBrush* pBrush = NULL);
```  
  
### <a name="parameters"></a>參數  
 `pt`  
 指定映像的位置。  
  
 `size`  
 指定影像的大小。  
  
 `hBitmap`  
 點陣圖的控制代碼。  
  
 `nFlags`  
 指定的映像類型和狀態的旗標。 請參閱[DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496) Windows SDK 中針對可能`nFlags`型別和狀態。  
  
 `hBrush`  
 筆刷控制代碼。  
  
 `pBitmap`  
 CBitmap 物件的指標。  
  
 `pBrush`  
 CBrush 物件的指標。  
  
 `hIcon`  
 圖示的控制代碼。  
  
 `lpszText`  
 文字指標。  
  
 *bPrefixText*  
 可能包含快速鍵的助憶鍵的文字。 `lData`參數會指定字串的位址和`nTextLen`參數指定的長度。 如果`nTextLen`是 0，則會假設字串是以 null 結束。  
  
 `nTextLen`  
 所指向的文字字串的長度`lpszText`。 如果`nTextLen`是 0，則會假設字串是以 null 結束。  
  
 *lpDrawProc*  
 用來呈現影像的回呼函式指標。 這個參數是必要項，如果映像中鍵入`nFlags`是**DST_COMPLEX**。 它是選擇性的而且可以是**NULL**映像類型是否**DST_TEXT**。 對於其他所有影像類型，這個參數已忽略。 如需回呼函式的詳細資訊，請參閱[DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497) Windows SDK 中的函式。  
  
 `lData`  
 指定映像的相關資訊。 這個參數的意義取決於影像類型。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
##  <a name="drawtext"></a>CDC::DrawText  
 呼叫此成員函式，可以格式化文字方塊中指定的矩形。 若要指定其他格式化選項，請使用[CDC::DrawTextEx](#drawtextex)。  
  
```  
virtual int DrawText(
    LPCTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat);

 
int DrawText(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat);
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向要繪製的字串。 如果`nCount`為-1，字串必須是以 null 結束。  
  
 `nCount`  
 在字串中指定字元的數目。 如果`nCount`是-1，則`lpszString`假設為以 null 終止的字串長度指標和`DrawText`自動計算的字元計數。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含文字為格式化的矩形 （以邏輯座標表示）。  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製指定的字元。  
  
 `nFormat`  
 指定的格式化文字的方法。 它可以是所述，對任何的值組合`uFormat`中的參數[DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) Windows SDK 中。 （結合使用位元 OR 運算子）：  
  
> [!NOTE]
>  某些`uFormat`旗標的組合可能會導致修改傳遞的字串。 使用**DT_MODIFYSTRING**其中一種**DT_END_ELLIPSIS**或**DT_PATH_ELLIPSIS**可能會造成要修改字串造成的判斷提示`CString`覆寫。 值`DT_CALCRECT`， `DT_EXTERNALLEADING`， **DT_INTERNAL**， `DT_NOCLIP`，和`DT_NOPREFIX`不能與`DT_TABSTOP`值。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功之文字的高度。  
  
### <a name="remarks"></a>備註  
 它會將文字格式化成適當的空格，將文字左、 右對齊或置給定矩形中，展開索引標籤，並分為符合給定矩形內的行中的文字。 所指定的格式類型`nFormat`。  
  
 此成員函式會使用裝置內容的選取的字型、 文字色彩和背景色彩來繪製文字。 除非`DT_NOCLIP`使用格式，`DrawText`裁剪文字，讓文字未出現在指定的矩形的外面。 所有格式設定都假設擁有多行，除非`DT_SINGLELINE`格式指定。  
  
 如果選取的字型太大而無法針對指定的矩形，`DrawText`成員函式不會嘗試取代較小的字型。  
  
 如果`DT_CALCRECT`指定旗標時，所指定的矩形`lpRect`將更新以反映所需來繪製文字的高度與寬度。  
  
 如果**TA_UPDATECP**已設定文字對齊方式的旗標 (請參閱[CDC::SetTextAlign](#settextalign))，`DrawText`會顯示從目前位置，而不在給定矩形左邊的文字。 `DrawText`不會換行的文字時**TA_UPDATECP**設定旗標 (也就是`DT_WORDBREAK`旗標會有任何作用)。  
  
 可能設定的文字色彩[CDC::SetTextColor](#settextcolor)。  
  
##  <a name="drawtextex"></a>CDC::DrawTextEx  
 將指定的矩形中的文字。  
  
```  
virtual int DrawTextEx(
    LPTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

 
int DrawTextEx(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向要繪製的字串。 如果`nCount`為-1，字串必須結束的 null。  
  
 `nCount`  
 在字串中指定字元的數目。 如果`nCount`是-1，則`lpszString`假設為以 null 終止的字串長度指標和`DrawText`自動計算的字元計數。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含文字為格式化的矩形 （以邏輯座標表示）。  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製指定的字元。  
  
 `nFormat`  
 指定的格式化文字的方法。 它可以是所述，對任何的值組合`uFormat`中的參數[DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498) Windows SDK 中。 (結合使用位元`OR`運算子):  
  
> [!NOTE]
>  某些`uFormat`旗標的組合可能會導致修改傳遞的字串。 使用**DT_MODIFYSTRING**其中一種**DT_END_ELLIPSIS**或**DT_PATH_ELLIPSIS**可能會造成要修改字串造成的判斷提示`CString`覆寫。 值`DT_CALCRECT`， `DT_EXTERNALLEADING`， **DT_INTERNAL**， `DT_NOCLIP`，和`DT_NOPREFIX`不能與`DT_TABSTOP`值。  
  
 `lpDTParams`  
 指標[DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500)結構，指定其他格式化選項。 這個參數可以是**NULL**。  
  
### <a name="remarks"></a>備註  
 它會將文字格式化成適當的空格，將文字左、 右對齊或置給定矩形中，展開索引標籤，並分為符合給定矩形內的行中的文字。 所指定的格式類型`nFormat`和`lpDTParams`。 如需詳細資訊，請參閱[CDC::DrawText](#drawtext)和[DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499) Windows SDK 中。  
  
 可能設定的文字色彩[CDC::SetTextColor](#settextcolor)。  
  
##  <a name="ellipse"></a>CDC::Ellipse  
 繪製橢圓形。  
  
```  
BOOL Ellipse(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Ellipse(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定邏輯橢圓形之周框左上角的 x 座標。  
  
 `y1`  
 指定邏輯橢圓形之周框左上角的 y 座標。  
  
 `x2`  
 指定邏輯橢圓形之周框的右下角的 x 座標。  
  
 `y2`  
 指定邏輯橢圓形之周框的右下角的 y 座標。  
  
 `lpRect`  
 指定的橢圓形之周框。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 橢圓形的中心是所指定的週框矩形的中心`x1`， `y1`， `x2`，和`y2`，或`lpRect`。 使用目前的畫筆繪製橢圓形和它的內部會填入目前的筆刷。  
  
 此函式所繪製的圖最多至延伸，但不包括，右側和底部的座標。 這表示圖的高度是`y2`  -  `y1`圖的寬度，且`x2`  -  `x1`。  
  
 如果週框的高度或寬度是 0，會不繪製任何橢圓形。  
  
##  <a name="enddoc"></a>CDC::EndDoc  
 結束呼叫所啟動的列印工作[Cdc](#startdoc)成員函式。  
  
```  
int EndDoc();
```  
  
### <a name="return-value"></a>傳回值  
 大於或等於 0，如果函式成功或負數值，如果發生錯誤。  
  
### <a name="remarks"></a>備註  
 此成員函式取代**ENDDOC**印表機逸出，而且應該完成成功的列印工作之後，立即呼叫。  
  
 如果應用程式發生列印錯誤或已取消的列印作業時，它必須不會嘗試使用終止作業`EndDoc`或[AbortDoc](#abortdoc)。 GDI 自動終止之前傳回錯誤值的作業。  
  
 此函式不應在中繼檔內。  
  
### <a name="example"></a>範例  
  請參閱範例的[CDC::StartDoc](#startdoc)。  
  
##  <a name="endpage"></a>CDC::EndPage  
 通知裝置，應用程式已完成寫入頁面。  
  
```  
int EndPage();
```  
  
### <a name="return-value"></a>傳回值  
 大於或等於 0，如果函式成功或負數值，如果發生錯誤。  
  
### <a name="remarks"></a>備註  
 此成員函式通常用來直接前往新頁面的裝置驅動程式。  
  
 此成員函式取代**NEWFRAME**印表機逸出。 不同於**NEWFRAME**，一律會呼叫此函數後列印的頁面。  
  
### <a name="example"></a>範例  
  請參閱範例的[CDC::StartDoc](#startdoc)。  
  
##  <a name="endpath"></a>CDC::EndPath  
 關閉路徑括號，並選取放入裝置內容的 在括號所定義的路徑。  
  
```  
BOOL EndPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="example"></a>範例  
  請參閱範例的[cdc:: beginpath](#beginpath)。  
  
##  <a name="enumobjects"></a>Cdc:: enumobjects  
 列舉畫筆和筆刷在裝置內容中使用。  
  
```  
int EnumObjects(
    int nObjectType,  
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),  
    LPARAM lpData);
```  
  
### <a name="parameters"></a>參數  
 *nObjectType*  
 指定的物件類型。 它可以包含值**OBJ_BRUSH**或**OBJ_PEN**。  
  
 `lpfn`  
 是應用程式所提供的回呼函式的程序執行個體位址。 請參閱 < 備註 > 一節。  
  
 `lpData`  
 應用程式提供資料點。 資料會傳遞至回呼函式，以及物件中的資訊。  
  
### <a name="return-value"></a>傳回值  
 指定所傳回的最後一個值[回呼函式](../../mfc/reference/callback-function-for-cdc-enumobjects.md)。 它的意義是使用者定義的。  
  
### <a name="remarks"></a>備註  
 對於特定類型的每個物件，您傳遞的回呼函式稱為與該物件的資訊。 系統會呼叫回呼函式，直到沒有任何多個物件或回呼函式會傳回 0。  
  
 請注意，Microsoft Visual c + + 的新功能可讓您使用一般函式，函式傳遞至`EnumObjects`。 位址傳遞至`EnumObjects`與匯出的函式的指標**匯出**與 Pascal 呼叫慣例。 保護模式應用程式中，您不必使用 Windows MakeProcInstance 函式建立此函式或函式釋放之後 FreeProcInstance Windows 函式搭配使用。  
  
 您也沒有要匯出函式名稱中的**匯出**應用程式的模組定義檔中的陳述式。 您可以改為使用**匯出**函式中的修飾詞，  
  
 **int 回呼匯出**AFunction **(LPSTR**， **LPSTR);**  
  
 導致編譯器發出不含別名名稱所匯出的適當匯出記錄。 這適用於大部分的需求。 如需某些特殊情況下，例如匯出的函式依序數或別名匯出，您仍需要使用**匯出**模組定義檔中的陳述式。  
  
 編譯 Mfc 程式，您通常會使用 /GA 和 /GEs 編譯器選項。 /Gw 編譯器選項未 Microsoft Foundation classes 搭配使用。 (如果您使用 Windows 函式**MakeProcInstance**，您必須明確轉型從傳回的函式指標**FARPROC**這個 API 中所需的型別。)回呼註冊介面現在是型別安全 （您必須指向正確類型的特定回呼函式的函式指標傳遞）。  
  
 也請注意所有的回呼函式必須再傳回給 Windows，，因為無法跨回呼界限擲回例外狀況設陷 Mfc 例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  
  
##  <a name="escape"></a>CDC::Escape  
 此成員函式是 Win32 程式設計實際上已過時。  
  
```  
virtual int Escape(
    int nEscape,  
    int nCount,  
    LPCSTR lpszInData,  
    LPVOID lpOutData);

 
int Escape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData,  
    int nOutputSize,  
    LPSTR lpszOutputData);
```  
  
### <a name="parameters"></a>參數  
 `nEscape`  
 指定要執行的逸出函數。  
  
 如需逸出函式的完整清單，請參閱[逸出](http://msdn.microsoft.com/library/windows/desktop/dd162701)Windows SDK 中。  
  
 `nCount`  
 指定的資料所指向的位元組數目`lpszInData`。  
  
 `lpszInData`  
 指向此逸出所需的輸入的資料結構。  
  
 `lpOutData`  
 指向結構，這是要從這個逸出接收輸出。 `lpOutData`參數是**NULL**如果未不傳回任何資料。  
  
 `nInputSize`  
 指定的資料所指向的位元組數目`lpszInputData`參數。  
  
 `lpszInputData`  
 指定的逸出所需的輸入結構的點。  
  
 `nOutputSize`  
 指定的資料所指向的位元組數目`lpszOutputData`參數。  
  
 `lpszOutputData`  
 指向以接收來自此逸出之輸出的結構。 這個參數應該是**NULL**如果未不傳回任何資料。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，但傳回正值**QUERYESCSUPPORT**逸出，只會檢查實作。 如果未實作逸出，則會傳回零。 如果發生錯誤，則會傳回負值。 以下是常見的錯誤值：  
  
- **SP_ERROR**一般錯誤。  
  
- **SP_OUTOFDISK**足夠的磁碟空間是目前可供多工緩衝處理，且沒有更多的空間會變成可用。  
  
- **SP_OUTOFMEMORY**沒有足夠的記憶體可用於多工緩衝處理。  
  
- **SP_USERABORT**使用者結束透過列印管理員工作。  
  
### <a name="remarks"></a>備註  
 原始印表機逸出字元，僅**QUERYESCSUPPORT**支援 Win32 應用程式。 所有其他印表機逸出已經過時，僅支援以 16 位元應用程式的相容性。  
  
 Win32 程式設計`CDC`現在提供六個成員函式取代其對應的印表機逸出的應用程式：  
  
- [CDC::AbortDoc](#abortdoc)  
  
- [CDC::EndDoc](#enddoc)  
  
- [CDC::EndPage](#endpage)  
  
- [Cdc:: setabortproc](#setabortproc)  
  
- [CDC::StartDoc](#startdoc)  
  
- [CDC::StartPage](#startpage)  
  
 此外， [rastercaps](#getdevicecaps)支援 Win32 索引取代其他印表機逸出的應用程式。 請參閱[GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877)如需詳細資訊的 Windows SDK 中。  
  
 此成員函式可讓應用程式存取特定裝置不是直接透過 GDI 可用的設備。  
  
 如果您的應用程式會使用預先定義的逸出值，請使用第一個版本。 如果您的應用程式定義私用的逸出值，請使用第二個版本。 請參閱[ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708)如需有關第二個版本的 Windows SDK 中。  
  
##  <a name="excludecliprect"></a>CDC::ExcludeClipRect  
 建立新的裁剪區域所組成的現有的裁剪區域減去指定的矩形。  
  
```  
int ExcludeClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int ExcludeClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定邏輯之矩形左上角的 x 座標。  
  
 `y1`  
 指定矩形左上角的邏輯 y 座標。  
  
 `x2`  
 指定矩形右下角的邏輯 x 座標。  
  
 `y2`  
 指定矩形右下角的邏輯 y 座標。  
  
 `lpRect`  
 指定的矩形。 也可以是`CRect`物件。  
  
### <a name="return-value"></a>傳回值  
 指定新裁剪區域的類型。 它可以是下列值之一：  
  
- **COMPLEXREGION**區域具有重疊的框線。  
  
- **錯誤**已建立的任何區域。  
  
- **NULLREGION**區域是空白。  
  
- **SIMPLEREGION**區域有任何重疊的框線。  
  
### <a name="remarks"></a>備註  
 數值的絕對值所指定的矩形的寬度`x2`  -  `x1`，不能超過 32,767 單位。 這項限制適用於以及矩形的高度。  
  
##  <a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn  
 從相關聯的裁剪區域排除在視窗中的更新的區域，以防止無效區域內的視窗繪圖`CDC`物件。  
  
```  
int ExcludeUpdateRgn(CWnd* pWnd);
```  
  
### <a name="parameters"></a>參數  
 `pWnd`  
 指向要更新其視窗的視窗物件。  
  
### <a name="return-value"></a>傳回值  
 排除區域的類型。 它可以是下列值之一：  
  
- **COMPLEXREGION**區域具有重疊的框線。  
  
- **錯誤**已建立的任何區域。  
  
- **NULLREGION**區域是空白。  
  
- **SIMPLEREGION**區域有任何重疊的框線。  
  
##  <a name="extfloodfill"></a>CDC::ExtFloodFill  
 填入目前的筆刷顯示介面的區域。  
  
```  
BOOL ExtFloodFill(
    int x,  
    int y,  
    COLORREF crColor,  
    UINT nFillType);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定的點，填滿的開始處的邏輯 x 座標。  
  
 *y*  
 指定的點，填滿的開始處的邏輯 y 座標。  
  
 `crColor`  
 指定的色彩，或要填滿區域的界限。 解譯`crColor`取決於值`nFillType`。  
  
 `nFillType`  
 指定要執行的大量封包填滿的類型。 它必須是下列值之一：  
  
- **FLOODFILLBORDER**所指定的色彩填滿區域會受限於`crColor`。 這個樣式等同於所執行的填滿`FloodFill`。  
  
- **FLOODFILLSURFACE**定義所指定的色彩填滿區域`crColor`。 填滿所有方向中繼續向外，只要遇到色彩。 這個樣式可用於以彩色界限填滿區域。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則為非零否則為 0，如果填滿無法完成，如果指定的點的界限所指定的色彩`crColor`(如果**FLOODFILLBORDER**要求)，如果指定的點沒有所指定的色彩`crColor`（如果**FLOODFILLSURFACE**要求)，或如果點裁剪區域外。  
  
### <a name="remarks"></a>備註  
 此成員函式提供更多的彈性比`FloodFill`因為您可以指定在填滿類型`nFillType`。  
  
 如果`nFillType`設**FLOODFILLBORDER**，區域會假設為完整的限制所指定的色彩， `crColor`。 此函式的開頭位於所指定的點*x*和*y*並填滿色彩界限的所有方向。  
  
 如果`nFillType`設**FLOODFILLSURFACE**，函式的開頭位於所指定的點*x*和*y*並繼續所有填滿所有相鄰區域的方向包含所指定的色彩`crColor`。  
  
 只有記憶體裝置內容和支援點陣顯示技術支援的裝置`ExtFloodFill`。 如需詳細資訊，請參閱[GetDeviceCaps](#getdevicecaps)成員函式。  
  
##  <a name="exttextout"></a>CDC::ExtTextOut  
 呼叫此成員函式，將使用目前選取的字型的矩形區域中的字元字串。  
  
```  
virtual BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    LPCTSTR lpszString,  
    UINT nCount,  
    LPINT lpDxWidths);

 
BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    const CString& str,  
    LPINT lpDxWidths);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定的字串中指定的第一個字元的字元儲存格的邏輯 x 座標。  
  
 *y*  
 指定字串中指定的第一個字元的字元儲存格的頂端的邏輯 y 座標。  
  
 `nOptions`  
 指定矩形的型別。 這個參數可以是其中一個，兩者，或兩者皆非的下列值：  
  
- **ETO_CLIPPED**指定文字會被裁剪矩形中。  
  
- **ETO_OPAQUE**指定目前的背景色彩填滿的矩形。 (您可以設定與查詢目前的背景色彩與[SetBkColor](#setbkcolor)和[GetBkColor](#getbkcolor)成員函式。)  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構，決定矩形的維度。 這個參數可以是**NULL**。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `lpszString`  
 指向要繪製指定的字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。  
  
 `lpDxWidths`  
 指向陣列，這個值表示來源的相鄰的字元儲存格之間的距離。 比方說， `lpDxWidths`[*我*] 的邏輯單元會分隔字元儲存格的出處*我*和字元儲存格*我*+ 1。 如果`lpDxWidths`是**NULL**，`ExtTextOut`會使用預設值之間的間距字元。  
  
 `str`  
 A`CString`物件，其中包含要繪製指定的字元。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 矩形區域可以是不透明 （填滿，而且目前的背景色彩），而且它可以裁剪區域。  
  
 如果`nOptions`為 0 和`lpRect`是**NULL**，函式將文字寫入至裝置內容而不使用矩形區域。 根據預設，函式不會使用或更新目前的位置。 如果應用程式需要更新目前的位置時，它會呼叫`ExtTextOut`，應用程式可以呼叫`CDC`成員函式[SetTextAlign](#settextalign)與`nFlags`設**TA_UPDATECP**. 當設定這個旗標時，Windows 會略過*x*和*y*在後續呼叫`ExtTextOut`，並改為使用目前的位置。 當應用程式使用**TA_UPDATECP**更新目前的位置，`ExtTextOut`設定的目前位置到文字的上一行的結尾或所指陣列的最後一個元素所指定的位置`lpDxWidths`，較長者為準。  
  
##  <a name="fillpath"></a>CDC::FillPath  
 關閉目前路徑中的任何開放圖形，並使用目前的筆刷和多邊形填滿模式，填滿路徑的內部。  
  
```  
BOOL FillPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 填入其內部之後，就會捨棄裝置內容的路徑。  
  
##  <a name="fillrect"></a>CDC::FillRect  
 呼叫此成員函式，以填滿指定的矩形，使用指定的筆刷。  
  
```  
void FillRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構，其中包含要填滿的矩形的邏輯座標。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `pBrush`  
 識別用來填滿之矩形的筆刷。  
  
### <a name="remarks"></a>備註  
 函式會填滿完整的矩形中，包括左端和頂端的框線，但不會填右邊緣和下框線。  
  
 筆刷必須設為 使用建立[CBrush](../../mfc/reference/cbrush-class.md)成員函式[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)， [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)，和[CreateSolidBrush](../../mfc/reference/cbrush-class.md#createsolidbrush)，或擷取`GetStockObject`Windows 函式。  
  
 當填滿指定的矩形，`FillRect`不包含矩形的右邊緣和下面。 GDI 最多至填滿的矩形，但不包括，正確資料行和底端的資料列，不論目前的對應模式。 `FillRect`比較的值**頂端**，**底部**，**左**，和**右**指定矩形的成員。 如果**底部**小於或等於**頂端**，或如果**右**小於或等於**左**，不繪製矩形。  
  
 `FillRect`類似於[CDC::FillSolidRect](#fillsolidrect); 不過，`FillRect`採用筆刷，因此可以用來填入純色、 遞色的色彩，包含陰影的筆刷或圖樣的矩形。 `FillSolidRect`使用僅純色 (由**COLORREF**參數)。 `FillRect`通常低於`FillSolidRect`。  
  
##  <a name="fillrgn"></a>CDC::FillRgn  
 所指定的區域填滿`pRgn`與所指定的筆刷`pBrush`。  
  
```  
BOOL FillRgn(
    CRgn* pRgn,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 指向要填滿區域。 以邏輯單位表示指定的給定區域座標。  
  
 `pBrush`  
 識別用來填滿區域的筆刷。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 筆刷必須建立使用`CBrush`成員函式`CreateHatchBrush`， `CreatePatternBrush`， `CreateSolidBrush`，或擷取**GetStockObject**。  
  
### <a name="example"></a>範例  
  請參閱範例的[CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)。  
  
##  <a name="fillsolidrect"></a>CDC::FillSolidRect  
 呼叫此成員函式可使用的指定純色填滿指定的矩形。  
  
```  
void FillSolidRect(
    LPCRECT lpRect,  
    COLORREF clr);

 
void FillSolidRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clr);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指定的周框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](../../mfc/reference/rect-structure1.md)資料結構或`CRect`這個參數的物件。  
  
 `clr`指定要用來填滿之矩形的色彩。  
  
 *x*  
 指定邏輯之矩形左上角的 x 座標。  
  
 *y*  
 指定目的地矩形的左上角的邏輯 y 座標。  
  
 `cx`  
 指定的矩形的寬度。  
  
 `cy`  
 指定的矩形的高度。  
  
### <a name="remarks"></a>備註  
 `FillSolidRect`非常類似於[CDC::FillRect](#fillrect); 不過，`FillSolidRect`使用只有純色 (由**COLORREF**參數)，而`FillRect`採用筆刷，因此可以用來填滿矩形，純色、 遞色的色彩，包含陰影的筆刷或圖樣。 `FillSolidRect`通常的速度比`FillRect`。  
  
> [!NOTE]
>  當您呼叫`FillSolidRect`，背景色彩，而這些先前使用設定[SetBkColor](#setbkcolor)，設定為所指定的色彩`clr`。  
  
##  <a name="flattenpath"></a>CDC::FlattenPath  
 轉換到目前的裝置內容中，選取的路徑中任何曲線，並將每個曲線轉換成一連串的行。  
  
```  
BOOL FlattenPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="floodfill"></a>CDC::FloodFill  
 填入目前的筆刷顯示介面的區域。  
  
```  
BOOL FloodFill(
    int x,  
    int y,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定的點，填滿的開始處的邏輯 x 座標。  
  
 *y*  
 指定的點，填滿的開始處的邏輯 y 座標。  
  
 `crColor`  
 指定界限的色彩。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則為非零否則會傳回 0 無法完成填滿，如果指定的點具有所指定的界限色彩`crColor`，或該點是否裁剪區域外。  
  
### <a name="remarks"></a>備註  
 區域會假設所限制為指定`crColor`。 `FloodFill`函式所指定的點開始*x*和*y*並繼續在所有的方向，色彩界限。  
  
 只有記憶體裝置內容和支援點陣顯示技術支援的裝置`FloodFill`成員函式。 如需有關資訊**RC_BITBLT**功能，請參閱`GetDeviceCaps`成員函式。  
  
 `ExtFloodFill`函式會提供類似的功能，但更大的彈性。  
  
##  <a name="framerect"></a>CDC::FrameRect  
 繪製框線所指定的矩形`lpRect`。  
  
```  
void FrameRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含矩形的左上角和右下角的邏輯座標。 您也可以傳遞`CRect`這個參數的物件。  
  
 `pBrush`  
 識別要用於框架矩形的筆刷。  
  
### <a name="remarks"></a>備註  
 此函數會使用指定的筆刷繪製的框線。 框線的高度與寬度永遠為 1 的邏輯單元。  
  
 如果矩形**底部**座標小於或等於**頂端**，或如果**右**小於或等於**左**，矩形不繪製。  
  
 所繪製的框線`FrameRect`位於相同位置所繪製的框線**矩形**成員函式使用相同的座標 (如果**矩形**使用是 1 的邏輯單元寬的畫筆使用)。 不會填入的矩形內部`FrameRect`。  
  
##  <a name="framergn"></a>CDC::FrameRgn  
 所指定的區域周圍繪製框線`pRgn`使用所指定的筆刷`pBrush`。  
  
```  
BOOL FrameRgn(
    CRgn* pRgn,  
    CBrush* pBrush,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 指向`CRgn`物件，可識別要框線括住的區域。 以邏輯單位表示指定的給定區域座標。  
  
 `pBrush`  
 指向`CBrush`物件，可識別用來繪製框線的筆刷。  
  
 `nWidth`  
 在垂直的筆刷筆觸以裝置為單位指定框線的寬度。  
  
 `nHeight`  
 在水平的筆刷筆觸以裝置為單位指定框線的高度。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="example"></a>範例  
  請參閱範例的[CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn)。  
  
##  <a name="fromhandle"></a>CDC::FromHandle  
 將指標傳回至`CDC`物件時指定的裝置內容控制代碼。  
  
```  
static CDC* PASCAL FromHandle(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 包含 Windows 裝置內容的控制代碼。  
  
### <a name="return-value"></a>傳回值  
 指標可能是暫時性的不會儲存超過立即使用。  
  
### <a name="remarks"></a>備註  
 如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。  
  
### <a name="example"></a>範例  
  請參閱範例的[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。  
  
##  <a name="getarcdirection"></a>CDC::GetArcDirection  
 傳回目前弧形方向之裝置內容。  
  
```  
int GetArcDirection() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功的話，請指定目前的弧形方向。 以下是有效的傳回值：  
  
- **AD_COUNTERCLOCKWISE**弧形和以逆時針方向繪製的矩形。  
  
- **AD_CLOCKWISE**弧形和朝順時針方向繪製的矩形。  
  
 如果發生錯誤，傳回的值為零。  
  
### <a name="remarks"></a>備註  
 弧線和矩形函式使用弧形方向。  
  
##  <a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter  
 擷取目前的長寬比篩選條件的設定。  
  
```  
CSize GetAspectRatioFilter() const;  
```  
  
### <a name="return-value"></a>傳回值  
 A`CSize`物件，代表目前的長寬比篩選所使用的長寬比。  
  
### <a name="remarks"></a>備註  
 外觀比例是裝置的像素寬度和高度所形成的比例。 裝置的外觀比例的相關資訊用於建立、 選取範圍，以及顯示的字型。 Windows 提供的特殊篩選器長寬比篩選器，以選取 針對特定的長寬比，從所有可用的字型的字型。 篩選器會使用所指定的外觀比例`SetMapperFlags`成員函式。  
  
##  <a name="getbkcolor"></a>CDC::GetBkColor  
 傳回目前的背景色彩。  
  
```  
COLORREF GetBkColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 RGB 色彩值。  
  
### <a name="remarks"></a>備註  
 如果背景模式為**不透明**，系統會使用背景色彩填滿樣式的行中出現間距、 筆刷影線的行中的字元儲存格的背景的間隙。 轉換點陣圖之間色彩及單色裝置內容時，系統也會使用背景色彩。  
  
##  <a name="getbkmode"></a>CDC::GetBkMode  
 傳回背景模式。  
  
```  
int GetBkMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 目前背景模式中，它可以是**不透明**或**透明**。  
  
### <a name="remarks"></a>備註  
 背景模式會定義系統是否會繪製文字、 影線的筆刷或不是實線任何筆樣式之前移除現有的背景色彩的繪圖介面上。  
  
##  <a name="getboundsrect"></a>CDC::GetBoundsRect  
 傳回指定之裝置內容的目前累積週框矩形。  
  
```  
UINT GetBoundsRect(
    LPRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>參數  
 `lpRectBounds`  
 指出緩衝區將會接收目前週框。 矩形就會傳回邏輯座標。  
  
 `flags`  
 指定週框矩形是否傳回前加以清除。 此參數應為零，或設為下列值：  
  
- **DCB_RESET**強制傳回前要清除之周框。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，請指定目前的狀態，這個周框。 它可以是下列值的組合：  
  
- **DCB_ACCUMULATE**週框矩形累積發生。  
  
- **DCB_RESET**是空的週框。  
  
- **DCB_SET**不是空的週框。  
  
- **DCB_ENABLE**週框累積為開啟。  
  
- **DCB_DISABLE**週框累積為關閉。  
  
##  <a name="getbrushorg"></a>CDC::GetBrushOrg  
 擷取目前選取之裝置內容的筆刷的原點 （以裝置為單位）。  
  
```  
CPoint GetBrushOrg() const;  
```  
  
### <a name="return-value"></a>傳回值  
 目前 （以裝置單位表示） 做為筆刷的原點[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
### <a name="remarks"></a>備註  
 初始的筆刷的原點位於 (0，0) 的工作區。 傳回值會指定此點裝置單位，相對於來源的桌面視窗中。  
  
##  <a name="getcharacterplacement"></a>CDC::GetCharacterPlacement  
 擷取各種類型的字元字串的詳細資訊。  
  
```  
DWORD GetCharacterPlacement(
    LPCTSTR lpString,  
    int nCount,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
  
DWORD GetCharacterPlacement(
    CString& str,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpString`  
 要處理的字元字串指標。  
  
 `nCount`  
 指定字串的長度。 ANSI 版中，它是位元組計數和 Unicode 函數對於字數統計。 如需詳細資訊，請參閱[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)。  
  
 `nMaxExtent`  
 指定最大範圍 （以邏輯單位表示） 來處理字串。 如果處理，則會超過此範圍的字元會被忽略。 計算的任何必要的排序或圖像陣列僅適用於包含的字元。 GCP_MAXEXTENT 值中指定時才使用這個參數`dwFlags`參數。 當函式會處理輸入的字串，每個字元，其範圍是輸出、 範圍，以及其他陣列才加入總範圍尚未尚未超過最大值。 一旦達到限制時，將會停止處理。  
  
 lpResults  
 指標[GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\(v=vs.85\).aspx)接收函式的結果的結構。  
  
 `dwFlags`  
 指定如何處理字串到必要的陣列。 這個參數可以是其中一個或多個值中所列`dwFlags`區段[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)主題。  
  
 `str`  
 指標[CString](../../atl-mfc-shared/reference/cstringt-class.md)至處理序的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回值是以邏輯單位表示字串的高度與寬度。  
  
 如果此函式失敗，則傳回值為零。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)、 Windows SDK 中所述。  
  
##  <a name="getcharabcwidths"></a>CDC::GetCharABCWidths  
 擷取指定範圍內的連續字元的寬度，從目前的 TrueType 字型。  
  
```  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABC lpabc) const;  
  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABCFLOAT lpABCF) const;  
```  
  
### <a name="parameters"></a>參數  
 `nFirstChar`  
 指定的字元寬度傳回的目前字型的字元範圍中的第一個字元。  
  
 `nLastChar`  
 指定的字元寬度傳回的目前字型的字元範圍中的最後一個字元。  
  
 `lpabc`  
 指向陣列[ABC](../../mfc/reference/abc-structure.md)接收字元寬度，當函式傳回的結構。 這個陣列必須包含至少會為許多**ABC**做中所指定的範圍有字元結構`nFirstChar`和`nLastChar`參數。  
  
 *lpABCF*  
 應用程式所提供的緩衝區的陣列會指向[ABCFLOAT](../../mfc/reference/abcfloat-structure.md)結構函式傳回時，接收字元寬度。 此函數所傳回的寬，IEEE 浮點格式。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 寬度會傳回以邏輯單位表示。 此函式會成功，只能使用 TrueType 字型。  
  
 已選取的特定點大小之後，TrueType 轉譯器會提供"ABC"字元的間距。 "A"間距是前面放置圖像 （glyph） 加入至目前位置的距離。 "B"間距是黑色圖像部分的寬度。 "C"間距會加入至目前的位置，以便圖像右邊空白字元的帳戶。 進階寬度總計有由 A + B + c。  
  
 當`GetCharABCWidths`成員函式會擷取負數"A"或"C"寬字元，該字元包括 underhangs 或突出部分。  
  
 若要將 ABC 寬度為字型設計單位，應用程式應該建立字型的高度 (如同在中指定**lfHeight**隸屬[LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037)結構) 等於中儲存的值**ntmSizeEM**隸屬[NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741)結構。 (值**ntmSizeEM**成員可以藉由呼叫擷取[EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) Windows 函式。)  
  
 ABC 寬度的預設字元用於目前選取字型的範圍以外的字元。  
  
 若要擷取非 TrueType 字型中的字元寬度，應用程式應該使用[GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) Windows 函式。  
  
##  <a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI  
 擷取的寬度，以邏輯單位，從目前的 TrueType 字型在指定範圍中的連續圖像索引。  
  
```  
BOOL GetCharABCWidthsI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPABC lpabc) const;  
```  
  
### <a name="parameters"></a>參數  
 `giFirst`  
 指定第一個圖像 （glyph） 索引群組中的所有連續的圖像索引，從目前的字型。 若此參數只會用於`pgi`參數是**NULL**。  
  
 `cgi`  
 指定圖像索引的數目。  
  
 `pgi`  
 包含圖像索引的陣列指標。 如果值為**NULL**、`giFirst`改為使用參數。 `cgi`參數會指定此陣列中的圖像索引鍵的數目。  
  
 `lpabc`  
 陣列的指標[ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454)結構接收字元寬度。 這個陣列必須包含至少會為許多**ABC**做有 glyph 索引所指定的結構`cgi`參數。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859)、 Windows SDK 中所述。  
  
##  <a name="getcharwidth"></a>CDC::GetCharWidth  
 擷取從目前的字型，連續的字元群組中的個別字元寬度使用`m_hAttribDC`，輸入的裝置內容。  
  
```  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    float* lpFloatBuffer) const;  
```  
  
### <a name="parameters"></a>參數  
 `nFirstChar`  
 指定連續的目前字型中的字元群組中的第一個字元。  
  
 `nLastChar`  
 指定連續的目前字型中的字元群組中的最後一個字元。  
  
 `lpBuffer`  
 指出緩衝區中目前的字型中將會接收一組連續字元的寬度值。  
  
 *lpFloatBuffer*  
 指出緩衝區接收字元寬度。 傳回的寬度會以 32 位元 IEEE 浮點格式。 （寬度會測量基底線條的字元）。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 例如，如果`nFirstChar`識別字母 'a' 和`nLastChar`識別字母 'a'-'z'、 函式擷取所有小寫字元的寬度。  
  
 此函式所指向之緩衝區中儲存值`lpBuffer`。 這個緩衝區必須夠大，無法保存所有的寬度。 也就是必須有至少 26 項目中指定的範例。  
  
 如果連續的字元群組中的字元不存在於特定字型，則會指派預設字元寬度值。  
  
##  <a name="getcharwidthi"></a>CDC::GetCharWidthI  
 擷取的寬度，以邏輯座標，從目前的字型的指定範圍內的連續圖像索引。  
  
```  
BOOL GetCharWidthI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>參數  
 `giFirst`  
 指定第一個圖像 （glyph） 索引群組中的所有連續的圖像索引，從目前的字型。 若此參數只會用於`pgi`參數是**NULL**。  
  
 `cgi`  
 指定圖像索引的數目。  
  
 `pgi`  
 包含圖像索引的陣列指標。 如果值為**NULL**、`giFirst`改為使用參數。 `cgi`參數會指定此陣列中的圖像索引鍵的數目。  
  
 `lpBuffer`  
 接收寬度緩衝區的指標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864)、 Windows SDK 中所述。  
  
##  <a name="getclipbox"></a>CDC::GetClipBox  
 擷取目前裁剪邊界周圍 tightest 週框矩形的維度。  
  
```  
virtual int GetClipBox(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)所接收的矩形維度物件。  
  
### <a name="return-value"></a>傳回值  
 裁剪區域的類型。 它可以是下列值之一：  
  
- **COMPLEXREGION**裁剪區域具有重疊的框線。  
  
- **錯誤**裝置內容不正確。  
  
- **NULLREGION**裁剪區域是空的。  
  
- **SIMPLEREGION**裁剪區域有任何重疊的框線。  
  
### <a name="remarks"></a>備註  
 維度會複製到所指向的緩衝區`lpRect`。  
  
##  <a name="getcoloradjustment"></a>CDC::GetColorAdjustment  
 擷取裝置內容的色彩調整值。  
  
```  
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpColorAdjust`  
 指向[COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md)接收色彩調整值的資料結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap  
 讓指標回到目前所選`CBitmap`物件。  
  
```  
CBitmap* GetCurrentBitmap() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CBitmap`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentbrush"></a>CDC::GetCurrentBrush  
 讓指標回到目前所選`CBrush`物件。  
  
```  
CBrush* GetCurrentBrush() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CBrush`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentfont"></a>CDC::GetCurrentFont  
 讓指標回到目前所選`CFont`物件。  
  
```  
CFont* GetCurrentFont() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CFont`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentpalette"></a>CDC::GetCurrentPalette  
 讓指標回到目前所選`CPalette`物件。  
  
```  
CPalette* GetCurrentPalette() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CPalette`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentpen"></a>CDC::GetCurrentPen  
 讓指標回到目前所選`CPen`物件。  
  
```  
CPen* GetCurrentPen() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CPen`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentposition"></a>CDC::GetCurrentPosition  
 擷取目前的位置 （以邏輯座標表示）。  
  
```  
CPoint GetCurrentPosition() const;  
```  
  
### <a name="return-value"></a>傳回值  
 目前的位置，以`CPoint`物件。  
  
### <a name="remarks"></a>備註  
 目前的位置可以設定與`MoveTo`成員函式。  
  
##  <a name="getdcbrushcolor"></a>CDC::GetDCBrushColor  
 擷取目前的筆刷色彩。  
  
```  
COLORREF GetDCBrushColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回值是[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)目前的筆刷色彩值。  
  
 如果函式失敗，傳回值是**CLR_INVALID**。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872)、 Windows SDK 中所述。  
  
##  <a name="getdcpencolor"></a>CDC::GetDCPenColor  
 擷取目前的畫筆顏色。  
  
```  
COLORREF GetDCPenColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回值是[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)值目前的畫筆顏色。  
  
 如果函式失敗，傳回值是**CLR_INVALID**。  
  
### <a name="remarks"></a>備註  
 此成員函式會利用 Win32 函式[GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875)、 Windows SDK 中所述。  
  
##  <a name="getdevicecaps"></a>Rastercaps  
 擷取各種不同的顯示裝置的裝置特定資訊。  
  
```  
int GetDeviceCaps(int nIndex) const;  
```  
  
### <a name="parameters"></a>參數  
 `nIndex`  
 指定要傳回資訊的類型。 請參閱[GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877)值清單的 Windows SDK 中。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功要求功能的值。  
  
### <a name="example"></a>範例  
  請參閱範例的[CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)。  
  
##  <a name="getfontdata"></a>CDC::GetFontData  
 擷取可調式字型檔案中的字型度量資訊。  
  
```  
DWORD GetFontData(
    DWORD dwTable,  
    DWORD dwOffset,  
    LPVOID lpData,  
    DWORD cbData) const;  
```  
  
### <a name="parameters"></a>參數  
 `dwTable`  
 指定要傳回之度量資料表的名稱。 這個參數可以是 Microsoft Corporation 所發行的 TrueType 字型檔案規格所述的度量資料表。 如果這個參數是 0，字型檔的開頭擷取的資訊。  
  
 `dwOffset`  
 指定從資料表中要開始擷取資訊的開始位移。 如果這個參數是 0，擷取資訊從指定的資料表開頭`dwTable`參數。 如果這個值是大於或等於大小的表格，`GetFontData`傳回 0。  
  
 `lpData`  
 字型資訊中將會接收之緩衝區的點。 如果此值為**NULL**，此函數會傳回在指定的字型資料所需的緩衝區大小`dwTable`參數。  
  
 `cbData`  
 指定長度，以位元組為單位的要擷取的資訊。 如果這個參數是 0，`GetFontData`會傳回在指定的資料大小`dwTable`參數。  
  
### <a name="return-value"></a>傳回值  
 指定傳回中所指向之緩衝區的位元組數目`lpData`如果函式成功; 否則為-1。  
  
### <a name="remarks"></a>備註  
 指定位移至字型檔案，以及要傳回的資訊來識別要擷取之資訊。  
  
 應用程式有時也可以使用`GetFontData`TrueType 字型儲存的文件的成員函式。 若要這樣做，應用程式會決定是否字型可以內嵌，，然後擷取整個字型檔案，可以指定 0 代表`dwTable`， `dwOffset`，和`cbData`參數。  
  
 應用程式可以決定是否可以藉由檢查中內嵌字型**otmfsType**隸屬[OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)結構。 如果位元 1 **otmfsType**設定內嵌字型不允許。 如果已清除的位元 1，就可以內嵌字型。 如果設定位元 2，內嵌為唯讀。  
  
 如果應用程式嘗試使用這個函數來擷取資訊，對於非 TrueType 字型`GetFontData`成員函式會傳回-1。  
  
##  <a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo  
 傳回指定的顯示內容的目前選取字型的相關資訊。  
  
```  
DWORD GetFontLanguageInfo() const;  
```  
  
### <a name="return-value"></a>傳回值  
 傳回值會指出目前選取的字型特性。 如需可能值的完整清單，請參閱[GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)、 Windows SDK 中所述。  
  
##  <a name="getglyphoutline"></a>CDC::GetGlyphOutline  
 擷取大綱曲線或點陣圖的外框字元，在目前的字型。  
  
```  
DWORD GetGlyphOutline(
    UINT nChar,  
    UINT nFormat,  
    LPGLYPHMETRICS lpgm,  
    DWORD cbBuffer,  
    LPVOID lpBuffer,  
    const MAT2* lpmat2) const;  
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定要傳回資訊的字元。  
  
 `nFormat`  
 指定的功能為傳回資訊的格式。 它可以是下列值之一或 0:  
  
|值|意義|  
|-----------|-------------|  
|**GGO_BITMAP**|傳回圖像點陣圖。 當函式傳回時，所指向的緩衝區`lpBuffer`包含其資料列開始 doubleword 界限的 1 位元-每個像素點陣圖。|  
|**GGO_NATIVE**|傳回資料點的曲線，轉譯器的原生格式，使用裝置單位。 當指定這個值時，在中指定任何轉換`lpmat2`會被忽略。|  
  
 當值`nFormat`是 0，則此函式會填入[GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955)結構但未傳回字符外框的資料。  
  
 *lpgm*  
 指向**GLYPHMETRICS**結構描述的字元儲存格的字符的位置。  
  
 `cbBuffer`  
 指定函式會大綱字元的相關資訊複製到其中的緩衝區的大小。 如果此值為 0 和`nFormat`參數為**GGO_BITMAP**或**GGO_NATIVE**值，此函數會傳回緩衝區的所需的大小。  
  
 `lpBuffer`  
 指向函式會大綱字元的相關資訊複製到其中的緩衝區。 如果`nFormat`指定**GGO_NATIVE**值，資訊會的形式複製**TTPOLYGONHEADER**和**TTPOLYCURVE**結構。 如果此值為**NULL**和`nFormat`是**GGO_BITMAP**或**GGO_NATIVE**值，函式會傳回緩衝區的所需的大小。  
  
 `lpmat2`  
 指向[MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048)結構，其中包含轉換矩陣的字元。 此參數不得為**NULL**，即使**GGO_NATIVE**指定值`nFormat`。  
  
### <a name="return-value"></a>傳回值  
 大小 （位元組），如果擷取的資訊所需的緩衝區`cbBuffer`為 0 或`lpBuffer`是**NULL**。 否則，它是正數值函式如果成功，則為-1，如果發生錯誤。  
  
### <a name="remarks"></a>備註  
 應用程式可以旋轉點陣圖格式擷取藉由指定 2-2 的轉換矩陣所指向的結構中的字元數`lpmat2`。  
  
 字符外框會傳回為一系列的分佈。 每個分佈由定義[TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158)結構後面加上最大數量**TTPOLYCURVE**做，描述所需的結構。 所有資料點會以傳回[POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806)結構，而且代表絕對位置，而非相對的移動。 開始點給定**pfxStart**隸屬[TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158)結構是分佈的外框的開始點。 [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157)記錄聚合線條或曲線記錄，可以遵循的結構。 聚合線條的記錄是一系列的點。點之間繪製的直線說明外框的字元。 曲線記錄代表 TrueType （也就是二次方 b-曲線） 所使用的二次方曲線。  
  
##  <a name="getgraphicsmode"></a>CDC::GetGraphicsMode  
 擷取指定之裝置內容的目前圖形模式。  
  
```  
int GetGraphicsMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 成功時傳回目前的圖形模式。 如需這個方法可以傳回的值，請參閱[GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)。  
  
 在失敗時傳回 0。  
  
 若要取得延伸錯誤資訊，請呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)。  
  
##  <a name="gethalftonebrush"></a>CDC::GetHalftoneBrush  
 呼叫此成員函式可擷取半色調筆刷。  
  
```  
static CBrush* PASCAL GetHalftoneBrush();
```  
  
### <a name="return-value"></a>傳回值  
 指標`CBrush`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 半色調筆刷顯示或者是建立為遞色的圖樣的前景和背景色彩的像素為單位。 以下是由 半色調筆刷為遞色圖樣的範例。  
  
 ![遞色的畫筆筆劃的詳細資料](../../mfc/reference/media/vc318s1.gif "vc318s1")  
  
##  <a name="getkerningpairs"></a>CDC::GetKerningPairs  
 擷取的字元間距組指定的裝置內容中目前選取的字型。  
  
```  
int GetKerningPairs(
    int nPairs,  
    LPKERNINGPAIR lpkrnpair) const;  
```  
  
### <a name="parameters"></a>參數  
 `nPairs`  
 指定的數目[KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024)結構所指`lpkrnpair`。 此函式將不會複製超過所指定的多個 kerning 組`nPairs`。  
  
 `lpkrnpair`  
 指向陣列**KERNINGPAIR**接收字元間距調整的結構組函式傳回時。 這個陣列必須包含所指定的數目，至少結構`nPairs`。 如果這個參數是**NULL**，此函數會傳回的字元間距調整字型組總數。  
  
### <a name="return-value"></a>傳回值  
 指定的字元間距調整組擷取數或總數間距字型中的組，如果函式成功。 如果函式失敗，或沒有 kerning 成對的字型，則會傳回零。  
  
##  <a name="getlayout"></a>CDC::GetLayout  
 呼叫此成員函式，來決定文字和圖形裝置內容，例如印表機或中繼檔的配置。  
  
```  
DWORD GetLayout() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功的話，版面配置旗標目前的裝置內容。 否則， **GDI_ERROR**。 取得延伸的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。 如需版面配置旗標的清單，請參閱[CDC::SetLayout](#setlayout)。  
  
### <a name="remarks"></a>備註  
 預設版面配置是由左到右。  
  
##  <a name="getmapmode"></a>CDC::GetMapMode  
 擷取目前的對應模式。  
  
```  
int GetMapMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 此對應模式。  
  
### <a name="remarks"></a>備註  
 如需對應模式的說明，請參閱`SetMapMode`成員函式。  
  
> [!NOTE]
>  如果您呼叫[SetLayout](#setlayout) DC 變成由右至左配置**SetLayout**會自動變更的對應模式`MM_ISOTROPIC`。 因此，任何後續呼叫`GetMapMode`會傳回`MM_ISOTROPIC`。  
  
##  <a name="getmiterlimit"></a>CDC::GetMiterLimit  
 傳回裝置內容的斜接角限制。  
  
```  
float GetMiterLimit() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 包含繪製幾何行儀表聯結時，會使用斜接角限制。  
  
##  <a name="getnearestcolor"></a>CDC::GetNearestColor  
 傳回最符合指定的邏輯色彩的純色。  
  
```  
COLORREF GetNearestColor(COLORREF crColor) const;  
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定要比對的色彩。  
  
### <a name="return-value"></a>傳回值  
 定義實線 RGB （紅色、 綠色、 藍色） 的色彩值色彩最接近`crColor`裝置可以表示的值。  
  
### <a name="remarks"></a>備註  
 指定的裝置必須能夠代表這個色彩。  
  
##  <a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics  
 擷取 TrueType 字型度量資訊。  
  
```  
UINT GetOutlineTextMetrics(
    UINT cbData,  
    LPOUTLINETEXTMETRIC lpotm) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpotm`  
 指向陣列[OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)結構。 如果這個參數是**NULL**，此函數會傳回所需的擷取衡量標準資料緩衝區的大小。  
  
 `cbData`  
 指定的大小，以位元組為單位傳回資訊的緩衝區。  
  
 `lpotm`  
 指向**OUTLINETEXTMETRIC**結構。 如果這個參數是**NULL**，此函數會傳回所擷取的度量資訊所需的緩衝區大小。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)結構包含大部分的 TrueType 格式時，所提供的字型度量資訊包括[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)結構。 最後四個成員**OUTLINETEXTMETRIC**結構都是字串指標。 應用程式應該針對這些字串，除了其他成員所需的空間配置空間。 因為沒有任何系統加諸限制為字串的大小，配置記憶體的最簡單方法是藉由指定擷取所需的大小**NULL**如`lpotm`中的第一個呼叫`GetOutlineTextMetrics`函式。  
  
##  <a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth  
 會使用輸出裝置內容中， `m_hDC`，並擷取從目前的字型顯示連續的字元群組中個別字元的寬度。  
  
```  
BOOL GetOutputCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>參數  
 `nFirstChar`  
 指定連續的目前字型中的字元群組中的第一個字元。  
  
 `nLastChar`  
 指定連續的目前字型中的字元群組中的最後一個字元。  
  
 `lpBuffer`  
 指出緩衝區中目前的字型中將會接收一組連續字元的寬度值。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 例如，如果`nFirstChar`識別字母 'a' 和`nLastChar`識別字母 'a'-'z'、 函式擷取所有小寫字元的寬度。  
  
 此函式所指向之緩衝區中儲存值`lpBuffer`。 這個緩衝區必須夠大，無法保存所有的寬度。也就是必須有至少 26 項目中指定的範例。  
  
 如果連續的字元群組中的字元不存在於特定字型，則會指派預設字元寬度值。  
  
##  <a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent  
 呼叫此成員函式，來計算的寬度和高度的字元字串使用[m_hDC](#m_hdc)，輸出裝置內容。  
  
```  
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetOutputTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向要測量的字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為-1，長度會計算。  
  
 `nTabPositions`  
 指定所指陣列中的定位停駐點位置數`lpnTabStopPositions`。  
  
 `lpnTabStopPositions`  
 指向陣列包含的邏輯單元的定位停駐點位置的整數。 必須排序定位停駐點，以遞增順序排列;最小的 x 值應該在陣列中的第一個項目。 不允許背景索引標籤。  
  
 `str`  
 A`CString`物件，其中包含要測量指定的字元。  
  
### <a name="return-value"></a>傳回值  
 中的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 如果字串包含一個或多個 tab 字元，字串的寬度根據所指定的定位停駐點`lpnTabStopPositions`。 函式會使用目前選取的字型，計算字串的維度。  
  
 為目前裁剪區域不位移所傳回的高度與寬度`GetOutputTabbedTextExtent`函式。  
  
 因為某些裝置並將字元放在規則資料格陣列中 （也就是它們微調字元），將字串中字元的範圍的總和可能不等於字串的範圍。  
  
 如果`nTabPositions`為 0 和`lpnTabStopPositions`是**NULL**，索引標籤會展開成八個平均字元寬度。 如果`nTabPositions`為 1，第一個值的陣列中所指定的距離會分開定位停駐點`lpnTabStopPositions`點。 如果`lpnTabStopPositions`到多個單一值的點，每個值最多指定的數字陣列中設定定位停駐點`nTabPositions`。  
  
##  <a name="getoutputtextextent"></a>CDC::GetOutputTextExtent  
 呼叫此成員函式，來使用輸出裝置內容中， [m_hDC](#m_hdc)，並計算行的文字，使用目前的字型的高度與寬度。  
  
```  
CSize GetOutputTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetOutputTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向字元的字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為-1，長度會計算。  
  
 `str`  
 A`CString`物件，其中包含要測量指定的字元。  
  
### <a name="return-value"></a>傳回值  
 傳回的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 為目前裁剪區域不會影響所傳回的高度與寬度`GetOutputTextExtent`。  
  
 因為某些裝置並將字元放在規則資料格陣列中 （也就是它們執行字元間距調整），請將字串中字元的範圍的總和可能不等於字串的範圍。  
  
##  <a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics  
 擷取目前的字型使用的度量`m_hDC`，輸出裝置內容。  
  
```  
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpMetrics`  
 指向[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)接收度量的結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="getpath"></a>CDC::GetPath  
 擷取定義的線條端點和的曲線選入裝置內容的路徑中找到的控點的座標。  
  
```  
int GetPath(
    LPPOINT lpPoints,  
    LPBYTE lpTypes,  
    int nCount) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)資料結構或`CPoint`的線條端點和曲線控制點的物件。  
  
 `lpTypes`  
 指向陣列的位元組頂點類型放置的位置。 值可以是下列其中一項：  
  
- **PT_MOVETO**對應點中的指定`lpPoints`開始脫離的圖形。  
  
- **PT_LINETO**先前的點與對應端點的指定`lpPoints`線條的端點。  
  
- **PT_BEZIERTO**對應點中的指定`lpPoints`控制點或 Bzier 曲線的結束點。  
  
 **PT_BEZIERTO**類型一律出現三個的集合。 緊接在其之前的路徑中的點定義 Bzier 曲線的開始點。 前兩個**PT_BEZIERTO**點是第三個控制點， **PT_BEZIERTO**點是結束點 (如果硬式編碼)。  
  
     A **PT_LINETO**或**PT_BEZIERTO**類型可能會結合下列的旗標 (使用位元運算子`OR`) 來指出對應的點圖中的最後一個點應該先關閉圖：  
  
- **PT_CLOSEFIGURE**指定對應的行之後，會自動關閉圖或繪製曲線。 繪製一條線從線條或曲線端點對應到最後一個點關閉圖**PT_MOVETO**。  
  
 `nCount`  
 指定的總數[點](../../mfc/reference/point-structure1.md)資料結構，可能會放置於`lpPoints`陣列。 這個值必須是相同的位元組數目，顯示可能會放置於`lpTypes`陣列。  
  
### <a name="return-value"></a>傳回值  
 如果`nCount`參數不是零，點列舉數目。 如果`nCount`為 0，在路徑中的點總數 (與`GetPath`緩衝區寫入 nothing)。 如果`nCount`為非零值，而且小於點的數目在路徑中，傳回的值為-1。  
  
### <a name="remarks"></a>備註  
 裝置內容必須包含已關閉的路徑。 邏輯座標中，會傳回路徑的點。 因此儲存在裝置座標中的路徑點`GetPath`使用反目前轉換為邏輯座標變更點從裝置座標。 `FlattenPath`之前，可能呼叫成員函式`GetPath`，以在路徑中所有的曲線轉換成直線線段。  
  
### <a name="example"></a>範例  
  請參閱範例的[cdc:: beginpath](#beginpath)。  
  
##  <a name="getpixel"></a>CDC::GetPixel  
 擷取所指定的點像素的 RGB 色彩值*x*和*y*。  
  
```  
COLORREF GetPixel(
    int x,  
    int y) const;  
  
COLORREF GetPixel(POINT point) const;  
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要檢查點的邏輯 x 座標。  
  
 *y*  
 指定要檢查點的邏輯 y 座標。  
  
 `point`  
 指定邏輯 x 和 y 座標的檢查點。  
  
### <a name="return-value"></a>傳回值  
 函式，指定點的色彩的 RGB 色彩值的任一版本。 如果座標的裁剪區域中未指定的點，它會為-1。  
  
### <a name="remarks"></a>備註  
 裁剪區域必須是點。 如果沒有點的裁剪區域中，函式沒有任何作用，並傳回-1。  
  
 並非所有裝置都支援**GetPixel**函式。 如需詳細資訊，請參閱**RC_BITBLT**點陣功能底下[GetDeviceCaps](#getdevicecaps)成員函式。  
  
 **GetPixel**成員函式有兩種形式。 第一個會採用兩個座標的值;第二個會接受[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
##  <a name="getpolyfillmode"></a>CDC::GetPolyFillMode  
 擷取目前的多邊形填滿模式。  
  
```  
int GetPolyFillMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 目前的多邊形填滿模式，**替代**或**捲繞**，如果函式成功。  
  
### <a name="remarks"></a>備註  
 請參閱`SetPolyFillMode`的多邊形填滿模式描述的成員函式。  
  
##  <a name="getrop2"></a>CDC::GetROP2  
 擷取目前的繪圖模式。  
  
```  
int GetROP2() const;  
```  
  
### <a name="return-value"></a>傳回值  
 繪圖模式。 如需繪圖模式值的清單，請參閱`SetROP2`成員函式。  
  
### <a name="remarks"></a>備註  
 繪圖模式指定如何結合的畫筆色彩和填滿物件的內部使用的色彩顯示表面上已經存在。  
  
##  <a name="getsafehdc"></a>CDC::GetSafeHdc  
 呼叫此成員函式可取得[m_hDC](#m_hdc)，輸出裝置內容。  
  
```  
HDC GetSafeHdc() const;  
```  
  
### <a name="return-value"></a>傳回值  
 裝置內容控制代碼。  
  
### <a name="remarks"></a>備註  
 此成員函式也可以搭配 null 指標。  
  
##  <a name="getstretchbltmode"></a>CDC::GetStretchBltMode  
 擷取目前的點陣圖自動縮放模式。  
  
```  
int GetStretchBltMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 傳回值會指定目前的點陣圖自動縮放模式 — **STRETCH_ANDSCANS**， **STRETCH_DELETESCANS**，或**STRETCH_ORSCANS** — 如果函式成功。  
  
### <a name="remarks"></a>備註  
 點陣圖縮放模式可讓您定義資訊從延伸或壓縮點陣圖的移除方式`StretchBlt`成員函式。  
  
 **STRETCH_ANDSCANS**和**STRETCH_ORSCANS**模式通常用來保留前景單色點陣圖的像素。 **STRETCH_DELETESCANS**模式通常用來保留彩色點陣圖中的色彩。  
  
##  <a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent  
 呼叫此成員函式，來計算的寬度和高度的字元字串使用[m_hAttribDC](#m_hattribdc)，屬性的裝置內容。  
  
```  
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為-1，長度會計算。  
  
 `nTabPositions`  
 指定所指陣列中的定位停駐點位置數`lpnTabStopPositions`。  
  
 `lpnTabStopPositions`  
 指向陣列包含的邏輯單元的定位停駐點位置的整數。 必須排序定位停駐點，以遞增順序排列;最小的 x 值應該在陣列中的第一個項目。 不允許背景索引標籤。  
  
 `str`  
 A`CString`物件，其中包含要繪製指定的字元。  
  
### <a name="return-value"></a>傳回值  
 中的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 如果字串包含一個或多個 tab 字元，字串的寬度根據所指定的定位停駐點`lpnTabStopPositions`。 函式會使用目前選取的字型，計算字串的維度。  
  
 為目前裁剪區域不位移所傳回的高度與寬度`GetTabbedTextExtent`函式。  
  
 因為某些裝置並將字元放在規則資料格陣列中 （也就是它們微調字元），將字串中字元的範圍的總和可能不等於字串的範圍。  
  
 如果`nTabPositions`為 0 和`lpnTabStopPositions`是**NULL**，索引標籤會展開成八次的平均字元寬度。 如果`nTabPositions`為 1，第一個值的陣列中所指定的距離會分開定位停駐點`lpnTabStopPositions`點。 如果`lpnTabStopPositions`到多個單一值的點，每個值最多指定的數字陣列中設定定位停駐點`nTabPositions`。  
  
##  <a name="gettextalign"></a>CDC::GetTextAlign  
 擷取裝置內容的文字對齊旗標狀態。  
  
```  
UINT GetTextAlign() const;  
```  
  
### <a name="return-value"></a>傳回值  
 文字對齊方式的旗標的狀態。 傳回值是一或多個下列值：  
  
- **TA_BASELINE**指定對齊 x 軸和字型的週框矩形內的基準線。  
  
- **TA_BOTTOM**指定對齊 x 軸和週框矩形的底部。  
  
- **TA_CENTER**指定週框的中間和 y 軸的對齊方式。  
  
- **TA_LEFT**指定 y 軸，這個周框左邊的對齊方式。  
  
- **TA_NOUPDATECP**指定不會更新目前的位置。  
  
- **TA_RIGHT**指定 y 軸的對齊方式及週框的右側。  
  
- **TA_TOP**指定 x 軸和週框矩形頂端對齊。  
  
- **TA_UPDATECP**指定目前位置進行更新。  
  
### <a name="remarks"></a>備註  
 文字對齊方式的旗標決定如何`TextOut`和`ExtTextOut`成員函式對齊關於字串的起始點的文字字串。 文字對齊方式的旗標不一定是單一位元旗標，且可能是等於 0。 若要測試是否已設定旗標，應用程式應該遵循下列步驟：  
  
1.  將位元 OR 運算子套用至旗標和其相關的旗標，組成群組，如下所示：  
  
    - **TA_LEFT**， **TA_CENTER**，和**TA_RIGHT**  
  
    - **TA_BASELINE**， **TA_BOTTOM**，和**TA_TOP**  
  
    - **TA_NOUPDATECP**和**TA_UPDATECP**  
  
2.  適用於位元-和運算子的結果並傳回值`GetTextAlign`。  
  
3.  測試結果和旗標相等。  
  
##  <a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra  
 擷取 intercharacter 距離的目前設定。  
  
```  
int GetTextCharacterExtra() const;  
```  
  
### <a name="return-value"></a>傳回值  
 Intercharacter 的間距數量。  
  
### <a name="remarks"></a>備註  
 GDI 新增這個間距，包括分行符號字元，當它將一行文字寫入至裝置內容的每個字元。  
  
 Intercharacter 間距所需的預設值為 0。  
  
##  <a name="gettextcolor"></a>CDC::GetTextColor  
 擷取目前的文字色彩。  
  
```  
COLORREF GetTextColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 RGB 色彩值為目前的文字色彩。  
  
### <a name="remarks"></a>備註  
 文字色彩就是使用 GDI 文字輸出成員函式來繪製的字元的前景色彩[TextOut](#textout)， [ExtTextOut](#exttextout)，和[TabbedTextOut](#tabbedtextout)。  
  
##  <a name="gettextextent"></a>CDC::GetTextExtent  
 呼叫此成員函式的一行文字決定維度使用目前的字型高度與寬度計算。  
  
```  
CSize GetTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向字元的字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。  
  
 `str`  
 A`CString`物件，其中包含指定的字元。  
  
### <a name="return-value"></a>傳回值  
 中的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 從擷取的資訊[m_hAttribDC](#m_hattribdc)，屬性的裝置內容。  
  
 根據預設，`GetTextExtent`假設沿著水平列設定它會擷取維度的文字 （也就是斜度為 0）。 如果您建立指定非零斜度字型，您必須轉換明確地取得維度的字串文字的角度。  
  
 為目前裁剪區域不會影響所傳回的高度與寬度`GetTextExtent`。  
  
 因為某些裝置並將字元放在規則資料格陣列中 （也就是它們執行字元間距調整），請將字串中字元的範圍的總和可能不等於字串的範圍。  
  
##  <a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI  
 擷取指定的空間可容納和陣列填入每個字元的文字範圍的指定字串中的字元數目。  
  
```  
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,  
    int cgi,  
    int nMaxExtent,  
    LPINT lpnFit,  
    LPINT alpDx,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `pgiIn`  
 要擷取範圍的圖像索引的陣列指標。  
  
 `cgi`  
 所指陣列中指定的圖像數目`pgiIn`。  
  
 `nMaxExtent`  
 指定的最大可允許的寬度，以邏輯單位，表示的格式化字串。  
  
 `lpnFit`  
 接收的最大所指定的空間容納的字元數計數的整數指標`nMaxExtent`。 當`lpnFit`是**NULL**，`nMaxExtent`會被忽略。  
  
 *alpDx*  
 接收部分圖像範圍整數的陣列指標。 陣列中的每個項目提供的距離，以邏輯單位，表示圖像索引陣列的開頭與符合所指定的空間中的圖像`nMaxExtent`。 雖然這個陣列應該有至少多的項目，為所指定的圖像索引`cgi`，函式會填滿陣列所使用最多圖像索引時所指定的範圍`lpnFit`。 如果*lpnDx*是**NULL**，函式不會計算部分字串的寬度。  
  
 `lpSize`  
 指標[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)以邏輯單位表示收到的圖像索引陣列維度的結構。 這個值不能**NULL**。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936)、 Windows SDK 中所述。  
  
##  <a name="gettextextentpointi"></a>CDC::GetTextExtentPointI  
 擷取指定之圖像索引陣列的高度與寬度。  
  
```  
BOOL GetTextExtentPointI(
    LPWORD pgiIn,  
    int cgi,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `pgiIn`  
 要擷取範圍的圖像索引的陣列指標。  
  
 `cgi`  
 所指陣列中指定的圖像數目`pgiIn`。  
  
 `lpSize`  
 指標[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)以邏輯單位表示收到的圖像索引陣列維度的結構。 這個值不能**NULL**。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939)、 Windows SDK 中所述。  
  
##  <a name="gettextface"></a>CDC::GetTextFace  
 呼叫此成員函式複製到緩衝區的目前字型的字樣名稱。  
  
```  
int GetTextFace(
    int nCount,  
    LPTSTR lpszFacename) const;  
  
int GetTextFace(CString& rString) const;  
```  
  
### <a name="parameters"></a>參數  
 `nCount`  
 指定緩衝區的大小 （以位元組為單位）。 如果超過此參數所指定的位元組數目的字樣名稱，名稱將會被截斷。  
  
 *lpszFacename*  
 指向的字樣名稱的緩衝區。  
  
 `rString`  
 若要參考[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。  
  
### <a name="return-value"></a>傳回值  
 複製到緩衝區，不包括結束的 null 字元的位元組數目。 如果發生錯誤，它可以是 0。  
  
### <a name="remarks"></a>備註  
 以 null 結束的字串複製的字樣名稱。  
  
##  <a name="gettextmetrics"></a>CDC::GetTextMetrics  
 擷取目前使用屬性的裝置內容的字型度量資訊。  
  
```  
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpMetrics`  
 指向[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)接收度量的結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="getviewportext"></a>CDC::GetViewportExt  
 擷取，x-與 y-範圍的裝置內容的檢視區。  
  
```  
CSize GetViewportExt() const;  
```  
  
### <a name="return-value"></a>傳回值  
 X-與 y-範圍 （以裝置為單位） 為`CSize`物件。  
  
##  <a name="getviewportorg"></a>CDC::GetViewportOrg  
 擷取裝置內容相關聯的檢視區原點 x 和 y 座標。  
  
```  
CPoint GetViewportOrg() const;  
```  
  
### <a name="return-value"></a>傳回值  
 （以裝置座標表示） 做為檢視區原點`CPoint`物件。  
  
##  <a name="getwindow"></a>CDC::GetWindow  
 傳回顯示裝置內容相關聯的視窗。  
  
```  
CWnd* GetWindow() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CWnd`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 這是進階函式。 例如，此成員函式可能不會傳回 [檢視] 視窗，列印時，或在預覽列印中。 它一律會傳回與 output 相關聯的視窗。 使用指定的 DC 的輸出函式會繪製到這個視窗。  
  
##  <a name="getwindowext"></a>CDC::GetWindowExt  
 擷取，x-與 y-範圍相關聯的裝置內容的視窗。  
  
```  
CSize GetWindowExt() const;  
```  
  
### <a name="return-value"></a>傳回值  
 X-與 y-範圍 （以邏輯單位表示） 做為`CSize`物件。  
  
##  <a name="getwindoworg"></a>CDC::GetWindowOrg  
 擷取裝置內容相關聯的視窗原點 x 和 y 座標。  
  
```  
CPoint GetWindowOrg() const;  
```  
  
### <a name="return-value"></a>傳回值  
 間隔 （以邏輯座標） 做為來源`CPoint`物件。  
  
##  <a name="getworldtransform"></a>CDC::GetWorldTransform  
 擷取目前分頁空間轉換到全球的空間。  
  
```  
BOOL GetWorldTransform(XFORM& rXform) const;  
```  
  
### <a name="parameters"></a>參數  
 `rXform`  
 若要參考[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)接收目前世界空間分頁空間轉換的結構。  
  
### <a name="return-value"></a>傳回值  
 成功時傳回非零值。  
  
 在失敗時傳回 0。  
  
 若要取得延伸錯誤資訊，請呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953)。  
  
##  <a name="gradientfill"></a>CDC::GradientFill  
 呼叫此成員函式以順暢其他淡從一端的色彩填滿的矩形和三角形的結構。  
  
```  
BOOL GradientFill(
    TRIVERTEX* pVertices,  
    ULONG nVertices,  
    void* pMesh,  
    ULONG nMeshElements,  
    DWORD dwMode);
```  
  
### <a name="parameters"></a>參數  
 *pVertices*  
 陣列的指標[TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142)結構，每個會定義一個三角形的頂點。  
  
 *nVertices*  
 頂點數目。  
  
 `pMesh`  
 陣列[GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959)三角形模式或陣列中的結構[GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958)矩形模式中的結構。  
  
 *nMeshElements*  
 中的元素數目 （三角形或矩形） `pMesh`。  
  
 `dwMode`  
 指定漸層填滿模式。 如需可能值的清單，請參閱[GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957) Windows SDK 中。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果成功，否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 如需詳細資訊，請參閱`GradientFill`Windows SDK 中。  
  
##  <a name="graystring"></a>Cdc:: graystring  
 繪製寫入記憶體點陣圖中的文字、 變暗的點陣圖，並再將點陣圖複製到顯示灰色 （灰色） 在指定位置的文字。  
  
```  
virtual BOOL GrayString(
    CBrush* pBrush,  
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),  
    LPARAM lpData,  
    int nCount,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `pBrush`  
 識別要用於變暗 （對於） 筆刷。  
  
 `lpfnOutput`  
 指定字串，會繪製應用程式所提供的回呼函式的程序執行個體的位址。 如需詳細資訊，請參閱 Windows 說明**OutputFunc** [回呼函式](../../mfc/reference/callback-function-for-cdc-graystring.md)。 如果這個參數是**NULL**，系統會使用 Windows`TextOut`繪製字串的函式和`lpData`假設為輸出的字元字串的長指標。  
  
 `lpData`  
 指定要傳遞給輸出函式資料的遠端指標。 如果`lpfnOutput`是**NULL**，`lpData`必須是指向要輸出字串的長度。  
  
 `nCount`  
 指定要輸出的字元數。 如果這個參數是 0，`GrayString`計算字串的長度 (假設`lpData`是字串的指標)。 如果`nCount`為-1，且所指向之函式`lpfnOutput`傳回 0 時，映像時顯示，但是未呈現灰色。  
  
 *x*  
 指定包圍字串的矩形的開始位置的邏輯 x 座標。  
  
 *y*  
 指定包圍字串的矩形的開始位置的邏輯 y 座標。  
  
 `nWidth`  
 指定包圍字串的矩形的寬度 （以邏輯單位表示）。 如果`nWidth`為 0，`GrayString`計算寬度，假設`lpData`是字串的指標。  
  
 `nHeight`  
 指定包圍字串的矩形的高度 （以邏輯單位表示）。 如果`nHeight`為 0，`GrayString`計算區域的高度假設`lpData`是字串的指標。  
  
### <a name="return-value"></a>傳回值  
 如果在繪製字串時，則為非零或 0，如果有任一個`TextOut`函式或應用程式所提供的輸出函式傳回 0，或如果沒有記憶體不足，無法建立變暗的記憶體點陣圖。  
  
### <a name="remarks"></a>備註  
 此函式變暗的文字，不論所選的筆刷和背景。 `GrayString`成員函式會使用目前選取的字型。 `MM_TEXT`必須選擇對應模式，才能使用這個函式。  
  
 應用程式可以支援全灰色而不需呼叫的裝置上繪製呈現暗灰色 （灰色） 字串`GrayString`成員函式。 系統色彩**COLOR_GRAYTEXT**為用來繪製已停用的文字的實線灰色系統色彩。 應用程式可以呼叫**GetSysColor** Windows 函式可擷取的色彩值**COLOR_GRAYTEXT**。 如果 color 是 0 （黑色） 以外，應用程式可以呼叫`SetTextColor`成員函式來設定文字色彩的色彩值，然後直接繪製的字串。 如果擷取的色彩為黑色，應用程式必須呼叫`GrayString`變暗的方法 （灰色） 文字。  
  
 如果`lpfnOutput`是**NULL**，GDI 會使用 Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133)函式，和`lpData`假設為輸出字元的遠端指標。 如果要輸出的字元不能由處理`TextOut`成員函式 （例如，字串會儲存為點陣圖，） 應用程式必須提供自己的輸出函式。  
  
 也請注意所有的回呼函式必須再傳回給 Windows，，因為無法跨回呼界限擲回例外狀況設陷 Mfc 例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。  
  
 回呼函式傳遞至`GrayString`必須使用`__stdcall`呼叫慣例，而且必須與匯出`__declspec`。  
  
 當架構處於預覽模式，請呼叫`GrayString`成員函式會轉譯為`TextOut`呼叫和回呼函式未呼叫。  
  
##  <a name="himetrictodp"></a>CDC::HIMETRICtoDP  
 使用此函式，當您轉換**HIMETRIC** OLE 像素為單位的大小。  
  
```  
void HIMETRICtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 裝置內容物件的對應模式是否`MM_LOENGLISH`， `MM_HIENGLISH`，`MM_LOMETRIC`或`MM_HIMETRIC`，則轉換會根據實體英吋的像素數目。 如果對應模式是一種其他非限制模式 (例如`MM_TEXT`)，然後轉換為基礎的邏輯英吋的像素數目。  
  
##  <a name="himetrictolp"></a>CDC::HIMETRICtoLP  
 呼叫此函式可將轉換**HIMETRIC**成邏輯單元的單位。  
  
```  
void HIMETRICtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 使用此函式，當您取得**HIMETRIC**大小為 OLE 和想要將它們轉換成應用程式的自然對應模式。  
  
 轉換透過第一個轉換**HIMETRIC**單位為像素為單位，然後再將這些單位轉換成使用裝置內容的目前對應單位的邏輯單元。 請注意的裝置 視窗和檢視區的範圍，會影響結果。  
  
##  <a name="intersectcliprect"></a>CDC::IntersectClipRect  
 建立新的裁剪區域所形成的目前地區和所指定的矩形的交集`x1`， `y1`， `x2`，和`y2`。  
  
```  
int IntersectClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int IntersectClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定邏輯之矩形左上角的 x 座標。  
  
 `y1`  
 指定矩形左上角的邏輯 y 座標。  
  
 `x2`  
 指定矩形右下角的邏輯 x 座標。  
  
 `y2`  
 指定矩形右下角的邏輯 y 座標。  
  
 `lpRect`  
 指定的矩形。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
### <a name="return-value"></a>傳回值  
 新的裁剪區域類型。 它可以是下列值之一：  
  
- **COMPLEXREGION**新裁剪區域具有重疊的框線。  
  
- **錯誤**裝置內容不正確。  
  
- **NULLREGION**新裁剪區域是空的。  
  
- **SIMPLEREGION**新裁剪區域有任何重疊的框線。  
  
### <a name="remarks"></a>備註  
 GDI 裁剪以符合新的界限內所有後續的輸出。 寬度和高度不得超過 32767。  
  
##  <a name="invertrect"></a>CDC::InvertRect  
 反轉指定的矩形的內容。  
  
```  
void InvertRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向`RECT`，其中包含要反轉矩形的邏輯座標。 您也可以傳遞`CRect`這個參數的物件。  
  
### <a name="remarks"></a>備註  
 反轉是邏輯作業，並是翻轉的每個像素的位元。 在單色顯示器，此函式對於白色像素的黑色和黑色的像素白色。 色彩的顯示中，在反轉取決於如何產生色彩的顯示。 呼叫`InvertRect`兩次以相同的矩形會顯示還原至其先前的色彩。  
  
 如果是空的矩形，不繪製任何內容。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  
  
##  <a name="invertrgn"></a>CDC::InvertRgn  
 反轉所指定的區域中的色彩`pRgn`。  
  
```  
BOOL InvertRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 識別要反轉的區域。 以邏輯單位表示指定的區域的座標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 在單色顯示器，此函式對於白色像素的黑色和黑色的像素白色。 色彩的顯示中，在反轉取決於如何顯示產生的色彩。  
  
##  <a name="isprinting"></a>CDC::IsPrinting  
 決定是否正在使用的裝置內容進行列印。  
  
```  
BOOL IsPrinting() const;  
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果`CDC`物件是印表機 DC; 否則為 0。  
  
##  <a name="lineto"></a>CDC::LineTo  
 從目前的位置，但不是包括，所指定的點繪製一條線*x*和*y* (或`point`)。  
  
```  
BOOL LineTo(
    int x,  
    int y);  
  
BOOL LineTo(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定線條的端點的邏輯 x 座標。  
  
 *y*  
 指定線條的端點的邏輯 y 座標。  
  
 `point`  
 指定線條的端點。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果繪製線條。否則便是 0。  
  
### <a name="remarks"></a>備註  
 使用所選畫筆繪製線條。 目前的位置會設定為*x*， *y*或`point`。  
  
### <a name="example"></a>範例  
  請參閱範例的[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。  
  
##  <a name="lptodp"></a>CDC::LPtoDP  
 將邏輯單元轉換成裝置單位。  
  
```  
void LPtoDP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列的點。 陣列中的每個點都[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
 `nCount`  
 陣列中的點數目。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 使用這個參數是對應到裝置單位從邏輯矩形的常見案例。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 此函式會在每個點的座標或維度大小，從裝置座標系統的 GDI 邏輯座標系統的對應。 轉換取決於目前的對應模式和來源的設定和裝置的視窗和檢視區的範圍。  
  
 X 和 y 座標的點是範圍-32,768 到 32,767 的 2 位元組帶正負號的整數。 在其中的對應模式會產生值大於這些限制的情況下，系統會將值設-32,768 璅 32,767，分別。  
  
##  <a name="lptohimetric"></a>CDC::LPtoHIMETRIC  
 呼叫此函式可將轉換成邏輯單元**HIMETRIC**單位。  
  
```  
void LPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向**大小**結構或`CSize`物件。  
  
### <a name="remarks"></a>備註  
 使用此函式，當您授與**HIMETRIC**至 OLE，從您的應用程式的自然對應模式轉換的大小。 請注意的裝置 視窗和檢視區的範圍，會影響結果。  
  
 轉換透過第一個轉換邏輯單位為像素使用裝置內容的目前對應單位，然後將轉換成這些單位**HIMETRIC**單位。  
  
##  <a name="m_hattribdc"></a>CDC::m_hAttribDC  
 這個屬性的裝置內容`CDC`物件。  
  
```  
HDC m_hAttribDC;  
```  
  
### <a name="remarks"></a>備註  
 根據預設，這個裝置內容等於`m_hDC`。 一般情況下， `CDC` GDI 呼叫要求資訊從裝置內容會被導向至`m_hAttribDC`。 請參閱[CDC](../../mfc/reference/cdc-class.md)類別描述如需有關使用這些兩個裝置內容。  
  
##  <a name="m_hdc"></a>CDC::m_hDC  
 輸出裝置內容，這個`CDC`物件。  
  
```  
HDC m_hDC;  
```  
  
### <a name="remarks"></a>備註  
 根據預設，`m_hDC`等於`m_hAttribDC`，其他所包裝的裝置內容`CDC`。 一般情況下，`CDC`建立輸出的 GDI 呼叫移至`m_hDC`裝置內容。 您可以初始化`m_hDC`和`m_hAttribDC`指向不同的裝置。 請參閱[CDC](../../mfc/reference/cdc-class.md)類別描述如需有關使用這些兩個裝置內容。  
  
##  <a name="maskblt"></a>CDC::MaskBlt  
 結合使用給定的遮罩和點陣作業的來源和目的地點陣圖的色彩資料。  
  
```  
BOOL MaskBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定目的地矩形的左上角的邏輯 x 座標。  
  
 *y*  
 指定目的地矩形的左上角的邏輯 y 座標。  
  
 `nWidth`  
 指定邏輯單元，目的地矩形和來源點陣圖的寬度。  
  
 `nHeight`  
 指定邏輯單元，目的地矩形和來源點陣圖的高度。  
  
 `pSrcDC`  
 識別裝置內容的複製來源點陣圖。 它必須是零如果*dwRop*參數會指定不包含來源的點陣作業。  
  
 `xSrc`  
 指定邏輯來源點陣圖的左上角的 x 座標。  
  
 `ySrc`  
 指定的來源點陣圖的左上角的邏輯 y 座標。  
  
 `maskBitmap`  
 識別結合色彩的點陣圖，來源裝置內容中的遮罩單色點陣圖。  
  
 `xMask`  
 指定所指定的遮罩點陣圖的像素水平位移`maskBitmap`參數。  
  
 `yMask`  
 指定所指定的遮罩點陣圖的垂直的像素位移`maskBitmap`參數。  
  
 *dwRop*  
 指定前景和背景三元點陣作業程式碼，用來控制的來源和目的地資料組合的函式。 背景的點陣作業程式碼儲存在此值; 高字其高位元前景點陣作業程式碼儲存在高的字組，此值; 的低位元組低序位文字這個值會被忽略，而且必須為零。 巨集**MAKEROP4**點陣作業程式碼會建立這類的前景和背景的組合。 請參閱 < 備註 > 一節討論的前景和背景，此函式的內容中。 請參閱`BitBlt`成員函式，如需常見的點陣作業程式碼的清單。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 值為 1 中所指定的遮罩`maskBitmap`表示前景點陣作業程式碼會指定由*dwRop*應該套用在該位置。 遮罩中的 0 值表示所指定背景的點陣作業程式碼*dwRop*應該套用在該位置。 點陣作業需要來源，遮罩矩形必須涵蓋來源矩形。 如果不存在，此函式會失敗。 點陣作業則不需要為來源，遮罩矩形必須涵蓋滿目的矩形。 如果不存在，此函式會失敗。  
  
 如果旋轉或傾斜轉換是作用中來源裝置內容中，呼叫此函式時，就會發生錯誤。 不過，允許其他類型的轉換。  
  
 如果來源、 模式和目的地點陣圖的色彩格式不同，此函式會將轉換模式或來源格式，或兩者，以符合目的格式。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 當記錄的增強型中繼檔時，發生錯誤 （和函式會傳回 0） 如果來源裝置內容找出的增強型中繼檔裝置內容。 並非所有裝置都支援`MaskBlt`。 應用程式應該呼叫`GetDeviceCaps`來判斷裝置是否支援此函式。 如果沒有提供任何遮罩點陣圖，此函式的行為完全一樣`BitBlt`，使用前景點陣作業程式碼。 來源裝置內容的點陣圖中的點 (0，0) 的遮罩點陣圖對應中位移的像素。 這適用於包含一組遮罩; 之遮罩點陣圖的情況下應用程式可以輕鬆地套用其中任何一個遮罩單色工作藉由調整像素偏移和矩形大小傳送至`MaskBlt`。  
  
##  <a name="modifyworldtransform"></a>CDC::ModifyWorldTransform  
 變更裝置內容中使用指定的模式的自然轉換。  
  
```  
BOOL ModifyWorldTransform(
    const XFORM& rXform,  
    DWORD iMode);
```  
  
### <a name="parameters"></a>參數  
 `rXform`  
 若要參考[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)用來修改給定的裝置內容的自然轉換的結構。  
  
 `iMode`  
 指定轉換資料修改目前的自然變換的方式。 如需這個參數可以接受的值，請參閱[ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)。  
  
### <a name="return-value"></a>傳回值  
 成功時傳回非零值。  
  
 在失敗時傳回 0。  
  
 若要取得延伸錯誤資訊，請呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)。  
  
##  <a name="moveto"></a>CDC::MoveTo  
 目前的位置移至指定的點*x*和*y* (或由`point`)。  
  
```  
CPoint MoveTo(
    int x,  
    int y);  
  
CPoint MoveTo(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新位置的邏輯 x 座標。  
  
 *y*  
 指定新位置的邏輯 y 座標。  
  
 `point`  
 指定新位置。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 先前的位置，以 x 和 y 座標`CPoint`物件。  
  
### <a name="example"></a>範例  
  請參閱範例的[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。  
  
##  <a name="offsetcliprgn"></a>CDC::OffsetClipRgn  
 將指定的位移移動裝置內容的裁剪區域。  
  
```  
int OffsetClipRgn(
    int x,  
    int y);  
  
int OffsetClipRgn(SIZE size);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要向左移動或向右的邏輯單元數目。  
  
 *y*  
 指定要上移或下移的邏輯單元數目。  
  
 `size`  
 指定的位移數量。  
  
### <a name="return-value"></a>傳回值  
 新的區域類型。 它可以是下列值之一：  
  
- **COMPLEXREGION**裁剪區域具有重疊的框線。  
  
- **錯誤**裝置內容不正確。  
  
- **NULLREGION**裁剪區域是空的。  
  
- **SIMPLEREGION**裁剪區域有任何重疊的框線。  
  
### <a name="remarks"></a>備註  
 此函式移動區域*x*沿著 x 軸單位並*y*沿著 y 軸的單位。  
  
##  <a name="offsetviewportorg"></a>CDC::OffsetViewportOrg  
 修改檢視區原點，相對於目前的檢視區原點座標的座標。  
  
```  
virtual CPoint OffsetViewportOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `nWidth`  
 指定將新增至目前的原點的 x 座標的裝置單位數目。  
  
 `nHeight`  
 指定將新增至目前的原點的 y 座標的裝置單位數目。  
  
### <a name="return-value"></a>傳回值  
 前一個檢視區的原點 （以裝置座標表示） 做為`CPoint`物件。  
  
##  <a name="offsetwindoworg"></a>CDC::OffsetWindowOrg  
 修改視窗原點，相對於目前視窗原點座標的座標。  
  
```  
CPoint OffsetWindowOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `nWidth`  
 指定將新增至目前的原點的 x 座標的邏輯單元數目。  
  
 `nHeight`  
 指定將新增至目前的原點的 y 座標的邏輯單元數目。  
  
### <a name="return-value"></a>傳回值  
 前一個視窗原點 （以邏輯座標表示） 做為`CPoint`物件。  
  
##  <a name="operator_hdc"></a>CDC::operator HDC  
 使用此運算子來擷取裝置內容控制代碼的`CDC`物件。  
  
```  
operator HDC() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功，裝置內容物件; 的控制代碼否則， **NULL**。  
  
### <a name="remarks"></a>備註  
 您可以直接呼叫 Windows Api 中使用控制代碼。  
  
##  <a name="paintrgn"></a>CDC::PaintRgn  
 所指定的區域填滿`pRgn`使用目前的筆刷。  
  
```  
BOOL PaintRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 識別要填滿區域。 以邏輯單位表示指定的給定區域座標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="patblt"></a>CDC::PatBlt  
 裝置上建立的位元模式。  
  
```  
BOOL PatBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要接收模式矩形左上角的邏輯 x 座標。  
  
 *y*  
 指定要接收模式矩形左上角的邏輯 y 座標。  
  
 `nWidth`  
 指定要接收模式的矩形的寬度 （以邏輯單位表示）。  
  
 `nHeight`  
 指定要接收模式的矩形的高度 （以邏輯單位表示）。  
  
 *dwRop*  
 指定的點陣作業程式碼。 點陣作業程式碼 (ROPs) 定義 GDI 結合在輸出作業牽涉到目前的筆刷、 可能的來源點陣圖和目的地點陣圖中色彩的方式。 這個參數可以是下列值之一：  
  
- **PATCOPY**複製到目的地點陣圖的模式。  
  
- **PATINVERT**模式使用布林值 XOR 運算子合併目的地點陣圖。  
  
- **DSTINVERT**反轉目的地點陣圖。  
  
- **BLACKNESS**所有將輸出的變成黑色。  
  
- **WHITENESS**所有將輸出的變成白色。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 模式是選取的筆刷和已在裝置上的模式的組合。 所指定的點陣作業程式碼*dwRop*定義模式的組合方式。 這個函式所列的點陣作業會完整 256 三元的點陣作業程式碼中的有限的子集特別是，是指來源的點陣作業程式碼不能使用。  
  
 並非所有的裝置內容支援`PatBlt`函式。 若要判斷裝置內容是否支援`PatBlt`，呼叫`GetDeviceCaps`成員函式**cdc:: GETDEVICECAPS**索引並檢查傳回值，如**RC_BITBLT**旗標。  
  
##  <a name="pie"></a>CDC::Pie  
 藉由繪製橢圓形弧線的置中與兩個端點會聯結線條繪製派形的楔形。  
  
```  
BOOL Pie(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示），這個周框左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示），這個周框左上角的 y 座標。  
  
 `x2`  
 指定 （以邏輯單位表示），這個周框的右下角的 x 座標。  
  
 `y2`  
 指定 （以邏輯單位表示），這個周框的右下角的 y 座標。  
  
 *x3*  
 指定的弧度 （以邏輯單位表示） 的起始點的 x 座標。 此時沒有完全位於弧線。  
  
 `y3`  
 指定的弧度 （以邏輯單位表示） 的起始點的 y 座標。 此時沒有完全位於弧線。  
  
 `x4`  
 指定弧線的端點 （在邏輯單位表示） 的 x 座標。 此時沒有完全位於弧線。  
  
 `y4`  
 指定弧線的端點 （在邏輯單位表示） 的 y 座標。 此時沒有完全位於弧線。  
  
 `lpRect`  
 指定的周框。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
 `ptStart`  
 指定弧線的起點。此時沒有完全位於弧線。您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
 `ptEnd`  
 指定弧線的端點。此時沒有完全位於弧線。您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 弧線的中心是所指定的週框矩形的中心`x1`， `y1`， `x2`，和`y2`(或由`lpRect`)。 所指定的開始和結束點弧線*x3*， `y3`， `x4`，和`y4`(或由`ptStart`和`ptEnd`)。  
  
 使用選取的畫筆，移動以逆時針方向繪製弧形。 兩個額外的線條會繪製弧線的中心從每個端點。 目前的筆刷填滿的派形區域。 如果*x3*等於`x4`和`y3`等於`y4`，結果是以單行從橢圓形的中心點的橢圓形 ( *x3*， `y3`) 或 ( `x4`, `y4`).  
  
 此函式所繪製的圖最多延伸，但不包含右側和底部的座標。 這表示圖的高度是`y2`  -  `y1`圖的寬度，且`x2`  -  `x1`。 週框的高度和寬度必須大於 2 的單位和小於 32,767 個單位。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  
  
##  <a name="playmetafile"></a>CDC::PlayMetaFile  
 播放裝置內容上的指定中繼檔的內容。  
  
```  
BOOL PlayMetaFile(HMETAFILE hMF);

 
BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,  
    LPCRECT lpBounds);
```  
  
### <a name="parameters"></a>參數  
 *hMF*  
 識別要播放的中繼檔。  
  
 *hEnhMetaFile*  
 識別增強型中繼檔。  
  
 `lpBounds`  
 指向`RECT`結構或`CRect`物件，其中包含用來顯示圖片，這個周框的座標。 以邏輯單位表示指定的座標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 中繼檔就可以播放次數。  
  
 第二個版本`PlayMetaFile`顯示儲存在給定的格式增強型中繼檔中的圖片。 當應用程式呼叫第二個版本`PlayMetaFile`，Windows 使用增強型中繼檔標頭中對應到所指向的矩形圖片相框`lpBounds`參數。 (這張圖片可能修剪或藉由設定全局轉換中的輸出裝置，然後再呼叫旋轉`PlayMetaFile`。)矩形的邊緣點包含在圖片中。 藉由定義輸出裝置中的裁剪區域，然後再播放增強型中繼檔，也可裁剪增強型中繼檔圖片。  
  
 增強型中繼檔包含選擇性的調色盤，如果應用程式可以藉由設定色彩調色盤上的輸出裝置，然後再呼叫第二個版本達到一致的色彩`PlayMetaFile`。 若要擷取的選擇性的調色盤，請使用**GetEnhMetaFilePaletteEntries** Windows 函式。 增強型中繼檔可以內嵌在新建立的增強型中繼檔中，藉由呼叫第二個版本`PlayMetaFile`和播放放入裝置內容的來源增強型中繼檔，新的增強型中繼檔。  
  
 輸出裝置內容的狀態會保留此函式。 此函式會刪除任何物件建立，但不是會刪除增強型中繼檔中。 若要停止此函式，呼叫應用程式可以**CancelDC** Windows 函式，從另一個執行緒終止作業。 在此情況下，函數會傳回零。  
  
##  <a name="plgblt"></a>CDC::PlgBlt  
 在來源裝置內容中指定的矩形的色彩資料位元的位元區塊傳輸，執行至指定的裝置內容中指定的平行四邊形中。  
  
```  
BOOL PlgBlt(
    LPPOINT lpPoint,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nWidth,  
    int nHeight,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask);
```  
  
### <a name="parameters"></a>參數  
 `lpPoint`  
 指向陣列識別目的地平行四邊形的三個角落的邏輯空間中的三個點。 來源矩形左上角會對應到這個陣列、 右上角，以在這個陣列中的第二個點和第三個點的左下角中的第一個點。 來源矩形的右下角會對應至的平行四邊形中隱含的第四個點。  
  
 `pSrcDC`  
 識別來源裝置內容。  
  
 `xSrc`  
 指定邏輯單元，來源矩形左上角的 x 軸座標。  
  
 `ySrc`  
 指定邏輯單元，來源矩形左上角的 y 座標。  
  
 `nWidth`  
 指定邏輯單元，來源矩形的寬度。  
  
 `nHeight`  
 指定邏輯單元，來源矩形的高度。  
  
 `maskBitmap`  
 識別用來遮罩來源矩形的色彩選擇性單色點陣圖。  
  
 `xMask`  
 指定單色點陣圖左上角的 x 座標。  
  
 `yMask`  
 指定單色點陣圖左上角的 y 座標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 如果指定的位元遮罩的控制代碼識別有效的單色點陣圖，此函數會使用此點陣圖遮罩從來源矩形的色彩資料位元。  
  
 定義平行四邊形 (D) 的第四個頂點藉由將前三個點 （A、 B 和 C） 做為向量和運算 D = B + C-a。  
  
 如果存在位元遮罩，1 遮罩中的值會指出來源像素色彩的應該複製到目的地。 遮罩中的 0 值表示目的地的像素色彩不會變更。  
  
 如果遮罩矩形小於來源和目的矩形，函式會將複寫的遮罩模式。  
  
 在 來源裝置內容中; 允許縮放、 轉移和反映轉換不過，旋轉及傾斜轉換不。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 目的地裝置內容的縮放模式用來判斷如何縮放或壓縮的像素為單位，這是必要。 當記錄的增強型中繼檔時，如果來源裝置內容中識別的增強型中繼檔裝置內容，就會發生錯誤。  
  
 目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。 如果來源轉換旋轉或傾斜，則會傳回錯誤。 如果目的地和來源矩形沒有相同的色彩格式`PlgBlt`轉換來源矩形以符合目的地矩形。 並非所有裝置都支援`PlgBlt`。 如需詳細資訊，請參閱描述**RC_BITBLT**點陣功能`CDC::GetDeviceCaps`成員函式。  
  
 如果來源和目的地裝置內容代表不相容的裝置，`PlgBlt`會傳回錯誤。  
  
##  <a name="polybezier"></a>CDC::PolyBezier  
 繪製一或多個 Bzier 曲線。  
  
```  
BOOL PolyBezier(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)資料結構，包含端點以及 spline(s) 點。  
  
 `nCount`  
 指定的中點數目`lpPoints`陣列。 此值必須是其中一個曲線要繪製的數目超過三次，因為每個 Bzier 曲線需要兩個控制點，以及初始曲線需要額外的起點。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式使用的端點和所指定的控制點繪製三次方 Bzier 曲線`lpPoints`參數。 第一個曲線會繪製從第一個點的第四個點所使用的第二個和第三個點做為控制點。 每個後續的曲線順序必須正好是三個的多個點： 上一個曲線的結束點是做為起點，序列中的下面兩個點是控點，而且第三個結束點。  
  
 目前的位置是使用都由更新`PolyBezier`函式。 此圖不會填滿。 此函式會使用目前的畫筆繪製線條。  
  
##  <a name="polybezierto"></a>CDC::PolyBezierTo  
 繪製一或多個 Bzier 曲線。  
  
```  
BOOL PolyBezierTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)點包含端點和控制項的資料結構。  
  
 `nCount`  
 指定的中點數目`lpPoints`陣列。 此值必須是三次曲線要繪製的數目，因為每個 Bzier 曲線需要兩個控點和結束點。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式使用所指定的控制點繪製三次方 Bzier 曲線`lpPoints`參數。 第一個曲線會繪製從目前位置的第三個點所使用的前兩個點做為控制點。 針對每個後續的曲線，函數需要正好是三個點，並做為起點的上一個曲線的結束點用於下一步。 `PolyBezierTo`將目前位置移至最後一個 Bzier 曲線結束點。 此圖不會填滿。 此函式會使用目前的畫筆繪製線條。  
  
### <a name="example"></a>範例  
  請參閱範例的[cdc:: beginpath](#beginpath)。  
  
##  <a name="polydraw"></a>CDC::PolyDraw  
 繪製一組直線線段和 Bzier 曲線。  
  
```  
BOOL PolyDraw(
    const POINT* lpPoints,  
    const BYTE* lpTypes,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)資料結構所包含的端點，每個直線線段與端點，並控制每個 Bzier 曲線的點。  
  
 `lpTypes`  
 指向陣列，指定如何在每個點中`lpPoints`用陣列。 值可以是下列其中一項：  
  
- **PT_MOVETO**指定此點開始脫離的圖形。 這點就會成為新的目前位置。  
  
- **PT_LINETO**指定要從目前位置到這個點，就會變成新的目前位置繪製一條線。  
  
- **PT_BEZIERTO**指定此點是一個控制點或 Bzier 曲線的結束點。  
  
 **PT_BEZIERTO**類型一律出現三個的集合。 目前的位置定義 Bzier 曲線的開始點。 前兩個**PT_BEZIERTO**點是第三個控制點， **PT_BEZIERTO**點是結束點。 結束點會成為新的目前位置。 如果沒有三個連續**PT_BEZIERTO**點、 錯誤結果。  
  
     A **PT_LINETO**或**PT_BEZIERTO**類型可以結合下列常數使用位元運算子，或關閉來指出對應的點圖及圖中的最後一個點:  
  
- **PT_CLOSEFIGURE**後自動關閉此圖中的指定**PT_LINETO**或**PT_BEZIERTO**輸入完成此點。 從這個點繪製線條最新**PT_MOVETO**或`MoveTo`點。  
  
     這個旗標會結合**PT_LINETO**類型的線條，或使用**PT_BEZIERTO**類型使用的位元結束點 Bzier 曲線，`OR`運算子。 目前的位置設定為終點的結尾行。  
  
 `nCount`  
 指定的中點總數`lpPoints`陣列中的位元組數目相同`lpTypes`陣列。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式可以用來繪製不相鄰的數字取代連續呼叫`CDC::MoveTo`， `CDC::LineTo`，和`CDC::PolyBezierTo`成員函式。 線條和曲線會使用目前的畫筆繪製和圖表並沒有填滿。 如果沒有使用中的路徑，藉由呼叫啟動`CDC::BeginPath`成員函式，`PolyDraw`將加入路徑。 中所包含的點`lpPoints`陣列和`lpTypes`表示每個點是否屬於`CDC::MoveTo`、 `CDC::LineTo`，或**CDC::BezierTo**作業。 它也可關閉圖表。 此函式會更新目前的位置。  
  
### <a name="example"></a>範例  
  請參閱範例的[cdc:: beginpath](#beginpath)。  
  
##  <a name="polygon"></a>CDC::Polygon  
 繪製多邊形，其包含兩個或多個點 （端點） 透過線路連線，使用目前的畫筆。  
  
```  
BOOL Polygon(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列的指定多邊形的頂點的點。 陣列中的每個點都**點**結構或`CPoint`物件。  
  
 `nCount`  
 陣列中指定頂點的數目。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 系統多邊形會自動關閉，如有必要，藉由從最後一個頂點繪製一條線，第一個。  
  
 目前的多邊形填滿模式可擷取或設定使用`GetPolyFillMode`和`SetPolyFillMode`成員函式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  
  
##  <a name="polyline"></a>CDC::Polyline  
 繪製連接所指定的點之直線線段的一組`lpPoints`。  
  
```  
BOOL Polyline(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列**點**結構或`CPoint`連接物件。  
  
 `nCount`  
 陣列中指定的點數。 此值必須至少為 2。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 線條會繪製從透過使用目前的畫筆的後續點的第一個點。 不同於`LineTo`成員函式，`Polyline`函式不會使用，也不會更新目前的位置。  
  
 如需詳細資訊，請參閱[聚合線條](http://msdn.microsoft.com/library/windows/desktop/dd162815)Windows SDK 中。  
  
##  <a name="polylineto"></a>CDC::PolylineTo  
 繪製一或多個直線。  
  
```  
BOOL PolylineTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)包含線條的頂點的資料結構。  
  
 `nCount`  
 陣列中指定的點數。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 從目前的位置繪製線條所指定的第一個點`lpPoints`參數使用目前的畫筆。 每一個額外的行，函式用來繪製之結束點的上一行從所指定的下一個指標`lpPoints`。 `PolylineTo`將目前位置移至之結束點的最後一行。 如果這個函式所繪製之直線線段形成封閉的圖表，此圖不會填滿。  
  
##  <a name="polypolygon"></a>CDC::PolyPolygon  
 建立兩個或多個使用目前的多邊形填滿模式會填滿的多邊形。  
  
```  
BOOL PolyPolygon(
    LPPOINT lpPoints,  
    LPINT lpPolyCounts,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列**點**結構或`CPoint`定義的多邊形頂點的物件。  
  
 `lpPolyCounts`  
 指向陣列的整數，其中每個指定的點數內之多邊形的其中一個`lpPoints`陣列。  
  
 `nCount`  
 中的項目數`lpPolyCounts`陣列。 此數字會指定要繪製多邊形的數目。 此值必須至少為 2。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 脫離或重疊，則可能是多邊形。  
  
 每個呼叫中指定的多邊形`PolyPolygon`函式必須先關閉。 不同於所建立的多邊形**多邊形**成員函式，所建立之多邊形`PolyPolygon`不會自動關閉。  
  
 函式會建立兩個或多個多邊形。 若要建立單一的多邊形，應用程式應該使用**多邊形**成員函式。  
  
 目前的多邊形填滿模式可擷取或設定使用`GetPolyFillMode`和`SetPolyFillMode`成員函式。  
  
##  <a name="polypolyline"></a>CDC::PolyPolyline  
 繪製連接的直線線段的多個數列。  
  
```  
BOOL PolyPolyline(
    const POINT* lpPoints,  
    const DWORD* lpPolyPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列的結構，其中包含聚合線條的端點。 聚合線條會指定連續。  
  
 `lpPolyPoints`  
 指向指定的點數中的變數陣列`lpPoints`對應之多邊形的陣列。 每個項目必須是大於或等於 2。  
  
 `nCount`  
 指定總數中計數的`lpPolyPoints`陣列。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 使用目前的畫筆繪製之直線線段。 區段所形成的數字不會填滿。 目前的位置是使用都更新此函式。  
  
##  <a name="ptvisible"></a>CDC::PtVisible  
 判斷指定的點是否在裝置內容的裁剪區域中。  
  
```  
virtual BOOL PtVisible(
    int x,  
    int y) const;  
  
BOOL PtVisible(POINT point) const;  
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定點的邏輯 x 座標。  
  
 *y*  
 指定點的邏輯 y 座標。  
  
 `point`  
 指定要檢查的邏輯座標的點。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果指定的點中的裁剪區域; 非零，否則便是 0。  
  
##  <a name="queryabort"></a>CDC::QueryAbort  
 所安裝的中止函式會呼叫[SetAbortProc](#setabortproc)是否應該終止列印成員函式列印的應用程式和查詢。  
  
```  
BOOL QueryAbort() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果應該繼續列印，或沒有中止程序則為非零的傳回值。 如果應終止列印工作，它會為 0。 Abort 函式提供傳回值。  
  
##  <a name="realizepalette"></a>CDC::RealizePalette  
 將對應從目前的邏輯色板到系統調色盤項目。  
  
```  
UINT RealizePalette();
```  
  
### <a name="return-value"></a>傳回值  
 表示邏輯調色盤中的項目數量已對應至不同系統調色盤中的項目。 這代表此函式重新對應至配合系統調色盤中的變更，因為邏輯色板上次倍的項目數。  
  
### <a name="remarks"></a>備註  
 邏輯色板作用是緩衝區大量色彩的應用程式和系統，可讓應用程式使用許多視需要而不妨礙處理自己的色彩顯示色彩之間或與其他視窗所顯示的色彩。  
  
 當視窗具有輸入的焦點時，呼叫`RealizePalette`，Windows 會確保此視窗會顯示所有要求的色彩，最多同時在螢幕上可用的最大數目。 Windows 也會顯示找不到視窗的調色盤中的其比對時可用的色彩的色彩。  
  
 此外，Windows 會比對非使用中視窗的可用色彩儘可能密集地呼叫的函式所要求的色彩。 這會大幅降低不需要變更在非使用中視窗中顯示的色彩。  
  
##  <a name="rectangle"></a>CDC::Rectangle  
 繪製矩形，使用目前的畫筆。  
  
```  
BOOL Rectangle(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Rectangle(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 y 座標。  
  
 `x2`  
 指定 （以邏輯單位表示） 的矩形右下角的 x 座標。  
  
 `y2`  
 指定 （以邏輯單位表示） 的矩形右下角的 y 座標。  
  
 `lpRect`  
 以邏輯單位表示指定的矩形。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 矩形的內部會使用目前的筆刷填滿。  
  
 矩形會擴充最多至但不包含，右側和底部的座標。 這表示的矩形的高度是`y2`  -  `y1`矩形的寬度，且`x2`  -  `x1`。 矩形的高度和寬度必須大於 2 的單位和小於 32,767 個單位。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  
  
##  <a name="rectvisible"></a>CDC::RectVisible  
 判斷指定的任何的矩形部分是否之內顯示內容的裁剪區域。  
  
```  
virtual BOOL RectVisible(LPCRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向`RECT`結構或`CRect`物件，其中包含指定的矩形的邏輯座標。  
  
### <a name="return-value"></a>傳回值  
 如果有任何非零，部分給定矩形之內的裁剪區域。否則便是 0。  
  
##  <a name="releaseattribdc"></a>CDC::ReleaseAttribDC  
 呼叫此成員函式設定`m_hAttribDC`至**NULL**。  
  
```  
virtual void ReleaseAttribDC();
```  
  
### <a name="remarks"></a>備註  
 這不會造成**卸離**發生。 只有輸出裝置內容會附加至`CDC`物件中，並只可卸離。  
  
##  <a name="releaseoutputdc"></a>CDC::ReleaseOutputDC  
 呼叫此成員函式設定`m_hDC`成員**NULL**。  
  
```  
virtual void ReleaseOutputDC();
```  
  
### <a name="remarks"></a>備註  
 無法呼叫此成員函式的輸出裝置內容會附加至`CDC`物件。 使用**卸離**成員函式來卸離輸出裝置內容。  
  
##  <a name="resetdc"></a>CDC::ResetDC  
 呼叫此成員函式，以更新裝置內容所包裝`CDC`物件。  
  
```  
BOOL ResetDC(const DEVMODE* lpDevMode);
```  
  
### <a name="parameters"></a>參數  
 *lpDevMode*  
 Windows 的指標`DEVMODE`結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 裝置內容會從指定的 Windows 中的資訊更新`DEVMODE`結構。 此成員函式只會重設屬性裝置內容。  
  
 應用程式通常會使用`ResetDC`成員函式，當視窗處理`WM_DEVMODECHANGE`訊息。 您也可以使用此成員函式，若要變更紙張方向或紙張紙匣列印文件時。  
  
 若要變更的驅動程式名稱、 裝置名稱，或輸出連接埠，您無法使用此成員函式。 當使用者變更的連接埠連線或裝置名稱時，您必須刪除原始的裝置內容，並以新的資訊建立新的裝置內容。  
  
 呼叫此成員函式之前，您必須確定時，已選取 （非內建物件） 放入裝置內容已被選取的所有物件。  
  
##  <a name="restoredc"></a>CDC::RestoreDC  
 還原至先前的狀態所識別的裝置內容`nSavedDC`。  
  
```  
virtual BOOL RestoreDC(int nSavedDC);
```  
  
### <a name="parameters"></a>參數  
 `nSavedDC`  
 指定要還原的裝置內容。 它可以是先前傳回的值`SaveDC`函式呼叫。 如果`nSavedDC`為-1，最新儲存為還原裝置內容。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果還原指定的內容。否則便是 0。  
  
### <a name="remarks"></a>備註  
 `RestoreDC`還原裝置內容取出堆疊，以先前呼叫所建立的狀態資訊`SaveDC`成員函式。  
  
 堆疊可以包含數種裝置內容的狀態資訊。 如果所指定內容`nSavedDC`不是在堆疊頂端`RestoreDC`刪除所指定的裝置內容之間的所有狀態資訊`nSavedDC`和堆疊的頂端。 已刪除的資訊都會遺失。  
  
##  <a name="roundrect"></a>CDC::RoundRect  
 具有圓角使用目前的畫筆繪製矩形。  
  
```  
BOOL RoundRect(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3);

 
BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 y 座標。  
  
 `x2`  
 指定 （以邏輯單位表示） 的矩形右下角的 x 座標。  
  
 `y2`  
 指定 （以邏輯單位表示） 的矩形右下角的 y 座標。  
  
 *x3*  
 指定用來繪製圓弧角的半徑 （以邏輯單位表示） 的橢圓形的寬度。  
  
 `y3`  
 指定要繪製圓的角 （以邏輯單位表示） 時所用橢圓形的高度。  
  
 `lpRect`  
 以邏輯單位表示指定的周框。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
 `point`  
 X 軸座標`point`指定橢圓形的寬度 （以邏輯單位表示） 繪製圓的角。 Y 座標`point`指定的高度 （以邏輯單位表示） 繪製圓的角橢圓形。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 矩形的內部會使用目前的筆刷填滿。  
  
 此圖中繪製此函式最多延伸，但不包含右邊緣和下座標。 這表示圖的高度是`y2`  -  `y1`圖的寬度，且`x2`  -  `x1`。 週框矩形的寬度和高度必須大於 2 的單位和小於 32,767 個單位。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  
  
##  <a name="savedc"></a>CDC::SaveDC  
 藉由複製 （例如裁剪區域中，選取的物件和對應模式） 的狀態資訊將由 Windows 維護內容堆疊裝置內容的目前狀態。  
  
```  
virtual int SaveDC();
```  
  
### <a name="return-value"></a>傳回值  
 識別已儲存的裝置內容的整數。 如果發生錯誤，它可以是 0。 這會傳回值可以用來還原裝置內容呼叫`RestoreDC`。  
  
### <a name="remarks"></a>備註  
 儲存的裝置內容可以稍後使用還原`RestoreDC`。  
  
 `SaveDC`可以是用來儲存任何數目的裝置內容狀態的任意數目的時間。  
  
##  <a name="scaleviewportext"></a>CDC::ScaleViewportExt  
 修改檢視區範圍相對於目前的值。  
  
```  
virtual CSize ScaleViewportExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>參數  
 `xNum`  
 指定所要乘以 x 目前範圍。  
  
 `xDenom`  
 指定要除以的值相乘 x 目前範圍的量`xNum`參數。  
  
 `yNum`  
 指定所要乘以 y 目前範圍。  
  
 `yDenom`  
 指定要除以的值相乘 y 目前範圍的量`yNum`參數。  
  
### <a name="return-value"></a>傳回值  
 前一個檢視區中的範圍 （裝置單位） 為`CSize`物件。  
  
### <a name="remarks"></a>備註  
 公式會寫入，如下所示：  
  
 `xNewVE = ( xOldVE * xNum ) / xDenom`  
  
 `yNewVE = ( yOldVE * yNum ) / yDenom`  
  
 新的檢視區範圍會計算的乘以指定分子中目前的範圍，然後除以指定的分母。  
  
##  <a name="scalewindowext"></a>CDC::ScaleWindowExt  
 修改視窗範圍相對於目前的值。  
  
```  
virtual CSize ScaleWindowExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>參數  
 `xNum`  
 指定所要乘以 x 目前範圍。  
  
 `xDenom`  
 指定要除以的值相乘 x 目前範圍的量`xNum`參數。  
  
 `yNum`  
 指定所要乘以 y 目前範圍。  
  
 `yDenom`  
 指定要除以的值相乘 y 目前範圍的量`yNum`參數。  
  
### <a name="return-value"></a>傳回值  
 前一個視窗中的範圍 （邏輯單位表示） 做為`CSize`物件。  
  
### <a name="remarks"></a>備註  
 公式會寫入，如下所示：  
  
 `xNewWE = ( xOldWE * xNum ) / xDenom`  
  
 `yNewWE = ( yOldWE * yNum ) / yDenom`  
  
 新的視窗範圍會計算的乘以指定分子中目前的範圍，然後除以指定的分母。  
  
##  <a name="scrolldc"></a>CDC::ScrollDC  
 水平和垂直捲動的位元的矩形。  
  
```  
BOOL ScrollDC(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* pRgnUpdate,  
    LPRECT lpRectUpdate);
```  
  
### <a name="parameters"></a>參數  
 `dx`  
 指定水平捲動單位數目。  
  
 *dy*  
 指定垂直捲軸的單位數目。  
  
 `lpRectScroll`  
 指向`RECT`結構或`CRect`物件，其中包含捲動矩形的座標。  
  
 `lpRectClip`  
 指向`RECT`結構或`CRect`物件，其中包含裁剪矩形的座標。 當這個矩形小於其中所指的原始`lpRectScroll`，捲動只會發生在較小的矩形。  
  
 `pRgnUpdate`  
 識別捲動程序所發現的區域。 `ScrollDC`函式會定義此區域; 它不一定是一個矩形。  
  
 `lpRectUpdate`  
 指向`RECT`結構或`CRect`接收框住捲軸的更新區域的矩形座標的物件。 這是最大需要重新繪製的矩形區域。 結構或函式會傳回的物件中的值是在用戶端座標，不論指定之裝置內容的對應模式。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果執行捲動。否則便是 0。  
  
### <a name="remarks"></a>備註  
 如果`lpRectUpdate`是**NULL**，Windows 不會計算更新矩形。 如果兩個`pRgnUpdate`和`lpRectUpdate`是**NULL**，Windows 不會計算更新區域。 如果`pRgnUpdate`不**NULL**，Windows 會假設它包含有效的指標捲動程序所發現的區域 (定義`ScrollDC`成員函式)。 更新區域中傳回`lpRectUpdate`可以傳遞至`CWnd::InvalidateRgn`必要。  
  
 應用程式應該使用`ScrollWindow`類別成員函式`CWnd`時需要捲動視窗的整個工作區。 否則，它應該使用`ScrollDC`。  
  
##  <a name="selectclippath"></a>CDC::SelectClipPath  
 選取目前的路徑做為裝置內容中，使用指定的模式結合具有任何現有的裁剪區域的新區域的裁剪區域。  
  
```  
BOOL SelectClipPath(int nMode);
```  
  
### <a name="parameters"></a>參數  
 `nMode`  
 指定的方式使用的路徑。 允許下列值：  
  
- **RGN_AND**新裁剪區域包含 （重疊的區域） 的目前裁剪區域和目前路徑的交集。  
  
- **RGN_COPY**新裁剪區域是目前的路徑。  
  
- **RGN_DIFF**新裁剪區域包含目前裁剪區域的區域，並與目前的路徑排除。  
  
- **RGN_OR**新裁剪區域包含目前裁剪區域和目前路徑的聯集 （結合區域）。  
  
- **RGN_XOR**新裁剪區域包含聯集為目前裁剪區域和目前的路徑，但不包含重疊的區域。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 識別的裝置內容必須包含已關閉的路徑。  
  
##  <a name="selectcliprgn"></a>CDC::SelectClipRgn  
 選取指定的地區做為目前裁剪區域之裝置內容。  
  
```  
int SelectClipRgn(CRgn* pRgn);

 
int SelectClipRgn(
    CRgn* pRgn,  
    int nMode);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 識別要選取的區域。  
  
-   此函式，如果此值為第一個版本**NULL**、 整個工作區已選取，而且輸出仍裁剪至視窗。  
  
-   此函式的第二個版本，此控制代碼可以是**NULL**時，才**RGN_COPY**指定模式。  
  
 `nMode`  
 指定要執行的作業。 它必須是下列值之一：  
  
- **RGN_AND**新裁剪區域結合了目前裁剪區域和所識別之區域的重疊區域`pRgn`。  
  
- **RGN_COPY**新裁剪區域是一份所識別之區域`pRgn`。 這是功能等同於第一個版本`SelectClipRgn`。 如果所識別之區域`pRgn`是**NULL**，新的裁剪區域會變成預設裁剪區域 （空值區）。  
  
- **RGN_DIFF**新裁剪區域結合了目前裁剪區域的區域，以排除所識別之區域的區域`pRgn`。  
  
- **RGN_OR**新裁剪區域結合了目前裁剪區域和所識別之區域`pRgn`。  
  
- **RGN_XOR**新裁剪區域結合了目前裁剪區域和所識別之區域`pRgn`但會排除任何重疊的區域。  
  
### <a name="return-value"></a>傳回值  
 區域的類型。 它可以是下列值之一：  
  
- **COMPLEXREGION**新裁剪區域具有重疊的框線。  
  
- **錯誤**裝置內容或區域無效。  
  
- **NULLREGION**新裁剪區域是空的。  
  
- **SIMPLEREGION**新裁剪區域有任何重疊的框線。  
  
### <a name="remarks"></a>備註  
 用於所選區域的複本。 選取本身的區域來代表任何數目的其他裝置內容中，或刪除它。  
  
 函式會假設裝置單位中指定的特定區域的座標。 某些印表機裝置支援比圖形輸出才能保留 express 文字度量所需的有效位數更高的解析度的文字輸出。 這些裝置報告更高解析度裝置單位也就是以文字為單位。 這些裝置以便數個只有 1 個圖形單位來報告裝置單位對應，然後調整圖形的座標。 您應該一律呼叫`SelectClipRgn`函式使用的文字單元。  
  
 必須採取 GDI 中的圖形物件的縮放比例的應用程式可以使用**GETSCALINGFACTOR**印表機來決定縮放比例的逸出。 此縮放因數會影響裁剪。 如果區域用來裁剪圖形，GDI 會除以縮放比例的座標。 如果區域用來裁剪文字，GDI 會使無縮放比例調整。 縮放比例為 1 會使要除以 2; 座標為 2 的縮放比例會導致除以 4; 座標等等。  
  
##  <a name="selectobject"></a>Cdc:: selectobject  
 選取的物件放入裝置內容。  
  
```  
CPen* SelectObject(CPen* pPen);  
CBrush* SelectObject(CBrush* pBrush);  
virtual CFont* SelectObject(CFont* pFont);  
CBitmap* SelectObject(CBitmap* pBitmap);  
int SelectObject(CRgn* pRgn);  
CGdiObject* SelectObject(CGdiObject* pObject);
```  
  
### <a name="parameters"></a>參數  
 *pPen*  
 指標[CPen](../../mfc/reference/cpen-class.md)要選取的物件。  
  
 `pBrush`  
 指標[CBrush](../../mfc/reference/cbrush-class.md)要選取的物件。  
  
 `pFont`  
 指標[CFont](../../mfc/reference/cfont-class.md)要選取的物件。  
  
 `pBitmap`  
 指標[CBitmap](../../mfc/reference/cbitmap-class.md)要選取的物件。  
  
 `pRgn`  
 指標[CRgn](../../mfc/reference/crgn-class.md)要選取的物件。  
  
 `pObject`  
 指標[CGdiObject](../../mfc/reference/cgdiobject-class.md)要選取的物件。  
  
### <a name="return-value"></a>傳回值  
 要取代的物件指標。 這是其中一個衍生自的類別物件的指標`CGdiObject`，例如`CPen`，視使用的函式的版本。 傳回值是**NULL**如果發生錯誤。 此函式可能是暫存物件中傳回的指標。 此暫存物件是唯一一個 Windows 訊息處理期間有效。 如需詳細資訊，請參閱`CGdiObject::FromHandle`。  
  
 採用區域參數的成員函式版本會執行相同的工作`SelectClipRgn`成員函式。 它的傳回值可以是下列其中一項：  
  
- **COMPLEXREGION**新裁剪區域具有重疊的框線。  
  
- **錯誤**裝置內容或區域無效。  
  
- **NULLREGION**新裁剪區域是空的。  
  
- **SIMPLEREGION**新裁剪區域有任何重疊的框線。  
  
### <a name="remarks"></a>備註  
 類別`CDC`提供五個版本的特製化針對特定類型的 GDI 物件，包括畫筆、 筆刷、 字型、 點陣圖、 圖示和區域。 新選取的物件會取代相同類型的上一個物件。 例如，如果`pObject`一般版本的`SelectObject`指向[CPen](../../mfc/reference/cpen-class.md)物件，此函式所指定的畫筆以取代目前的畫筆`pObject`。  
  
 應用程式只能選取一個點陣圖到記憶體裝置內容及到只有一個記憶體裝置內容一次。 點陣圖的格式必須是單色或相容的裝置內容。如果不是，`SelectObject`會傳回錯誤。  
  
 Windows 3.1 和更新版本、`SelectObject`函式會傳回相同的值，不管或不使用中繼檔中。 在舊版的 Windows，`SelectObject`傳回成功則為非零值以 0 代表失敗時使用中繼檔中。  
  
##  <a name="selectpalette"></a>CDC::SelectPalette  
 選取所指定的邏輯色板`pPalette`裝置內容的所選的調色盤物件形式。  
  
```  
CPalette* SelectPalette(
    CPalette* pPalette,  
    BOOL bForceBackground);
```  
  
### <a name="parameters"></a>參數  
 `pPalette`  
 識別要選取的邏輯調色盤。 這個調色盤必須已經建立具有`CPalette`成員函式[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)。  
  
 `bForceBackground`  
 指定是否強制邏輯色板是背景調色盤。 如果`bForceBackground`為非零，選取的調色盤永遠是背景調色盤，不論視窗是否擁有輸入的焦點。 如果`bForceBackground`是 0，而且裝置內容附加至視窗，邏輯色板時前景調色盤視窗具有輸入的焦點。  
  
### <a name="return-value"></a>傳回值  
 指標`CPalette`物件，可識別取代所指定的調色盤邏輯色板`pPalette`。 它是**NULL**如果發生錯誤。  
  
### <a name="remarks"></a>備註  
 新的調色盤會成為 GDI 用來顯示在裝置內容中的控制項色彩調色盤物件，並取代先前的調色盤。  
  
 應用程式可以放入一個以上的裝置內容中選取邏輯色板。 但是，邏輯色板的變更會影響所有的裝置內容，它會選取。 如果應用程式選取放入一個以上的裝置內容的調色盤，裝置內容必須全部屬於相同的實體裝置。  
  
##  <a name="selectstockobject"></a>CDC::SelectStockObject  
 選取[CGdiObject](../../mfc/reference/cgdiobject-class.md)對應至其中一個預先定義的內建畫筆、 筆刷或字型的物件。  
  
```  
virtual CGdiObject* SelectStockObject(int nIndex);
```  
  
### <a name="parameters"></a>參數  
 `nIndex`  
 指定需要的內建物件種類。 它可以是下列值之一：  
  
- **BLACK_BRUSH**黑色筆刷。  
  
- **DKGRAY_BRUSH**暗灰色的筆刷。  
  
- **GRAY_BRUSH**灰色筆刷。  
  
- **HOLLOW_BRUSH**中空筆刷。  
  
- **LTGRAY_BRUSH**淺灰色的筆刷。  
  
- **NULL_BRUSH** Null 筆刷。  
  
- **WHITE_BRUSH**白色筆刷。  
  
- **BLACK_PEN**黑色畫筆。  
  
- **NULL_PEN** Null 畫筆。  
  
- **WHITE_PEN**白色畫筆。  
  
- **ANSI_FIXED_FONT** ANSI 固定的系統字型。  
  
- **ANSI_VAR_FONT** ANSI 變數系統字型。  
  
- **DEVICE_DEFAULT_FONT**裝置而異的字型。  
  
- **OEM_FIXED_FONT** OEM 相依固定字型。  
  
- **SYSTEM_FONT**系統字型。 根據預設，Windows 會使用系統字型來繪製功能表、 對話方塊控制項和其他文字。 它是最佳方法，不過，不依賴 SYSTEM_FONT 取得對話方塊和視窗所使用的字型。 請改用`SystemParametersInfo`SPI_GETNONCLIENTMETRICS 參數，以擷取目前的字型函式。 `SystemParametersInfo`會考量目前的佈景主題，並提供字型資訊的標題、 功能表和訊息對話方塊。  
  
- **SYSTEM_FIXED_FONT** 3.0 版之前的視窗中所使用的固定寬度系統字型。 這個物件是供與舊版的 Windows 相容性。  
  
- **DEFAULT_PALETTE**預設色彩調色盤。 這個調色盤包含 20 靜態中系統調色盤色彩。  
  
### <a name="return-value"></a>傳回值  
 指標`CGdiObject`如果函式成功，已被取代的物件。 指向實際的物件是[CPen](../../mfc/reference/cpen-class.md)， [CBrush](../../mfc/reference/cbrush-class.md)，或[CFont](../../mfc/reference/cfont-class.md)物件。 如果呼叫不成功，傳回值是**NULL**。  
  
##  <a name="setabortproc"></a>Cdc:: setabortproc  
 安裝列印工作的中止程序。  
  
```  
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```  
  
### <a name="parameters"></a>參數  
 `lpfn`  
 若要安裝與中止程序中止函式的指標。 如需詳細資訊的回呼函式，請參閱[:: setabortproc 的回呼函式](../../mfc/reference/callback-function-for-cdc-setabortproc.md)。  
  
### <a name="return-value"></a>傳回值  
 指定結果的`SetAbortProc`函式。 下列值的某些更可能比其他項目，但所有都可能。  
  
- **SP_ERROR**一般錯誤。  
  
- **SP_OUTOFDISK**足夠的磁碟空間是目前可供多工緩衝處理，且沒有更多的空間會變成可用。  
  
- **SP_OUTOFMEMORY**沒有足夠的記憶體可用於多工緩衝處理。  
  
- **SP_USERABORT**使用者結束透過列印管理員工作。  
  
### <a name="remarks"></a>備註  
 如果應用程式可讓多工緩衝處理期間取消列印工作時，它就必須設定中止函式，列印工作開始使用之前，先[Cdc](#startdoc)成員函式。 列印管理員允許應用程式取消列印工作，或處理不足的磁碟空間條件的多工緩衝處理期間呼叫的中止函式。 如果沒有中止函式設定，列印工作將會失敗，如果多工緩衝處理的磁碟空間不足。  
  
 請注意 Microsoft Visual c + + 功能簡化傳遞至回呼函式建立`SetAbortProc`。 位址傳遞至`EnumObjects`成員函式是使用匯出的函式的指標**__declspec （dllexport)**與`__stdcall`呼叫慣例。  
  
 您也沒有要匯出函式名稱中的**匯出**應用程式的模組定義檔中的陳述式。 您可以改為使用**匯出**函式中的修飾詞，  
  
 **BOOL 回呼匯出**AFunction ( **HDC**， `int` **);**  
  
 導致編譯器發出不含別名名稱所匯出的適當匯出記錄。 這適用於大部分的需求。 如需某些特殊情況下，例如匯出的函式依序數或別名匯出，您仍需要使用**匯出**模組定義檔中的陳述式。  
  
 回呼註冊介面現在是型別安全 （您必須指向正確類型的特定回呼函式的函式指標傳遞）。  
  
 也請注意所有的回呼函式必須再傳回給 Windows，，因為無法跨回呼界限擲回例外狀況設陷 Mfc 例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。  
  
##  <a name="setarcdirection"></a>CDC::SetArcDirection  
 設定要用於弧線和矩形函式的繪圖方向。  
  
```  
int SetArcDirection(int nArcDirection);
```  
  
### <a name="parameters"></a>參數  
 *nArcDirection*  
 指定新的弧形方向。 這個參數可以是下列值之一：  
  
- **AD_COUNTERCLOCKWISE**以逆時針方向繪製的圖表。  
  
- **AD_CLOCKWISE**朝順時針方向繪製的圖表。  
  
### <a name="return-value"></a>傳回值  
 指定舊的弧形方向，如果登錄成功。否則便是 0。  
  
### <a name="remarks"></a>備註  
 預設方向是以逆時針算起。 `SetArcDirection`函式指定下列函式繪製的方向：  
  
|Arc|圓形圖|  
|---------|---------|  
|`ArcTo`|**矩形**|  
|`Chord`|`RoundRect`|  
|**橢圓形**||  
  
##  <a name="setattribdc"></a>CDC::SetAttribDC  
 呼叫此函式來設定屬性的裝置內容， `m_hAttribDC`。  
  
```  
virtual void SetAttribDC(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 Windows 裝置內容。  
  
### <a name="remarks"></a>備註  
 此成員函式不會附加的裝置內容`CDC`物件。 只有輸出裝置內容會附加至`CDC`物件。  
  
##  <a name="setbkcolor"></a>CDC::SetBkColor  
 將目前的背景色彩設定為指定的色彩。  
  
```  
virtual COLORREF SetBkColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定新的背景色彩。  
  
### <a name="return-value"></a>傳回值  
 RGB 色彩值為先前的背景色彩。 如果發生錯誤，則傳回的值會為 0x80000000。  
  
### <a name="remarks"></a>備註  
 如果背景模式為**不透明**，系統會使用背景色彩填滿樣式的行中出現間距、 筆刷影線的行中的字元儲存格的背景的間隙。 轉換點陣圖之間色彩及單色裝置內容時，系統也會使用背景色彩。  
  
 如果裝置無法顯示指定的色彩，系統就會設定為最接近的實體色彩的背景色彩。  
  
##  <a name="setbkmode"></a>CDC::SetBkMode  
 設定背景模式。  
  
```  
int SetBkMode(int nBkMode);
```  
  
### <a name="parameters"></a>參數  
 *nBkMode*  
 指定要設定的模式。 這個參數可以是下列值之一：  
  
- **不透明**背景填滿之前的文字，包含陰影的筆刷，目前的背景色彩或畫筆會繪製。 這是預設背景模式。  
  
- **透明**背景則不會繪製前變更。  
  
### <a name="return-value"></a>傳回值  
 先前的背景模式。  
  
### <a name="remarks"></a>備註  
 背景模式會定義系統是否會繪製文字、 影線的筆刷或不是實線任何筆樣式之前移除現有的背景色彩的繪圖介面上。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。  
  
##  <a name="setboundsrect"></a>CDC::SetBoundsRect  
 控制累積的週框矩形指定之裝置內容的資訊。  
  
```  
UINT SetBoundsRect(
    LPCRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>參數  
 `lpRectBounds`  
 指向`RECT`結構或`CRect`物件，用來設定週框矩形。 矩形的維度都指定在邏輯座標。 這個參數可以是**NULL**。  
  
 `flags`  
 指定新的矩形累積矩形的組合方式。 這個參數可以是下列值的組合：  
  
- **DCB_ACCUMULATE**加入所指定的矩形`lpRectBounds`週框矩形中 （使用矩形 union 作業）。  
  
- **DCB_DISABLE**關閉界限累積。  
  
- **DCB_ENABLE**開啟界限累積。 （界限累積的預設值是停用）。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，這個周框的目前狀態。 像`flags`，傳回值可以是組合的**DCB_**值：  
  
- **DCB_ACCUMULATE**不是空的這個周框。 這個值一定會設定。  
  
- **DCB_DISABLE**界限累積為關閉。  
  
- **DCB_ENABLE**界限累積為開啟。  
  
### <a name="remarks"></a>備註  
 Windows 可以維護所有繪圖作業的周框。 可以查詢這個矩形，並將它重設應用程式中。 繪製界限可用於讓點陣圖快取失效。  
  
##  <a name="setbrushorg"></a>CDC::SetBrushOrg  
 指定的 GDI 會指派至下一個應用程式便可選取的裝置內容的筆刷的原點。  
  
```  
CPoint SetBrushOrg(
    int x,  
    int y);  
  
CPoint SetBrushOrg(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新的原點的 x 座標 （以裝置為單位）。 此值必須是範圍 0-7。  
  
 *y*  
 指定新原點的 y 座標 （以裝置為單位）。 此值必須是範圍 0-7。  
  
 `point`  
 指定新原點的 x 和 y 座標。 每個值必須是範圍 0-7。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 前一個裝置單位的筆刷的原點。  
  
### <a name="remarks"></a>備註  
 預設的筆刷的原點的座標為 （0，0）。 若要變更筆刷的原點，呼叫`UnrealizeObject`函式`CBrush`物件，呼叫`SetBrushOrg`，然後呼叫`SelectObject`成員函式來選取放入裝置內容的筆刷。  
  
 請勿使用`SetBrushOrg`與庫存`CBrush`物件。  
  
##  <a name="setcoloradjustment"></a>CDC::SetColorAdjustment  
 設定彩色調整值之裝置內容，使用指定的值。  
  
```  
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```  
  
### <a name="parameters"></a>參數  
 `lpColorAdjust`  
 指向[COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md)資料結構，包含色彩調整值。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 色彩調整值可用來調整輸入的呼叫來源點陣圖的色彩`CDC::StretchBlt`成員函式時**半色調**模式設定。  
  
##  <a name="setdcbrushcolor"></a>CDC::SetDCBrushColor  
 將目前的裝置內容 (DC) 筆刷色彩設定為指定的色彩值。  
  
```  
COLORREF SetDCBrushColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定新的筆刷色彩。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回值會指定與先前的 DC 筆刷色彩`COLORREF`值。  
  
 如果函式失敗，傳回值是`CLR_INVALID`。  
  
### <a name="remarks"></a>備註  
 這個方法會模擬函式的功能[SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969)、 Windows SDK 中所述。  
  
##  <a name="setdcpencolor"></a>CDC::SetDCPenColor  
 將目前的裝置內容 (DC) 畫筆顏色設定為指定的色彩值。  
  
```  
COLORREF SetDCPenColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定新的畫筆顏色。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式會利用 Win32 函式[SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970)、 Windows SDK 中所述。  
  
##  <a name="setgraphicsmode"></a>CDC::SetGraphicsMode  
 設定指定之裝置內容的圖形模式。  
  
```  
int SetGraphicsMode(int iMode);
```  
  
### <a name="parameters"></a>參數  
 `iMode`  
 指定的圖形模式。 如需這個參數可以接受的值，請參閱[SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)。  
  
### <a name="return-value"></a>傳回值  
 如果成功傳回舊的圖形模式。  
  
 在失敗時傳回 0。 若要取得延伸錯誤資訊，請呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)。  
  
##  <a name="setlayout"></a>CDC::SetLayout  
 呼叫此成員函式可將文字和圖形裝置內容的配置變更為 右到左、 文化特性而有所不同，如阿拉伯文與希伯來文的標準版面配置。  
  
```  
DWORD SetLayout(DWORD dwLayout);
```  
  
### <a name="parameters"></a>參數  
 `dwLayout`  
 裝置內容的配置和點陣圖控制旗標。 它可以是下列值的組合。  
  
|值|意義|  
|-----------|-------------|  
|LAYOUT_BITMAPORIENTATIONPRESERVED|停用呼叫的任何反映[cdc:: bitblt](#bitblt)和[CDC::StretchBlt](#stretchblt)。|  
|LAYOUT_RTL|設定預設的水平配置是由右至左。|  
|LAYOUT_LTR|設定要由左到右的預設配置。|  
  
### <a name="return-value"></a>傳回值  
 如果成功，裝置內容的先前的版面配置。  
  
 如果不成功， **GDI_ERROR**。 若要取得延伸錯誤資訊，請呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 一般來說，您不會呼叫**SetLayout**視窗。 相反地，您從右至左配置，在視窗中的設定控制[延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)例如**WS_EX_RTLREADING**。 裝置內容，例如印表機或中繼檔，不會繼承這個版面配置。 若要從右至左配置是藉由呼叫設定裝置內容的唯一方式**SetLayout**。  
  
 如果您呼叫**SetLayout (LAYOUT_RTL** )， **SetLayout**會自動變更的對應模式`MM_ISOTROPIC`。 如此一來，後續呼叫[GetMapMode](#getmapmode)會傳回**MM_ISOTROPIC**而不是`MM_TEXT`。  
  
 在某些情況下，例如與許多點陣圖，您可能想要保留左到右配置。 在這些情況下，呈現影像藉由呼叫`BitBlt`或`StretchBlt`，然後設定 點陣圖控制旗標，如`dwLayout`至**LAYOUT_BITMAPORIENTATIONPRESERVED**。  
  
 一旦變更版面配置與**LAYOUT_RTL**旗標，通常指定權限的旗標或左邊會反轉。 為了避免混淆，您可能想要定義標準的旗標的替代名稱。 如需建議替代的旗標名稱的清單，請參閱[SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979) Windows SDK 中。  
  
##  <a name="setmapmode"></a>CDC::SetMapMode  
 設定對應模式。  
  
```  
virtual int SetMapMode(int nMapMode);
```  
  
### <a name="parameters"></a>參數  
 `nMapMode`  
 指定新的對應模式。 它可以是下列值之一：  
  
- `MM_ANISOTROPIC`邏輯單元具有任意縮放軸轉換為任意的單位。 若要設定的對應模式`MM_ANISOTROPIC`不會變更目前的視窗或檢視區設定。 若要變更單位，方向與縮放比例，呼叫[SetWindowExt](#setwindowext)和[SetViewportExt](#setviewportext)成員函式。  
  
- `MM_HIENGLISH`每個邏輯單元會轉換為 0.001 英吋。 正數 x 是右邊。正數 y 已啟動。  
  
- `MM_HIMETRIC`每個邏輯單元會轉換為 0.01 公釐。 正數 x 是右邊。正數 y 已啟動。  
  
- `MM_ISOTROPIC`邏輯單元時，會轉換成任意單位上，具有同樣縮放軸。也就是 1 個單位沿著 x 軸會等於 1 個單位沿著 y 軸。 使用`SetWindowExt`和`SetViewportExt`成員函式以指定的所需的單位，以及這兩個軸的方向。 GDI 會視需要調整 x 和 y，確認單位維持相同大小。  
  
- `MM_LOENGLISH`每個邏輯單元會轉換成 0.01 英吋。 正數 x 是右邊。正數 y 已啟動。  
  
- `MM_LOMETRIC`每個邏輯單元會轉換成 0.1 公釐。 正數 x 是右邊。正數 y 已啟動。  
  
- `MM_TEXT`每個邏輯單元會轉換成 1 部裝置像素。 正數 x 是右邊。正數 y 已關閉。  
  
- `MM_TWIPS`每個邏輯單元會轉換成 1/20 的點。 （「 點 」 是 1/72 英吋，因為 twip 是 1/1440年英吋）。正數 x 是右邊。正數 y 已啟動。  
  
### <a name="return-value"></a>傳回值  
 先前的對應模式。  
  
### <a name="remarks"></a>備註  
 對應模式會定義用來將邏輯單元轉換成裝置單位; 量值的單位它也會定義裝置的 x 軸和 y 軸的方向。 GDI 邏輯座標轉換為適當的裝置座標使用的對應模式。 `MM_TEXT`模式可讓應用程式運作中裝置像素為單位，其中 1 個單位等於 1 像素。 像素的實體大小而異的裝置。  
  
 `MM_HIENGLISH`， `MM_HIMETRIC`， `MM_LOENGLISH`， `MM_LOMETRIC`，和`MM_TWIPS`模式都適用於應用程式必須繪製實際有意義的單位 （例如英吋或公釐為單位）。 `MM_ISOTROPIC`模式可確保 1:1 的外觀比例，請務必保留影像的確切形狀時，會很有用。 `MM_ANISOTROPIC`模式可讓 x 和 y 座標分別調整。  
  
> [!NOTE]
>  如果您呼叫[SetLayout](#setlayout) DC （裝置內容） 變更為從右至左配置**SetLayout**會自動變更的對應模式`MM_ISOTROPIC`。  
  
### <a name="example"></a>範例  
  請參閱範例的[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setmapperflags"></a>CDC::SetMapperFlags  
 變更時它會轉換成實體字型的邏輯字型的字型對應程式所使用的方法。  
  
```  
DWORD SetMapperFlags(DWORD dwFlag);
```  
  
### <a name="parameters"></a>參數  
 `dwFlag`  
 指定是否字型對應工具會嘗試比對字型的長寬高度和寬度，以裝置。 當這個值是**ASPECT_FILTERING**、 對應工具僅字型選取其 x 外觀和 y 外觀完全符合指定的裝置。  
  
### <a name="return-value"></a>傳回值  
 先前的字型對應程式旗標值。  
  
### <a name="remarks"></a>備註  
 應用程式可以使用`SetMapperFlags`導致嘗試選擇只有完全符合指定的裝置比例實體字型的字型對應程式。  
  
 使用僅點陣字型的應用程式可以使用`SetMapperFlags`函式，以確保所選取的字型對應程式的字型吸引人也可在指定的裝置上讀取。 應用程式通常使用可擴充的 (TrueType) 字型，請勿使用`SetMapperFlags`。  
  
 如果沒有實體的字型已符合中的邏輯字型規格長寬比，GDI 選擇新的長寬比，並選取符合這個新的長寬比的字型。  
  
##  <a name="setmiterlimit"></a>CDC::SetMiterLimit  
 設定斜接角聯結之裝置內容的長度限制。  
  
```  
BOOL SetMiterLimit(float fMiterLimit);
```  
  
### <a name="parameters"></a>參數  
 *fMiterLimit*  
 指定裝置內容的新斜接角限制。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 斜接角長度定義為內部聯結線牆面交集直線牆上的外部聯結的交集的距離。 斜接角限制為最大允許的行寬斜接角長度的比例。 預設斜接角限制為 10.0。  
  
##  <a name="setoutputdc"></a>CDC::SetOutputDC  
 呼叫此成員函式，來設定輸出裝置內容， `m_hDC`。  
  
```  
virtual void SetOutputDC(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 Windows 裝置內容。  
  
### <a name="remarks"></a>備註  
 此成員函式只能呼叫，裝置內容未附加至`CDC`物件。 此成員函式會將`m_hDC`但不會附加的裝置內容`CDC`物件。  
  
##  <a name="setpixel"></a>CDC::SetPixel  
 設定像素色彩所指定的最接近的近似值至指定的點`crColor`。  
  
```  
COLORREF SetPixel(
    int x,  
    int y,  
    COLORREF crColor);

 
COLORREF SetPixel(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要設定點的邏輯 x 座標。  
  
 *y*  
 指定要設定點的邏輯 y 座標。  
  
 `crColor`  
 A **COLORREF** RGB 值，指定用來繪製點的色彩。 請參閱[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449) Windows SDK 中針對此值的描述。  
  
 `point`  
 指定邏輯 x 和 y 座標的點，會設定。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 實際繪製 點色彩的 RGB 值。 這個值可以不同於所指定`crColor`如果使用該色彩的近似值。 如果函式會失敗 （如果點裁剪區域外），則傳回值為-1。  
  
### <a name="remarks"></a>備註  
 裁剪區域必須是點。 如果沒有點的裁剪區域中，函式沒有任何作用。  
  
 並非所有的裝置皆支援 `SetPixel` 函式。 若要判斷裝置是否支援`SetPixel`，呼叫`GetDeviceCaps`成員函式**cdc:: GETDEVICECAPS**索引並檢查傳回值，如**RC_BITBLT**旗標。  
  
##  <a name="setpixelv"></a>CDC::SetPixelV  
 以指定的色彩最接近的指定座標上設定像素。  
  
```  
BOOL SetPixelV(
    int x,  
    int y,  
    COLORREF crColor);

 
BOOL SetPixelV(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定 x 軸座標，以邏輯單位，表示要設定的點。  
  
 *y*  
 指定以邏輯單位，表示要設定點的 y 座標。  
  
 `crColor`  
 指定要用來繪製點的色彩。  
  
 `point`  
 指定邏輯 x 和 y 座標的點，會設定。 您可以傳遞[點](../../mfc/reference/point-structure1.md)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 裁剪區域和裝置介面的可見部分必須是點。 並非所有裝置都支援此成員函式。 如需詳細資訊，請參閱**RC_BITBLT**功能`CDC::GetDeviceCaps`成員函式。 `SetPixelV`速度比`SetPixel`因為不需要傳回實際繪製點的色彩值。  
  
##  <a name="setpolyfillmode"></a>CDC::SetPolyFillMode  
 將多邊形填滿模式設定。  
  
```  
int SetPolyFillMode(int nPolyFillMode);
```  
  
### <a name="parameters"></a>參數  
 `nPolyFillMode`  
 指定新的填滿模式。 這個值可以是**替代**或**捲繞**。 在 Windows 中設定的預設模式是**替代**。  
  
### <a name="return-value"></a>傳回值  
 前一個填滿模式中，如果登錄成功。否則便是 0。  
  
### <a name="remarks"></a>備註  
 多邊形填滿模式時**替代**，系統會掃描一行奇數和偶數多邊形側邊之間的區域填滿。 也就是說，系統會填滿區域之間的第一個和第二個邊，等第三個和第四個側邊之間。 這個模式是預設值。  
  
 多邊形填滿模式時**捲繞**，系統會用來判斷是否要填滿區域已繪製圖形的方向。 順時針或逆時針方向會繪製多邊形中的每個直線線段。 每當取自括住的區域圖外面虛數行通過順時針旋轉的直線線段的計數會遞增。 當行通過逆時針算起的直線線段時，計數會遞減。 如果行達到圖的外面時計數則為非零，則會填滿區域。  
  
##  <a name="setrop2"></a>CDC::SetROP2  
 設定目前的繪圖模式。  
  
```  
int SetROP2(int nDrawMode);
```  
  
### <a name="parameters"></a>參數  
 `nDrawMode`  
 指定新的繪圖模式。 它可以是下列值之一：  
  
- **R2_BLACK**像素永遠都是黑色。  
  
- **R2_WHITE**一律為白色像素。  
  
- **R2_NOP**像素維持不變。  
  
- **R2_NOT**像素是螢幕色彩的反轉。  
  
- **R2_COPYPEN**像素為畫筆顏色。  
  
- **R2_NOTCOPYPEN**像素是反向的畫筆顏色。  
  
- **R2_MERGEPENNOT**的畫筆色彩組合和螢幕色彩的反轉像素都是 (最後一個像素 = （不是螢幕像素），或畫筆)。  
  
- **R2_MASKPENNOT**像素是通用的同時畫筆色彩組合和螢幕的反向 (最後一個像素 = （不是螢幕像素），而且畫筆)。  
  
- **R2_MERGENOTPEN**像素是反向的畫筆顏色及螢幕色彩組合 (最後一個像素 = （不是畫筆） 或畫面像素)。  
  
- **R2_MASKNOTPEN**像素是反向的畫筆及通用同時螢幕色彩組合 (最後一個像素 = （不是畫筆） 和螢幕像素)。  
  
- **R2_MERGEPEN**像素為畫筆顏色和螢幕色彩的組合 (最後一個像素 = 畫筆 OR 螢幕的像素)。  
  
- **R2_NOTMERGEPEN**像素是反向**R2_MERGEPEN**色彩 (最後一個像素 = 未 （畫筆 OR 螢幕的像素）)。  
  
- **R2_MASKPEN**像素是通用的畫筆和畫面色彩的組合 (最後一個像素 = 畫筆 AND 螢幕的像素)。  
  
- **R2_NOTMASKPEN**像素是反向**R2_MASKPEN**色彩 (最後一個像素 = 未 （畫筆 AND 螢幕的像素）)。  
  
- **R2_XORPEN**像素是色彩的畫筆或在畫面中，但不是在兩者的組合 (最後一個像素 = 畫筆 XOR 螢幕的像素)。  
  
- **R2_NOTXORPEN**像素是反向**R2_XORPEN**色彩 (最後一個像素 = 未 （畫筆 XOR 螢幕像素）)。  
  
### <a name="return-value"></a>傳回值  
 先前的繪圖模式。  
  
 它可以是任何的 Windows SDK 中所指定的值。  
  
### <a name="remarks"></a>備註  
 繪圖模式指定如何結合的畫筆色彩和填滿物件的內部使用的色彩顯示表面上已經存在。  
  
 繪圖模式適用於僅限; 點陣裝置它不適用於向量裝置。 繪圖模式會代表所有可能的布林值組合的兩個變數，不使用二元運算子 AND、 OR 和 XOR (排除 OR)，一元運算的二進位的點陣作業程式碼。  
  
##  <a name="setstretchbltmode"></a>CDC::SetStretchBltMode  
 設定點陣圖自動縮放模式`StretchBlt`成員函式。  
  
```  
int SetStretchBltMode(int nStretchMode);
```  
  
### <a name="parameters"></a>參數  
 *nStretchMode*  
 指定的縮放模式。 它可以是下列值之一：  
  
|值|描述|  
|-----------|-----------------|  
|**BLACKONWHITE**|執行已排除的和現有的像素中使用的色彩值的布林值 AND 運算。 如果點陣圖是單色點陣圖，此模式會保留黑色的像素，但會犧牲白色像素為單位。|  
|**COLORONCOLOR**|刪除像素為單位。 此模式中刪除所有已排除像素為單位的行，但不會嘗試保留他們的資訊。|  
|**半色調**|會從來源矩形的像素對應至目的矩形中的像素的區塊。 透過像素為單位的目標區塊的平均色彩近似於來源像素色彩。|  
||設定之後**半色調**延展模式時，應用程式必須呼叫 Win32 函式[SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967)設定筆刷的原點。 如果它無法這樣做，就會發生筆刷對齊錯誤。|  
|**STRETCH_ANDSCANS**|**Windows 95/98**： 相同**BLACKONWHITE**|  
|**STRETCH_DELETESCANS**|**Windows 95/98**： 相同**COLORONCOLOR**|  
|**STRETCH_HALFTONE**|**Windows 95/98**： 相同**半色調**。|  
|**STRETCH_ORSCANS**|**Windows 95/98**： 相同**WHITEONBLACK**|  
|**WHITEONBLACK**|執行布林值 OR 運算，使用已排除的和現有的像素的色彩值。 如果點陣圖是單色點陣圖，此模式會保留白色像素，但會犧牲黑色的像素為單位。|  
  
### <a name="return-value"></a>傳回值  
 先前的自動縮放模式。 它可以是**STRETCH_ANDSCANS**， **STRETCH_DELETESCANS**，或**STRETCH_ORSCANS**。  
  
### <a name="remarks"></a>備註  
 點陣圖縮放模式會定義如何從使用此函數就會進行壓縮的點陣圖中移除資訊。  
  
 **BLACKONWHITE** ( **STRETCH_ANDSCANS**) 和**WHITEONBLACK** ( **STRETCH_ORSCANS**) 模式通常用來保留前景單色點陣圖的像素。 **COLORONCOLOR** ( **STRETCH_DELETESCANS**) 模式通常用來保留彩色點陣圖中的色彩。  
  
 **半色調**模式需要更多的來源映像處理比其他三個模式; 低於其他人，但會產生高品質影像。 也請注意， **SetBrushOrgEx**必須呼叫之後設定**半色調**模式，以避免筆刷對齊錯誤。  
  
 可能也會根據裝置驅動程式的功能提供額外的自動縮放模式。  
  
##  <a name="settextalign"></a>CDC::SetTextAlign  
 設定文字對齊方式的旗標。  
  
```  
UINT SetTextAlign(UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 指定文字對齊方式的旗標。 旗標指定點與界限文字的矩形之間的關聯性。 點可以是目前的位置或文字輸出函式所指定的座標。 相鄰的字元儲存格的文字字串中所定義的矩形框住的文字。 `nFlags`參數可以是下列三個類別的一個或多個旗標。 從每個類別目錄中，選擇只有一個旗標。 第一個類別會影響在 x 方向的文字對齊方式：  
  
- **TA_CENTER**對齊水平中央的點，這個周框。  
  
- **TA_LEFT**對齊，這個周框左邊的點。 這是預設設定。  
  
- **TA_RIGHT**對齊右邊的點，這個周框。  
  
 第二個類別會影響在 y 方向的文字對齊方式：  
  
- **TA_BASELINE**對齊字型與基準線的點。  
  
- **TA_BOTTOM**對齊具有週框矩形的底部的點。  
  
- **TA_TOP**對齊點的週框矩形的頂端。 這是預設設定。  
  
 第三個類別目錄會決定是否要在寫入文字時，更新目前的位置：  
  
- **TA_NOUPDATECP**不會更新目前的位置之後的文字輸出函式每次呼叫。 這是預設設定。  
  
- **TA_UPDATECP**之後每個呼叫的文字輸出函式會更新目前的 x 位置。 新的位置是在右側的文字，這個周框。 當這個旗標設定時，呼叫中指定的座標`TextOut`成員函式會被忽略。  
  
### <a name="return-value"></a>傳回值  
 先前文字對齊方式的設定，如果成功的話。 低序位位元組包含水平的設定，高序位位元組包含垂直的設定。否則便是 0。  
  
### <a name="remarks"></a>備註  
 `TextOut`和`ExtTextOut`定位的顯示或裝置上的文字字串時，成員函式會使用這些旗標。 旗標指定的特定點與界限文字的矩形之間的關聯性。 此點的座標會當做參數傳遞給`TextOut`成員函式。 矩形會框住的文字是相鄰的字元儲存格的文字字串中所構成。  
  
##  <a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra  
 設定 intercharacter 的間距數量。  
  
```  
int SetTextCharacterExtra(int nCharExtra);
```  
  
### <a name="parameters"></a>參數  
 `nCharExtra`  
 指定要加入至每個字元的 （以邏輯單位表示） 的額外空間數量。 如果不是目前的對應模式`MM_TEXT`，`nCharExtra`是轉換與捨入到最接近像素。  
  
### <a name="return-value"></a>傳回值  
 先前的 intercharacter 間距數量。  
  
### <a name="remarks"></a>備註  
 GDI 新增這個間距，包括分行符號字元，當它將一行文字寫入至裝置內容的每個字元。 Intercharacter 間距所需的預設值為 0。  
  
##  <a name="settextcolor"></a>CDC::SetTextColor  
 為指定的色彩設定的文字色彩。  
  
```  
virtual COLORREF SetTextColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定文字的色彩為 RGB 色彩值。  
  
### <a name="return-value"></a>傳回值  
 先前的文字色彩的 RGB 值。  
  
### <a name="remarks"></a>備註  
 將文字寫入至這個裝置內容也之間的轉換點陣圖的色彩和單色裝置內容時，系統會使用此文字色彩。  
  
 如果裝置無法表示指定的色彩，系統就會設定為最接近的實體色彩的文字色彩。 所指定字元的背景色彩`SetBkColor`和`SetBkMode`成員函式。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。  
  
##  <a name="settextjustification"></a>CDC::SetTextJustification  
 分行符號字元，在字串中加上空格。  
  
```  
int SetTextJustification(
    int nBreakExtra,  
    int nBreakCount);
```  
  
### <a name="parameters"></a>參數  
 `nBreakExtra`  
 指定要加入至 （以邏輯單位表示） 的文字行的總額外空間。 如果不是目前的對應模式`MM_TEXT`，此參數所指定的值轉換成目前的對應模式，四捨五入為最接近的裝置單位。  
  
 *nBreakCount*  
 行中指定符號字元的數。  
  
### <a name="return-value"></a>傳回值  
 其中一個函式是否成功。否則便是 0。  
  
### <a name="remarks"></a>備註  
 應用程式可以使用`GetTextMetrics`擷取字型的成員函式中斷字元。  
  
 之後`SetTextJustification`成員函式呼叫時，呼叫文字輸出函式 (例如`TextOut`) 將指定的額外空間之間指定的符號字元數，平均分散。 分行符號字元通常是空格字元 (ASCII 32)，但可能會當做其他某些字元字型來定義。  
  
 成員函式`GetTextExtent`通常會與搭配`SetTextJustification`。 `GetTextExtent`計算在對齊之前指定行的寬度。 應用程式就可以判斷多少空間，以指定在`nBreakExtra`參數所傳回的值減掉`GetTextExtent`從寬度之後對齊的字串。  
  
 `SetTextJustification`函式可以用來對齊包含不同的字型中的多個回合的那一行。 在此情況下，必須分次建立列藉由對齊，並分別撰寫每次執行。  
  
 對齊期間可能會發生捨入錯誤，因為系統會保留定義目前錯誤的執行錯誤詞彙。 對齊線，其中包含多個回合，當`GetTextExtent`會自動使用它會計算下一次執行的範圍。 這個錯誤詞彙。 這可讓文字輸出函式融合新的執行錯誤。  
  
 已對齊每一行之後，必須清除這個錯誤的詞彙，以防止它被合併至下一行。 您可以清除一詞，藉由呼叫`SetTextJustification`與`nBreakExtra`設為 0。  
  
##  <a name="setviewportext"></a>CDC::SetViewportExt  
 設定 x-與 y-範圍的裝置內容的檢視區。  
  
```  
virtual CSize SetViewportExt(
    int cx,  
    int cy);  
  
CSize SetViewportExt(SIZE size);
```  
  
### <a name="parameters"></a>參數  
 `cx`  
 指定檢視區 （以裝置為單位） 的 x 程度。  
  
 `cy`  
 指定的檢視區 （以裝置單位表示） y 範圍。  
  
 `size`  
 指定 x-與 y-範圍的檢視區 （以裝置為單位）。  
  
### <a name="return-value"></a>傳回值  
 做為檢視區的前一個範圍[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。 當錯誤發生時，x 和 y 座標的傳回`CSize`物件都設定為 0。  
  
### <a name="remarks"></a>備註  
 檢視區，以及裝置內容 視窗中，定義 GDI 在實際裝置之點的座標系統中所對應的邏輯座標系統中的點。 也就是說，它們會定義 GDI 如何將邏輯座標轉換成裝置座標。  
  
 當設定下列的對應模式時，呼叫`SetWindowExt`和`SetViewportExt`都會被忽略：  
  
|MM_HIENGLISH|MM_LOMETRIC|  
|-------------------|------------------|  
|`MM_HIMETRIC`|`MM_TEXT`|  
|`MM_LOENGLISH`|`MM_TWIPS`|  
  
 當`MM_ISOTROPIC`模式設定，應用程式必須呼叫`SetWindowExt`成員函式呼叫之前`SetViewportExt`。  
  
### <a name="example"></a>範例  
  請參閱範例的[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setviewportorg"></a>CDC::SetViewportOrg  
 設定裝置內容的檢視區的原點。  
  
```  
virtual CPoint SetViewportOrg(
    int x,  
    int y);  
  
CPoint SetViewportOrg(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定的檢視區原點的 x 座標 （以裝置為單位）。 值必須是裝置座標系統的範圍內。  
  
 *y*  
 指定的檢視區原點的 y 座標 （以裝置為單位）。 值必須是裝置座標系統的範圍內。  
  
 `point`  
 指定檢視區的來源。 值必須是裝置座標系統的範圍內。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 先前的 （以裝置座標表示） 做為檢視區原點`CPoint`物件。  
  
### <a name="remarks"></a>備註  
 檢視區，以及裝置內容 視窗中，定義 GDI 在實際裝置之點的座標系統中所對應的邏輯座標系統中的點。 也就是說，它們會定義 GDI 如何將邏輯座標轉換成裝置座標。  
  
 檢視區原點標示 GDI 對應視窗原點的點，在邏輯座標系統中所指定裝置座標系統中的點**SetWindowOrg**成員函式。 GDI 會對應所有其他點將視窗原點對應到檢視區原點所需的程序相同。 比方說，繞著視窗原點的點的圓形中的所有點都會在檢視區原點的點周圍的圓形。 同樣地，通過視窗原點的列的所有點都都通過捲動檢視區原點的列。  
  
### <a name="example"></a>範例  
  請參閱範例的[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setwindowext"></a>CDC::SetWindowExt  
 設定 x-與 y-範圍相關聯的裝置內容的視窗。  
  
```  
virtual CSize SetWindowExt(
    int cx,  
    int cy);  
  
CSize SetWindowExt(SIZE size);
```  
  
### <a name="parameters"></a>參數  
 `cx`  
 指定的 x-程度 （以邏輯單位表示） 的視窗。  
  
 `cy`  
 指定的 y-程度 （以邏輯單位表示） 的視窗。  
  
 `size`  
 指定 x-與 y-範圍 （以邏輯單位表示） 的視窗。  
  
### <a name="return-value"></a>傳回值  
 間隔 （以邏輯單位表示） 做為前一個範圍`CSize`物件。 如果發生錯誤，x 和 y 座標的傳回`CSize`物件都設定為 0。  
  
### <a name="remarks"></a>備註  
 視窗中的，裝置內容檢視區，以及定義 GDI 裝置座標系統中的點所對應的邏輯座標系統中的點。  
  
 當設定下列的對應模式時，呼叫`SetWindowExt`和`SetViewportExt`函式會被忽略：  
  
- `MM_HIENGLISH`  
  
- `MM_HIMETRIC`  
  
- `MM_LOENGLISH`  
  
- `MM_LOMETRIC`  
  
- `MM_TEXT`  
  
- `MM_TWIPS`  
  
 當`MM_ISOTROPIC`模式設定，應用程式必須呼叫`SetWindowExt`成員函式，然後再呼叫`SetViewportExt`。  
  
### <a name="example"></a>範例  
  請參閱範例的[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setwindoworg"></a>CDC::SetWindowOrg  
 設定裝置內容的視窗原點。  
  
```  
CPoint SetWindowOrg(
    int x,  
    int y);  
  
CPoint SetWindowOrg(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新的視窗原點的邏輯 x 座標。  
  
 *y*  
 指定新的視窗原點的邏輯 y 座標。  
  
 `point`  
 指定新的來源視窗的邏輯座標。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 為視窗的上一個原點`CPoint`物件。  
  
### <a name="remarks"></a>備註  
 視窗中的，裝置內容檢視區，以及定義 GDI 裝置座標系統中的點所對應的邏輯座標系統中的點。  
  
 視窗原點標示 GDI 將檢視區原點，在裝置座標系統中所指定的點對應的邏輯座標系統中的點**SetWindowOrg**函式。 GDI 會對應所有其他點將視窗原點對應到檢視區原點所需的程序相同。 比方說，繞著視窗原點的點的圓形中的所有點都會在檢視區原點的點周圍的圓形。 同樣地，通過視窗原點的列的所有點都都通過捲動檢視區原點的列。  
  
##  <a name="setworldtransform"></a>CDC::SetWorldTransform  
 設定二維線性世界空間與指定之裝置內容的分頁空間之間轉換。 此轉換可用來縮放、 旋轉、 傾斜或轉譯圖形輸出。  
  
```  
BOOL SetWorldTransform(const XFORM& rXform);
```  
  
### <a name="parameters"></a>參數  
 `rXform`  
 若要參考[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)結構，其中包含轉換資料。  
  
### <a name="return-value"></a>傳回值  
 成功時傳回非零值。  
  
 在失敗時傳回 0。  
  
 若要取得延伸錯誤資訊，請呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104)。  
  
##  <a name="startdoc"></a>CDC::StartDoc  
 通知正在啟動新的列印工作的裝置驅動程式，所有後續`StartPage`和`EndPage`呼叫應該在相同的作業，直到多工緩衝`EndDoc`呼叫，就會發生。  
  
```  
int StartDoc(LPDOCINFO lpDocInfo);  
int StartDoc(LPCTSTR lpszDocName);
```  
  
### <a name="parameters"></a>參數  
 *lpDocInfo*  
 指向[DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574)結構，其中包含文件檔案的名稱和輸出檔的名稱。  
  
 *lpszDocName*  
 包含文件檔案名稱的字串指標。  
  
### <a name="return-value"></a>傳回值  
 函式成功，傳回的值小於或等於零。 這個值會是文件的列印工作識別項。  
  
 如果函式失敗，傳回的值小於或等於零。  
  
### <a name="remarks"></a>備註  
 這可確保不會與其他工作顛倒文件的長度大於一頁。  
  
 對於 Windows 3.1 和更新版本的版本，此函數會取代**CDC**印表機逸出。 使用此函式，可確保包含多個頁面的文件不會穿插其他列印工作。  
  
 `StartDoc`不應該使用內部中繼檔。  
  
### <a name="example"></a>範例  
 此程式碼片段會取得預設印表機、 列印工作，就會開啟和多工緩衝處理"Hello World ！"的單一頁面 它。 這段程式碼所列印的文字不調整到印表機的邏輯單元，因為輸出文字可能無法以這類小寫字母的結果是無法讀取。 調整函式，例如 CDC `SetMapMode`， `SetViewportOrg`，和`SetWindowExt`，可用來修正縮放比例。  
  
 [!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  
  
##  <a name="startpage"></a>CDC::StartPage  
 呼叫此成員函式，以準備印表機驅動程式接收資料。  
  
```  
int StartPage();
```  
  
### <a name="return-value"></a>傳回值  
 大於或等於 0，如果函式成功或負數值，如果發生錯誤。  
  
### <a name="remarks"></a>備註  
 `StartPage`取代**NEWFRAME**和**BANDINFO**逸出。  
  
 如需列印的呼叫順序的概觀，請參閱[Cdc](#startdoc)成員函式。  
  
 系統會停用`ResetDC`成員函式呼叫之間`StartPage`和`EndPage`。  
  
### <a name="example"></a>範例  
  請參閱範例的[CDC::StartDoc](#startdoc)。  
  
##  <a name="stretchblt"></a>CDC::StretchBlt  
 將來源矩形的點陣圖複製到目的地矩形，必要時可延伸或壓縮點陣圖，使其符合目的地矩形的維度。  
  
```  
BOOL StretchBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定目的地矩形左上角的 X 座標 (以邏輯單位表示)。  
  
 *y*  
 指定目的地矩形左上角的 Y 座標 (以邏輯單位表示)。  
  
 `nWidth`  
 指定目的地矩形的寬度 (以邏輯單位表示)。  
  
 `nHeight`  
 指定目的地矩形的高度 (以邏輯單位表示)。  
  
 `pSrcDC`  
 指定來源裝置內容。  
  
 `xSrc`  
 指定來源矩形左上角的 X 座標 (以邏輯單位表示)。  
  
 `ySrc`  
 指定來源矩形左上角的 Y 座標 (以邏輯單位表示)。  
  
 `nSrcWidth`  
 指定來源矩形的寬度 (以邏輯單位表示)。  
  
 `nSrcHeight`  
 指定來源矩形的高度 (以邏輯單位表示)。  
  
 *dwRop*  
 指定待執行的點陣作業。 點陣作業程式碼定義 GDI 在輸出作業中結合色彩的方式；該輸出作業與目前的筆刷、可能的來源點陣圖和目的地點陣圖相關。 這個參數可以是下列其中一個值：  
  
- **BLACKNESS**所有將輸出的變成黑色。  
  
- **DSTINVERT**反轉目的地點陣圖。  
  
- **MERGECOPY**合併模式和來源點陣圖使用布林值 AND 運算子。  
  
- **MERGEPAINT**合併反轉的來源點陣圖和目的地點陣圖使用布林值 OR 運算子。  
  
- **NOTSRCCOPY**將反轉的來源點陣圖複製到目的地。  
  
- **NOTSRCERASE**反轉合併目的地點陣圖和來源點陣圖使用布林值 OR 運算子的結果。  
  
- **PATCOPY**將模式複製到目的地點陣圖。  
  
- **PATINVERT**模式使用布林值 XOR 運算子合併目的地點陣圖。  
  
- **PATPAINT**模式使用布林值 OR 運算子合併反轉的來源點陣圖。 使用布林值 OR 運算子合併此作業的結果與目的地點陣圖。  
  
- **SRCAND**合併使用布林值 AND 運算子的目的地和來源點陣圖的像素。  
  
- **SRCCOPY**將來源點陣圖複製到目的地點陣圖。  
  
- **SRCERASE**反轉目的地點陣圖，並將結果與使用布林值 AND 運算子的來源點陣圖。  
  
- **SRCINVERT**合併使用布林值 XOR 運算子的目的地和來源點陣圖的像素。  
  
- **SRCPAINT**合併使用布林值 OR 運算子的目的地和來源點陣圖的像素。  
  
- **WHITENESS**所有將輸出的變成白色。  
  
### <a name="return-value"></a>傳回值  
 如果繪製了點陣圖即為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式使用目的地裝置內容 (以 `SetStretchBltMode` 設定) 的縮放模式判斷如何縮放或壓縮點陣圖。  
  
 `StretchBlt` 函式會將點陣圖從 `pSrcDC` 指定的來源裝置移到裝置內容物件代表的目的地裝置 (此物件的成員函式會被呼叫)。 `xSrc`、`ySrc`、`nSrcWidth` 和 `nSrcHeight` 參數定義來源矩形的左上角和維度。 *x*， *y*， `nWidth`，和`nHeight`左上角和目的地矩形的維度，提供給參數。 所指定的點陣作業*dwRop*定義如何合併來源點陣圖和已在目的地裝置上的位元。  
  
 如果 `StretchBlt` 和 `nSrcWidth` 或 `nWidth` 和 `nSrcHeight` 參數的符號不同，`nHeight` 函式會建立點陣圖的鏡像。 如果 `nSrcWidth` and `nWidth` 的符號不同，函式會沿著 X 軸建立點陣圖的鏡像。 如果 `nSrcHeight` and `nHeight` 的符號不同，函式會沿著 Y 軸建立點陣圖的鏡像。  
  
 `StretchBlt` 函式會延伸或壓縮記憶體中的來源點陣圖，然後將結果複製到目的地。 如果要合併模式和結果，除非將延伸的來源點陣圖複製到目的地，否則不會進行合併。 如果使用筆刷，會使用在目的地裝置內容中選取的筆刷。 目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。  
  
 如果目的地、來源和模式點陣圖的色彩格式不同，`StretchBlt` 會轉換來源和模式點陣圖以符合目的地點陣圖。 轉換中會使用目的地裝置内容的前景和背景色彩。  
  
 如果 `StretchBlt` 必須將單色點陣圖轉換為彩色，會將白色位元 (1) 設為背景色彩，並將黑色位元 (0) 設為前景色彩。 若要將彩色轉換為單色，則會將符合背景色彩的像素轉換成白色 (1)，並將其他所有像素設為黑色 (0)。 會使用彩色裝置內容的前景和背景色彩。  
  
 並非所有的裝置皆支援 `StretchBlt` 函式。 若要判斷裝置是否支援`StretchBlt`，呼叫`GetDeviceCaps`成員函式**cdc:: GETDEVICECAPS**索引並檢查傳回值，如**RC_STRETCHBLT**旗標。  
  
##  <a name="strokeandfillpath"></a>CDC::StrokeAndFillPath  
 關閉任何開啟的圖形路徑中，使用目前的畫筆 strokes 外框的路徑並填滿其內部使用目前的筆刷。  
  
```  
BOOL StrokeAndFillPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 裝置內容必須包含已關閉的路徑。 `StrokeAndFillPath`成員函式具有相同的效果關閉所有開啟的圖表，在路徑中，而且繪製，並分別填入路徑，不同之處在於填滿的區域將不會重疊繪製的區域即使畫筆寬度僅能。  
  
##  <a name="strokepath"></a>CDC::StrokePath  
 使用目前的畫筆來呈現指定的路徑。  
  
```  
BOOL StrokePath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 裝置內容必須包含已關閉的路徑。  
  
##  <a name="tabbedtextout"></a>CDC::TabbedTextOut  
 呼叫此成員函式可寫入的字元字串，在指定的位置，展開索引標籤的定位停駐點位置陣列中指定的值。  
  
```  
virtual CSize TabbedTextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);

 
CSize TabbedTextOut(
    int x,  
    int y,  
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定字串的起始點的邏輯 x 座標。  
  
 *y*  
 指定字串的起始點的邏輯 y 座標。  
  
 `lpszString`  
 指向要繪製的字元字串。 您可以將指標傳遞至字元陣列或[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為-1，長度會計算。  
  
 `nTabPositions`  
 指定陣列中的定位停駐點位置的值數目。  
  
 `lpnTabStopPositions`  
 指向陣列，其中包含定位停駐點位置 （以邏輯單位表示）。 必須排序定位停駐點，以遞增順序排列;最小的 x 值應該在陣列中的第一個項目。  
  
 `nTabOrigin`  
 指定要從中索引標籤會展開 （以邏輯單位表示） 的開始位置的 x 座標。  
  
 `str`  
 A`CString`物件，其中包含指定的字元。  
  
### <a name="return-value"></a>傳回值  
 形式的字串 （以邏輯單位表示） 的維度`CSize`物件。  
  
### <a name="remarks"></a>備註  
 文字是撰寫目前選取的字型。 如果`nTabPositions`為 0 和`lpnTabStopPositions`是**NULL**，索引標籤會展開成八次的平均字元寬度。  
  
 如果`nTabPositions`為 1，[] 索引標籤中的第一個值所指定的距離相隔停駐點`lpnTabStopPositions`陣列。 如果`lpnTabStopPositions`陣列包含多個值、 定位點設定為最多指定的數字陣列中每個值`nTabPositions`。 `nTabOrigin`參數可讓應用程式呼叫`TabbedTextOut`函式數次的單一行。 如果應用程式會呼叫此函式一次以上與`nTabOrigin`每次設定為相同的值，函式會展開所有索引標籤相對於所指定的位置`nTabOrigin`。  
  
 根據預設，函式不會使用或更新目前的位置。 如果應用程式需要更新目前的位置，它會呼叫此函式時，應用程式可以呼叫[SetTextAlign](#settextalign)成員函式`nFlags`設**TA_UPDATECP**。 當設定這個旗標時，Windows 會略過*x*和*y*參數在後續呼叫`TabbedTextOut`，改為使用目前的位置。  
  
##  <a name="textout"></a>CDC::TextOut  
 使用目前選取的字型，在指定的位置寫入字元字串。  
  
```  
virtual BOOL TextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount);

 
BOOL TextOut(
    int x,
    int y,
    const CString& str);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定文字起點的邏輯 X 座標。  
  
 *y*  
 指定文字起點的邏輯 Y 座標。  
  
 `lpszString`  
 指向要繪製的字元字串。  
  
 `nCount`  
 指定字串中的字元數。  
  
 `str`  
 `CString` 物件，其中包含要繪製的字元。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 字元原點在字元儲存格的左上角。 根據預設，函式不會使用或更新目前的位置。  
  
 如果應用程式需要更新目前的位置時，它會呼叫`TextOut`，應用程式可以呼叫`SetTextAlign`成員函式`nFlags`設**TA_UPDATECP**。 當設定這個旗標時，Windows 會略過*x*和*y*參數在後續呼叫`TextOut`，改為使用目前的位置。  
  
### <a name="example"></a>範例  
  請參閱範例的[cdc:: beginpath](#beginpath)。  
  
##  <a name="transparentblt"></a>CDC::TransparentBlt  
 呼叫此成員函式，將對應從指定的來源裝置內容中，放入目的地裝置內容中的像素矩形的色彩資料位元區塊。  
  
```  
BOOL TransparentBlt(
    int xDest,  
    int yDest,
    int nDestWidth,
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    UINT clrTransparent);
```  
  
### <a name="parameters"></a>參數  
 `xDest`  
 指定邏輯的單位，目的地矩形左上角的 x 軸座標。  
  
 `yDest`  
 指定邏輯的單位，目的地矩形左上角的 y 軸座標。  
  
 `nDestWidth`  
 指定邏輯單元，目的矩形的寬度。  
  
 `nDestHeight`  
 指定邏輯單元，目的矩形的高度。  
  
 `pSrcDC`  
 來源裝置內容的指標。  
  
 `xSrc`  
 指定 x 軸座標，以來源矩形的邏輯單位。  
  
 `ySrc`  
 指定 y 軸座標，以來源矩形的邏輯單位。  
  
 `nSrcWidth`  
 指定邏輯單元，來源矩形的寬度。  
  
 `nSrcHeight`  
 指定邏輯單元，來源矩形的高度。  
  
 `clrTransparent`  
 中要視為透明的來源點陣圖的 RGB 色彩。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果成功，否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 `TransparentBlt`可讓透明度。也就是 RGB 色彩由`clrTransparent`呈現透明的傳輸。  
  
 如需詳細資訊，請參閱[TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141) Windows SDK 中。  
  
##  <a name="updatecolors"></a>CDC::UpdateColors  
 更新裝置內容比對目前的工作區中工作區，以像素 x 像素為基礎的系統調色盤的色彩。  
  
```  
void UpdateColors();
```  
  
### <a name="remarks"></a>備註  
 可能會呼叫非作用中視窗，以實現的邏輯色板`UpdateColors`作為系統調色盤變更時，重繪其工作區的替代方案。  
  
 如需使用色彩調色盤的詳細資訊，請參閱[UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166) Windows SDK 中。  
  
 `UpdateColors`成員函式通常會更新用戶端區域速度重新繪製區域。 不過，由於函式會執行系統調色盤變更之前，根據每個像素色彩的色彩轉譯，每次呼叫此函式就會導致某些色彩精確度遺失。  
  
##  <a name="widenpath"></a>CDC::WidenPath  
 如果路徑圖案使用目前選取的裝置內容到畫筆會繪製的區域來重新定義的目前路徑。  
  
```  
BOOL WidenPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式是成功，只有當目前的畫筆的第二個版本所建立的幾何畫筆`CreatePen`成員函式，或如果第一個版本建立畫筆`CreatePen`和裝置單位，大於 1 的寬度。 裝置內容必須包含已關閉的路徑。 在路徑中的任何 Bzier 曲線轉換成直線將逼近擴大的曲線的序列。 因此，沒有 Bzier 曲線保留在後面的路徑`WidenPath`呼叫。  
  
## <a name="see-also"></a>請參閱  
 [CObject 類別](../../mfc/reference/cobject-class.md)   
 [階層架構圖表](../../mfc/hierarchy-chart.md)   
 [CPaintDC 類別](../../mfc/reference/cpaintdc-class.md)   
 [CWindowDC 類別](../../mfc/reference/cwindowdc-class.md)   
 [CClientDC 類別](../../mfc/reference/cclientdc-class.md)   
 [CMetaFileDC 類別](../../mfc/reference/cmetafiledc-class.md)
