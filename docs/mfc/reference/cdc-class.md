---
title: CDC 類別
ms.date: 11/19/2018
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
helpviewer_keywords:
- CDC [MFC], CDC
- CDC [MFC], AbortDoc
- CDC [MFC], AbortPath
- CDC [MFC], AddMetaFileComment
- CDC [MFC], AlphaBlend
- CDC [MFC], AngleArc
- CDC [MFC], Arc
- CDC [MFC], ArcTo
- CDC [MFC], Attach
- CDC [MFC], BeginPath
- CDC [MFC], BitBlt
- CDC [MFC], Chord
- CDC [MFC], CloseFigure
- CDC [MFC], CreateCompatibleDC
- CDC [MFC], CreateDC
- CDC [MFC], CreateIC
- CDC [MFC], DeleteDC
- CDC [MFC], DeleteTempMap
- CDC [MFC], Detach
- CDC [MFC], DPtoHIMETRIC
- CDC [MFC], DPtoLP
- CDC [MFC], Draw3dRect
- CDC [MFC], DrawDragRect
- CDC [MFC], DrawEdge
- CDC [MFC], DrawEscape
- CDC [MFC], DrawFocusRect
- CDC [MFC], DrawFrameControl
- CDC [MFC], DrawIcon
- CDC [MFC], DrawState
- CDC [MFC], DrawText
- CDC [MFC], DrawTextEx
- CDC [MFC], Ellipse
- CDC [MFC], EndDoc
- CDC [MFC], EndPage
- CDC [MFC], EndPath
- CDC [MFC], EnumObjects
- CDC [MFC], Escape
- CDC [MFC], ExcludeClipRect
- CDC [MFC], ExcludeUpdateRgn
- CDC [MFC], ExtFloodFill
- CDC [MFC], ExtTextOut
- CDC [MFC], FillPath
- CDC [MFC], FillRect
- CDC [MFC], FillRgn
- CDC [MFC], FillSolidRect
- CDC [MFC], FlattenPath
- CDC [MFC], FloodFill
- CDC [MFC], FrameRect
- CDC [MFC], FrameRgn
- CDC [MFC], FromHandle
- CDC [MFC], GetArcDirection
- CDC [MFC], GetAspectRatioFilter
- CDC [MFC], GetBkColor
- CDC [MFC], GetBkMode
- CDC [MFC], GetBoundsRect
- CDC [MFC], GetBrushOrg
- CDC [MFC], GetCharABCWidths
- CDC [MFC], GetCharABCWidthsI
- CDC [MFC], GetCharacterPlacement
- CDC [MFC], GetCharWidth
- CDC [MFC], GetCharWidthI
- CDC [MFC], GetClipBox
- CDC [MFC], GetColorAdjustment
- CDC [MFC], GetCurrentBitmap
- CDC [MFC], GetCurrentBrush
- CDC [MFC], GetCurrentFont
- CDC [MFC], GetCurrentPalette
- CDC [MFC], GetCurrentPen
- CDC [MFC], GetCurrentPosition
- CDC [MFC], GetDCBrushColor
- CDC [MFC], GetDCPenColor
- CDC [MFC], GetDeviceCaps
- CDC [MFC], GetFontData
- CDC [MFC], GetFontLanguageInfo
- CDC [MFC], GetGlyphOutline
- CDC [MFC], GetGraphicsMode
- CDC [MFC], GetHalftoneBrush
- CDC [MFC], GetKerningPairs
- CDC [MFC], GetLayout
- CDC [MFC], GetMapMode
- CDC [MFC], GetMiterLimit
- CDC [MFC], GetNearestColor
- CDC [MFC], GetOutlineTextMetrics
- CDC [MFC], GetOutputCharWidth
- CDC [MFC], GetOutputTabbedTextExtent
- CDC [MFC], GetOutputTextExtent
- CDC [MFC], GetOutputTextMetrics
- CDC [MFC], GetPath
- CDC [MFC], GetPixel
- CDC [MFC], GetPolyFillMode
- CDC [MFC], GetROP2
- CDC [MFC], GetSafeHdc
- CDC [MFC], GetStretchBltMode
- CDC [MFC], GetTabbedTextExtent
- CDC [MFC], GetTextAlign
- CDC [MFC], GetTextCharacterExtra
- CDC [MFC], GetTextColor
- CDC [MFC], GetTextExtent
- CDC [MFC], GetTextExtentExPointI
- CDC [MFC], GetTextExtentPointI
- CDC [MFC], GetTextFace
- CDC [MFC], GetTextMetrics
- CDC [MFC], GetViewportExt
- CDC [MFC], GetViewportOrg
- CDC [MFC], GetWindow
- CDC [MFC], GetWindowExt
- CDC [MFC], GetWindowOrg
- CDC [MFC], GetWorldTransform
- CDC [MFC], GradientFill
- CDC [MFC], GrayString
- CDC [MFC], HIMETRICtoDP
- CDC [MFC], HIMETRICtoLP
- CDC [MFC], IntersectClipRect
- CDC [MFC], InvertRect
- CDC [MFC], InvertRgn
- CDC [MFC], IsPrinting
- CDC [MFC], LineTo
- CDC [MFC], LPtoDP
- CDC [MFC], LPtoHIMETRIC
- CDC [MFC], MaskBlt
- CDC [MFC], ModifyWorldTransform
- CDC [MFC], MoveTo
- CDC [MFC], OffsetClipRgn
- CDC [MFC], OffsetViewportOrg
- CDC [MFC], OffsetWindowOrg
- CDC [MFC], PaintRgn
- CDC [MFC], PatBlt
- CDC [MFC], Pie
- CDC [MFC], PlayMetaFile
- CDC [MFC], PlgBlt
- CDC [MFC], PolyBezier
- CDC [MFC], PolyBezierTo
- CDC [MFC], PolyDraw
- CDC [MFC], Polygon
- CDC [MFC], Polyline
- CDC [MFC], PolylineTo
- CDC [MFC], PolyPolygon
- CDC [MFC], PolyPolyline
- CDC [MFC], PtVisible
- CDC [MFC], RealizePalette
- CDC [MFC], Rectangle
- CDC [MFC], RectVisible
- CDC [MFC], ReleaseAttribDC
- CDC [MFC], ReleaseOutputDC
- CDC [MFC], ResetDC
- CDC [MFC], RestoreDC
- CDC [MFC], RoundRect
- CDC [MFC], SaveDC
- CDC [MFC], ScaleViewportExt
- CDC [MFC], ScaleWindowExt
- CDC [MFC], ScrollDC
- CDC [MFC], SelectClipPath
- CDC [MFC], SelectClipRgn
- CDC [MFC], SelectObject
- CDC [MFC], SelectPalette
- CDC [MFC], SelectStockObject
- CDC [MFC], SetAbortProc
- CDC [MFC], SetArcDirection
- CDC [MFC], SetAttribDC
- CDC [MFC], SetBkColor
- CDC [MFC], SetBkMode
- CDC [MFC], SetBoundsRect
- CDC [MFC], SetBrushOrg
- CDC [MFC], SetColorAdjustment
- CDC [MFC], SetDCBrushColor
- CDC [MFC], SetDCPenColor
- CDC [MFC], SetGraphicsMode
- CDC [MFC], SetLayout
- CDC [MFC], SetMapMode
- CDC [MFC], SetMapperFlags
- CDC [MFC], SetMiterLimit
- CDC [MFC], SetOutputDC
- CDC [MFC], SetPixel
- CDC [MFC], SetPixelV
- CDC [MFC], SetPolyFillMode
- CDC [MFC], SetROP2
- CDC [MFC], SetStretchBltMode
- CDC [MFC], SetTextAlign
- CDC [MFC], SetTextCharacterExtra
- CDC [MFC], SetTextColor
- CDC [MFC], SetTextJustification
- CDC [MFC], SetViewportExt
- CDC [MFC], SetViewportOrg
- CDC [MFC], SetWindowExt
- CDC [MFC], SetWindowOrg
- CDC [MFC], SetWorldTransform
- CDC [MFC], StartDoc
- CDC [MFC], StartPage
- CDC [MFC], StretchBlt
- CDC [MFC], StrokeAndFillPath
- CDC [MFC], StrokePath
- CDC [MFC], TabbedTextOut
- CDC [MFC], TextOut
- CDC [MFC], TransparentBlt
- CDC [MFC], UpdateColors
- CDC [MFC], WidenPath
- CDC [MFC], m_hAttribDC
- CDC [MFC], m_hDC
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
ms.openlocfilehash: fc5d41221ab0f9679e7d38a399464efc1a38dd52
ms.sourcegitcommit: c3093251193944840e3d0a068ecc30e6449624ba
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/04/2019
ms.locfileid: "57305077"
---
# <a name="cdc-class"></a>CDC 類別

定義裝置內容物件的類別。

## <a name="syntax"></a>語法

```
class CDC : public CObject
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CDC::CDC](#cdc)|建構 `CDC` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CDC::AbortDoc](#abortdoc)|終止目前的列印工作，清除所有應用程式時，已寫入至裝置上，自上次呼叫的項目`StartDoc`成員函式。|
|[CDC::AbortPath](#abortpath)|關閉並捨棄任何在裝置內容中的路徑。|
|[CDC::AddMetaFileComment](#addmetafilecomment)|將註解從緩衝區複製到指定的格式增強型中繼檔。|
|[CDC::AlphaBlend](#alphablend)|顯示具有透明或半透明的像素的點陣圖。|
|[CDC::AngleArc](#anglearc)|繪製直線線段和弧形，並將目前位置移到弧形結束點。|
|[CDC::Arc](#arc)|繪製橢圓形弧線。|
|[CDC::ArcTo](#arcto)|繪製橢圓形弧線。此函數非常類似於`Arc`，不同之處在於會更新目前的位置。|
|[CDC::Attach](#attach)|將 Windows 裝置內容附加至這個`CDC`物件。|
|[CDC::BeginPath](#beginpath)|裝置內容中開啟的路徑括號。|
|[CDC::BitBlt](#bitblt)|複製指定的裝置內容中的點陣圖。|
|[CDC::Chord](#chord)|繪製的同步選取 （橢圓形 和 直線線段的交集所繫結到封閉的圖表）。|
|[CDC::CloseFigure](#closefigure)|關閉開放的圖形路徑中。|
|[CDC::CreateCompatibleDC](#createcompatibledc)|建立與另一個裝置內容相容的裝置記憶體裝置內容。 您可以使用它來準備映像，在記憶體中。|
|[CDC::CreateDC](#createdc)|建立特定裝置的裝置內容。|
|[CDC::CreateIC](#createic)|建立特定裝置的資訊內容。 這提供快速的方法來取得裝置的相關資訊，而建立的裝置內容。|
|[CDC::DeleteDC](#deletedc)|刪除與此相關聯的 Windows 裝置內容`CDC`物件。|
|[CDC::DeleteTempMap](#deletetempmap)|由呼叫`CWinApp`閒置時間處理常式，來刪除暫時`CDC`所建立的物件`FromHandle`。 也會中斷連結的裝置內容。|
|[CDC::Detach](#detach)|卸離 Windows 裝置內容，從這個`CDC`物件。|
|[CDC::DPtoHIMETRIC](#dptohimetric)|將裝置單位轉換成 HIMETRIC 單位中。|
|[CDC::DPtoLP](#dptolp)|將裝置單位轉換成邏輯單元。|
|[CDC::Draw3dRect](#draw3drect)|繪製 3d 矩形。|
|[CDC::DrawDragRect](#drawdragrect)|清除並重新繪製矩形，因為它被拖曳。|
|[CDC::DrawEdge](#drawedge)|繪製矩形邊緣。|
|[CDC::DrawEscape](#drawescape)|繪製便無法直接透過圖形裝置介面 (GDI) 視訊的顯示功能的存取。|
|[CDC::DrawFocusRect](#drawfocusrect)|用來指出焦點的樣式繪製矩形。|
|[CDC::DrawFrameControl](#drawframecontrol)|繪製畫面格控制項。|
|[CDC::DrawIcon](#drawicon)|繪製圖示。|
|[CDC::DrawState](#drawstate)|顯示影像，並套用來表示狀態的視覺效果。|
|[CDC::DrawText](#drawtext)|繪製格式化指定的矩形中的文字。|
|[CDC::DrawTextEx](#drawtextex)|繪製格式化指定的矩形，使用其他格式中的文字。|
|[CDC::Ellipse](#ellipse)|繪製橢圓形。|
|[CDC::EndDoc](#enddoc)|結束列印工作開始著手`StartDoc`成員函式。|
|[CDC::EndPage](#endpage)|會通知頁面即將結束的裝置驅動程式。|
|[CDC::EndPath](#endpath)|關閉路徑括號，並選取放入裝置內容的 方括號所定義的路徑。|
|[CDC::EnumObjects](#enumobjects)|列舉畫筆和筆刷會在裝置內容中使用。|
|[CDC::Escape](#escape)|允許應用程式存取不是來自特定裝置透過 GDI 直接提供的功能。 也可讓 Windows 逸出功能的存取權。 應用程式所提出的逸出呼叫會轉譯，並傳送給裝置驅動程式。|
|[CDC::ExcludeClipRect](#excludecliprect)|建立新的裁剪區域，其中包含現有的裁剪區域，減去指定的矩形。|
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|從裁剪區域排除的更新的區域視窗中，以防止無效視窗區域內的繪圖。|
|[CDC::ExtFloodFill](#extfloodfill)|使用目前的筆刷，填滿區域。 提供更大的彈性比[CDC::FloodFill](#floodfill)成員函式。|
|[CDC::ExtTextOut](#exttextout)|寫入使用目前選取的字型的矩形區域中的字元字串。|
|[CDC::FillPath](#fillpath)|關閉任何開啟的數字，目前路徑中，填滿的路徑內部使用目前的筆刷和多邊形填滿模式。|
|[CDC::FillRect](#fillrect)|使用特定的筆刷，填滿指定的矩形。|
|[CDC::FillRgn](#fillrgn)|特定區域填入指定的筆刷。|
|[CDC::FillSolidRect](#fillsolidrect)|使用純色，填滿的矩形。|
|[CDC::FlattenPath](#flattenpath)|轉換到目前的裝置內容中，選取的路徑中的任何型曲線，並將每條曲線轉換成一連串的行。|
|[CDC::FloodFill](#floodfill)|使用目前的筆刷，填滿區域。|
|[CDC::FrameRect](#framerect)|繪製矩形周圍的框線。|
|[CDC::FrameRgn](#framergn)|使用筆刷的特定區域周圍繪製框線。|
|[CDC::FromHandle](#fromhandle)|將指標傳回至`CDC`物件時指定的裝置內容的控制代碼。 如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。|
|[CDC::GetArcDirection](#getarcdirection)|傳回目前的弧形方向，裝置內容。|
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|擷取目前的長寬比篩選器的值。|
|[CDC::GetBkColor](#getbkcolor)|擷取目前的背景色彩。|
|[CDC::GetBkMode](#getbkmode)|擷取背景模式。|
|[CDC::GetBoundsRect](#getboundsrect)|傳回指定的裝置內容的目前累積周框矩形。|
|[CDC::GetBrushOrg](#getbrushorg)|擷取目前的筆刷的原點。|
|[CDC::GetCharABCWidths](#getcharabcwidths)|擷取寬度，以邏輯單位，在指定的範圍內，從目前的字型的連續字元。|
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|擷取寬度，以邏輯單位，從目前的 TrueType 字型在指定範圍中的連續的字符索引。|
|[CDC::GetCharacterPlacement](#getcharacterplacement)|擷取各種類型的字元字串的詳細資訊。|
|[CDC::GetCharWidth](#getcharwidth)|擷取目前的字型小數給定範圍中的連續字元的寬度。|
|[CDC::GetCharWidthI](#getcharwidthi)|擷取寬度，以邏輯座標，從目前的字型在指定範圍中的連續的字符索引。|
|[CDC::GetClipBox](#getclipbox)|擷取目前的裁剪界限周圍 tightest 週框矩形的維度。|
|[CDC::GetColorAdjustment](#getcoloradjustment)|擷取裝置內容的色彩調整值。|
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|讓指標回到目前所選`CBitmap`物件。|
|[CDC::GetCurrentBrush](#getcurrentbrush)|讓指標回到目前所選`CBrush`物件。|
|[CDC::GetCurrentFont](#getcurrentfont)|讓指標回到目前所選`CFont`物件。|
|[CDC::GetCurrentPalette](#getcurrentpalette)|讓指標回到目前所選`CPalette`物件。|
|[CDC::GetCurrentPen](#getcurrentpen)|讓指標回到目前所選`CPen`物件。|
|[CDC::GetCurrentPosition](#getcurrentposition)|擷取目前的畫筆位置 （以邏輯座標中）。|
|[CDC::GetDCBrushColor](#getdcbrushcolor)|擷取目前的筆刷色彩。|
|[CDC::GetDCPenColor](#getdcpencolor)|擷取目前的畫筆顏色。|
|[CDC::GetDeviceCaps](#getdevicecaps)|擷取指定的一種指定的顯示裝置的功能的裝置特定資訊。|
|[CDC::GetFontData](#getfontdata)|擷取可調式字型檔案中的字型度量資訊。 要擷取之資訊識別到字型檔案，以及要傳回的資訊中指定的位移。|
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|傳回指定的顯示內容的目前選取字型的相關資訊。|
|[CDC::GetGlyphOutline](#getglyphoutline)|擷取的外框曲線或外框中字元的目前字型的點陣圖。|
|[CDC::GetGraphicsMode](#getgraphicsmode)|擷取指定的裝置內容的目前圖形模式。|
|[CDC::GetHalftoneBrush](#gethalftonebrush)|擷取半色調筆刷。|
|[CDC::GetKerningPairs](#getkerningpairs)|擷取字元間距調整組指定的裝置內容中目前選取之字型的字元。|
|[CDC::GetLayout](#getlayout)|擷取裝置內容 (DC) 的配置。 配置可以是保留到右 （預設值），或由右至左 （鏡像）。|
|[CDC::GetMapMode](#getmapmode)|擷取目前的對應模式。|
|[CDC::GetMiterLimit](#getmiterlimit)|傳回裝置內容斜接限制。|
|[CDC::GetNearestColor](#getnearestcolor)|擷取最接近的邏輯色彩，以指定的邏輯色彩可代表指定的裝置。|
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|擷取 TrueType 字型的字型度量資訊。|
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|擷取目前使用的輸出裝置內容的字型顯示連續的字元群組中的個別字元的寬度。|
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|計算字元字串，在輸出裝置內容的高度與寬度。|
|[CDC::GetOutputTextExtent](#getoutputtextextent)|計算的輸出裝置內容，來決定維度使用的目前字型的文字行的高度與寬度。|
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|擷取輸出裝置內容中的目前字型度量資訊。|
|[CDC::GetPath](#getpath)|擷取定義線條的端點和選入裝置內容的路徑中找到的曲線的控制點座標。|
|[CDC::GetPixel](#getpixel)|擷取位於指定點的像素的 RGB 色彩值。|
|[CDC::GetPolyFillMode](#getpolyfillmode)|擷取目前的多邊形填滿模式。|
|[CDC::GetROP2](#getrop2)|擷取目前的繪製模式。|
|[CDC::GetSafeHdc](#getsafehdc)|傳回[CDC::m_hDC](#m_hdc)，輸出裝置內容。|
|[CDC::GetStretchBltMode](#getstretchbltmode)|擷取目前的點陣圖縮放模式。|
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|計算字元字串屬性的裝置內容的高度與寬度。|
|[CDC::GetTextAlign](#gettextalign)|擷取的文字對齊方式的旗標。|
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|擷取目前的設定 intercharacter 間距量。|
|[CDC::GetTextColor](#gettextcolor)|擷取目前的文字色彩。|
|[CDC::GetTextExtent](#gettextextent)|計算以決定維度使用目前的字型屬性裝置內容上的文字行高度與寬度。|
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|擷取在指定的字串將放入指定的空間中，陣列中填入文字範圍的每個這些字元的字元數目。|
|[CDC::GetTextExtentPointI](#gettextextentpointi)|擷取指定之陣列的字符索引的高度與寬度。|
|[CDC::GetTextFace](#gettextface)|將目前的字型的字樣名稱複製到緩衝區中，為以 null 結束的字串。|
|[CDC::GetTextMetrics](#gettextmetrics)|擷取屬性的裝置內容中的目前字型度量資訊。|
|[CDC::GetViewportExt](#getviewportext)|擷取 x-和 y-範圍的檢視區。|
|[CDC::GetViewportOrg](#getviewportorg)|擷取的檢視區原點 x 和 y 座標。|
|[CDC::GetWindow](#getwindow)|傳回顯示裝置內容相關聯的視窗。|
|[CDC::GetWindowExt](#getwindowext)|擷取 x-和 y-範圍相關聯的視窗。|
|[CDC::GetWindowOrg](#getwindoworg)|擷取相關聯的視窗的原始 x 和 y 座標。|
|[CDC::GetWorldTransform](#getworldtransform)|擷取目前世界空間頁面空間轉換。|
|[CDC::GradientFill](#gradientfill)|填入 gradating 色彩矩形和三角形的結構。|
|[CDC::GrayString](#graystring)|繪製停用 （呈現灰色） 在指定位置的文字。|
|[CDC::HIMETRICtoDP](#himetrictodp)|將 HIMETRIC 單位轉換成裝置單位。|
|[CDC::HIMETRICtoLP](#himetrictolp)|將 HIMETRIC 單位轉換成邏輯單元。|
|[CDC::IntersectClipRect](#intersectcliprect)|建立新的裁剪區域形成目前的區域和矩形的交集。|
|[CDC::InvertRect](#invertrect)|反轉一個矩形的內容。|
|[CDC::InvertRgn](#invertrgn)|反轉色彩區域中。|
|[CDC::IsPrinting](#isprinting)|判斷是否正在使用的裝置內容進行列印。|
|[CDC::LineTo](#lineto)|從目前的位置，但不是包括，點繪製的線條。|
|[CDC::LPtoDP](#lptodp)|將邏輯單元轉換成裝置單位。|
|[CDC::LPtoHIMETRIC](#lptohimetric)|將邏輯單元轉換成 HIMETRIC 單位中。|
|[CDC::MaskBlt](#maskblt)|結合使用給定的遮罩和點陣作業的來源和目的地點陣圖的色彩資料。|
|[CDC::ModifyWorldTransform](#modifyworldtransform)|變更裝置內容中使用指定的模式自然轉換。|
|[CDC::MoveTo](#moveto)|將目前位置的移動。|
|[CDC::OffsetClipRgn](#offsetcliprgn)|移動指定的裝置的裁剪區域。|
|[CDC::OffsetViewportOrg](#offsetviewportorg)|修改檢視區的原點，相對於目前的檢視區原點座標。|
|[CDC::OffsetWindowOrg](#offsetwindoworg)|修改視窗原點，相對於目前視窗原點座標。|
|[CDC::PaintRgn](#paintrgn)|使用選取的筆刷，填滿區域。|
|[CDC::PatBlt](#patblt)|會建立一個位元模式。|
|[CDC::Pie](#pie)|繪製派形的楔形。|
|[CDC::PlayMetaFile](#playmetafile)|指定的裝置上播放所指定的中繼檔的內容。 增強型的版本`PlayMetaFile`會顯示指定的格式增強型中繼檔中儲存的圖片。 中繼檔可以播放次數。|
|[CDC::PlgBlt](#plgblt)|執行從來源裝置內容中指定之矩形的色彩資料位元的位元區塊傳輸，以指定的裝置內容中指定的平行四邊形。|
|[CDC::PolyBezier](#polybezier)|繪製一個或多個 Bzier 曲線。 目前的位置不會使用或更新。|
|[CDC::PolyBezierTo](#polybezierto)|繪製一個或多個 Bzier 曲線，並將目前位置移至最後一個 Bzier 曲線的結束點。|
|[CDC::PolyDraw](#polydraw)|繪製一組直線線段和 Bzier 曲線。 此函式會更新目前的位置。|
|[CDC::Polygon](#polygon)|繪製多邊形，其中包含兩個或多個 （頂點） 以折線連接點。|
|[CDC::Polyline](#polyline)|繪製連接指定的點之線段的一組。|
|[CDC::PolylineTo](#polylineto)|繪製一或多個直線，並將目前位置移到最後一行的結束點。|
|[CDC::PolyPolygon](#polypolygon)|建立兩個或多個多邊形的填滿使用目前的多邊形填滿模式。 多邊形可能不相鄰，或是可能會重疊。|
|[CDC::PolyPolyline](#polypolyline)|繪製連接的直線線段的多個數列。 目前的位置不會使用或更新此函式。|
|[CDC::PtVisible](#ptvisible)|指定的裁剪區域中是否為指定的時間點。|
|[CDC::RealizePalette](#realizepalette)|將目前的邏輯調色盤中的調色盤項目對應至系統調色盤中。|
|[CDC::Rectangle](#rectangle)|使用目前畫筆繪製矩形，並填滿它使用目前的筆刷。|
|[CDC::RectVisible](#rectvisible)|判斷指定的任何的矩形部分是否蘊含的裁剪區域。|
|[CDC::ReleaseAttribDC](#releaseattribdc)|版本`m_hAttribDC`，屬性的裝置內容。|
|[CDC::ReleaseOutputDC](#releaseoutputdc)|版本`m_hDC`，輸出裝置內容。|
|[CDC::ResetDC](#resetdc)|更新`m_hAttribDC`裝置內容。|
|[CDC::RestoreDC](#restoredc)|將裝置內容還原成先前的狀態，以儲存`SaveDC`。|
|[CDC::RoundRect](#roundrect)|繪製具有圓角，使用目前的畫筆，並使用目前的筆刷填滿的矩形。|
|[CDC::SaveDC](#savedc)|將儲存的裝置內容的目前狀態。|
|[CDC::ScaleViewportExt](#scaleviewportext)|修改檢視區範圍相對於目前的值。|
|[CDC::ScaleWindowExt](#scalewindowext)|修改視窗範圍相對於目前的值。|
|[CDC::ScrollDC](#scrolldc)|水平和垂直，請捲動的位元的矩形。|
|[CDC::SelectClipPath](#selectclippath)|選取目前的路徑做為裝置內容中，使用指定的模式結合新的區域與任何現有的裁剪區域的裁剪區域。|
|[CDC::SelectClipRgn](#selectcliprgn)|使用指定的模式會結合指定的區域與目前裁剪區域。|
|[CDC::SelectObject](#selectobject)|選取 GDI 繪圖的物件，例如畫筆。|
|[CDC::SelectPalette](#selectpalette)|選取邏輯調色盤。|
|[CDC::SelectStockObject](#selectstockobject)|選取其中一個預先定義的內建畫筆、 筆刷或 Windows 所提供的字型。|
|[CDC::SetAbortProc](#setabortproc)|設定 Windows 呼叫如果必須中止列印工作的程式設計人員提供的回呼函式。|
|[CDC::SetArcDirection](#setarcdirection)|設定要用於弧線和矩形函式的繪製方向。|
|[CDC::SetAttribDC](#setattribdc)|設定`m_hAttribDC`，屬性的裝置內容。|
|[CDC::SetBkColor](#setbkcolor)|設定目前的背景色彩。|
|[CDC::SetBkMode](#setbkmode)|設定 背景模式。|
|[CDC::SetBoundsRect](#setboundsrect)|控制指定的裝置內容的週框矩形資訊的累積。|
|[CDC::SetBrushOrg](#setbrushorg)|指定放入裝置內容中選取 [下一步] 筆刷的原點。|
|[CDC::SetColorAdjustment](#setcoloradjustment)|設定裝置內容，使用指定的值的色彩調整值。|
|[CDC::SetDCBrushColor](#setdcbrushcolor)|設定目前的筆刷色彩。|
|[CDC::SetDCPenColor](#setdcpencolor)|設定目前的畫筆色彩。|
|[CDC::SetGraphicsMode](#setgraphicsmode)|設定指定的裝置內容的目前圖形模式。|
|[CDC::SetLayout](#setlayout)|變更裝置內容 (DC) 的配置。|
|[CDC::SetMapMode](#setmapmode)|設定目前的對應模式。|
|[CDC::SetMapperFlags](#setmapperflags)|改變時則會對應至實體字型的邏輯字型的字型對應程式所使用的演算法。|
|[CDC::SetMiterLimit](#setmiterlimit)|設定斜接角聯結裝置內容的長度限制。|
|[CDC::SetOutputDC](#setoutputdc)|設定`m_hDC`，輸出裝置內容。|
|[CDC::SetPixel](#setpixel)|將像素設定在指定的時間點，來指定色彩的最接近的近似值。|
|[CDC::SetPixelV](#setpixelv)|將像素設定在指定的座標，來指定色彩的最接近的近似值。 `SetPixelV` 速度比`SetPixel`因為不需要傳回實際繪製點的色彩值。|
|[CDC::SetPolyFillMode](#setpolyfillmode)|將多邊形填滿模式。|
|[CDC::SetROP2](#setrop2)|設定目前的繪製模式。|
|[CDC::SetStretchBltMode](#setstretchbltmode)|設定的點陣圖縮放模式。|
|[CDC::SetTextAlign](#settextalign)|設定文字對齊方式的旗標。|
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|設定 intercharacter 的間距數量。|
|[CDC::SetTextColor](#settextcolor)|設定文字色彩。|
|[CDC::SetTextJustification](#settextjustification)|將字串中的分行符號字元空間。|
|[CDC::SetViewportExt](#setviewportext)|設定 x-和 y-範圍的檢視區。|
|[CDC::SetViewportOrg](#setviewportorg)|設定檢視區的原點。|
|[CDC::SetWindowExt](#setwindowext)|設定 x-和 y-範圍相關聯的視窗。|
|[CDC::SetWindowOrg](#setwindoworg)|設定裝置內容的視窗原點。|
|[CDC::SetWorldTransform](#setworldtransform)|將目前的世界空間設定分頁空間轉換。|
|[CDC::StartDoc](#startdoc)|正在啟動新的列印工作的裝置驅動程式就會通知。|
|[CDC::StartPage](#startpage)|會通知裝置驅動程式正在啟動新的頁面。|
|[CDC::StretchBlt](#stretchblt)|將點陣圖的來源矩形和裝置移到目的地矩形，延伸或壓縮點陣圖，如有必要，以符合目的地矩形的維度。|
|[CDC::StrokeAndFillPath](#strokeandfillpath)|關閉任何開啟的圖形路徑中，使用目前的畫筆，發生的外框路徑並填滿其內部使用目前的筆刷。|
|[CDC::StrokePath](#strokepath)|使用目前的畫筆，以呈現指定的路徑。|
|[CDC::TabbedTextOut](#tabbedtextout)|寫入指定的位置，並展開索引標籤的定位停駐點位置陣列中指定的值在字元字串。|
|[CDC::TextOut](#textout)|將字元字串，在指定的位置，使用目前選取的字型。|
|[CDC::TransparentBlt](#transparentblt)|從指定的來源裝置內容的色彩資料位元區塊傳輸到目的地裝置內容，轉譯指定的色彩透明在傳送中。|
|[CDC::UpdateColors](#updatecolors)|更新裝置內容比對目前的工作區中系統調色盤像素 x 像素為基礎的用戶端區域的色彩。|
|[CDC::WidenPath](#widenpath)|如果路徑圖案使用目前選取的裝置內容到畫筆會繪製的區域來重新定義目前的路徑。|

### <a name="public-operators"></a>公用運算子

|名稱|描述|
|----------|-----------------|
|[CDC::operator HDC](#operator_hdc)|擷取裝置內容控制的代碼。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CDC::m_hAttribDC](#m_hattribdc)|由這個屬性裝置內容`CDC`物件。|
|[CDC::m_hDC](#m_hdc)|由這個輸出裝置內容`CDC`物件。|

## <a name="remarks"></a>備註

`CDC`物件提供成員函式使用的裝置內容，例如顯示器或印表機，以及成員使用的視窗工作區相關聯的顯示內容。

請勿透過成員的所有繪圖函式的`CDC`物件。 類別會提供裝置內容的作業，使用繪圖工具，型別安全圖形裝置介面 (GDI) 物件選取項目，和使用的色彩與調色盤中的成員函式。 它也提供用於取得及設定繪製屬性對應，使用 [檢視區，而且要使用的視窗範圍內，轉換座標、 使用區域的裁剪： 繪製線條和繪圖的簡單圖形] 的省略符號，成員函式和多邊形。 成員函式也會提供繪製文字、 使用的字型、 使用印表機逸出，向下捲動，以及播放中繼檔。

若要使用`CDC`物件，建構，並接著呼叫其成員平行使用裝置內容的 Windows 函式的函式。

> [!NOTE]
>  在 Windows 95、windows 98/下所有的螢幕座標會限制為 16 位元。 因此， **int**傳遞至`CDC`成員函式必須介於-32768 到 32767 之間的範圍。

如需特定的用途，Microsoft Foundation 類別庫提供數個類別衍生自`CDC`。 `CPaintDC` 封裝呼叫`BeginPaint`和`EndPaint`。 `CClientDC` 管理視窗的工作區相關聯的顯示內容。 `CWindowDC` 管理整個視窗，包括其框架與控制項相關聯的顯示內容。 `CMetaFileDC` 關聯的中繼檔裝置內容。

`CDC` 提供兩個成員函式， [GetLayout](#getlayout)並[SetLayout](#setlayout)，為反轉的裝置內容，不會繼承其版面配置從視窗版面配置。 必須撰寫文化特性，例如阿拉伯文或希伯來文字元配置並不在歐洲的標準的應用程式這類由右至左的方向。

`CDC` 包含兩種裝置內容， [m_hDC](#m_hdc)並[m_hAttribDC](#m_hattribdc)，它會在建立`CDC`物件，參考相同的裝置。 `CDC` 將所有輸出 GDI 呼叫來都引導`m_hDC`和大部分屬性 GDI 呼叫`m_hAttribDC`。 (的屬性呼叫的範例`GetTextColor`，而`SetTextColor`輸出呼叫。)

比方說，架構會使用這兩個裝置的內容來實作`CMetaFileDC`會將輸出傳送到中繼檔從實體裝置讀取的屬性時的物件。 預覽列印中的架構以類似的方式實作。 您也可以使用兩種裝置內容類似的方式，在您的應用程式專屬程式碼。

有些時，您可能需要兩個文字度量資訊的時候`m_hDC`和`m_hAttribDC`裝置內容。 下列成對的函式提供這項功能：

|使用 m_hAttribDC|使用 m_hDC|
|-----------------------|-----------------|
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|

如需詳細資訊`CDC`，請參閱 <<c2> [ 裝置內容](../../mfc/device-contexts.md)。

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](../../mfc/reference/cobject-class.md)

`CDC`

## <a name="requirements"></a>需求

**標題:** afxwin.h

##  <a name="abortdoc"></a>  CDC::AbortDoc

終止目前的列印工作，並清除應用程式時，已寫入至裝置上，自上次呼叫的所有項目[StartDoc](#startdoc)成員函式。

```
int AbortDoc();
```

### <a name="return-value"></a>傳回值

當發生的錯誤為負值或大於或等於 0，如果成功的值。 下列清單顯示常見的錯誤值和其意義：

- SP_ERROR 一般錯誤。

- SP_OUTOFDISK 不足夠的磁碟空間目前適用於多工緩衝處理，並沒有更多的空間會變成可用。

- SP_OUTOFMEMORY 不足夠的記憶體可供多工緩衝處理。

- SP_USERABORT 使用者終止透過列印管理員工作。

### <a name="remarks"></a>備註

此成員函式會取代 ABORTDOC 印表機逸出。

`AbortDoc` 應該用來終止下列：

- 未指定中止函式使用的列印作業[SetAbortProc](#setabortproc)。

- 列印作業尚未達到其第一個 NEWFRAME 或 NEXTBAND 逸出呼叫。

如果應用程式發生列印錯誤或已取消的列印作業，它必須不會嘗試使用其中一種終止作業[EndDoc](#enddoc)或是`AbortDoc`類別成員函式`CDC`。 GDI 自動終止的操作，然後傳回錯誤值。

如果應用程式會顯示對話方塊，以允許使用者取消列印作業，它必須呼叫`AbortDoc`之前終結對話方塊。

如果列印管理員用來啟動列印工作，則呼叫`AbortDoc`清除整個多工緩衝處理作業，印表機會收到 nothing。 如果列印管理員不用來開始列印工作中，資料可能已傳送至印表機之前`AbortDoc`呼叫。 在此情況下，印表機驅動程式會重設的印表機 （如果可能），並關閉列印工作。

### <a name="example"></a>範例

  範例，請參閱[CDC::StartDoc](#startdoc)。

##  <a name="abortpath"></a>  CDC::AbortPath

關閉並捨棄任何在裝置內容中的路徑。

```
BOOL AbortPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果在裝置內容中沒有開放的路徑括號，路徑括號會關閉，而捨棄的路徑。 如果在裝置內容中沒有已關閉的路徑，路徑會被捨棄。

##  <a name="addmetafilecomment"></a>  CDC::AddMetaFileComment

將註解從緩衝區複製到指定的格式增強型中繼檔。

```
BOOL AddMetaFileComment(
    UINT nDataSize,
    const BYTE* pCommentData);
```

### <a name="parameters"></a>參數

*nDataSize*<br/>
指定的註解緩衝區長度，以位元組為單位。

*pCommentData*<br/>
指向包含註解的緩衝區。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

註解可以包含任何私人資訊 — 例如，圖片和日期的來源建立。 註解應該開始使用應用程式簽章，後面接著資料。 註解不應包含位置特定資料。 位置特定的資料指定的記錄，位置和它應該不會包含因為一個中繼檔可能會內嵌在另一個中繼檔。 此函式只能搭配增強型中繼檔。

##  <a name="alphablend"></a>  CDC::AlphaBlend

呼叫此成員函式，以顯示具有透明或半透明的像素的點陣圖。

```
BOOL AlphaBlend(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    BLENDFUNCTION blend);
```

### <a name="parameters"></a>參數

*xDest*<br/>
指定的 x 座標，以邏輯單位，目的地矩形左上角。

*yDest*<br/>
指定 y 軸座標，以邏輯單位，目的地矩形左上角。

*nDestWidth*<br/>
指定寬度，以目的地矩形的邏輯單位。

*nDestHeight*<br/>
指定高度，以目的地矩形的邏輯單位。

*pSrcDC*<br/>
來源裝置內容指標。

*xSrc*<br/>
指定的 x 座標，以邏輯單位，來源矩形左上角。

*ySrc*<br/>
指定 y 軸座標，以邏輯單位，來源矩形左上角。

*nSrcWidth*<br/>
指定寬度，以邏輯單位，來源矩形。

*nSrcHeight*<br/>
指定高度，以邏輯單位，來源矩形。

*blend*<br/>
指定[BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction)結構。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

請參閱[alphablend，還有旁邊](/windows/desktop/api/wingdi/nf-wingdi-alphablend)Windows sdk for 的詳細資訊。

##  <a name="anglearc"></a>  CDC::AngleArc

繪製直線線段與圓弧。

```
BOOL AngleArc(
    int x,
    int y,
    int nRadius,
    float fStartAngle,
    float fSweepAngle);
```

### <a name="parameters"></a>參數

*x*<br/>
指定邏輯的圓形中心的 x 座標。

*y*<br/>
指定邏輯的圓形中心的 y 座標。

*nRadius*<br/>
指定圓形的半徑，以邏輯單位表示。 此值必須是正數。

*fStartAngle*<br/>
指定的開始角度以度數為單位，相對於 x 軸。

*fSweepAngle*<br/>
指定掃掠角度，以相對的開始角度的度數為單位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

從目前的位置繪製直線線段弧線的開頭。繪製弧形沿著指定的 radius 與 center 圓形的圓周。 弧形的長度被定義所指定的開始和掃掠角度。

`AngleArc` 目前位置移到弧形結束點。此函式所繪製弧線似乎橢圓形，視目前的轉換和對應模式而定。 繪製弧形之前, 此函式會繪製直線線段，從目前位置到弧形開頭。藉由建構指定的中心點周圍的指定半徑虛數的圓形繪製弧形。 圓弧的起點取決於從圓形的 x 軸逆時針測量的開始角度度數的數目。 藉由從起點逆時針測量的掃掠角度的度數數位於類似到結束的點。

掃掠角度是否大於 360 度弧線是只要進行清理多次。 此函式使用目前畫筆繪製線條。 此圖不會填滿。

##  <a name="arc"></a>  CDC::Arc

繪製橢圓形弧線。

```
BOOL Arc(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Arc(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定的週框 （以邏輯單位表示） 的左上角的 x 座標。

*y1*<br/>
指定的週框 （以邏輯單位表示） 的左上角的 y 座標。

*x2*<br/>
指定的週框 （以邏輯單位表示） 的右下角的 x 座標。

*y2*<br/>
指定的週框 （以邏輯單位表示） 的右下角的 y 座標。

*x3*<br/>
指定定義弧形的點的 x 座標的起始點 （以邏輯單位表示）。 此點沒有落在弧線。

*y3*<br/>
指定定義弧形的點的 y 座標的起始點 （以邏輯單位表示）。 此點沒有落在弧線。

*x4*<br/>
指定定義弧線的端點 （以邏輯單位表示） 的點的 x 座標。 此點沒有落在弧線。

*y4*<br/>
指定定義弧線的端點 （以邏輯單位表示） 的點的 y 座標。 此點沒有落在弧線。

*lpRect*<br/>
指定的週框 （以邏輯單位表示）。 您可以將任一個 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)此參數的物件。

*ptStart*<br/>
指定定義弧形的點 x 和 y 座標的起始點 （以邏輯單位表示）。 此點沒有落在弧線。您可以傳遞[點](/windows/desktop/api/windef/ns-windef-tagpoint)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)此參數的物件。

*ptEnd*<br/>
指定定義弧線的終點 （以邏輯單位表示） 的點 x 和 y 座標。 此點沒有落在弧線。您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

使用函數來繪製弧形是所指定的週框定義橢圓形的區段。

弧線的實際的起始點是從透過指定的起始點的周框矩形的中央繪製無限遠的光線與橢圓形交集處的點。 弧線的實際的結束點是從透過指定的結束點的週框矩形的中央繪製無限遠的光線與橢圓形交集處的點。 以逆時鐘方向繪製弧形。 弧形不是封閉的圖表，因為它不會填入。 Width 和矩形的高度必須大於 2 個單位，且小於 32,767 個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#29](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]

##  <a name="arcto"></a>  CDC::ArcTo

繪製橢圓形弧線。

```
BOOL ArcTo(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL ArcTo(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定的週框 （以邏輯單位表示） 的左上角的 x 座標。

*y1*<br/>
指定的週框 （以邏輯單位表示） 的左上角的 y 座標。

*x2*<br/>
指定的週框 （以邏輯單位表示） 的右下角的 x 座標。

*y2*<br/>
指定的週框 （以邏輯單位表示） 的右下角的 y 座標。

*x3*<br/>
指定定義弧形的點的 x 座標的起始點 （以邏輯單位表示）。 此點沒有落在弧線。

*y3*<br/>
指定定義弧形的點的 y 座標的起始點 （以邏輯單位表示）。 此點沒有落在弧線。

*x4*<br/>
指定定義弧線的端點 （以邏輯單位表示） 的點的 x 座標。 此點沒有落在弧線。

*y4*<br/>
指定定義弧線的端點 （以邏輯單位表示） 的點的 y 座標。 此點沒有落在弧線。

*lpRect*<br/>
指定的週框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](/windows/desktop/api/windef/ns-windef-tagrect)資料結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)此參數的物件。

*ptStart*<br/>
指定定義弧形的點 x 和 y 座標的起始點 （以邏輯單位表示）。 此點沒有落在弧線。您可以傳遞[點](/windows/desktop/api/windef/ns-windef-tagpoint)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)此參數的物件。

*ptEnd*<br/>
指定定義弧線的終點 （以邏輯單位表示） 的點 x 和 y 座標。 此點沒有落在弧線。您可以傳遞`POINT`資料結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函數非常類似於`CDC::Arc`，不同之處在於會更新目前的位置。 點 ( *x1*， *y1*) 和 ( *x2*， *y2*) 指定的週框。 依據給定的周框的橢圓形定義曲線的弧線。弧線以逆時針方向延伸 （預設的反方向） 從在與交集放射狀線，從要的週框矩形的中心點 ( *x3*， *y3*)。 在與交集放射狀線，從要的週框矩形的中心弧形結束 ( *x4*， *y4*)。 如果的起點和終點是相同的則會完整橢圓形繪製。

從目前的位置繪製一條線弧線的起點。如果未發生錯誤，目前位置設定到弧形結束點。使用目前的畫筆; 繪製弧形未填入。

##  <a name="attach"></a>  CDC::Attach

使用此成員函式來附加*hDC*到`CDC`物件。

```
BOOL Attach(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
Windows 裝置內容。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

*HDC*會儲存在兩者`m_hDC`，輸出裝置內容，然後在`m_hAttribDC`，屬性的裝置內容。

##  <a name="beginpath"></a>  CDC::BeginPath

裝置內容中開啟的路徑括號。

```
BOOL BeginPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

開啟路徑括號之後，應用程式可以開始呼叫 GDI 繪圖函式定義之間的點，在路徑中。 應用程式可以藉由呼叫關閉開啟的路徑括號`EndPath`成員函式。 當應用程式呼叫`BeginPath`，會捨棄任何先前的路徑。

請參閱[BeginPath](/windows/desktop/api/wingdi/nf-wingdi-beginpath) Windows SDK 的路徑中定義點繪圖函式的清單中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#30](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]

##  <a name="bitblt"></a>  CDC::BitBlt

來源裝置內容的點陣圖複製到這個目前的裝置內容。

```
BOOL BitBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定目的地矩形左上角的邏輯 x 座標。

*y*<br/>
指定目的地矩形左上角的邏輯 y 座標。

*nWidth*<br/>
指定目的地矩形和來源點陣圖的寬度 （以邏輯單位表示）。

*nHeight*<br/>
指定目的地矩形和來源點陣圖的高度 （以邏輯單位表示）。

*pSrcDC*<br/>
指標`CDC`識別點陣圖會複製來源的裝置內容的物件。 它必須是 NULL，如果*dwRop*指定不包含來源的點陣作業。

*xSrc*<br/>
指定邏輯來源點陣圖左上角的 x 座標。

*ySrc*<br/>
指定邏輯來源點陣圖左上角的 y 座標。

*dwRop*<br/>
指定待執行的點陣作業。 點陣作業程式碼定義 GDI 如何結合輸出作業牽涉到目前的筆刷、 可能的來源點陣圖和目的地點陣圖中的色彩。 請參閱[BitBlt](/windows/desktop/api/wingdi/nf-wingdi-bitblt)在 Windows SDK 中取得一份的點陣作業碼*dwRop*及其描述

如需的點陣作業程式碼的完整清單，請參閱 <<c0> [ 點陣作業程式碼的相關](/windows/desktop/gdi/raster-operation-codes)Windows SDK 中。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

應用程式可以在 windows 或工作區，確保位元組界限上的對齊`BitBlt`位元組對齊的矩形上進行作業。 （設定 CS_BYTEALIGNWINDOW 或 CS_BYTEALIGNCLIENT 旗標時註冊視窗類別時）。

`BitBlt` 位元組對齊的矩形上的作業會比 new-object 快得比`BitBlt`作業不是位元組對齊的矩形。 如果您想要指定類別樣式，例如您自己的裝置內容的位元組對齊，您必須註冊視窗類別，而不是依賴 Microsoft Foundation classes，為您執行。 使用全域函式[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。

轉換 GDI *nWidth*並*nHeight*，一次使用目的地裝置內容，以及一次使用來源裝置內容。 如果不相符的結果範圍，GDI 就會使用 Windows`StretchBlt`来壓縮還是要延展視來源點陣圖的函式。

如果目的地、 來源和模式點陣圖沒有相同的色彩格式，`BitBlt`函式會轉換來源和模式點陣圖以符合目的地。 轉換中，會使用目的地點陣圖的前景和背景色彩。

當`BitBlt`函式會將單色點陣圖轉換成色彩，其將白色位元 (1) 設定為黑色的位元 (0) 設為前景色彩與背景色彩。 會使用目的地裝置內容的前景和背景色彩。 若要將色彩轉換為單色，`BitBlt`將符合背景色彩為白色的像素，並將其他所有像素設定為黑色。 `BitBlt` 若要將色彩轉換為單色，會使用彩色裝置內容的前景和背景色彩。

請注意，並非所有的裝置內容支援`BitBlt`。 若要檢查是否支援指定的裝置內容`BitBlt`，使用`GetDeviceCaps`成員函式，並指定 RASTERCAPS 索引。

### <a name="example"></a>範例

  範例，請參閱[CDC::CreateCompatibleDC](#createcompatibledc)。

##  <a name="cdc"></a>  CDC::CDC

建構 `CDC` 物件。

```
CDC();
```

##  <a name="chord"></a>  CDC::Chord

繪製的同步選取 （橢圓形 和 直線線段的交集所繫結到封閉的圖表）。

```
BOOL Chord(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Chord(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定的同步選取左上角的 x 座標之週框 （以邏輯單位表示）。

*y1*<br/>
指定的同步選取左上角的 y 座標之週框 （以邏輯單位表示）。

*x2*<br/>
指定的同步選取右下角的 x 座標之週框 （以邏輯單位表示）。

*y2*<br/>
指定的同步選取右下角的 y 座標之週框 （以邏輯單位表示）。

*x3*<br/>
指定定義的同步選取點的 x 座標的起始點 （以邏輯單位表示）。

*y3*<br/>
指定定義的同步選取點的 y 座標的起始點 （以邏輯單位表示）。

*x4*<br/>
指定定義 chord 的端點 （以邏輯單位表示） 的點的 x 座標。

*y4*<br/>
指定定義 chord 的端點 （以邏輯單位表示） 的點的 y 座標。

*lpRect*<br/>
指定的週框 （以邏輯單位表示）。 您可以將任一個 LPRECT 或[CRect](../../atl-mfc-shared/reference/crect-class.md)此參數的物件。

*ptStart*<br/>
指定定義弦點 x 和 y 座標的起始點 （以邏輯單位表示）。 此點沒有落在弦。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

*ptEnd*<br/>
指定定義的同步選取 （以邏輯單位表示） 的結束點的點 x 和 y 座標。 此點沒有落在弦。 您可以傳遞[點](/windows/desktop/api/windef/ns-windef-tagpoint)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)此參數的物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

( *X1*， *y1*) 和 ( *x2*， *y2*) 參數的左上角和右下角，分別指定的矩形週框的橢圓形 chord 的一部分。 ( *X3*， *y3*) 和 ( *x4*， *y4*) 參數指定的行之交集橢圓形的端點。 Chord 會使用所選的畫筆繪製，並使用選取的筆刷填滿。

所繪製的圖`Chord`函式最多至擴充，但不包含右側和底端座標。 這表示圖表的高度*y2* - *y1*圖的寬度，而且*x2* - *x1*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#31](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]

##  <a name="closefigure"></a>  CDC::CloseFigure

關閉開放的圖形路徑中。

```
BOOL CloseFigure();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

函式會關閉圖，藉由從目前位置中繪製一條線，以圖形的第一個點 (通常，將最新的呼叫所指定的點`MoveTo`成員函式)，並將行連線所使用的線條聯結樣式。 如果使用封閉的圖表`LineTo`成員函式，而不是`CloseFigure`，端點會用來建立而不是聯結的角。 `CloseFigure` 應該只呼叫中是否有為開放的路徑括號的裝置內容。

路徑中的圖形會開啟，除非它明確關閉使用此函式。 （即使目前的點和圖表的起點是相同的圖表可以是開啟）。任何線條或曲線加入後面的路徑`CloseFigure`開始新的圖形。

##  <a name="createcompatibledc"></a>  CDC::CreateCompatibleDC

建立記憶體裝置內容與所指定的裝置相容*pDC*。

```
BOOL CreateCompatibleDC(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。 如果*pDC*是 NULL，函式會建立適用於系統顯示記憶體裝置內容。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

記憶體裝置內容是記憶體的表示顯示表面區塊。 它可以用來準備在記憶體中的映像，再將它們複製到相容的裝置的實際裝置介面。

建立記憶體裝置內容時，GDI 就會自動為它選取 1-1 的單色股票點陣圖。 GDI 輸出函式可以搭配記憶體裝置內容，只有當已建立並選取放入該內容的點陣圖。

此函式只可用來建立支援點陣作業之裝置的相容裝置內容。 請參閱[cdc:: bitblt](#bitblt)裝置內容之間的位元區塊傳輸的相關資訊的成員函式。 若要判斷裝置的內容是否支援點陣作業，請參閱成員函式的 RC_BITBLT 點陣功能`CDC::GetDeviceCaps`。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#32](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]

##  <a name="createdc"></a>  CDC::CreateDC

建立指定之裝置的裝置內容。

```
BOOL CreateDC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>參數

*lpszDriverName*<br/>
指向以 null 終止的字串，指定裝置驅動程式 (例如，"EPSON") 的檔案名稱 （不含副檔名）。 您也可以傳遞`CString`此參數的物件。

*lpszDeviceName*<br/>
指向以 null 終止的字串，指定特定裝置都必須支援 （例如，"EPSON FX-80"） 的名稱。 *LpszDeviceName*如果模組支援多個裝置，會使用參數。 您也可以傳遞`CString`此參數的物件。

*lpszOutput*<br/>
指向以 null 終止的字串，指定實體輸出媒介 （檔或輸出連接埠） 的檔案或裝置名稱。 您也可以傳遞`CString`此參數的物件。

*lpInitData*<br/>
指向`DEVMODE`包含裝置驅動程式的裝置特定的初始化資料結構。 Windows`DocumentProperties`函式會擷取為指定的裝置填入這個結構。 *LpInitData*參數必須是 NULL，如果裝置驅動程式是使用由使用者透過控制台所指定的預設初始化 （如果有的話）。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

列印。如果 H 標頭檔，則需要[DEVMODE](/windows/desktop/api/wingdi/ns-wingdi-_devicemodea)使用結構。

裝置名稱遵循下列慣例： 結尾的冒號 （:） 是建議，但非必要。 Windows 會去除終止的冒號，以便將裝置名稱，結尾冒號做為相同的名稱，不含冒號的相同連接埠對應。 驅動程式和連接埠的名稱不能包含開頭或尾端空格。 GDI 輸出函式不能使用資訊內容。

##  <a name="createic"></a>  CDC::CreateIC

建立指定之裝置的資訊內容。

```
BOOL CreateIC(
    LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName,
    LPCTSTR lpszOutput,
    const void* lpInitData);
```

### <a name="parameters"></a>參數

*lpszDriverName*<br/>
指向以 null 終止的字串，指定裝置驅動程式 (例如，"EPSON") 的檔案名稱 （不含副檔名）。 您可以傳遞`CString`此參數的物件。

*lpszDeviceName*<br/>
指向以 null 終止的字串，指定特定裝置都必須支援 （例如，"EPSON FX-80"） 的名稱。 *LpszDeviceName*如果模組支援多個裝置，會使用參數。 您可以傳遞`CString`此參數的物件。

*lpszOutput*<br/>
指向以 null 終止的字串，指定實體輸出媒介 （檔案或連接埠） 的檔案或裝置名稱。 您可以傳遞`CString`此參數的物件。

*lpInitData*<br/>
裝置驅動程式的裝置特定的初始化資料點。 *LpInitData*參數必須是 NULL，如果裝置驅動程式是使用由使用者透過控制台所指定的預設初始化 （如果有的話）。 請參閱`CreateDC`裝置特定的初始化資料格式。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

資訊內容會提供可快速取得裝置的相關資訊，而建立的裝置內容。

裝置名稱遵循下列慣例： 結尾的冒號 （:） 是建議，但非必要。 Windows 會去除終止的冒號，以便將裝置名稱，結尾冒號做為相同的名稱，不含冒號的相同連接埠對應。 驅動程式和連接埠的名稱不能包含開頭或尾端空格。 GDI 輸出函式不能使用資訊內容。

##  <a name="deletedc"></a>  CDC::DeleteDC

一般情況下，不會呼叫此函式;解構函式會替您。

```
BOOL DeleteDC();
```

### <a name="return-value"></a>傳回值

如果順利完成的函式，非零值。否則為 0。

### <a name="remarks"></a>備註

`DeleteDC`成員函式會刪除相關聯的 Windows 裝置內容`m_hDC`目前`CDC`物件。 如果這個`CDC`物件是最後一個作用中的裝置內容給指定的裝置，裝置會收到通知時釋放所有裝置所使用的儲存體和系統資源。

應用程式不應該呼叫`DeleteDC`如果已選取的物件放入裝置內容。 必須先選取物件從裝置內容被刪除之前。

應用程式不能刪除裝置內容控制代碼取得藉由呼叫[cwnd:: Getdc](../../mfc/reference/cwnd-class.md#getdc)。 相反地，它必須呼叫[cwnd:: Releasedc](../../mfc/reference/cwnd-class.md#releasedc)釋放裝置內容。 [CClientDC](../../mfc/reference/cclientdc-class.md)並[CWindowDC](../../mfc/reference/cwindowdc-class.md)會提供類別以包裝此功能。

`DeleteDC`函式通常用來刪除裝置內容以建立[CreateDC](#createdc)， [CreateIC](#createic)，或[CreateCompatibleDC](#createcompatibledc)。

### <a name="example"></a>範例

  範例，請參閱[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。

##  <a name="deletetempmap"></a>  CDC::DeleteTempMap

會自動呼叫`CWinApp`閒置時間處理常式中，`DeleteTempMap`刪除暫時`CDC`所建立的物件`FromHandle`，但不會終結裝置內容控制代碼 ( `hDC`s) 暫時聯`CDC`物件。

```
static void PASCAL DeleteTempMap();
```

##  <a name="detach"></a>  CDC::Detach

呼叫此函式可卸離`m_hDC`（輸出裝置內容） 從`CDC`物件，並設定兩者`m_hDC`和`m_hAttribDC`為 NULL。

```
HDC Detach();
```

### <a name="return-value"></a>傳回值

Windows 裝置內容。

##  <a name="dptohimetric"></a>  CDC::DPtoHIMETRIC

當您為 HIMETRIC 大小至 OLE，以 HIMETRIC 轉換像素為單位，請使用此函式。

```
void DPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

如果裝置內容物件的對應模式 MM_LOENGLISH、 MM_HIENGLISH、 MM_LOMETRIC，還是 MM_HIMETRIC，轉換將根據在實體英吋的像素數目。 如果此對應模式是其中一個其他非限制模式 (例如 MM_TEXT)，轉換將根據邏輯英吋的像素數目。

##  <a name="dptolp"></a>  CDC::DPtoLP

將裝置單位轉換成邏輯單元。

```
void DPtoLP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列[點](/windows/desktop/api/windef/ns-windef-tagpoint)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

*nCount*<br/>
陣列中的點數目。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 這個參數使用於簡單的情況下，將一個矩形從裝置點轉換為邏輯的點。

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

函式會在每個點的座標或維度的大小，從裝置座標系統的 GDI 的邏輯座標系統的對應。 轉換取決於目前的對應模式，以及設定原始來源及裝置的視窗和檢視區的範圍。

##  <a name="draw3drect"></a>  CDC::Draw3dRect

呼叫此成員函式可繪製 3d 矩形。

```
void Draw3dRect(
    LPCRECT lpRect,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);

void Draw3dRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clrTopLeft,
    COLORREF clrBottomRight);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指定的週框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)此參數的物件。

*clrTopLeft*<br/>
指定線上方和左側 3d 矩形的色彩。

*clrBottomRight*<br/>
指定下方的色彩和右邊的 3d 矩形。

*x*<br/>
指定邏輯 3d 矩形左上角的 x 座標。

*y*<br/>
指定邏輯 3d 矩形左上角的 y 座標。

*cx*<br/>
指定 3d 矩形的寬度。

*cy*<br/>
指定 3d 矩形的高度。

### <a name="remarks"></a>備註

將會以線上方和左側中所指定的色彩來繪製矩形*clrTopLeft*下方和右側所指定的色彩*clrBottomRight*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#33](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]

##  <a name="drawdragrect"></a>  CDC::DrawDragRect

呼叫此成員函式重複重繪拖曳矩形。

```
void DrawDragRect(
    LPCRECT lpRect,
    SIZE size,
    LPCRECT lpRectLast,
    SIZE sizeLast,
    CBrush* pBrush = NULL,
    CBrush* pBrushLast = NULL);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)指定矩形的邏輯座標的物件 — 在此情況下，重新繪製的矩形的結束位置。

*size*<br/>
會指定從左上角的外框左上角的矩形內部的框線 （也就是框線的粗細）。

*lpRectLast*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)指定矩形的位置的邏輯座標的物件 — 在此情況下，重新繪製的矩形的原始位置。

*sizeLast*<br/>
會指定從左上角的外框左上角的原始重新繪製的矩形內部的框線 （也就是框線的粗細）。

*pBrush*<br/>
筆刷物件的指標。 若要使用的預設色調筆刷設定為 NULL。

*pBrushLast*<br/>
若要使用的最後一筆刷物件的指標。 若要使用的預設色調筆刷設定為 NULL。

### <a name="remarks"></a>備註

以呼叫它在迴圈中您取樣滑鼠位置，以便將提供視覺化回饋。 當您呼叫`DrawDragRect`、 清除先前的矩形和一個新的繪製。 例如，為使用者拖曳矩形在螢幕上`DrawDragRect`會清除原始矩形，然後重繪其新位置在新的資源。 根據預設，`DrawDragRect`消除閃爍，並建立順暢移動矩形的外觀，使用半色調筆刷繪製的矩形。

第一次呼叫`DrawDragRect`，則*lpRectLast*參數應該是 NULL。

##  <a name="drawedge"></a>  CDC::DrawEdge

呼叫此成員函式，來繪製矩形，以指定的型別和樣式的邊緣。

```
BOOL DrawEdge(
    LPRECT lpRect,
    UINT nEdge,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指標`RECT`結構，其中包含矩形的邏輯座標。

*nEdge*<br/>
指定要繪製的內部和外部邊緣類型。 這個參數必須是一個內部框線旗標和一個外框旗標的組合。 請參閱[DrawEdge](/windows/desktop/api/winuser/nf-winuser-drawedge) Windows SDK 的參數類型的資料表中。

*nFlags*<br/>
旗標，指定要繪製的框線類型。 請參閱`DrawEdge`Windows sdk for 參數的值的資料表。 斜 BF_RECT 旗標會指定結束點的矩形參數所繫結的向量。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

##  <a name="drawescape"></a>  CDC::DrawEscape

繪製便無法直接透過圖形裝置介面 (GDI) 視訊的顯示功能的存取。

```
int DrawEscape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData);
```

### <a name="parameters"></a>參數

*nEscape*<br/>
指定要執行的逸出函數。

*nInputSize*<br/>
指定的資料所指向的位元組數目*lpszInputData*參數。

*lpszInputData*<br/>
指定逸出所需的輸入結構的點。

### <a name="return-value"></a>傳回值

指定函式的結果。 小於或等於零，如果成功，除了; 實作會檢查 QUERYESCSUPPORT 繪製逸出零，如果未實作逸出;或小於零，如果錯誤發生。

### <a name="remarks"></a>備註

當應用程式呼叫`DrawEscape`，所識別的資料*nInputSize*並*lpszInputData*會直接傳遞至指定的顯示驅動程式。

##  <a name="drawfocusrect"></a>  CDC::DrawFocusRect

用來表示矩形具有焦點的樣式繪製的矩形。

```
void DrawFocusRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定要繪製的矩形的邏輯座標。

### <a name="remarks"></a>備註

由於這是布林值 XOR 函式，呼叫此函式的第二次相同的矩形在顯示中移除矩形。 無法捲動此函式所繪製的矩形。 若要捲動包含此函式所繪製的矩形區域，請先呼叫`DrawFocusRect`若要從顯示中移除矩形，然後捲動區域，，然後呼叫`DrawFocusRect`以新的位置中繪製的矩形。

> [!CAUTION]
> `DrawFocusRect` 只適用於 MM_TEXT 模式。 在其他模式中，此函式不能正確地繪製焦點矩形，但它不會傳回錯誤值。

##  <a name="drawframecontrol"></a>  CDC::DrawFrameControl

呼叫此成員函式，來繪製指定的型別和樣式的畫面格控制項。

```
BOOL DrawFrameControl(
    LPRECT lpRect,
    UINT nType,
    UINT nState);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指標`RECT`結構，其中包含矩形的邏輯座標。

*nType*<br/>
指定要繪製的畫面格控制項類型。 請參閱*uType*中的參數[DrawFrameControl](/windows/desktop/api/winuser/nf-winuser-drawframecontrol) Windows SDK，如需此參數的可能值的清單中。

*nState*<br/>
指定框架控制項的初始狀態。 可以是下列一個或多個值描述*uState*中的參數`DrawFrameControl`Windows SDK 中。 使用*nState*值 DFCS_ADJUSTRECT 調整以排除 [推送] 按鈕的周圍邊緣的周框。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

在許多情況下， *nState*取決於*n*參數。 下列清單顯示四個之間的關聯性*n*值並*nState*:

- DFC_BUTTON

    - DFCS_BUTTON3STATE 三態按鈕

    - DFCS_BUTTONCHECK 核取方塊

    - DFCS_BUTTONPUSH 推送按鈕

    - DFCS_BUTTONRADIO 選項按鈕

    - 選項按鈕的 DFCS_BUTTONRADIOIMAGE 映像 （非方形需要映像）

    - 選項按鈕的 DFCS_BUTTONRADIOMASK 遮罩 （非方形需要遮罩）

- DFC_CAPTION

    - DFCS_CAPTIONCLOSE [關閉] 按鈕

    - DFCS_CAPTIONHELP 說明 按鈕

    - DFCS_CAPTIONMAX 最大化 按鈕

    - DFCS_CAPTIONMIN 最小化 按鈕

    - DFCS_CAPTIONRESTORE 還原按鈕

- DFC_MENU

    - DFCS_MENUARROW 子功能表的箭號

    - DFCS_MENUBULLET 項目符號

    - DFCS_MENUCHECK 核取記號

- DFC_SCROLL

    - DFCS_SCROLLCOMBOBOX 下拉式方塊捲軸

    - 捲軸的 DFCS_SCROLLDOWN 向下鍵

    - 捲軸的 DFCS_SCROLLLEFT 向左鍵

    - 捲軸的 DFCS_SCROLLRIGHT 向右箭號

    - 在視窗的右下角的 DFCS_SCROLLSIZEGRIP 大小底框

    - 捲軸的 DFCS_SCROLLUP 向上鍵

### <a name="example"></a>範例

此程式碼會繪製大小的移駐夾在視窗的右下角。 適用於`OnPaint`的對話方塊，其中有沒有樣式，且通常不包含其他控制項 （例如 [狀態] 列中） 可以為它提供大小的移駐夾的處理常式。

[!code-cpp[NVC_MFCDocView#34](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]

##  <a name="drawicon"></a>  CDC::DrawIcon

代表由目前的裝置上繪製一個圖示`CDC`物件。

```
BOOL DrawIcon(
    int x,
    int y,
    HICON hIcon);

BOOL DrawIcon(
    POINT point,
    HICON hIcon);
```

### <a name="parameters"></a>參數

*x*<br/>
指定邏輯圖示的左上角的 x 座標。

*y*<br/>
指定邏輯圖示的左上角的 y 座標。

*hIcon*<br/>
識別要繪製的圖示的控制代碼。

*point*<br/>
指定邏輯 x 和 y 座標的左上角的圖示。 您可以傳遞[點](/windows/desktop/api/windef/ns-windef-tagpoint)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)此參數的物件。

### <a name="return-value"></a>傳回值

如果順利完成的函式，非零值。否則為 0。

### <a name="remarks"></a>備註

此函式會置於所指定的位置中的圖示的左上角*x*並*y*。 位置受限於目前的裝置內容的對應模式。

圖示資源必須先前已載入使用的函式`CWinApp::LoadIcon`， `CWinApp::LoadStandardIcon`，或`CWinApp::LoadOEMIcon`。 `MM_TEXT`必須選取的對應模式，才能使用此函式。

### <a name="example"></a>範例

  範例，請參閱[CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic)。

##  <a name="drawstate"></a>  CDC::DrawState

呼叫此成員函式，來顯示影像，並套用視覺效果以表示狀態，例如已停用或預設狀態。

> [!NOTE]
>  針對所有*旗*狀態 DSS_NORMAL，除了套用視覺效果之前，將會轉換為單色的映像。

```
BOOL DrawState(
    CPoint pt,
    CSize size,
    HBITMAP hBitmap,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    CBitmap* pBitmap,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    HICON hIcon,
    UINT nFlags,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    LPCTSTR lpszText,
    UINT nFlags,
    BOOL bPrefixText = TRUE,
    int nTextLen = 0,
    CBrush* pBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    HBRUSH hBrush = NULL);

BOOL DrawState(
    CPoint pt,
    CSize size,
    DRAWSTATEPROC lpDrawProc,
    LPARAM lData,
    UINT nFlags,
    CBrush* pBrush = NULL);
```

### <a name="parameters"></a>參數

*pt*<br/>
指定映像的位置。

*size*<br/>
指定影像的大小。

*hBitmap*<br/>
點陣圖控制代碼。

*nFlags*<br/>
指定的映像類型和狀態的旗標。 請參閱[DrawState](/windows/desktop/api/winuser/nf-winuser-drawstatea) Windows sdk for 可能*nFlags*類型及狀態。

*hBrush*<br/>
筆刷控制代碼。

*pBitmap*<br/>
CBitmap 物件的指標。

*pBrush*<br/>
CBrush 物件的指標。

*hIcon*<br/>
圖示控制代碼。

*lpszText*<br/>
文字指標。

*bPrefixText*<br/>
可能包含加速器助憶鍵的文字。 *LData*參數指定位址的字串，而*nTextLen*參數指定的長度。 如果*nTextLen*是 0，則假設字串是以 null 結束。

*nTextLen*<br/>
所指向的文字字串的長度*lpszText*。 如果*nTextLen*是 0，則假設字串是以 null 結束。

*lpDrawProc*<br/>
用來呈現影像的回呼函式指標。 這個參數是必要的如果映像中鍵入*nFlags*是 DST_COMPLEX。 它是選擇性的而且可以是 NULL，如果映像類型為 DST_TEXT。 對於所有其他的映像類型，會忽略這個參數。 如需詳細的回呼函式的詳細資訊，請參閱[DrawStateProc](/windows/desktop/api/winuser/nc-winuser-drawstateproc) Windows SDK 中的函式。

*lData*<br/>
指定映像的相關資訊。 此參數的意義取決於影像類型。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

##  <a name="drawtext"></a>  CDC::DrawText

呼叫此成員函式，若要格式化文字方塊中指定的矩形。 若要指定其他格式化選項，請使用[CDC::DrawTextEx](#drawtextex)。

```
virtual int DrawText(
    LPCTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat);

int DrawText(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向要繪製的字串。 如果*nCount*為-1，字串必須以 null 結束。

*nCount*<br/>
在字串中指定字元的數目。 如果*nCount*為-1，然後*lpszString*皆必須以 null 終止的字串長度指標和`DrawText`自動計算的字元計數。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含要格式化文字的矩形 （在邏輯座標中）。

*str*<br/>
A [CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製指定的字元。

*nFormat*<br/>
指定的格式化文字的方法。 它可以是如所述的任何的值組合*uFormat*中的參數[DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) Windows SDK 中。 （結合使用位元的 OR 運算子）：

> [!NOTE]
>  有些*uFormat*旗標的組合可能會導致修改傳遞的字串。 使用 DT_MODIFYSTRING DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 可能會導致修改字串造成的判斷提示`CString`覆寫。 DT_CALCRECT、 DT_EXTERNALLEADING、 DT_INTERNAL、 DT_NOCLIP 和 DT_NOPREFIX 的值不能搭配 DT_TABSTOP 值。

### <a name="return-value"></a>傳回值

如果函式成功之文字的高度。

### <a name="remarks"></a>備註

它會將文字格式化成適當的空格，將文字左、 右對齊或置指定的矩形中，展開索引標籤，並分成配合給定矩形內的行中的文字。 格式化型別由*nFormat*。

此成員函式會使用裝置內容的選取的字型、 文字色彩和背景色彩來繪製文字。 除非使用 DT_NOCLIP 格式，`DrawText`裁剪文字，以便在指定的矩形的外面不顯示文字。 所有的格式設定會假設您有多行，除非 DT_SINGLELINE 格式提供。

如果選取的字型太大而無法針對指定的矩形，`DrawText`成員函式不會嘗試取代較小的字型。

如果指定 DT_CALCRECT 旗標時，所指定的矩形*lpRect*將會更新以反映所需來繪製文字的高度與寬度。

如果已設定 TA_UPDATECP 文字對齊旗標 (請參閱[CDC::SetTextAlign](#settextalign))，`DrawText`會顯示從開始於目前的位置，而不給定矩形左邊的文字。 `DrawText` 不會換行文字 TA_UPDATECP 旗標已經設定時 （也就是 DT_WORDBREAK 旗標不會影響）。

文字色彩可能會設定[CDC::SetTextColor](#settextcolor)。

##  <a name="drawtextex"></a>  CDC::DrawTextEx

將指定的矩形中的文字格式化。

```
virtual int DrawTextEx(
    LPTSTR lpszString,
    int nCount,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

int DrawTextEx(
    const CString& str,
    LPRECT lpRect,
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向要繪製的字串。 如果*nCount*為-1，此字串必須終止的 null。

*nCount*<br/>
在字串中指定字元的數目。 如果*nCount*為-1，然後*lpszString*皆必須以 null 終止的字串長度指標和`DrawText`自動計算的字元計數。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，其中包含要格式化文字的矩形 （在邏輯座標中）。

*str*<br/>
A [CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製指定的字元。

*nFormat*<br/>
指定的格式化文字的方法。 它可以是如所述的任何的值組合*uFormat*中的參數[DrawText](/windows/desktop/api/winuser/nf-winuser-drawtext) Windows SDK 中。 (結合使用位元**或**運算子):

> [!NOTE]
>  有些*uFormat*旗標的組合可能會導致修改傳遞的字串。 使用 DT_MODIFYSTRING DT_END_ELLIPSIS 或 DT_PATH_ELLIPSIS 可能會導致修改字串造成的判斷提示`CString`覆寫。 DT_CALCRECT、 DT_EXTERNALLEADING、 DT_INTERNAL、 DT_NOCLIP 和 DT_NOPREFIX 的值不能搭配 DT_TABSTOP 值。

*lpDTParams*<br/>
指標[DRAWTEXTPARAMS](/windows/desktop/api/winuser/ns-winuser-tagdrawtextparams)結構，指定其他格式設定選項。 這個參數可以是 NULL。

### <a name="remarks"></a>備註

它會將文字格式化成適當的空格，將文字左、 右對齊或置指定的矩形中，展開索引標籤，並分成配合給定矩形內的行中的文字。 格式化型別由*nFormat*並*lpDTParams*。 如需詳細資訊，請參閱 < [CDC::DrawText](#drawtext)並[DrawTextEx](/windows/desktop/api/winuser/nf-winuser-drawtextexa) Windows SDK 中。

文字色彩可能會設定[CDC::SetTextColor](#settextcolor)。

##  <a name="ellipse"></a>  CDC::Ellipse

繪製橢圓形。

```
BOOL Ellipse(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Ellipse(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定邏輯橢圓形之週框左上角的 x 座標。

*y1*<br/>
指定邏輯橢圓形之週框左上角的 y 座標。

*x2*<br/>
指定邏輯橢圓形之週框右下角的 x 座標。

*y2*<br/>
指定邏輯橢圓形之週框右下角的 y 座標。

*lpRect*<br/>
指定的橢圓形的週框矩形。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)此參數的物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

橢圓形的中心是所指定的週框矩形的中心*x1*， *y1*， *x2*，以及*y2*，或*lpRect*。 使用目前的畫筆，繪製橢圓形和目前的筆刷填滿其內部。

此函式所繪製的圖延伸最多至但不包含，右側和底端座標。 這表示圖表的高度*y2* - *y1*圖的寬度，而且*x2* - *x1*。

如果週框矩形的高度或寬度為 0，會不繪製任何橢圓形。

##  <a name="enddoc"></a>  CDC::EndDoc

結束列印工作的呼叫開始著手[StartDoc](#startdoc)成員函式。

```
int EndDoc();
```

### <a name="return-value"></a>傳回值

大於或等於 0，如果函式成功或為負數值，如果發生錯誤。

### <a name="remarks"></a>備註

此成員函式會取代 ENDDOC 印表機逸出，並應該完成成功的列印工作之後，立即呼叫。

如果應用程式發生列印錯誤或已取消的列印作業，它必須不會嘗試使用其中一種終止作業`EndDoc`或是[AbortDoc](#abortdoc)。 GDI 自動終止的操作，然後傳回錯誤值。

此函式不應該使用中繼檔內。

### <a name="example"></a>範例

  範例，請參閱[CDC::StartDoc](#startdoc)。

##  <a name="endpage"></a>  CDC::EndPage

通知裝置的應用程式已完成寫入頁面。

```
int EndPage();
```

### <a name="return-value"></a>傳回值

大於或等於 0，如果函式成功或為負數值，如果發生錯誤。

### <a name="remarks"></a>備註

此成員函式通常用來直接前往新頁面的裝置驅動程式。

此成員函式會取代 NEWFRAME 印表機逸出。 不同於 NEWFRAME，一律會呼叫此函數之後列印的頁面。

### <a name="example"></a>範例

  範例，請參閱[CDC::StartDoc](#startdoc)。

##  <a name="endpath"></a>  CDC::EndPath

關閉路徑括號，並選取放入裝置內容的 方括號所定義的路徑。

```
BOOL EndPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="example"></a>範例

  範例，請參閱[cdc:: beginpath](#beginpath)。

##  <a name="enumobjects"></a>  CDC::EnumObjects

列舉畫筆和筆刷會在裝置內容中使用。

```
int EnumObjects(
    int nObjectType,
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),
    LPARAM lpData);
```

### <a name="parameters"></a>參數

*nObjectType*<br/>
指定的物件型別。 它可以有 OBJ_BRUSH 或 OBJ_PEN 的值。

*lpfn*<br/>
是應用程式所提供的回呼函式的程序執行個體位址。 請參閱 < 備註 > 一節。

*lpData*<br/>
應用程式提供資料點。 資料會傳遞至回呼函式，以及物件資訊。

### <a name="return-value"></a>傳回值

指定所傳回的最後一個值[回呼函式](callback-functions-used-by-mfc.md#enum_objects)。 它的意義是由使用者定義。

### <a name="remarks"></a>備註

對於指定型別的每個物件，您傳遞的回呼函式會呼叫該物件的資訊。 系統會呼叫回呼函式，直到沒有更多的物件或回呼函式會傳回 0。

請注意，Microsoft Visual c + + 的新功能可讓您使用一般函式，函式傳遞至`EnumObjects`。 位址傳遞給`EnumObjects`是與匯出的函式的指標**匯出**與 Pascal 呼叫慣例。 在 保護模式的應用程式，您不必與 Windows MakeProcInstance 函式建立此函式或 FreeProcInstance Windows 函式搭配使用後釋放函式。

您也不必匯出中的函式名稱**匯出**應用程式的模組定義檔中的陳述式。 您可以改用**匯出**函式中的修飾詞，

**int 回呼匯出**AFunction **(LPSTR**， **LPSTR);**

若要讓編譯器發出適當的匯出記錄匯出沒有別名的名稱。 這適用於大部分的需求。 某些特殊的情況下，例如匯出的函式的序數或別名的匯出，您仍然需要使用**匯出**模組定義檔中的陳述式。

編譯 Mfc 程式，您通常會使用 /GA 和 /GEs 編譯器選項。 /Gw 編譯器選項不搭配 Microsoft Foundation classes。 (如果您使用 Windows 函式`MakeProcInstance`，您必須明確轉換需要此 API 中的型別傳回的函式指標從 FARPROC。)回呼註冊介面現在是型別安全 （您必須指向正確類型的特定回呼函式的函式指標傳遞）。

也請注意所有的回呼函式必須 Mfc 例外狀況設陷然後再回到 Windows，因為無法跨回呼界限擲回例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#35](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]

##  <a name="escape"></a>  CDC::Escape

此成員函式是 Win32 程式設計幾乎已經過時。

```
virtual int Escape(
    int nEscape,
    int nCount,
    LPCSTR lpszInData,
    LPVOID lpOutData);

int Escape(
    int nEscape,
    int nInputSize,
    LPCSTR lpszInputData,
    int nOutputSize,
    LPSTR lpszOutputData);
```

### <a name="parameters"></a>參數

*nEscape*<br/>
指定要執行的逸出函數。

如需逸出函式的完整清單，請參閱 <<c0> [ 逸出](/windows/desktop/api/wingdi/nf-wingdi-escape)Windows SDK 中。

*nCount*<br/>
指定的資料所指向的位元組數目*lpszInData*。

*lpszInData*<br/>
指向此逸出所需的輸入的資料結構。

*lpOutData*<br/>
指向要從這個逸出接收輸出的結構。 *LpOutData*參數為 NULL，如果未不傳回任何資料。

*nInputSize*<br/>
指定的資料所指向的位元組數目*lpszInputData*參數。

*lpszInputData*<br/>
指定逸出所需的輸入結構的點。

*nOutputSize*<br/>
指定的資料所指向的位元組數目*lpszOutputData*參數。

*lpszOutputData*<br/>
接收此逸出的輸出結構的點。 這個參數應該是 NULL，如果未不傳回任何資料。

### <a name="return-value"></a>傳回值

如果函式成功時，除了 QUERYESCSUPPORT 逸出，只會檢查實作，會傳回正值。 如果未實作逸出，則會傳回零。 如果發生錯誤，則會傳回負值。 以下是常見的錯誤值：

- SP_ERROR 一般錯誤。

- SP_OUTOFDISK 不足夠的磁碟空間目前適用於多工緩衝處理，並沒有更多的空間會變成可用。

- SP_OUTOFMEMORY 不足夠的記憶體可供多工緩衝處理。

- SP_USERABORT 使用者結束作業，透過列印管理員。

### <a name="remarks"></a>備註

原始的印表機逸出字元，僅 QUERYESCSUPPORT 支援 Win32 應用程式。 所有其他印表機逸出已經過時，而且只支援 16 位元應用程式相容性。

Win32 程式設計`CDC`現在提供六個成員函式取代其對應的印表機逸出的應用程式：

- [CDC::AbortDoc](#abortdoc)

- [CDC::EndDoc](#enddoc)

- [CDC::EndPage](#endpage)

- [CDC::SetAbortProc](#setabortproc)

- [CDC::StartDoc](#startdoc)

- [CDC::StartPage](#startpage)

颾魤 ㄛ [rastercaps](#getdevicecaps)支援 Win32 索引取代其他印表機逸出的應用程式。 請參閱[GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps) Windows sdk for 的詳細資訊。

此成員函式可讓應用程式存取的特定裝置，便無法直接透過 GDI 的功能。

如果您的應用程式會使用預先定義的逸出值，請使用第一個版本。 如果您的應用程式定義的私用的逸出值，請使用第二個版本。 請參閱[ExtEscape](/windows/desktop/api/wingdi/nf-wingdi-extescape)如需有關第二個版本的 Windows SDK 中。

##  <a name="excludecliprect"></a>  CDC::ExcludeClipRect

建立新的裁剪區域，其中包含現有的裁剪區域，減去指定的矩形。

```
int ExcludeClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int ExcludeClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定矩形左上角的邏輯 x 座標。

*y1*<br/>
指定矩形左上角的邏輯 y 座標。

*x2*<br/>
指定矩形右下角的邏輯 x 座標。

*y2*<br/>
指定矩形右下角的邏輯 y 座標。

*lpRect*<br/>
指定的矩形。 也可以是`CRect`物件。

### <a name="return-value"></a>傳回值

指定新的裁剪區域的類型。 它可以是下列值之一：

- COMPLEXREGION 區域具有重疊的框線。

- 沒有任何區域所建立的錯誤。

- NULLREGION 區域是空的。

- SIMPLEREGION 區域沒有任何重疊的框線。

### <a name="remarks"></a>備註

指定的絕對值的矩形的寬度*x2* - *x1*，不能超過 32,767 的單位。 這項限制適用於以及矩形的高度。

##  <a name="excludeupdatergn"></a>  CDC::ExcludeUpdateRgn

從相關聯的裁剪區域排除的更新的區域視窗中，會防止無效視窗區域內的繪圖`CDC`物件。

```
int ExcludeUpdateRgn(CWnd* pWnd);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
正在更新其視窗的視窗物件的點。

### <a name="return-value"></a>傳回值

排除區域的類型。 它可以是下列值之一：

- COMPLEXREGION 區域具有重疊的框線。

- 沒有任何區域所建立的錯誤。

- NULLREGION 區域是空的。

- SIMPLEREGION 區域沒有任何重疊的框線。

##  <a name="extfloodfill"></a>  CDC::ExtFloodFill

填入目前的筆刷的顯示表面區域。

```
BOOL ExtFloodFill(
    int x,
    int y,
    COLORREF crColor,
    UINT nFillType);
```

### <a name="parameters"></a>參數

*x*<br/>
指定填滿的起始處之點的邏輯 x 座標。

*y*<br/>
指定填滿的起始處之點的邏輯 y 座標。

*crColor*<br/>
指定的界限，或要填滿之區域的色彩。 解譯*crColor*的值而定*nFillType*。

*nFillType*<br/>
指定要執行的大量封包填滿類型。 它必須是下列值：

- 所指定的色彩填滿區域會受限於的 FLOODFILLBORDER *crColor*。 這個樣式等同於所執行的填滿`FloodFill`。

- 定義所指定的色彩填滿區域的 FLOODFILLSURFACE *crColor*。 填滿往所有方向繼續往外，只要遇到色彩。 此樣式是用於多色界限以填滿區域。

### <a name="return-value"></a>傳回值

如果成功，函式，非零值。否則為 0，如果填滿無法完成，如果指定的點的界限所指定的色彩*crColor* （如果 FLOODFILLBORDER 要求），如果指定的時間點沒有所指定的色彩*crColor*（如果 FLOODFILLSURFACE 要求），或如果點外的裁剪區域。

### <a name="remarks"></a>備註

此成員函式提供更大的彈性比`FloodFill`因為您可以指定在填滿類型*nFillType*。

如果*nFillType*設定到 FLOODFILLBORDER，區域會假設為完全受限於所指定的色彩*crColor*。 函式從所指定的點開始*x*並*y*並填滿色彩界限的所有方向。

如果*nFillType*設定 FLOODFILLSURFACE，函式開始在指定的點*x*並*y*並繼續往所有方向，填滿所有相鄰區域包含所指定的色彩*crColor*。

只有記憶體裝置內容和支援點陣顯示技術支援的裝置`ExtFloodFill`。 如需詳細資訊，請參閱 < [GetDeviceCaps](#getdevicecaps)成員函式。

##  <a name="exttextout"></a>  CDC::ExtTextOut

呼叫此成員函式，將使用目前選取的字型的矩形區域中的字元字串。

```
virtual BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    LPCTSTR lpszString,
    UINT nCount,
    LPINT lpDxWidths);

BOOL ExtTextOut(
    int x,
    int y,
    UINT nOptions,
    LPCRECT lpRect,
    const CString& str,
    LPINT lpDxWidths);
```

### <a name="parameters"></a>參數

*x*<br/>
指定的字串中指定的第一個字元的字元儲存格的邏輯 x 座標。

*y*<br/>
指定字串中指定邏輯的第一個字元的字元儲存格上方的 y 座標。

*nOptions*<br/>
指定矩形的型別。 這個參數可以是其中一個、 兩者皆非的下列值：

- ETO_CLIPPED 指定會裁剪矩形的文字。

- ETO_OPAQUE 指定，目前的背景色彩填滿矩形。 (您可以設定及查詢與目前的背景顏色[SetBkColor](#setbkcolor)並[GetBkColor](#getbkcolor)成員函式。)

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構，決定矩形的維度。 這個參數可以是 NULL。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)此參數的物件。

*lpszString*<br/>
指向要繪製指定的字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)此參數的物件。

*nCount*<br/>
指定字串中的字元數。

*lpDxWidths*<br/>
指向陣列，這個值表示來源的相鄰的字元儲存格之間的距離。 比方說， *lpDxWidths*[*我*] 邏輯單元會分隔字元儲存格的起源*我*與字元儲存格*我*+ 1。 如果*lpDxWidths*是 NULL，`ExtTextOut`使用字元的預設間距。

*str*<br/>
A`CString`物件，其中包含要繪製指定的字元。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

矩形區域可以是不透明 （填入目前的背景色彩），而且它可以裁剪區域。

如果*nOptions*為 0 並*lpRect*是 NULL，函式將文字寫入至 裝置內容而不需使用矩形區域。 根據預設，函式不會使用或更新目前的位置。 如果應用程式需要呼叫時，更新目前的位置`ExtTextOut`，應用程式可以呼叫`CDC`成員函式[SetTextAlign](#settextalign)具有*nFlags*設 TA_UPDATECP。 當設定這個旗標時，Windows 會忽略*x*並*y*在後續呼叫`ExtTextOut`，並改為使用目前的位置。 當應用程式來更新目前的位置，使用 TA_UPDATECP`ExtTextOut`文字的上一行的結尾，或指向陣列的最後一個項目所指定的位置設定的目前位置*lpDxWidths*，為準。

##  <a name="fillpath"></a>  CDC::FillPath

關閉任何開啟的數字，目前路徑中，填滿的路徑內部使用目前的筆刷和多邊形填滿模式。

```
BOOL FillPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

其內部填滿之後，路徑也會從裝置內容會被捨棄。

##  <a name="fillrect"></a>  CDC::FillRect

呼叫此成員函式，以填滿指定的矩形，使用指定的筆刷。

```
void FillRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構，其中包含要填滿的矩形的邏輯座標。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)此參數的物件。

*pBrush*<br/>
識別用來填滿矩形的筆刷。

### <a name="remarks"></a>備註

函式會填滿完整的矩形中，包括左邊和頂端框線，但它不會不會填滿的右邊緣和下框線。

筆刷必須設為使用來建立[CBrush](../../mfc/reference/cbrush-class.md)成員函式[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)， [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)，和[createsolidbrush 以](../../mfc/reference/cbrush-class.md#createsolidbrush)，或藉由擷取`GetStockObject`Windows 函式。

填滿指定的矩形，`FillRect`不包含矩形的右邊緣和下面。 GDI 填滿矩形時，最多至但不包含，右側資料行和底端資料列，不論目前的對應模式。 `FillRect` 比較的值`top`， `bottom`， `left`，和`right`指定矩形的成員。 如果`bottom`小於或等於`top`，或如果`right`小於或等於`left`，不繪製矩形。

`FillRect` 類似於[CDC::FillSolidRect](#fillsolidrect); 不過，`FillRect`採用筆刷，並因此可以用來填入純色、 遞色的色彩、 規劃的筆刷或圖樣的矩形。 `FillSolidRect` 會使用 （以 COLORREF 參數） 只純色。 `FillRect` 通常低於`FillSolidRect`。

##  <a name="fillrgn"></a>  CDC::FillRgn

所指定的區域會填滿*pRgn*使用所指定的筆刷*pBrush*。

```
BOOL FillRgn(
    CRgn* pRgn,
    CBrush* pBrush);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
指標，要填滿的區域。 指定區域的座標會指定以邏輯單位表示。

*pBrush*<br/>
識別用來填滿區域的筆刷。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

筆刷必須建立使用`CBrush`成員函式`CreateHatchBrush`， `CreatePatternBrush`， `CreateSolidBrush`，或擷取`GetStockObject`。

### <a name="example"></a>範例

  範例，請參閱[CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)。

##  <a name="fillsolidrect"></a>  CDC::FillSolidRect

呼叫此成員函式的指定純色填滿指定的矩形。

```
void FillSolidRect(
    LPCRECT lpRect,
    COLORREF clr);

void FillSolidRect(
    int x,
    int y,
    int cx,
    int cy,
    COLORREF clr);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指定的週框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](/windows/desktop/api/windef/ns-windef-tagrect)資料結構或`CRect`此參數的物件。

*clr*指定要用來填滿矩形的色彩。

*x*<br/>
指定矩形左上角的邏輯 x 座標。

*y*<br/>
指定目的地矩形左上角的邏輯 y 座標。

*cx*<br/>
指定矩形的寬度。

*cy*<br/>
指定矩形的高度。

### <a name="remarks"></a>備註

`FillSolidRect` 非常類似[CDC::FillRect](#fillrect); 不過，`FillSolidRect`會使用僅純色 （COLORREF 參數所指示），同時`FillRect`採用筆刷，並因此可以用來填入純色，遞色的矩形色彩、 規劃的筆刷或模式。 `FillSolidRect` 通常的速度比`FillRect`。

> [!NOTE]
>  當您呼叫`FillSolidRect`，背景色彩，而這些使用先前設定[SetBkColor](#setbkcolor)，設定為所指定的色彩*clr*。

##  <a name="flattenpath"></a>  CDC::FlattenPath

轉換到目前的裝置內容中，選取的路徑中的任何型曲線，並將每條曲線轉換成一連串的行。

```
BOOL FlattenPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

##  <a name="floodfill"></a>  CDC::FloodFill

填入目前的筆刷的顯示表面區域。

```
BOOL FloodFill(
    int x,
    int y,
    COLORREF crColor);
```

### <a name="parameters"></a>參數

*x*<br/>
指定填滿的起始處之點的邏輯 x 座標。

*y*<br/>
指定填滿的起始處之點的邏輯 y 座標。

*crColor*<br/>
指定界限的色彩。

### <a name="return-value"></a>傳回值

如果成功，函式，非零值。否則會傳回 0 無法完成填滿，如果指定的時間點具有所指定邊界色彩*crColor*，或是點外的裁剪區域。

### <a name="remarks"></a>備註

區域會假設所會限定為指定*crColor*。 `FloodFill`函式從所指定的點開始*x*並*y*並繼續往所有方向色彩界限。

只有記憶體裝置內容和支援點陣顯示技術支援的裝置`FloodFill`成員函式。 如需 RC_BITBLT 功能的資訊，請參閱`GetDeviceCaps`成員函式。

`ExtFloodFill`函式會提供類似的功能，但更大的彈性。

##  <a name="framerect"></a>  CDC::FrameRect

繪製所指定的矩形框線*lpRect*。

```
void FrameRect(
    LPCRECT lpRect,
    CBrush* pBrush);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)包含矩形的左上角和右下角邊角的邏輯座標的物件。 您也可以傳遞`CRect`此參數的物件。

*pBrush*<br/>
識別要用於框架矩形的筆刷。

### <a name="remarks"></a>備註

此函數會使用指定的筆刷來繪製框線。 框線的高度與寬度永遠是 1 的邏輯單元。

如果矩形`bottom`座標小於或等於`top`，或如果`right`小於或等於`left`，不繪製矩形。

所繪製的框線`FrameRect`位於相同的位置，以繪製框線`Rectangle`成員函式使用相同的座標 (如果`Rectangle`使用是 1 的邏輯單元寬畫筆)。 矩形內部不會填入`FrameRect`。

##  <a name="framergn"></a>  CDC::FrameRgn

所指定的區域周圍繪製框線*pRgn*使用所指定的筆刷*pBrush*。

```
BOOL FrameRgn(
    CRgn* pRgn,
    CBrush* pBrush,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
指向`CRgn`物件，可識別要加上框線的區域。 指定區域的座標會指定以邏輯單位表示。

*pBrush*<br/>
指向`CBrush`可識別用來繪製框線的筆刷物件。

*nWidth*<br/>
指定框線的寬度，單位為裝置的垂直的筆刷筆劃。

*nHeight*<br/>
指定框線的高度，單位為裝置的水平的筆刷筆劃。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="example"></a>範例

  範例，請參閱[CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn)。

##  <a name="fromhandle"></a>  CDC::FromHandle

將指標傳回至`CDC`物件時指定的裝置內容的控制代碼。

```
static CDC* PASCAL FromHandle(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
包含 Windows 裝置內容控制代碼。

### <a name="return-value"></a>傳回值

指標可能是暫時性的不應儲存超過立即使用。

### <a name="remarks"></a>備註

如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。

### <a name="example"></a>範例

  範例，請參閱[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。

##  <a name="getarcdirection"></a>  CDC::GetArcDirection

傳回目前的弧形方向，裝置內容。

```
int GetArcDirection() const;
```

### <a name="return-value"></a>傳回值

如果成功，請指定目前的弧形方向。 以下是有效的傳回值：

- AD_COUNTERCLOCKWISE 弧線和以逆時針方向繪製的矩形。

- AD_CLOCKWISE 弧線，依順時針方向繪製的矩形。

如果發生錯誤，傳回的值為零。

### <a name="remarks"></a>備註

弧線和矩形函式使用弧形方向。

##  <a name="getaspectratiofilter"></a>  CDC::GetAspectRatioFilter

擷取目前的長寬比篩選器的值。

```
CSize GetAspectRatioFilter() const;
```

### <a name="return-value"></a>傳回值

A`CSize`物件，表示目前的長寬比篩選所使用的長寬比。

### <a name="remarks"></a>備註

外觀比例是依據裝置的像素寬度和高度的比例。 裝置的外觀比例的相關資訊會在建立、 選取項目，與顯示的字型。 Windows 提供的特殊篩選器外觀比例篩選器，以選取專為特定的長寬比，從所有可用字型的字型。 此篩選會使用所指定的外觀比例`SetMapperFlags`成員函式。

##  <a name="getbkcolor"></a>  CDC::GetBkColor

傳回目前的背景色彩。

```
COLORREF GetBkColor() const;
```

### <a name="return-value"></a>傳回值

RGB 色彩值。

### <a name="remarks"></a>備註

如果背景模式是不透明，則系統會使用背景色彩來填滿樣式的行中的間隙中的字元儲存格的背景筆刷中的規劃的線條之間的間距。 轉換點陣圖的色彩與單色裝置內容時，系統也會使用背景色彩。

##  <a name="getbkmode"></a>  CDC::GetBkMode

傳回背景模式。

```
int GetBkMode() const;
```

### <a name="return-value"></a>傳回值

目前的背景模式，它可以是不透明。

### <a name="remarks"></a>備註

背景模式會定義系統是否會繪製文字、 規劃的筆刷或不是一條實線任何畫筆樣式之前移除現有的繪圖介面上的背景色彩。

##  <a name="getboundsrect"></a>  CDC::GetBoundsRect

傳回指定的裝置內容的目前累積周框矩形。

```
UINT GetBoundsRect(
    LPRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>參數

*lpRectBounds*<br/>
指向的緩衝區，將會收到目前週框。 傳回矩形的邏輯座標。

*flags*<br/>
指定週框的矩形是否要清除之後會傳回此錯誤。 此參數應為零，或設為下列值：

- DCB_RESET 強制之後就會傳回要清除的周框。

### <a name="return-value"></a>傳回值

如果函式成功，請指定週框的目前狀態。 它可以是下列值的組合：

- 發生 DCB_ACCUMULATE 週框矩形累積。

- DCB_RESET 週框矩形是空的。

- DCB_SET 週框矩形不是空的。

- 所在的周框 DCB_ENABLE 累積。

- 週框 DCB_DISABLE 累積為關閉。

##  <a name="getbrushorg"></a>  CDC::GetBrushOrg

擷取目前選取的裝置內容的筆刷的原點 （以裝置為單位）。

```
CPoint GetBrushOrg() const;
```

### <a name="return-value"></a>傳回值

目前的筆刷 （以裝置為單位） 做為原點[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

### <a name="remarks"></a>備註

初始的筆刷的原點位於 (0，0) 的工作區。 傳回值會指定此點，以裝置單位相對於原點的桌面視窗。

##  <a name="getcharacterplacement"></a>  CDC::GetCharacterPlacement

擷取各種類型的字元字串的詳細資訊。

```
DWORD GetCharacterPlacement(
    LPCTSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;

DWORD GetCharacterPlacement(
    CString& str,
    int nMaxExtent,
    LPGCP_RESULTS lpResults,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*lpString*<br/>
要處理的字元字串指標。

*nCount*<br/>
指定字串的長度。 ANSI 版本，它是 BYTE 計數，而且 Unicode 函式的字數統計。 如需詳細資訊，請參閱 < [GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)。

*nMaxExtent*<br/>
指定最大範圍 （以邏輯單位表示） 來處理字串。 如果處理，則會超出此範圍的字元會被忽略。 任何必要的定序或圖像陣列的計算只適用於包含的字元。 這個參數用在中指定 GCP_MAXEXTENT 值時才*dwFlags*參數。 函式會處理輸入的字串，每個字元和其範圍被加入至輸出、 擴充和其他陣列才在總範圍不超過最大值。 一旦達到限制時，就會停止處理。

*lpResults*<br/>
指標[GCP_Results](/windows/desktop/api/wingdi/ns-wingdi-taggcp_resultsa)接收結果的函式的結構。

*dwFlags*<br/>
指定如何將字串處理成所需的陣列。 這個參數可以是其中一個或多個值中所列*dwFlags*一節[GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)主題。

*str*<br/>
指標[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件可以處理。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回的值會是以邏輯單位表示字串的高度與寬度。

如果此函式失敗，則傳回值為零。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetCharacterPlacement](/windows/desktop/api/wingdi/nf-wingdi-getcharacterplacementa)、 Windows SDK 中所述。

##  <a name="getcharabcwidths"></a>  CDC::GetCharABCWidths

擷取指定範圍內的連續字元的寬度，從目前的 TrueType 字型。

```
BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABC lpabc) const;

BOOL GetCharABCWidths(
    UINT nFirstChar,
    UINT nLastChar,
    LPABCFLOAT lpABCF) const;
```

### <a name="parameters"></a>參數

*nFirstChar*<br/>
從目前的字型字元寬度為其傳回的字元範圍中指定的第一個字元。

*nLastChar*<br/>
從目前的字型字元寬度為其傳回的字元範圍中指定的最後一個字元。

*lpabc*<br/>
指向陣列[ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc)接收字元寬度，當函式傳回的結構。 這個陣列必須包含至少會為許多`ABC`結構中所指定的範圍有字元*nFirstChar*並*nLastChar*參數。

*lpABCF*<br/>
指向陣列的一個應用程式所提供的緩衝區[ABCFLOAT](/windows/desktop/api/wingdi/ns-wingdi-_abcfloat)接收字元寬度，當函式傳回的結構。 此函數所傳回的寬度是 IEEE 浮點格式。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

寬度會傳回以邏輯單位表示。 此函式會成功，只能使用 TrueType 字型。

已選取的特定點大小之後，TrueType 轉譯器會提供"ABC"的字元間距。 "A"間距是前面放置圖像 （glyph） 加入至目前位置的距離。 "B"間距是圖像的黑色的組件的寬度。 "C"間距會新增至目前的位置向負責圖像右邊空白字元。 進階寬度總計根據 A + B + c。

當`GetCharABCWidths`成員函式擷取負"A"或"C"寬字元，而該字元包括 underhangs 或突出部分。

若要轉換的字型設計單位 ABC 寬度，應用程式應該建立字型高度 (中所指定`lfHeight`隸屬[LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta)結構) 中儲存的值等於`ntmSizeEM`的成員[NEWTEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagnewtextmetrica)結構。 (Windows 7`ntmSizeEM`成員可以藉由呼叫擷取[EnumFontFamilies](/windows/desktop/api/wingdi/nf-wingdi-enumfontfamiliesa) Windows 函式。)

ABC 寬度的預設字元用來在目前選取的字型的範圍之外的字元。

若要擷取的非 TrueType 字型中的字元寬度，應用程式應該使用[GetCharWidth](/windows/desktop/api/wingdi/nf-wingdi-getcharwidtha) Windows 函式。

##  <a name="getcharabcwidthsi"></a>  CDC::GetCharABCWidthsI

擷取寬度，以邏輯單位，從目前的 TrueType 字型在指定範圍中的連續的字符索引。

```
BOOL GetCharABCWidthsI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPABC lpabc) const;
```

### <a name="parameters"></a>參數

*giFirst*<br/>
指定第一個圖像 （glyph） 索引群組中的所有連續的字符索引，從目前的字型。 此參數才會使用*pgi*參數為 NULL。

*cgi*<br/>
指定字符索引的數目。

*pgi*<br/>
包含字符索引的陣列指標。 如果值為 NULL， *giFirst*改為使用參數。 *Cgi*參數會指定此陣列中的圖像 （glyph） 索引鍵的數目。

*lpabc*<br/>
陣列的指標[ABC](/windows/desktop/api/wingdi/ns-wingdi-_abc)結構接收字元寬度。 這個陣列必須包含至少會盡可能`ABC`結構所指定的字符索引還有*cgi*參數。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetCharABCWidthsI](/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsi)、 Windows SDK 中所述。

##  <a name="getcharwidth"></a>  CDC::GetCharWidth

從目前的字型，擷取的連續字元群組中的個別字元寬度使用`m_hAttribDC`，輸入的裝置內容。

```
BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;

BOOL GetCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    float* lpFloatBuffer) const;
```

### <a name="parameters"></a>參數

*nFirstChar*<br/>
在連續的目前字型中的字元群組中指定的第一個字元。

*nLastChar*<br/>
指定連續的目前字型中的字元群組中的最後一個字元。

*lpBuffer*<br/>
指向的緩衝區，將會收到一組連續字元的寬度值中目前的字型。

*lpFloatBuffer*<br/>
接收字元寬度之緩衝區的指標。 傳回的寬度會以 32 位元 IEEE 浮點數格式。 （寬度會測量總基底的字元）。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

比方說，如果*nFirstChar*識別為字母 'a' 並*nLastChar*識別字母 'a'-'z'、 函式擷取的所有小寫字元寬度。

函式會將值儲存在所指的緩衝區*lpBuffer*。 這個緩衝區必須夠大，無法容納所有的寬度。 也就是必須有至少 26 的項目中指定的範例。

如果連續的字元群組中的字元不存在於特定的字型，則會指派預設字元寬度值。

##  <a name="getcharwidthi"></a>  CDC::GetCharWidthI

擷取寬度，以邏輯座標，從目前的字型在指定範圍中的連續的字符索引。

```
BOOL GetCharWidthI(
    UINT giFirst,
    UINT cgi,
    LPWORD pgi,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>參數

*giFirst*<br/>
指定第一個圖像 （glyph） 索引群組中的所有連續的字符索引，從目前的字型。 此參數才會使用*pgi*參數為 NULL。

*cgi*<br/>
指定字符索引的數目。

*pgi*<br/>
包含字符索引的陣列指標。 如果值為 NULL， *giFirst*改為使用參數。 *Cgi*參數會指定此陣列中的圖像 （glyph） 索引鍵的數目。

*lpBuffer*<br/>
接收寬度的緩衝區指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetCharWidthI](/windows/desktop/api/wingdi/nf-wingdi-getcharwidthi)、 Windows SDK 中所述。

##  <a name="getclipbox"></a>  CDC::GetClipBox

擷取目前的裁剪界限周圍 tightest 週框矩形的維度。

```
virtual int GetClipBox(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)接收矩形維度的物件。

### <a name="return-value"></a>傳回值

裁剪區域的類型。 它可以是下列值之一：

- COMPLEXREGION 裁剪區域會有重疊的框線。

- 錯誤的裝置內容不是有效的。

- NULLREGION 裁剪區域是空的。

- SIMPLEREGION 裁剪區域沒有任何重疊的框線。

### <a name="remarks"></a>備註

維度會複製到所指向的緩衝區*lpRect*。

##  <a name="getcoloradjustment"></a>  CDC::GetColorAdjustment

擷取裝置內容的色彩調整值。

```
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
```

### <a name="parameters"></a>參數

*lpColorAdjust*<br/>
指向[COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment)接收色彩調整值的資料結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

##  <a name="getcurrentbitmap"></a>  CDC::GetCurrentBitmap

讓指標回到目前所選`CBitmap`物件。

```
CBitmap* GetCurrentBitmap() const;
```

### <a name="return-value"></a>傳回值

指標`CBitmap`物件，如果成功，否則為 NULL。

### <a name="remarks"></a>備註

此成員函式可能會傳回暫存物件。

##  <a name="getcurrentbrush"></a>  CDC::GetCurrentBrush

讓指標回到目前所選`CBrush`物件。

```
CBrush* GetCurrentBrush() const;
```

### <a name="return-value"></a>傳回值

指標`CBrush`物件，如果成功，否則為 NULL。

### <a name="remarks"></a>備註

此成員函式可能會傳回暫存物件。

##  <a name="getcurrentfont"></a>  CDC::GetCurrentFont

讓指標回到目前所選`CFont`物件。

```
CFont* GetCurrentFont() const;
```

### <a name="return-value"></a>傳回值

指標`CFont`物件，如果成功，否則為 NULL。

### <a name="remarks"></a>備註

此成員函式可能會傳回暫存物件。

##  <a name="getcurrentpalette"></a>  CDC::GetCurrentPalette

讓指標回到目前所選`CPalette`物件。

```
CPalette* GetCurrentPalette() const;
```

### <a name="return-value"></a>傳回值

指標`CPalette`物件，如果成功，否則為 NULL。

### <a name="remarks"></a>備註

此成員函式可能會傳回暫存物件。

##  <a name="getcurrentpen"></a>  CDC::GetCurrentPen

讓指標回到目前所選`CPen`物件。

```
CPen* GetCurrentPen() const;
```

### <a name="return-value"></a>傳回值

指標`CPen`物件，如果成功，否則為 NULL。

### <a name="remarks"></a>備註

此成員函式可能會傳回暫存物件。

##  <a name="getcurrentposition"></a>  CDC::GetCurrentPosition

擷取目前的位置 （以邏輯座標中）。

```
CPoint GetCurrentPosition() const;
```

### <a name="return-value"></a>傳回值

目前的位置，以`CPoint`物件。

### <a name="remarks"></a>備註

目前的位置可以設定與`MoveTo`成員函式。

##  <a name="getdcbrushcolor"></a>  CDC::GetDCBrushColor

擷取目前的筆刷色彩。

```
COLORREF GetDCBrushColor() const;
```

### <a name="return-value"></a>傳回值

如果此函數成功，傳回的值是[COLORREF](/windows/desktop/gdi/colorref)目前的筆刷色彩的值。

如果函式失敗，則傳回的值會是 CLR_INVALID。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-getdcbrushcolor)、 Windows SDK 中所述。

##  <a name="getdcpencolor"></a>  CDC::GetDCPenColor

擷取目前的畫筆顏色。

```
COLORREF GetDCPenColor() const;
```

### <a name="return-value"></a>傳回值

如果此函數成功，傳回的值是[COLORREF](/windows/desktop/gdi/colorref)目前的畫筆色彩值。

如果函式失敗，則傳回的值會是 CLR_INVALID。

### <a name="remarks"></a>備註

此成員函式會利用 Win32 函式[GetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-getdcpencolor)、 Windows SDK 中所述。

##  <a name="getdevicecaps"></a>  CDC::GetDeviceCaps

擷取各種不同的顯示裝置的裝置特定資訊。

```
int GetDeviceCaps(int nIndex) const;
```

### <a name="parameters"></a>參數

*nIndex*<br/>
指定要傳回資訊的類型。 請參閱[GetDeviceCaps](/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps)值清單的 Windows SDK 中。

### <a name="return-value"></a>傳回值

所要求的功能，如果函式成功的值。

### <a name="example"></a>範例

  範例，請參閱[CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)。

##  <a name="getfontdata"></a>  CDC::GetFontData

擷取可調式字型檔案中的字型度量資訊。

```
DWORD GetFontData(
    DWORD dwTable,
    DWORD dwOffset,
    LPVOID lpData,
    DWORD cbData) const;
```

### <a name="parameters"></a>參數

*dwTable*<br/>
指定要傳回之度量資料表的名稱。 這個參數可以是其中一個計量的資料表，Microsoft Corporation 所發佈的 TrueType 字型檔案規格所述。 如果此參數為 0，字型檔的開頭擷取的資訊。

*dwOffset*<br/>
指定從資料表中要開始擷取資訊的開頭的位移。 如果此參數為 0，擷取的資訊是開頭指定的資料表*dwTable*參數。 如果這個值是大於或等於的資料表大小`GetFontData`會傳回 0。

*lpData*<br/>
指向的緩衝區，將會收到的字型資訊。 如果這個值是 NULL，函式會傳回緩衝區中指定的字型資料所需的大小*dwTable*參數。

*cbData*<br/>
指定長度，以位元組為單位，要擷取的資訊。 如果這個參數是 0，`GetFontData`會傳回在指定的資料大小*dwTable*參數。

### <a name="return-value"></a>傳回值

指定傳回中所指向緩衝區的位元組數目*lpData*如果函式成功，否則為-1。

### <a name="remarks"></a>備註

要擷取之資訊識別到字型檔案，以及要傳回的資訊中指定的位移。

應用程式有時也可以使用`GetFontData`儲存 TrueType 字型的文件的成員函式。 若要這樣做，應用程式會判斷是否字型可內嵌，然後擷取整個字型檔案，可以指定 0 代表*dwTable*， *dwOffset*，並*cbData*參數。

應用程式可以判斷是否可以藉由檢查中內嵌字型`otmfsType`隸屬[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)結構。 如果位元 1`otmfsType`設定內嵌字型不允許。 如果位元 1 已清除，則可以內嵌字型。 如果設定位元 2，內嵌為唯讀。

如果應用程式嘗試使用此函數來擷取非 TrueType 字型，資訊`GetFontData`成員函式會傳回-1。

##  <a name="getfontlanguageinfo"></a>  CDC::GetFontLanguageInfo

傳回指定的顯示內容的目前選取字型的相關資訊。

```
DWORD GetFontLanguageInfo() const;
```

### <a name="return-value"></a>傳回值

傳回值會識別目前選取的字型的特性。 如需可能值的完整清單，請參閱 < [GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo)。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetFontLanguageInfo](/windows/desktop/api/wingdi/nf-wingdi-getfontlanguageinfo)、 Windows SDK 中所述。

##  <a name="getglyphoutline"></a>  CDC::GetGlyphOutline

擷取的外框曲線或外框中字元的目前字型的點陣圖。

```
DWORD GetGlyphOutline(
    UINT nChar,
    UINT nFormat,
    LPGLYPHMETRICS lpgm,
    DWORD cbBuffer,
    LPVOID lpBuffer,
    const MAT2* lpmat2) const;
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定要傳回資訊的字元。

*nFormat*<br/>
指定要傳回資訊的函式的格式。 它可以是下列值，其中一項或 0:

|值|意義|
|-----------|-------------|
|GGO_BITMAP|傳回圖像 （glyph） 點陣圖。 當函式傳回時，所指向的緩衝區*lpBuffer*包含其資料列開始 doubleword 界限的 1 位元-每個像素點陣圖。|
|GGO_NATIVE|傳回資料點的曲線，轉譯器的原生格式，使用裝置單位。 中指定此值時，指定任何轉換*lpmat2*會被忽略。|

當 windows 7 *nFormat*是 0，則此函式會填入[GLYPHMETRICS](/windows/desktop/api/wingdi/ns-wingdi-_glyphmetrics)結構，但不會傳回字符外框資料。

*lpgm*<br/>
指向 GLYPHMETRICS 結構描述中的字元儲存格的圖像 （glyph） 的位置。

*cbBuffer*<br/>
指定函式會大綱字元的相關資訊複製到其中的緩衝區的大小。 如果此值為 0， *nFormat*參數是 GGO_BITMAP 或 GGO_NATIVE 值函式會傳回緩衝區的必要的大小。

*lpBuffer*<br/>
指向函式會大綱字元的相關資訊複製到其中的緩衝區。 如果*nFormat*指定 GGO_NATIVE 值，資訊會複製 TTPOLYGONHEADER 和 TTPOLYCURVE 結構的形式。 如果這個值是 NULL， *nFormat* GGO_BITMAP 或 GGO_NATIVE 值函式會傳回緩衝區的必要的大小。

*lpmat2*<br/>
指向[MAT2](/windows/desktop/api/wingdi/ns-wingdi-_mat2)結構，其中包含轉換矩陣的字元。 此參數不得為 NULL，指定 GGO_NATIVE 值時，即使*nFormat*。

### <a name="return-value"></a>傳回值

大小 （位元組），如果擷取的資訊所需的緩衝區*cbBuffer*為 0 或*lpBuffer*是 NULL。 否則就是正數值如果函式成功，則為-1，如果發生錯誤。

### <a name="remarks"></a>備註

應用程式可以旋轉點陣圖格式擷取藉由指定 2-2 的轉換矩陣所指向的結構中的字元數*lpmat2*。

字符外框會傳回為一系列的輪廓。 定義每個分佈[TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader)結構後面加上任意數目`TTPOLYCURVE`結構來描述它所需。 所有資料點會以傳回[POINTFX](/windows/desktop/api/wingdi/ns-wingdi-tagpointfx)結構及代表絕對位置，而非相對的移動。 起始點的指定`pfxStart`隸屬[TTPOLYGONHEADER](/windows/desktop/api/wingdi/ns-wingdi-tagttpolygonheader)結構是分佈的大綱開始處的點。 [TTPOLYCURVE](/windows/desktop/api/wingdi/ns-wingdi-tagttpolycurve)聚合線條的記錄，或是曲線記錄，可以遵循的結構。 聚合線條的記錄是一系列的點;點之間繪製線條描述字元的外框。 曲線記錄代表 TrueType （也就是二次方 b-曲線） 所使用的二次方曲線。

##  <a name="getgraphicsmode"></a>  CDC::GetGraphicsMode

擷取指定的裝置內容的目前圖形模式。

```
int GetGraphicsMode() const;
```

### <a name="return-value"></a>傳回值

成功時傳回目前的圖形模式。 如需這個方法可以傳回值的清單，請參閱 < [GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode)。

在失敗時傳回 0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函式[GetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-getgraphicsmode)。

##  <a name="gethalftonebrush"></a>  CDC::GetHalftoneBrush

呼叫此成員函式可擷取半色調筆刷。

```
static CBrush* PASCAL GetHalftoneBrush();
```

### <a name="return-value"></a>傳回值

指標`CBrush`如果成功，否則為 NULL 的物件。

### <a name="remarks"></a>備註

半色調筆刷顯示或者是建立為遞色的圖樣的前景和背景色彩的像素。 以下是由 半色調筆刷為遞色圖樣的範例。

![詳細資料的遞色的畫筆筆劃](../../mfc/reference/media/vc318s1.gif "遞色的畫筆筆劃的詳細資料")

##  <a name="getkerningpairs"></a>  CDC::GetKerningPairs

擷取字元間距調整組指定的裝置內容中目前選取之字型的字元。

```
int GetKerningPairs(
    int nPairs,
    LPKERNINGPAIR lpkrnpair) const;
```

### <a name="parameters"></a>參數

*nPairs*<br/>
指定的數目[KERNINGPAIR](/windows/desktop/api/wingdi/ns-wingdi-tagkerningpair)所指向結構*lpkrnpair*。 此函式不會複製所指定的多個 kerning 配對*nPairs*。

*lpkrnpair*<br/>
指向陣列`KERNINGPAIR`函式傳回時，接收字元間距調整的結構配對。 這個陣列必須包含數至少與所指定的結構*nPairs*。 如果此參數為 NULL，函式會傳回的字元間距調整組字型的總數。

### <a name="return-value"></a>傳回值

如果函式成功，請指定的字元間距調整組擷取數或總數字型中的組字元間距調整。 如果函式失敗，或沒有 kerning 成對字型，則會傳回零。

##  <a name="getlayout"></a>  CDC::GetLayout

呼叫此成員函式，來判斷文字和圖形裝置內容，例如印表機或中繼檔的配置。

```
DWORD GetLayout() const;
```

### <a name="return-value"></a>傳回值

如果成功，版面配置旗標目前的裝置內容。 否則，GDI_ERROR。 如需擴充的錯誤資訊，呼叫[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。 如需版面配置的旗標的清單，請參閱 < [CDC::SetLayout](#setlayout)。

### <a name="remarks"></a>備註

預設的版面配置是由左到右。

##  <a name="getmapmode"></a>  CDC::GetMapMode

擷取目前的對應模式。

```
int GetMapMode() const;
```

### <a name="return-value"></a>傳回值

此對應模式。

### <a name="remarks"></a>備註

如需對應模式的說明，請參閱`SetMapMode`成員函式。

> [!NOTE]
>  如果您呼叫[SetLayout](#setlayout)若要從右至左的配置，以變更 DC`SetLayout`自動將此對應模式變更為 MM_ISOTROPIC。 因此，任何後續呼叫`GetMapMode`會傳回 MM_ISOTROPIC。

##  <a name="getmiterlimit"></a>  CDC::GetMiterLimit

傳回裝置內容斜接限制。

```
float GetMiterLimit() const;
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

包含的繪製幾何行儀表聯結時，會使用斜接限制。

##  <a name="getnearestcolor"></a>  CDC::GetNearestColor

傳回最符合指定的邏輯色彩的純色。

```
COLORREF GetNearestColor(COLORREF crColor) const;
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定要比對的色彩。

### <a name="return-value"></a>傳回值

定義穩固的 RGB （紅、 綠、 藍） 色彩值色彩最接近*crColor*裝置可代表的值。

### <a name="remarks"></a>備註

指定的裝置必須能夠代表這個色彩。

##  <a name="getoutlinetextmetrics"></a>  CDC::GetOutlineTextMetrics

擷取 TrueType 字型度量資訊。

```
UINT GetOutlineTextMetrics(
    UINT cbData,
    LPOUTLINETEXTMETRIC lpotm) const;
```

### <a name="parameters"></a>參數

*lpotm*<br/>
指向陣列[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)結構。 如果此參數為 NULL，則函數會傳回所擷取的度量資料所需的緩衝區大小。

*cbData*<br/>
指定的大小，以位元組為單位傳回資訊的緩衝區。

*lpotm*<br/>
指向`OUTLINETEXTMETRIC`結構。 如果此參數為 NULL，則函數會傳回所擷取的度量資訊所需的緩衝區大小。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

[OUTLINETEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-_outlinetextmetrica)結構包含 TrueType 格式時，所提供的字型度量資訊的大部分包括[TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)結構。 最後四個成員`OUTLINETEXTMETRIC`結構都是字串指標。 應用程式應該針對這些字串，除了其他成員所需的空間配置空間。 因為沒有系統加諸的限制為字串的大小，配置記憶體的最簡單方法是藉由指定，則為 NULL，擷取所需的大小*lpotm*中的第一個呼叫`GetOutlineTextMetrics`函式。

##  <a name="getoutputcharwidth"></a>  CDC::GetOutputCharWidth

會使用輸出裝置內容中， `m_hDC`，並擷取從目前的字型的連續字元群組中的個別字元的寬度。

```
BOOL GetOutputCharWidth(
    UINT nFirstChar,
    UINT nLastChar,
    LPINT lpBuffer) const;
```

### <a name="parameters"></a>參數

*nFirstChar*<br/>
在連續的目前字型中的字元群組中指定的第一個字元。

*nLastChar*<br/>
指定連續的目前字型中的字元群組中的最後一個字元。

*lpBuffer*<br/>
指向的緩衝區，將會收到一組連續字元的寬度值中目前的字型。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

比方說，如果*nFirstChar*識別為字母 'a' 並*nLastChar*識別字母 'a'-'z'、 函式擷取的所有小寫字元寬度。

函式會將值儲存在所指的緩衝區*lpBuffer*。 這個緩衝區必須夠大，無法容納所有的寬度;也就是必須有至少 26 的項目中指定的範例。

如果連續的字元群組中的字元不存在於特定的字型，則會指派預設字元寬度值。

##  <a name="getoutputtabbedtextextent"></a>  CDC::GetOutputTabbedTextExtent

呼叫此成員函式，來計算字元字串使用的高度與寬度[m_hDC](#m_hdc)，輸出裝置內容。

```
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetOutputTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向要測量的字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)此參數的物件。

*nCount*<br/>
指定字串中的字元數。 如果*nCount*為-1，長度會計算。

*nTabPositions*<br/>
指定所指陣列中的定位停駐點位置數目*lpnTabStopPositions*。

*lpnTabStopPositions*<br/>
指向陣列包含以邏輯單位表示的定位停駐點位置的整數。 定位停駐點必須以遞增順序排序最小的 x 值應該在陣列中的第一個項目。 不允許反向索引標籤。

*str*<br/>
A`CString`物件，其中包含要測量指定的字元。

### <a name="return-value"></a>傳回值

中的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

如果字串包含一或多個索引標籤字元，字串的寬度取決於所指定的定位停駐點*lpnTabStopPositions*。 此函數會使用目前選取的字型，計算字串的大小。

目前的裁剪區域不位移所傳回的高度與寬度`GetOutputTabbedTextExtent`函式。

因為某些裝置請勿將字元放在一般的資料格陣列中 （也就是它們微調字元），在字串中的字元範圍的總和可能不等於字串的範圍。

如果*nTabPositions*為 0 並*lpnTabStopPositions*是 NULL 時，索引標籤會展開至八個的平均字元寬度。 如果*nTabPositions*為 1，定位停駐點會隔開第一個值的陣列中所指定的距離*lpnTabStopPositions*點。 如果*lpnTabStopPositions*至多個單一值的點，最多指定數目的陣列中每個值設定定位停駐點*nTabPositions*。

##  <a name="getoutputtextextent"></a>  CDC::GetOutputTextExtent

呼叫此成員函式，若要使用的輸出裝置內容中， [m_hDC](#m_hdc)，和計算的一行文字，使用目前的字型的高度與寬度。

```
CSize GetOutputTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetOutputTextExtent(const CString& str) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向字串的字元。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)此參數的物件。

*nCount*<br/>
指定字串中的字元數。 如果*nCount*為-1，長度會計算。

*str*<br/>
A`CString`物件，其中包含要測量指定的字元。

### <a name="return-value"></a>傳回值

（以邏輯單位表示） 的字串中傳回的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

目前的裁剪區域不會影響所傳回的高度與寬度`GetOutputTextExtent`。

因為某些裝置未在規則資料格陣列中放置字元 （亦即，它們會帶出字元間距調整），在字串中的字元範圍的總和可能不等於字串的範圍。

##  <a name="getoutputtextmetrics"></a>  CDC::GetOutputTextMetrics

擷取目前的字型使用的度量`m_hDC`，輸出裝置內容。

```
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>參數

*lpMetrics*<br/>
指向[TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)收到計量的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

##  <a name="getpath"></a>  CDC::GetPath

擷取定義線條的端點和選入裝置內容的路徑中找到的曲線的控制點座標。

```
int GetPath(
    LPPOINT lpPoints,
    LPBYTE lpTypes,
    int nCount) const;
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列[點](/windows/desktop/api/windef/ns-windef-tagpoint)資料結構或`CPoint`位於其中的線條端點和曲線控制點的物件。

*lpTypes*<br/>
指向陣列的頂點類型的放置位置的位元組。 值可以是下列其中一項：

- PT_MOVETO 指定，並對應指向*lpPoints*開始脫離的圖形。

- PT_LINETO 指定前一個點，並對應點*lpPoints*線條的端點。

- PT_BEZIERTO 指定，並對應指向*lpPoints*控制點或 Bzier 曲線的結束點。

PT_BEZIERTO 類型一定要進行中的三個集合。 立即前的路徑中的點定義 Bzier 曲線的起始點。 前兩個 PT_BEZIERTO 點是控制點，而第三個 PT_BEZIERTO 點是結束點 (如果硬式編碼)。

   PT_LINETO 或 PT_BEZIERTO 類型也可以結合下列旗標 (使用位元運算子**OR**) 以指出對應的點是圖表中的最後一點，且圖都應該關閉：

- PT_CLOSEFIGURE 指定對應的行之後，會自動關閉圖或繪製曲線。 此圖會關閉從直線或曲線結束點繪製一條線，對應到最後一個 PT_MOVETO 的點。

*nCount*<br/>
指定的總數[點](/windows/desktop/api/windef/ns-windef-tagpoint)資料結構，可能會放置於*lpPoints*陣列。 此值必須是相同的位元組數目，顯示可能會放置於*lpTypes*陣列。

### <a name="return-value"></a>傳回值

如果*nCount*參數為非零值，列舉的點數目。 如果*nCount*為 0，在路徑中的點總數 (與`GetPath`nothing 寫入緩衝區)。 如果*nCount*為非零值，而且小於的點數在路徑中，傳回的值為-1。

### <a name="remarks"></a>備註

裝置內容必須包含已關閉的路徑。 路徑的點會傳回邏輯座標。 因此儲存在裝置座標中的路徑點`GetPath`使用目前轉換的反向從裝置座標變更點為邏輯座標。 `FlattenPath`之前，可能會呼叫成員函式`GetPath`，以在路徑中的所有曲線都轉換成直線線段。

### <a name="example"></a>範例

  範例，請參閱[cdc:: beginpath](#beginpath)。

##  <a name="getpixel"></a>  CDC::GetPixel

擷取所指定的點的像素的 RGB 色彩值*x*並*y*。

```
COLORREF GetPixel(
    int x,
    int y) const;

COLORREF GetPixel(POINT point) const;
```

### <a name="parameters"></a>參數

*x*<br/>
指定要檢查點的邏輯 x 座標。

*y*<br/>
指定要檢查點的邏輯 y 座標。

*point*<br/>
指定邏輯 x 和 y 座標的檢查點。

### <a name="return-value"></a>傳回值

函式，針對指定的時間點的色彩的 RGB 色彩值的任一版本。 如果座標的裁剪區域中未指定的點，它會為-1。

### <a name="remarks"></a>備註

裁剪區域必須是點。 重點不是裁剪區域中，如果函式沒有任何作用，並傳回-1。

並非所有的裝置皆支援 `GetPixel` 函式。 如需詳細資訊，請參閱底下的 RC_BITBLT 點陣功能[GetDeviceCaps](#getdevicecaps)成員函式。

`GetPixel`成員函式有兩種形式。 第一個採用兩個座標的值;第二個會接受[點](/windows/desktop/api/windef/ns-windef-tagpoint)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

##  <a name="getpolyfillmode"></a>  CDC::GetPolyFillMode

擷取目前的多邊形填滿模式。

```
int GetPolyFillMode() const;
```

### <a name="return-value"></a>傳回值

目前的多邊形填滿模式中，替代或捲繞，如果函式成功。

### <a name="remarks"></a>備註

請參閱`SetPolyFillMode`的多邊形填滿模式描述的成員函式。

##  <a name="getrop2"></a>  CDC::GetROP2

擷取目前的繪製模式。

```
int GetROP2() const;
```

### <a name="return-value"></a>傳回值

繪圖的模式。 如需繪圖的模式值的清單，請參閱`SetROP2`成員函式。

### <a name="remarks"></a>備註

繪製模式會指定如何與已經在顯示介面上的色彩結合色彩的畫筆和填滿物件的內部。

##  <a name="getsafehdc"></a>  CDC::GetSafeHdc

呼叫以取得此成員函式[m_hDC](#m_hdc)，輸出裝置內容。

```
HDC GetSafeHdc() const;
```

### <a name="return-value"></a>傳回值

裝置內容控制代碼。

### <a name="remarks"></a>備註

此成員函式也可以搭配 null 指標。

##  <a name="getstretchbltmode"></a>  CDC::GetStretchBltMode

擷取目前的點陣圖縮放模式。

```
int GetStretchBltMode() const;
```

### <a name="return-value"></a>傳回值

傳回的值會指定目前的點陣圖縮放模式 — STRETCH_ANDSCANS、 STRETCH_DELETESCANS 或 STRETCH_ORSCANS — 如果函式成功。

### <a name="remarks"></a>備註

點陣圖縮放模式可讓您定義如何從自動縮放或壓縮點陣圖中移除資訊`StretchBlt`成員函式。

STRETCH_ANDSCANS 和 STRETCH_ORSCANS 模式通常用來保留前景中單色點陣圖的像素。 STRETCH_DELETESCANS 模式通常用來保留在色彩點陣圖的色彩。

##  <a name="gettabbedtextextent"></a>  CDC::GetTabbedTextExtent

呼叫此成員函式，來計算字元字串使用的高度與寬度[m_hAttribDC](#m_hattribdc)，屬性的裝置內容。

```
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;

CSize GetTabbedTextExtent(
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)此參數的物件。

*nCount*<br/>
指定字串中的字元數。 如果*nCount*為-1，長度會計算。

*nTabPositions*<br/>
指定所指陣列中的定位停駐點位置數目*lpnTabStopPositions*。

*lpnTabStopPositions*<br/>
指向陣列包含以邏輯單位表示的定位停駐點位置的整數。 定位停駐點必須以遞增順序排序最小的 x 值應該在陣列中的第一個項目。 不允許反向索引標籤。

*str*<br/>
A`CString`物件，其中包含要繪製指定的字元。

### <a name="return-value"></a>傳回值

中的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

如果字串包含一或多個索引標籤字元，字串的寬度取決於所指定的定位停駐點*lpnTabStopPositions*。 此函數會使用目前選取的字型，計算字串的大小。

目前的裁剪區域不位移所傳回的高度與寬度`GetTabbedTextExtent`函式。

因為某些裝置請勿將字元放在一般的資料格陣列中 （也就是它們微調字元），在字串中的字元範圍的總和可能不等於字串的範圍。

如果*nTabPositions*為 0 並*lpnTabStopPositions*是 NULL 時，索引標籤會展開至八倍的平均字元寬度。 如果*nTabPositions*為 1，定位停駐點會隔開第一個值的陣列中所指定的距離*lpnTabStopPositions*點。 如果*lpnTabStopPositions*至多個單一值的點，最多指定數目的陣列中每個值設定定位停駐點*nTabPositions*。

##  <a name="gettextalign"></a>  CDC::GetTextAlign

擷取裝置內容的文字對齊旗標的狀態。

```
UINT GetTextAlign() const;
```

### <a name="return-value"></a>傳回值

文字對齊方式的旗標的狀態。 傳回值是一或多個下列值：

- X 軸和基準線的週框矩形內的所選字型 TA_BASELINE 指定的對齊方式。

- X 軸和週框矩形的底部 TA_BOTTOM 指定的對齊方式。

- Y 軸和週框矩形的中心 TA_CENTER 指定的對齊方式。

- Y 軸和週框矩形左邊 TA_LEFT 指定的對齊方式。

- TA_NOUPDATECP 指定不會更新目前的位置。

- Y 軸，指定的週框右邊 TA_RIGHT 指定的對齊方式。

- X 軸和週框矩形的頂端 TA_TOP 指定的對齊方式。

- TA_UPDATECP 指定，會更新目前的位置。

### <a name="remarks"></a>備註

文字對齊方式的旗標決定如何`TextOut`和`ExtTextOut`成員函式對齊文字相對於字串的起始點的字串。 文字對齊方式的旗標不一定要為單一位元旗標，且可能會等於 0。 若要測試是否已設定的旗標，應用程式應該遵循下列步驟：

1. 適用於位元的 OR 運算子的旗標和其相關的旗標，分組，如下所示：

    - TA_LEFT、 TA_CENTER 和 TA_RIGHT

    - TA_BASELINE、 TA_BOTTOM 和 TA_TOP

    - TA_NOUPDATECP 和 TA_UPDATECP

1. 適用於位元-和結果的傳回值的運算子`GetTextAlign`。

1. 測試這個結果和旗標相等。

##  <a name="gettextcharacterextra"></a>  CDC::GetTextCharacterExtra

擷取目前的設定 intercharacter 間距量。

```
int GetTextCharacterExtra() const;
```

### <a name="return-value"></a>傳回值

Intercharacter 的間距數量。

### <a name="remarks"></a>備註

GDI 會將每個字元，包括分行符號字元，當它將一行文字寫入至裝置內容中的此間距。

Intercharacter 間距所需的預設值為 0。

##  <a name="gettextcolor"></a>  CDC::GetTextColor

擷取目前的文字色彩。

```
COLORREF GetTextColor() const;
```

### <a name="return-value"></a>傳回值

目前的文字色彩為 RGB 色彩值。

### <a name="remarks"></a>備註

文字色彩是由使用 GDI 文字輸出成員函式描繪的字元的前景色彩[TextOut](#textout)， [ExtTextOut](#exttextout)，並[TabbedTextOut](#tabbedtextout)。

##  <a name="gettextextent"></a>  CDC::GetTextExtent

呼叫此成員函式，來計算以決定維度使用的目前字型的文字行高度與寬度。

```
CSize GetTextExtent(
    LPCTSTR lpszString,
    int nCount) const;

CSize GetTextExtent(const CString& str) const;
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向字串的字元。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)此參數的物件。

*nCount*<br/>
指定字串中的字元數。

*str*<br/>
A`CString`物件，其中包含指定的字元。

### <a name="return-value"></a>傳回值

中的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

從擷取的資訊[m_hAttribDC](#m_hattribdc)，屬性的裝置內容。

根據預設，`GetTextExtent`假設它會擷取該維度的文字會沿著水平列設定 （也就是 escapement 為 0）。 如果您建立指定非零 escapement 字型，您必須轉換明確地取得字串的大小文字的角度。

目前的裁剪區域不會影響所傳回的高度與寬度`GetTextExtent`。

因為某些裝置未在規則資料格陣列中放置字元 （亦即，它們會帶出字元間距調整），在字串中的字元範圍的總和可能不等於字串的範圍。

##  <a name="gettextextentexpointi"></a>  CDC::GetTextExtentExPointI

擷取在指定的字串將放入指定的空間中，陣列中填入文字範圍的每個這些字元的字元數目。

```
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,
    int cgi,
    int nMaxExtent,
    LPINT lpnFit,
    LPINT alpDx,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*pgiIn*<br/>
要擷取範圍對於的字符索引的陣列指標。

*cgi*<br/>
所指陣列中指定的字符數目*pgiIn*。

*nMaxExtent*<br/>
指定的最大允許的寬度，以邏輯單位，格式化字串。

*lpnFit*<br/>
接收的最大中所指定的空間可容納的字元數計數的整數指標*nMaxExtent*。 當*lpnFit*為 NULL，就*nMaxExtent*會被忽略。

*alpDx*<br/>
接收部分圖像 （glyph） 範圍的整數的陣列指標。 陣列中的每個項目提供的距離，以邏輯單位，表示圖像 （glyph） 索引陣列的開頭與符合所指定的空間中的一個字符的之間*nMaxExtent*。 雖然這個陣列應該有至少多個項目，為所指定的字符索引*cgi*，此函式會填滿範圍只會針對多個字符索引時所指定的陣列*lpnFit*。 如果*lpnDx*是 NULL，函式不會計算部分的字串寬度。

*lpSize*<br/>
指標[大小](/windows/desktop/api/windef/ns-windef-tagsize)以邏輯單位表示收到的圖像 （glyph） 索引陣列維度的結構。 此值不能是 NULL。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetTextExtentExPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentexpointi)、 Windows SDK 中所述。

##  <a name="gettextextentpointi"></a>  CDC::GetTextExtentPointI

擷取指定之陣列的字符索引的高度與寬度。

```
BOOL GetTextExtentPointI(
    LPWORD pgiIn,
    int cgi,
    LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*pgiIn*<br/>
要擷取範圍對於的字符索引的陣列指標。

*cgi*<br/>
所指陣列中指定的字符數目*pgiIn*。

*lpSize*<br/>
指標[大小](/windows/desktop/api/windef/ns-windef-tagsize)以邏輯單位表示收到的圖像 （glyph） 索引陣列維度的結構。 此值不能是 NULL。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetTextExtentPointI](/windows/desktop/api/wingdi/nf-wingdi-gettextextentpointi)、 Windows SDK 中所述。

##  <a name="gettextface"></a>  CDC::GetTextFace

呼叫此成員函式複製到緩衝區的目前字型的字樣名稱。

```
int GetTextFace(
    int nCount,
    LPTSTR lpszFacename) const;

int GetTextFace(CString& rString) const;
```

### <a name="parameters"></a>參數

*nCount*<br/>
指定緩衝區的大小 （以位元組為單位）。 如果超過此參數所指定的位元組數目的字樣名稱，名稱是被截斷。

*lpszFacename*<br/>
指向的字樣名稱的緩衝區。

*rString*<br/>
參考[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

### <a name="return-value"></a>傳回值

複製到緩衝區，不包括結束的 null 字元的位元組數目。 如果發生錯誤，它就會是 0。

### <a name="remarks"></a>備註

以 null 終止字串複製的字樣名稱。

##  <a name="gettextmetrics"></a>  CDC::GetTextMetrics

擷取目前使用屬性的裝置內容的字型度量資訊。

```
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
```

### <a name="parameters"></a>參數

*lpMetrics*<br/>
指向[TEXTMETRIC](/windows/desktop/api/wingdi/ns-wingdi-tagtextmetrica)收到計量的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

##  <a name="getviewportext"></a>  CDC::GetViewportExt

擷取 x-和 y-範圍的裝置內容的檢視區。

```
CSize GetViewportExt() const;
```

### <a name="return-value"></a>傳回值

X-和 y 的範圍 （以裝置為單位） 為`CSize`物件。

##  <a name="getviewportorg"></a>  CDC::GetViewportOrg

擷取的裝置內容相關聯的檢視區原點 x 和 y 座標。

```
CPoint GetViewportOrg() const;
```

### <a name="return-value"></a>傳回值

（以裝置座標表示） 做為檢視區原點`CPoint`物件。

##  <a name="getwindow"></a>  CDC::GetWindow

傳回顯示裝置內容相關聯的視窗。

```
CWnd* GetWindow() const;
```

### <a name="return-value"></a>傳回值

指標`CWnd`如果成功，否則為 NULL 的物件。

### <a name="remarks"></a>備註

這是進階的函式。 例如，此成員函式可能不會傳回 [檢視] 視窗，當列印或預覽列印中。 它一律會傳回與 output 相關聯的視窗。 使用指定的 DC 的輸出函式會繪製到這個視窗。

##  <a name="getwindowext"></a>  CDC::GetWindowExt

擷取 x-和 y-範圍相關聯的裝置內容的視窗。

```
CSize GetWindowExt() const;
```

### <a name="return-value"></a>傳回值

X-和 y 的範圍 （以邏輯單位表示） 做為`CSize`物件。

##  <a name="getwindoworg"></a>  CDC::GetWindowOrg

擷取視窗的裝置內容相關聯的原始 x 和 y 座標。

```
CPoint GetWindowOrg() const;
```

### <a name="return-value"></a>傳回值

間隔 （以邏輯座標中） 做為原點`CPoint`物件。

##  <a name="getworldtransform"></a>  CDC::GetWorldTransform

擷取目前世界空間頁面空間轉換。

```
BOOL GetWorldTransform(XFORM& rXform) const;
```

### <a name="parameters"></a>參數

*rXform*<br/>
若要參考[XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)接收目前世界空間頁面空間轉換的結構。

### <a name="return-value"></a>傳回值

成功時傳回非零值。

在失敗時傳回 0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函式[GetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-getworldtransform)。

##  <a name="gradientfill"></a>  CDC::GradientFill

呼叫此成員函式可從一端到另順暢會淡的色彩填滿矩形和三角形的結構。

```
BOOL GradientFill(
    TRIVERTEX* pVertices,
    ULONG nVertices,
    void* pMesh,
    ULONG nMeshElements,
    DWORD dwMode);
```

### <a name="parameters"></a>參數

*pVertices*<br/>
陣列的指標[TRIVERTEX](/windows/desktop/api/wingdi/ns-wingdi-_trivertex)結構，每個定義三角形頂點。

*nVertices*<br/>
頂點數目。

*pMesh*<br/>
陣列[GRADIENT_TRIANGLE](/windows/desktop/api/wingdi/ns-wingdi-_gradient_triangle)三角形 模式中或陣列中的結構[GRADIENT_RECT](/windows/desktop/api/wingdi/ns-wingdi-_gradient_rect)以矩形模式的結構。

*nMeshElements*<br/>
中的項目 （「 三角形 」 或 「 矩形 」） 的數目*pMesh*。

*dwMode*<br/>
指定漸層填滿模式。 如需可能值的清單，請參閱 < [GradientFill](/windows/desktop/api/wingdi/nf-wingdi-gradientfill) Windows SDK 中。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱`GradientFill`Windows SDK 中。

##  <a name="graystring"></a>  CDC::GrayString

繪製將文字寫入記憶體點陣圖中、 變暗的點陣圖，然後再將點陣圖複製到顯示灰色 （灰色） 在指定位置的文字。

```
virtual BOOL GrayString(
    CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),
    LPARAM lpData,
    int nCount,
    int x,
    int y,
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*pBrush*<br/>
識別要用於變暗 （讓） 筆刷。

*lpfnOutput*<br/>
指定將會繪製字串的應用程式所提供的回呼函式的程序執行個體位址。 如需詳細資訊，請參閱 Windows popis `OutputFunc` [回呼函式](callback-functions-used-by-mfc.md#graystring)。 如果此參數為 NULL，系統會使用 Windows`TextOut`函式，來繪製字串，並*lpData*假設為要輸出的字元字串的長指標。

*lpData*<br/>
指定要傳遞至輸出函式的資料的遠端指標。 如果*lpfnOutput*為 NULL，就*lpData*必須要輸出字串的長指標。

*nCount*<br/>
指定要輸出的字元數。 如果這個參數是 0，`GrayString`計算字串的長度 (假設*lpData*是字串的指標)。 如果*nCount*為-1 和所指向之函式*lpfnOutput*傳回 0 時，映像時顯示，但是未呈現灰色。

*x*<br/>
指定矩形包圍字串的開始位置的邏輯 x 座標。

*y*<br/>
指定矩形包圍字串的開始位置的邏輯 y 座標。

*nWidth*<br/>
指定含括字串之矩形的寬度 （以邏輯單位表示）。 如果*nWidth*為 0，`GrayString`計算區域中，寬度假設*lpData*是字串的指標。

*nHeight*<br/>
指定含括字串之矩形的高度 （以邏輯單位表示）。 如果*nHeight*為 0，`GrayString`計算區域的高度假設*lpData*是字串的指標。

### <a name="return-value"></a>傳回值

非零值，如果繪製字串時，或 0，如果有任一個`TextOut`函式或應用程式所提供的輸出函式傳回 0，或如果發生記憶體不足，無法建立變暗的記憶體點陣圖。

### <a name="remarks"></a>備註

此函式變暗不論選取的筆刷和背景的文字。 `GrayString`成員函式使用目前選取的字型。 必須選取 MM_TEXT 對應模式，才能使用此函式。

應用程式可以支援全灰色而不需呼叫的裝置上繪製呈現暗灰色 （灰色） 字串`GrayString`成員函式。 系統色彩 COLOR_GRAYTEXT 是用來繪製已停用的文字的灰色實心系統色彩。 應用程式可以呼叫`GetSysColor`Windows 函式來擷取 COLOR_GRAYTEXT 的色彩值。 如果色彩是 0 （黑色） 以外，應用程式可以呼叫`SetTextColor`成員函式來設定文字色彩的色彩值，然後直接繪製字串。 如果已擷取的色彩為黑色，應用程式必須呼叫`GrayString`變暗的方法 （灰色） 文字。

如果*lpfnOutput*是 NULL，GDI 會使用 Windows [TextOut](/windows/desktop/api/wingdi/nf-wingdi-textouta)函式，並*lpData*假設為輸出字元的遠端指標。 如果要輸出的字元不能由處理`TextOut`成員函式 （例如，字串會儲存為點陣圖，） 的應用程式必須提供自己的輸出函式。

也請注意所有的回呼函式必須 Mfc 例外狀況設陷然後再回到 Windows，因為無法跨回呼界限擲回例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。

回呼函式傳遞至`GrayString`必須使用`__stdcall`呼叫慣例，且必須以匯出`__declspec`。

當架構處於預覽模式時，呼叫`GrayString`成員函式會轉譯為`TextOut`呼叫時，並回呼函式未呼叫。

##  <a name="himetrictodp"></a>  CDC::HIMETRICtoDP

當您將 HIMETRIC 大小從 OLE 轉換為像素為單位，請使用此函式。

```
void HIMETRICtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

如果裝置內容物件的對應模式 MM_LOENGLISH、 MM_HIENGLISH、 MM_LOMETRIC 或 MM_HIMETRIC，轉換將根據在實體英吋的像素數目。 如果此對應模式是其中一個其他非限制模式 (例如 MM_TEXT)，轉換將根據邏輯英吋的像素數目。

##  <a name="himetrictolp"></a>  CDC::HIMETRICtoLP

呼叫此函式可將 HIMETRIC 單位轉換成邏輯單元。

```
void HIMETRICtoLP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

當您從 OLE 取得 HIMETRIC 大小，並想要將它們轉換成您的應用程式的自然對應模式，請使用此函式。

轉換被透過前 HIMETRIC 單位轉換為像素為單位，然後再將這些單位轉換成邏輯單元，使用裝置內容的目前對應單位而定。 請注意，裝置的視窗和檢視區的範圍會影響結果。

##  <a name="intersectcliprect"></a>  CDC::IntersectClipRect

建立新的裁剪區域是組成目前的區域和所指定的矩形的交集*x1*， *y1*， *x2*，和*y2*.

```
int IntersectClipRect(
    int x1,
    int y1,
    int x2,
    int y2);

int IntersectClipRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定矩形左上角的邏輯 x 座標。

*y1*<br/>
指定矩形左上角的邏輯 y 座標。

*x2*<br/>
指定矩形右下角的邏輯 x 座標。

*y2*<br/>
指定矩形右下角的邏輯 y 座標。

*lpRect*<br/>
指定的矩形。 您可以傳遞`CRect`物件的指標或`RECT`結構為此參數。

### <a name="return-value"></a>傳回值

新的裁剪區域的類型。 它可以是下列值之一：

- COMPLEXREGION 新裁剪區域會有重疊的框線。

- 錯誤的裝置內容不是有效的。

- NULLREGION 新裁剪區域是空的。

- SIMPLEREGION 新裁剪區域沒有任何重疊的框線。

### <a name="remarks"></a>備註

GDI 裁剪以符合新的界限內所有後續的輸出。 寬度和高度不得超過 32,767。

##  <a name="invertrect"></a>  CDC::InvertRect

反轉指定矩形的內容。

```
void InvertRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向`RECT`，其中包含要反轉的矩形的邏輯座標。 您也可以傳遞`CRect`此參數的物件。

### <a name="remarks"></a>備註

反轉是邏輯作業，並是每個像素的位元翻轉。 在單色顯示器，此函式會白色像素黑色及黑色像素白色。 反轉色彩顯示，取決於色彩顯示的產生方式。 呼叫`InvertRect`兩次使用相同的矩形會顯示還原至其先前的色彩。

如果矩形是空的不會繪製它。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#36](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]

##  <a name="invertrgn"></a>  CDC::InvertRgn

反轉所指定的區域中的色彩*pRgn*。

```
BOOL InvertRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別要反轉的地區。 以邏輯單位表示指定之區域的座標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

在單色顯示器，此函式會白色像素黑色及黑色像素白色。 反轉色彩顯示，取決於如何顯示產生的色彩。

##  <a name="isprinting"></a>  CDC::IsPrinting

判斷是否正在使用的裝置內容進行列印。

```
BOOL IsPrinting() const;
```

### <a name="return-value"></a>傳回值

非零`CDC`物件是印表機 DC; 否則為 0。

##  <a name="lineto"></a>  CDC::LineTo

從目前的位置，但不是包括，所指定的點繪製一條線*x*並*y* (或*點*)。

```
BOOL LineTo(
    int x,
    int y);

BOOL LineTo(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定線條的端點的邏輯 x 座標。

*y*<br/>
指定線條的端點的邏輯 y 座標。

*point*<br/>
指定線條的端點。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

非零值，如果繪製線條;否則為 0。

### <a name="remarks"></a>備註

使用所選的畫筆繪製線條。 目前的位置會設定為*x*， *y*上，或者*點*。

### <a name="example"></a>範例

  範例，請參閱[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。

##  <a name="lptodp"></a>  CDC::LPtoDP

將邏輯單元轉換成裝置單位。

```
void LPtoDP(
    LPPOINT lpPoints,
    int nCount = 1) const;

void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列的點。 陣列中的每個點都[點](/windows/desktop/api/windef/ns-windef-tagpoint)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

*nCount*<br/>
陣列中的點數目。

*lpRect*<br/>
指向[RECT](/windows/desktop/api/windef/ns-windef-tagrect)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 這個參數會用於對應裝置單位從邏輯的矩形的常見案例。

*lpSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

### <a name="remarks"></a>備註

函式會在每個點的座標或維度的大小，從裝置座標系統的 GDI 邏輯座標系統的對應。 轉換取決於目前的對應模式和來源的設定和裝置的視窗和檢視區的範圍。

X 和 y 座標的點是在-32,768 到 32,767 範圍內的 2 位元組帶正負號的整數。 在其中的對應模式會導致值大於這些限制的情況下，系統會將值-32,768 到 32,767，分別。

##  <a name="lptohimetric"></a>  CDC::LPtoHIMETRIC

呼叫此函式來轉換 HIMETRIC 單位中的邏輯單元。

```
void LPtoHIMETRIC(LPSIZE lpSize) const;
```

### <a name="parameters"></a>參數

*lpSize*<br/>
指向`SIZE`結構或`CSize`物件。

### <a name="remarks"></a>備註

當您為 HIMETRIC 大小至 OLE，從您的應用程式的自然對應模式轉換，請使用此函式。 請注意，裝置的視窗和檢視區的範圍會影響結果。

轉換是藉由第一個轉換的邏輯單位為像素為單位使用的裝置內容的目前對應單位，並再將這些單位轉換成 himetric 為單位來完成。

##  <a name="m_hattribdc"></a>  CDC::m_hAttribDC

這個屬性的裝置內容`CDC`物件。

```
HDC m_hAttribDC;
```

### <a name="remarks"></a>備註

根據預設，這個裝置內容是否等於`m_hDC`。 一般情況下， `CDC` GDI 呼叫，要求資訊從裝置內容會被導向至`m_hAttribDC`。 請參閱[CDC](../../mfc/reference/cdc-class.md)類別如需使用詳細資訊的這兩個裝置內容的描述。

##  <a name="m_hdc"></a>  CDC::m_hDC

此輸出裝置內容`CDC`物件。

```
HDC m_hDC;
```

### <a name="remarks"></a>備註

根據預設，`m_hDC`等於`m_hAttribDC`，其他所包裝的裝置內容`CDC`。 一般情況下， `CDC` GDI 呼叫建立輸出，請移至`m_hDC`裝置內容。 您可以初始化`m_hDC`和`m_hAttribDC`指向不同的裝置。 請參閱[CDC](../../mfc/reference/cdc-class.md)類別如需使用詳細資訊的這兩個裝置內容的描述。

##  <a name="maskblt"></a>  CDC::MaskBlt

結合使用給定的遮罩和點陣作業的來源和目的地點陣圖的色彩資料。

```
BOOL MaskBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    CBitmap& maskBitmap,
    int xMask,
    int yMask,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定目的地矩形左上角的邏輯 x 座標。

*y*<br/>
指定目的地矩形左上角的邏輯 y 座標。

*nWidth*<br/>
指定寬度，以邏輯單位，目的地的 rectangle 和來源點陣圖。

*nHeight*<br/>
指定高度，以邏輯單位，目的地的 rectangle 和來源點陣圖。

*pSrcDC*<br/>
識別裝置內容的複製來源點陣圖。 它必須是零，如果*dwRop*參數會指定不包含來源的點陣作業。

*xSrc*<br/>
指定邏輯來源點陣圖左上角的 x 座標。

*ySrc*<br/>
指定邏輯來源點陣圖左上角的 y 座標。

*maskBitmap*<br/>
識別色彩點陣圖來源裝置內容中與結合單色遮罩點陣圖。

*xMask*<br/>
指定所指定的遮罩點陣圖的像素水平位移*maskBitmap*參數。

*yMask*<br/>
指定所指定的遮罩點陣圖的像素垂直位移*maskBitmap*參數。

*dwRop*<br/>
指定前景和背景三元點陣作業程式碼，此函式用來控制來源和目的地資料的組合。 背景的點陣作業程式碼會儲存在這個值; 高字其高位元前景點陣作業程式碼會儲存在此值的高位文字的低位元組低位文字的這個值會被忽略，而且必須為零。 巨集 MAKEROP4 建立這類的組合，前景和背景的點陣作業程式碼。 請參閱 < 備註 > 一節討論的前景和背景，此函式的內容中。 請參閱`BitBlt`成員函式，如需常見的點陣作業程式碼的清單。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

值為 1 中所指定的遮罩*maskBitmap*所指定前景點陣作業程式碼會指示*dwRop*應該套用在該位置。 遮罩中的 0 值表示所指定背景的點陣作業程式碼*dwRop*應該套用在該位置。 點陣作業需要來源，如果遮罩矩形必須涵蓋來源矩形。 如果不存在，此函式會失敗。 點陣作業不需要為來源，如果遮罩矩形必須涵蓋滿目的矩形。 如果不存在，此函式會失敗。

如果旋轉或上下的傾斜轉換是作用中的來源裝置內容中，呼叫此函式時，就會發生錯誤。 不過，允許其他類型的轉換。

如果來源、 模式和目的地點陣圖的色彩格式不同，則此函式會轉換模式或來源格式，或兩者，以符合目的格式。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 當記錄加強型中繼檔時，發生錯誤 （而此函數會傳回 0） 如果來源裝置內容，找出 「 增強型中繼檔裝置內容。 並非所有裝置都支援`MaskBlt`。 應用程式應該呼叫`GetDeviceCaps`來判斷裝置是否支援此函式。 如果未不提供任何遮罩點陣圖，則此函式的行為完全相同`BitBlt`，使用前景點陣作業程式碼。 來源裝置內容的點陣圖中的遮罩點陣圖對應至點 (0，0) 中位移的像素。 這是包含一組的遮罩; 之遮罩點陣圖的情況下很有用應用程式可以輕易地將其中任何一個遮罩單色工作藉由調整的像素的位移和矩形大小傳送至`MaskBlt`。

##  <a name="modifyworldtransform"></a>  CDC::ModifyWorldTransform

變更裝置內容中使用指定的模式自然轉換。

```
BOOL ModifyWorldTransform(
    const XFORM& rXform,
    DWORD iMode);
```

### <a name="parameters"></a>參數

*rXform*<br/>
若要參考[XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)結構，用來修改全局轉換指定的裝置內容。

*iMode*<br/>
指定轉換的資料修改目前的自然變換的方式。 如需這個參數可以接受的值，請參閱[ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform)。

### <a name="return-value"></a>傳回值

成功時傳回非零值。

在失敗時傳回 0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函式[ModifyWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-modifyworldtransform)。

##  <a name="moveto"></a>  CDC::MoveTo

目前的位置移至指定的點*x*並*y* (或由*點*)。

```
CPoint MoveTo(
    int x,
    int y);

CPoint MoveTo(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定新位置的邏輯 x 座標。

*y*<br/>
指定新位置的邏輯 y 座標。

*point*<br/>
指定新的位置。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

先前的位置，以 x 和 y 座標`CPoint`物件。

### <a name="example"></a>範例

  範例，請參閱[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。

##  <a name="offsetcliprgn"></a>  CDC::OffsetClipRgn

指定的位移所移動的裝置內容的裁剪區域。

```
int OffsetClipRgn(
    int x,
    int y);

int OffsetClipRgn(SIZE size);
```

### <a name="parameters"></a>參數

*x*<br/>
指定要向左移動或向右的邏輯單元數目。

*y*<br/>
指定要上移或下移的邏輯單位數目。

*size*<br/>
指定的位移數量。

### <a name="return-value"></a>傳回值

新的區域類型。 它可以是下列值之一：

- COMPLEXREGION 裁剪區域會有重疊的框線。

- 錯誤的裝置內容不是有效的。

- NULLREGION 裁剪區域是空的。

- SIMPLEREGION 裁剪區域沒有任何重疊的框線。

### <a name="remarks"></a>備註

函式會移動的區域*x*沿著 x 軸單位並*y*沿著 y 軸的單位。

##  <a name="offsetviewportorg"></a>  CDC::OffsetViewportOrg

修改檢視區的原點，相對於目前的檢視區原點座標的座標。

```
virtual CPoint OffsetViewportOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定裝置將新增至目前的原始 x 軸的單位的數。

*nHeight*<br/>
指定將新增至目前的原始 y 座標的裝置單位數目。

### <a name="return-value"></a>傳回值

上一個檢視區的原點 （以裝置座標表示） 做為`CPoint`物件。

##  <a name="offsetwindoworg"></a>  CDC::OffsetWindowOrg

修改視窗原點，相對於目前視窗原點座標的座標。

```
CPoint OffsetWindowOrg(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定將新增至目前的原始 x 座標的邏輯單元數目。

*nHeight*<br/>
指定將新增至目前的原始 y 座標的邏輯單元數目。

### <a name="return-value"></a>傳回值

前一個視窗來源 （在邏輯座標中） 與`CPoint`物件。

##  <a name="operator_hdc"></a>  CDC::operator HDC

若要擷取的裝置內容控制代碼使用這個運算子`CDC`物件。

```
operator HDC() const;
```

### <a name="return-value"></a>傳回值

如果成功，裝置內容物件的控制代碼否則為 NULL。

### <a name="remarks"></a>備註

您可以使用控制代碼來直接呼叫 Windows Api。

##  <a name="paintrgn"></a>  CDC::PaintRgn

所指定的區域會填滿*pRgn*使用目前的筆刷。

```
BOOL PaintRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別要填滿的區域。 指定區域的座標會指定以邏輯單位表示。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

##  <a name="patblt"></a>  CDC::PatBlt

在裝置上建立一個位元模式。

```
BOOL PatBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定要接收模式的矩形的左上角的邏輯 x 座標。

*y*<br/>
指定要接收模式的矩形的左上角的邏輯 y 座標。

*nWidth*<br/>
指定要接收模式的矩形的寬度 （以邏輯單位表示）。

*nHeight*<br/>
指定要接收模式的矩形的高度 （以邏輯單位表示）。

*dwRop*<br/>
指定的點陣作業程式碼。 點陣作業程式碼 (ROPs) 會定義如何 GDI 中結合色彩的輸出作業牽涉到目前的筆刷、 可能的來源點陣圖和目的地點陣圖。 這個參數可以是下列值之一：

- PATCOPY 複製到目的地點陣圖的模式。

- PATINVERT 合併目的地點陣圖與模式使用布林值 XOR 運算子。

- DSTINVERT 反轉目的地點陣圖。

- 將所有輸出黑色 BLACKNESS 變成。

- 將所有輸出白色 WHITENESS 變成。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

模式是選取的筆刷和已在裝置上的模式的組合。 所指定的點陣作業程式碼*dwRop*定義模式的合併的方式。 列出此函式的點陣作業是完整 256 的三元的點陣作業程式碼的有限的子集特別的是，您無法使用點陣作業程式碼，指的來源。

並非所有的裝置內容支援`PatBlt`函式。 若要判斷裝置的內容是否支援`PatBlt`，呼叫`GetDeviceCaps`成員函式具有 RASTERCAPS 索引，並檢查傳回的值，RC_BITBLT 旗標。

##  <a name="pie"></a>  CDC::Pie

藉由繪製橢圓形弧線的置中與兩個端點進行聯結線條繪製派形的楔形。

```
BOOL Pie(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4);

BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定的週框 （以邏輯單位表示） 的左上角的 x 座標。

*y1*<br/>
指定的週框 （以邏輯單位表示） 的左上角的 y 座標。

*x2*<br/>
指定的週框 （以邏輯單位表示） 的右下角的 x 座標。

*y2*<br/>
指定的週框 （以邏輯單位表示） 的右下角的 y 座標。

*x3*<br/>
指定弧線的起點 （以邏輯單位表示） 的 x 座標。 此點沒有落在弧線。

*y3*<br/>
指定弧線的起點 （以邏輯單位表示） 的 y 座標。 此點沒有落在弧線。

*x4*<br/>
指定弧線的端點 （以邏輯單位表示） 的 x 座標。 此點沒有落在弧線。

*y4*<br/>
指定弧線的端點 （以邏輯單位表示） 的 y 座標。 此點沒有落在弧線。

*lpRect*<br/>
指定週框矩形。 您可以傳遞`CRect`物件的指標或`RECT`結構為此參數。

*ptStart*<br/>
指定弧線的起點。此點沒有落在弧線。您可以傳遞[點](/windows/desktop/api/windef/ns-windef-tagpoint)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)此參數的物件。

*ptEnd*<br/>
指定弧線的端點。此點沒有落在弧線。您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

弧線的中心是所指定的週框矩形的中央*x1*， *y1*， *x2*，以及*y2* (或由*lpRect*). 所指定的開始和結束點弧線*x3*， *y3*， *x4*，以及*y4* (或*ptStart*並*ptEnd*)。

使用選取的畫筆，移動以逆時鐘方向繪製弧形。 兩個額外的線條會繪製弧線的中心從每個端點。 目前的筆刷填滿派形的區域。 如果*x3* equals *x4*並*y3*等於*y4*，結果是透過一行從橢圓形的中心點 (橢圓形*x3*， *y3*) 或 ( *x4*， *y4*)。

此函式所繪製的圖最多擴充，但不包含右側和底端座標。 這表示圖表的高度*y2* - *y1*圖的寬度，而且*x2* - *x1*。 週框矩形的高度和寬度必須大於 2 個單位，且小於 32,767 個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#37](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]

##  <a name="playmetafile"></a>  CDC::PlayMetaFile

在裝置內容上扮演指定的中繼檔的內容。

```
BOOL PlayMetaFile(HMETAFILE hMF);

BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,
    LPCRECT lpBounds);
```

### <a name="parameters"></a>參數

*hMF*<br/>
識別要播放之中繼檔。

*hEnhMetaFile*<br/>
識別加強型中繼檔。

*lpBounds*<br/>
指向`RECT`結構或`CRect`物件，其中包含用來顯示該圖片的周框的座標。 座標的指定以邏輯單位表示。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

中繼檔可以播放次數。

第二版`PlayMetaFile`會顯示指定的格式增強型中繼檔中儲存的圖片。 當應用程式會呼叫第二版`PlayMetaFile`，Windows 加強型中繼檔標頭中使用圖片框來對應至矩形所指的圖片*lpBounds*參數。 (此圖片中可能會修剪或旋轉輸出裝置，然後再呼叫中設定全局轉換`PlayMetaFile`。)邊緣的矩形中的點包含在圖片中。 在輸出裝置中定義之裁剪區域，播放加強型中繼檔之前，也可裁剪加強型中繼檔圖片。

應用程式如果加強型中繼檔中包含選擇性的調色盤，可以設定輸出裝置上的色板，然後再呼叫第二個版本來達到一致的色彩`PlayMetaFile`。 若要擷取的選擇性的調色盤，請使用`GetEnhMetaFilePaletteEntries`Windows 函式。 加強型中繼檔可以內嵌在新建立的增強型中繼檔，藉由呼叫第二版`PlayMetaFile`和播放放入裝置內容的來源增強型中繼檔，新的增強型中繼檔。

此函式會保留輸出裝置內容的狀態。 此函式會刪除任何建立，但不是會刪除在加強型中繼檔中的物件。 若要停止此函式，應用程式可以呼叫`CancelDC`Windows 函式，從另一個執行緒終止作業。 在此情況下，函式會傳回零。

##  <a name="plgblt"></a>  CDC::PlgBlt

執行從來源裝置內容中指定之矩形的色彩資料位元的位元區塊傳輸，以指定的裝置內容中指定的平行四邊形。

```
BOOL PlgBlt(
    LPPOINT lpPoint,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nWidth,
    int nHeight,
    CBitmap& maskBitmap,
    int xMask,
    int yMask);
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向陣列識別目的地平行四邊形的三個角落的邏輯空間中的三個點。 來源矩形左上角會對應至這個陣列、 右上角，在此陣列中，第二點和第三個點的左下角的第一個點。 來源矩形的右下角會對應至隱含的平行四邊形中第四個點。

*pSrcDC*<br/>
識別來源裝置內容。

*xSrc*<br/>
指定的 x 座標，以邏輯單位，來源矩形左上角。

*ySrc*<br/>
指定 y 軸座標，以邏輯單位，來源矩形左上角。

*nWidth*<br/>
指定寬度，以邏輯單位，來源矩形。

*nHeight*<br/>
指定高度，以邏輯單位，來源矩形。

*maskBitmap*<br/>
識別選擇性的單色點陣圖，用來遮罩來源矩形的色彩。

*xMask*<br/>
指定的單色點陣圖左上角的 x 座標。

*yMask*<br/>
指定的單色點陣圖左上角的 y 座標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果指定的位元遮罩的控制代碼識別有效的單色點陣圖，此函數會使用此點陣圖遮罩從來源矩形的色彩資料位元。

第四個頂點的平行四邊形 (D) 的定義，將前三個點 （A、 B 和 C） 做為向量和運算 D = B + C-a。

如果存在位元遮罩，遮罩中的 1 的值會指出來源像素色彩都應該複製到目的地。 遮罩中的 0 值會指出，目的地像素色彩就不會變更。

如果遮罩矩形小於來源和目的地矩形，則函式會複製遮罩模式。

在 來源裝置內容中，允許調整、 轉譯和反映的轉換不過，旋轉及傾斜轉換不。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 目的地裝置內容的縮放模式用來判斷如何縮放或壓縮的像素為單位，這是必要。 當記錄加強型中繼檔時，如果來源裝置內容識別加強型中繼檔裝置內容，就會發生錯誤。

目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。 如果來源轉換具有循環或是傾斜時，會傳回錯誤。 如果目的地和來源矩形沒有相同的色彩格式，`PlgBlt`將轉換的來源矩形，以符合目的地矩形。 並非所有裝置都支援`PlgBlt`。 如需詳細資訊，請參閱中的 RC_BITBLT 點陣功能的描述`CDC::GetDeviceCaps`成員函式。

如果來源和目的地裝置內容代表不相容的裝置，`PlgBlt`會傳回錯誤。

##  <a name="polybezier"></a>  CDC::PolyBezier

繪製一個或多個 Bzier 曲線。

```
BOOL PolyBezier(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列[點](/windows/desktop/api/windef/ns-windef-tagpoint)資料結構，包含端點及控制 spline(s) 的點。

*nCount*<br/>
指定的資料點數目*lpPoints*陣列。 此值必須是其中一個要繪製曲線的數目超過三次，因為每個 Bzier 曲線需要兩個控制點和結束點，以及初始的曲線，所以需要額外的起始點。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式所使用的端點和所指定的控制點繪製三次方 Bzier 曲線*lpPoints*參數。 第一次的曲線會使用第二個和第三個點做為控制點，從第一個點繪製到第四個點。 每個後續的曲線順序必須剛好三個重點： 先前曲線結束點做為起點、 序列中的下面兩個點控點，以及第三個是結束點。

目前的位置不會使用或更新`PolyBezier`函式。 此圖不會填滿。 此函式使用目前畫筆繪製線條。

##  <a name="polybezierto"></a>  CDC::PolyBezierTo

繪製一個或多個 Bzier 曲線。

```
BOOL PolyBezierTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列[點](/windows/desktop/api/windef/ns-windef-tagpoint)包含端點和控制項的資料結構的點。

*nCount*<br/>
指定的資料點數目*lpPoints*陣列。 此值必須是三次要繪製曲線的數目，因為每個 Bzier 曲線需要兩個控制點和結束點。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式使用指定的控制點繪製三次方 Bzier 曲線*lpPoints*參數。 第一個的曲線會藉由使用前兩個點做為控制點，從目前的位置繪製到第三個點。 針對每個後續的曲線，函式需要剛好三個點，並做為起點的上一個曲線結束點用於下一步。 `PolyBezierTo` 目前位置移到最後一個 Bzier 曲線結束點。 此圖不會填滿。 此函式使用目前畫筆繪製線條。

### <a name="example"></a>範例

  範例，請參閱[cdc:: beginpath](#beginpath)。

##  <a name="polydraw"></a>  CDC::PolyDraw

繪製一組直線線段和 Bzier 曲線。

```
BOOL PolyDraw(
    const POINT* lpPoints,
    const BYTE* lpTypes,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列[點](/windows/desktop/api/windef/ns-windef-tagpoint)包含每個端點的資料結構行區段和端點，並控制每個 Bzier 曲線的點。

*lpTypes*<br/>
陣列，指定每個中的點會指向*lpPoints*陣列用。 值可以是下列其中一項：

- PT_MOVETO 指定這個點開始脫離的圖形。 這個點會成為新的目前位置。

- PT_LINETO 指定所要從目前位置到目前為止，就會變成新的目前位置繪製一條線。

- PT_BEZIERTO 指定此點是一個控制點或 Bzier 曲線的結束點。

PT_BEZIERTO 類型一定要進行中的三個集合。 目前的位置定義 Bzier 曲線的起始點。 前兩個 PT_BEZIERTO 點是控制點，而第三個 PT_BEZIERTO 點則是結束點。 結束點會成為新的目前位置。 如果有不連續 PT_BEZIERTO 三點，會發生錯誤。

   PT_LINETO 或 PT_BEZIERTO 類型可以結合下列常數所使用的位元運算子，或已關閉，表示對應的點圖及圖中的最後一點：

- PT_CLOSEFIGURE 指定圖會自動關閉之後 PT_LINETO 或 PT_BEZIERTO 型別，這個點會完成。 從這裡開始到最新的 PT_MOVETO 繪製線條或`MoveTo`點。

   與線條，PT_LINETO 類型或 PT_BEZIERTO 類型使用的位元結束 Bzier 曲線的點，這個旗標會結合**OR**運算子。 目前的位置設定為結束點的結尾行。

*nCount*<br/>
指定的資料點總數*lpPoints*陣列中的位元組數目相同*lpTypes*陣列。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式可以用來繪製不相鄰的數字取代連續呼叫`CDC::MoveTo`， `CDC::LineTo`，和`CDC::PolyBezierTo`成員函式。 線條和曲線會使用目前的畫筆繪製和數字不會填滿。 如果沒有使用的路徑啟動藉由呼叫`CDC::BeginPath`成員函式，`PolyDraw`將加入路徑。 中所包含的點*lpPoints*陣列並在*lpTypes*指出每個點是否屬於`CDC::MoveTo`，則`CDC::LineTo`，或`CDC::BezierTo`作業。 它也可關閉數字。 此函式會更新目前的位置。

### <a name="example"></a>範例

  範例，請參閱[cdc:: beginpath](#beginpath)。

##  <a name="polygon"></a>  CDC::Polygon

繪製多邊形，其中包含兩個或多個 （頂點） 以折線連接點，使用目前的畫筆。

```
BOOL Polygon(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列的指定多邊形的頂點的點。 陣列中的每個點都`POINT`結構或`CPoint`物件。

*nCount*<br/>
陣列中指定頂點的數目。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

系統多邊形會自動關閉，如有必要，所繪製一條線從上次的頂點，第一個。

可擷取或設定使用目前的多邊形填滿模式`GetPolyFillMode`和`SetPolyFillMode`成員函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#38](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]

##  <a name="polyline"></a>  CDC::Polyline

繪製連接所指定的點之線段的一組*lpPoints*。

```
BOOL Polyline(
    LPPOINT lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列`POINT`結構或`CPoint`連接物件。

*nCount*<br/>
陣列中指定點的數目。 此值必須至少為 2。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

線條會繪製從透過使用目前的畫筆的後續點的第一個點。 不同於`LineTo`成員函式，`Polyline`函式不會使用，也不會更新目前的位置。

如需詳細資訊，請參閱 <<c0> [ 聚合線條](/windows/desktop/api/wingdi/nf-wingdi-polyline)Windows SDK 中。

##  <a name="polylineto"></a>  CDC::PolylineTo

繪製一個或多個直線，線條。

```
BOOL PolylineTo(
    const POINT* lpPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列[點](/windows/desktop/api/windef/ns-windef-tagpoint)包含線條的頂點的資料結構。

*nCount*<br/>
陣列中指定點的數目。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

從目前的位置所指定的第一個點繪製線條*lpPoints*參數使用目前的畫筆。 對於每個其他的列，函式用來繪製從結束點上一行的下一步 指定的點*lpPoints*。 `PolylineTo` 目前位置移到最後一行的結束點。 如果此函式所繪製之直線線段形成封閉的圖表，此圖不會填滿。

##  <a name="polypolygon"></a>  CDC::PolyPolygon

建立兩個或多個多邊形的填滿使用目前的多邊形填滿模式。

```
BOOL PolyPolygon(
    LPPOINT lpPoints,
    LPINT lpPolyCounts,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列`POINT`結構或`CPoint`定義的多邊形頂點的物件。

*lpPolyCounts*<br/>
指向陣列的整數，其中每個指定的點數目中其中一個內之多邊形*lpPoints*陣列。

*nCount*<br/>
中的項目數*lpPolyCounts*陣列。 此數字會指定要繪製多邊形的數目。 此值必須至少為 2。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

脫離或重疊，則可能是多邊形。

每個呼叫中指定的多邊形`PolyPolygon`函式必須先關閉。 不同於所建立的多邊形`Polygon`成員函式，所建立之多邊形`PolyPolygon`不會自動關閉。

函式會建立兩個或多個多邊形。 若要建立單一的多邊形，應用程式應該使用`Polygon`成員函式。

可擷取或設定使用目前的多邊形填滿模式`GetPolyFillMode`和`SetPolyFillMode`成員函式。

##  <a name="polypolyline"></a>  CDC::PolyPolyline

繪製連接的直線線段的多個數列。

```
BOOL PolyPolyline(
    const POINT* lpPoints,
    const DWORD* lpPolyPoints,
    int nCount);
```

### <a name="parameters"></a>參數

*lpPoints*<br/>
指向陣列的結構，其中包含聚合線條的頂點。 連續指定多線條。

*lpPolyPoints*<br/>
指向陣列的變數指定的資料點數目*lpPoints*陣列中對應的多邊形。 每個項目必須是大於或等於 2。

*nCount*<br/>
指定的計數中總數*lpPolyPoints*陣列。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

使用目前畫筆繪製之直線線段。 未填入區段所形成的數字。 目前的位置不會使用或更新此函式。

##  <a name="ptvisible"></a>  CDC::PtVisible

判斷指定的點是否在裝置內容的裁剪區域。

```
virtual BOOL PtVisible(
    int x,
    int y) const;

BOOL PtVisible(POINT point) const;
```

### <a name="parameters"></a>參數

*x*<br/>
指定點的邏輯 x 座標。

*y*<br/>
指定點的邏輯 y 座標。

*point*<br/>
指定要檢查的邏輯座標的點。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

如果指定的點內的裁剪區域中，為非零否則為 0。

##  <a name="queryabort"></a>  CDC::QueryAbort

所安裝的中止函式會呼叫[SetAbortProc](#setabortproc)是否應該終止列印成員函式列印應用程式和查詢。

```
BOOL QueryAbort() const;
```

### <a name="return-value"></a>傳回值

如果應該繼續列印或沒有中止程序，傳回的值為非零值。 如果應終止列印工作，它就會是 0。 Abort 函式會提供傳回值。

##  <a name="realizepalette"></a>  CDC::RealizePalette

將對應從目前的邏輯色板到系統調色盤項目。

```
UINT RealizePalette();
```

### <a name="return-value"></a>傳回值

指出邏輯調色盤中的項目數量已對應至不同系統調色盤中的項目。 這表示此函式重新對應至配合系統調色盤中的變更，因為邏輯調色盤上一次已發現的項目數。

### <a name="remarks"></a>備註

邏輯的調色盤做為緩衝區大量色彩的應用程式與系統，可讓應用程式使用所需而不會干擾它自己的色彩量少於顯示色彩之間或與其他視窗所顯示的色彩。

當視窗具有輸入的焦點和呼叫`RealizePalette`，Windows 可確保視窗會顯示所有要求的色彩，同時提供在螢幕上的數目上限。 Windows 也會顯示找不到該視窗的調色盤中它們符合可用色彩的色彩。

此外，Windows 會符合可用的色彩來儘可能密集地呼叫函式的非使用中視窗所要求的色彩。 這會大幅降低非預期的變更，在非使用中視窗中顯示的色彩。

##  <a name="rectangle"></a>  CDC::Rectangle

繪製矩形，使用目前的畫筆。

```
BOOL Rectangle(
    int x1,
    int y1,
    int x2,
    int y2);

BOOL Rectangle(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定 （以邏輯單位表示） 的矩形左上角的 x 座標。

*y1*<br/>
指定 （以邏輯單位表示） 的矩形左上角的 y 座標。

*x2*<br/>
指定 （以邏輯單位表示） 的矩形右下角的 x 座標。

*y2*<br/>
指定 （以邏輯單位表示） 的矩形右下角的 y 座標。

*lpRect*<br/>
以邏輯單位表示指定的矩形。 您可以傳遞`CRect`物件的指標或`RECT`結構為此參數。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

矩形內部，會使用目前的筆刷填滿的。

矩形會擴充最多至但不包含，右側和底端座標。 這表示矩形的高度*y2* - *y1*矩形的寬度，而且*x2* - *x1*. 矩形的高度和寬度必須大於 2 個單位，且小於 32,767 個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#39](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]

##  <a name="rectvisible"></a>  CDC::RectVisible

決定是否在指定的任何的矩形部分蘊含的顯示內容的裁剪區域。

```
virtual BOOL RectVisible(LPCRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向`RECT`結構或`CRect`物件，其中包含指定之矩形的邏輯座標。

### <a name="return-value"></a>傳回值

指定之矩形的非零值，如果有任何部分位於的裁剪區域;否則為 0。

##  <a name="releaseattribdc"></a>  CDC::ReleaseAttribDC

呼叫此成員函式設定`m_hAttribDC`為 NULL。

```
virtual void ReleaseAttribDC();
```

### <a name="remarks"></a>備註

這不會造成`Detach`發生。 僅輸出裝置內容會附加至`CDC`物件中，並僅可卸離。

##  <a name="releaseoutputdc"></a>  CDC::ReleaseOutputDC

呼叫此成員函式設定`m_hDC`為 NULL 的成員。

```
virtual void ReleaseOutputDC();
```

### <a name="remarks"></a>備註

無法呼叫此成員函式，當輸出裝置內容會附加至`CDC`物件。 使用`Detach`成員函式來卸離輸出裝置內容。

##  <a name="resetdc"></a>  CDC::ResetDC

呼叫此成員函式，以更新由包裝的裝置內容`CDC`物件。

```
BOOL ResetDC(const DEVMODE* lpDevMode);
```

### <a name="parameters"></a>參數

*lpDevMode*<br/>
Windows 的指標`DEVMODE`結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

裝置內容會從指定的 Windows 中的資訊更新`DEVMODE`結構。 此成員函式只會重設之屬性的裝置內容。

應用程式通常會使用`ResetDC`成員函式時的視窗處理`WM_DEVMODECHANGE`訊息。 您也可以使用此成員函式，若要變更紙張方向或紙張的紙匣列印文件時。

若要變更的驅動程式名稱、 裝置名稱，或輸出連接埠，您無法使用此成員函式。 當使用者變更裝置名稱的連接埠的連接時，您必須刪除原始的裝置內容，並使用新的資訊來建立新的裝置內容。

在呼叫此成員函式之前，您必須確定時，已選取 （非內建物件） 已放入裝置內容已選取的所有物件。

##  <a name="restoredc"></a>  CDC::RestoreDC

還原至先前的狀態所識別的裝置內容*nSavedDC*。

```
virtual BOOL RestoreDC(int nSavedDC);
```

### <a name="parameters"></a>參數

*nSavedDC*<br/>
指定要還原的裝置內容。 它可以是先前傳回的值`SaveDC`函式呼叫。 如果*nSavedDC*為-1，最新的儲存裝置內容會還原。

### <a name="return-value"></a>傳回值

非零值，如果還原指定的內容;否則為 0。

### <a name="remarks"></a>備註

`RestoreDC` 還原裝置內容拉出堆疊由先前呼叫的狀態資訊`SaveDC`成員函式。

堆疊可以包含數種裝置內容的狀態資訊。 如果所指定的內容*nSavedDC*不是在堆疊頂端`RestoreDC`刪除所指定的裝置內容之間的所有狀態資訊*nSavedDC*和堆疊的頂端。 已刪除的資訊都會遺失。

##  <a name="roundrect"></a>  CDC::RoundRect

具有圓角，使用目前畫筆繪製矩形。

```
BOOL RoundRect(
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3);

BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```

### <a name="parameters"></a>參數

*x1*<br/>
指定 （以邏輯單位表示） 的矩形左上角的 x 座標。

*y1*<br/>
指定 （以邏輯單位表示） 的矩形左上角的 y 座標。

*x2*<br/>
指定 （以邏輯單位表示） 的矩形右下角的 x 座標。

*y2*<br/>
指定 （以邏輯單位表示） 的矩形右下角的 y 座標。

*x3*<br/>
指定用來繪製圓弧角的半徑 （以邏輯單位表示） 的省略符號的寬度。

*y3*<br/>
指定用來繪製圓弧角的半徑 （以邏輯單位表示） 的省略符號的高度。

*lpRect*<br/>
指定週框矩形以邏輯單位表示。 您可以傳遞`CRect`物件的指標或`RECT`結構為此參數。

*point*<br/>
X 座標*點*指定的寬度 （以邏輯單位表示） 繪製圓的角的省略符號。 Y 座標*點*指定的高度 （以邏輯單位表示） 繪製圓的角的省略符號。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

矩形內部，會使用目前的筆刷填滿的。

此函式所繪製的圖最多擴充，但不包含右側和底端座標。 這表示圖表的高度*y2* - *y1*圖的寬度，而且*x2* - *x1*。 週框矩形的寬度和高度必須大於 2 個單位，且小於 32,767 個單位。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCDocView#40](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]

##  <a name="savedc"></a>  CDC::SaveDC

藉由複製 （例如裁剪區域中，選取的物件和對應模式） 的狀態資訊將由 Windows 所維護的內容堆疊的裝置內容的目前狀態。

```
virtual int SaveDC();
```

### <a name="return-value"></a>傳回值

整數，識別已儲存的裝置內容。 如果發生錯誤，它就會是 0。 這會傳回值可以用來還原裝置內容呼叫`RestoreDC`。

### <a name="remarks"></a>備註

稍後可以使用還原的已儲存的裝置內容`RestoreDC`。

`SaveDC` 可以是用於無數次儲存任意數目的裝置內容的狀態。

##  <a name="scaleviewportext"></a>  CDC::ScaleViewportExt

修改檢視區範圍相對於目前的值。

```
virtual CSize ScaleViewportExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>參數

*xNum*<br/>
指定所要乘以目前的 x 範圍。

*xDenom*<br/>
指定要除以的值相乘 x 目前範圍的量*xNum*參數。

*yNum*<br/>
指定所要乘以 y 目前範圍的量。

*yDenom*<br/>
指定要除以的值相乘 y 目前範圍的量*yNum*參數。

### <a name="return-value"></a>傳回值

上一個檢視區範圍 （以裝置為單位） 為`CSize`物件。

### <a name="remarks"></a>備註

公式會寫入，如下所示：

`xNewVE = ( xOldVE * xNum ) / xDenom`

`yNewVE = ( yOldVE * yNum ) / yDenom`

新的檢視區範圍的計算方式是指定分子中乘以目前的範圍，再除以指定的分母。

##  <a name="scalewindowext"></a>  CDC::ScaleWindowExt

修改視窗範圍相對於目前的值。

```
virtual CSize ScaleWindowExt(
    int xNum,
    int xDenom,
    int yNum,
    int yDenom);
```

### <a name="parameters"></a>參數

*xNum*<br/>
指定所要乘以目前的 x 範圍。

*xDenom*<br/>
指定要除以的值相乘 x 目前範圍的量*xNum*參數。

*yNum*<br/>
指定所要乘以 y 目前範圍的量。

*yDenom*<br/>
指定要除以的值相乘 y 目前範圍的量*yNum*參數。

### <a name="return-value"></a>傳回值

前一個視窗範圍 （以邏輯單位表示） 做為`CSize`物件。

### <a name="remarks"></a>備註

公式會寫入，如下所示：

`xNewWE = ( xOldWE * xNum ) / xDenom`

`yNewWE = ( yOldWE * yNum ) / yDenom`

新的視窗延伸區的計算方式是指定分子中乘以目前的範圍，再除以指定的分母。

##  <a name="scrolldc"></a>  CDC::ScrollDC

水平和垂直，請捲動的位元的矩形。

```
BOOL ScrollDC(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* pRgnUpdate,
    LPRECT lpRectUpdate);
```

### <a name="parameters"></a>參數

*dx*<br/>
指定水平捲軸的單位數目。

*dy*<br/>
指定垂直捲軸的單位數目。

*lpRectScroll*<br/>
指向`RECT`結構或`CRect`物件，其中包含捲動的矩形的座標。

*lpRectClip*<br/>
指向`RECT`結構或`CRect`物件，其中包含的裁剪矩形的座標。 當這個矩形是小於其中一個所指的原始*lpRectScroll*，捲動只會發生較小的矩形。

*pRgnUpdate*<br/>
識別未發現捲動的程序的地區。 `ScrollDC`函式會定義此區域; 它不一定是矩形。

*lpRectUpdate*<br/>
指向`RECT`結構或`CRect`接收捲動的更新區域的界限之矩形的座標的物件。 這是需要重新繪製的最大的矩形區域。 中的結構或物件時此函數會傳回的值是在工作區座標，無論指定的裝置內容的對應模式。

### <a name="return-value"></a>傳回值

非零值，如果執行捲動;否則為 0。

### <a name="remarks"></a>備註

如果*lpRectUpdate*是 NULL 時，Windows 不會計算更新矩形。 如果兩個*pRgnUpdate*並*lpRectUpdate*為 NULL 時，Windows 不會計算更新區域。 如果*pRgnUpdate*不是 NULL，Windows 會假設它包含捲動的處理序未涵蓋範圍地區的有效指標 (定義`ScrollDC`成員函式)。 更新區域中傳回*lpRectUpdate*可以傳遞至`CWnd::InvalidateRgn`如有必要。

應用程式應該使用`ScrollWindow`類別成員函式`CWnd`時需要捲動視窗的整個用戶端區域。 否則，它應該使用`ScrollDC`。

##  <a name="selectclippath"></a>  CDC::SelectClipPath

選取目前的路徑做為裝置內容中，使用指定的模式結合新的區域與任何現有的裁剪區域的裁剪區域。

```
BOOL SelectClipPath(int nMode);
```

### <a name="parameters"></a>參數

*nMode*<br/>
指定使用路徑的方式。 允許下列值：

- RGN_AND 新裁剪區域包含了目前裁剪區域和目前的路徑 （重疊區域） 的交集。

- RGN_COPY 新裁剪區域是目前的路徑。

- RGN_DIFF 新裁剪區域包含了目前裁剪區域的區域，以及那些目前路徑會排除。

- RGN_OR 新裁剪區域包含了目前裁剪區域和目前路徑的聯集 （結合區域）。

- RGN_XOR 新裁剪區域包含了目前裁剪區域和目前的路徑，但不包含重疊的區域的聯集。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

識別的裝置內容必須包含已關閉的路徑。

##  <a name="selectcliprgn"></a>  CDC::SelectClipRgn

選取指定的區域做為目前裁剪區域的 裝置內容。

```
int SelectClipRgn(CRgn* pRgn);

int SelectClipRgn(
    CRgn* pRgn,
    int nMode);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別要選取的區域。

- 此函式，如果這個值是 NULL，在選取整個工作區，而且輸出仍會裁剪至視窗的第一個版本。

- 此函式的第二個版本，此控制代碼只有在指定 RGN_COPY 模式時，才可以是 NULL。

*nMode*<br/>
指定要執行的作業。 它必須是下列值之一：

- RGN_AND 新裁剪區域結合了目前裁剪區域和區域所識別的重疊區域*pRgn*。

- RGN_COPY 新裁剪區域是一份所識別的區域*pRgn*。 這是功能等同於第一版`SelectClipRgn`。 如果所識別的區域*pRgn*是 NULL，新的裁剪區域會變成預設的裁剪區域 （空值區）。

- RGN_DIFF 新裁剪區域結合了目前裁剪區域的區域，包含從所識別的區域中排除這些區域*pRgn*。

- RGN_OR 新裁剪區域結合了目前裁剪區域和所識別的區域*pRgn*。

- RGN_XOR 新裁剪區域結合了目前裁剪區域和所識別的區域*pRgn*但排除任何重疊的區域。

### <a name="return-value"></a>傳回值

此區域的類型。 它可以是下列值之一：

- COMPLEXREGION 新裁剪區域會有重疊的框線。

- 錯誤的裝置內容或地區不正確。

- NULLREGION 新裁剪區域是空的。

- SIMPLEREGION 新裁剪區域沒有任何重疊的框線。

### <a name="remarks"></a>備註

會使用只有所選區域的副本。 可以為任何數目的其他裝置內容中，選取該區域本身或將它刪除。

函式會假設為指定的區域的座標會指定以裝置為單位。 某些印表機裝置支援比圖形輸出，以維持 express 文字度量所需的精確度更高的解析度的文字輸出。 這些裝置報告裝置單位較高的解析度，也就是以文字為單位。 這些裝置，讓數個只有 1 個圖形的單位來報告裝置單位對應，然後調整圖形的座標。 您應該一律呼叫`SelectClipRgn`函式使用文字單元。

GDI 中的圖形物件的縮放比例必須建立應用程式，可用來決定擴充比例 GETSCALINGFACTOR 印表機逸出。 此縮放比例會影響裁剪。 如果區域用來裁剪圖形，GDI 會除以縮放比例的座標。 如果區域用來裁剪文字，GDI 會進行任何調整的調整。 為 1 的縮放比例會導致要除以 2; 座標為 2 的縮放比例會導致要除以 4; 座標等等。

##  <a name="selectobject"></a>  CDC::SelectObject

選取的物件放入裝置內容。

```
CPen* SelectObject(CPen* pPen);
CBrush* SelectObject(CBrush* pBrush);
virtual CFont* SelectObject(CFont* pFont);
CBitmap* SelectObject(CBitmap* pBitmap);
int SelectObject(CRgn* pRgn);
CGdiObject* SelectObject(CGdiObject* pObject);
```

### <a name="parameters"></a>參數

*pPen*<br/>
指標[CPen](../../mfc/reference/cpen-class.md)要選取的物件。

*pBrush*<br/>
指標[CBrush](../../mfc/reference/cbrush-class.md)要選取的物件。

*pFont*<br/>
指標[CFont](../../mfc/reference/cfont-class.md)要選取的物件。

*pBitmap*<br/>
指標[CBitmap](../../mfc/reference/cbitmap-class.md)要選取的物件。

*pRgn*<br/>
指標[CRgn](../../mfc/reference/crgn-class.md)要選取的物件。

*pObject*<br/>
指標[CGdiObject](../../mfc/reference/cgdiobject-class.md)要選取的物件。

### <a name="return-value"></a>傳回值

正要取代之物件指標。 這是其中一個衍生自的類別的物件指標`CGdiObject`，例如`CPen`，取決於所使用的函式的版本。 如果發生錯誤，則傳回的值是 NULL。 此函式可能是暫存物件中傳回的指標。 此暫存物件只是一個 Windows 訊息處理期間有效。 如需詳細資訊，請參閱`CGdiObject::FromHandle`。

採用區域參數的成員函式版本的執行方式與相同的工作`SelectClipRgn`成員函式。 它的傳回值可以是下列其中一項：

- COMPLEXREGION 新裁剪區域會有重疊的框線。

- 錯誤的裝置內容或地區不正確。

- NULLREGION 新裁剪區域是空的。

- SIMPLEREGION 新裁剪區域沒有任何重疊的框線。

### <a name="remarks"></a>備註

類別`CDC`提供五版本專門用於特定類型的 GDI 物件，包括畫筆、 筆刷、 字型、 點陣圖和區域。 新選取的物件會取代上一個相同型別的物件。 例如，如果*pObject*一般版本的`SelectObject`指向[CPen](../../mfc/reference/cpen-class.md)物件、 函式會將目前的畫筆取代所指定的畫筆*pObject*.

應用程式只能選取一個點陣圖記憶體裝置內容至及到只有一個記憶體裝置內容一次。 點陣圖的格式必須是單色或相容裝置內容中;如果未列出，請`SelectObject`會傳回錯誤。

Windows 3.1 和更新版本，`SelectObject`函式會傳回相同的值，不管是否使用中繼檔中。 在舊版的 Windows，`SelectObject`它已使用中繼檔中時，傳回非零的值，成功和失敗的 0。

##  <a name="selectpalette"></a>  CDC::SelectPalette

選取所指定的邏輯色板*pPalette*與所選的調色盤物件的裝置內容。

```
CPalette* SelectPalette(
    CPalette* pPalette,
    BOOL bForceBackground);
```

### <a name="parameters"></a>參數

*pPalette*<br/>
識別要選取的邏輯調色盤。 這個調色盤必須有已建立具有`CPalette`成員函式[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)。

*bForceBackground*<br/>
指定是否強制邏輯調色盤是背景調色盤。 如果*bForceBackground*為非零值，所選的調色盤總是背景的色板，不論視窗是否有輸入的焦點。 如果*bForceBackground*為 0 和裝置內容附加到視窗，邏輯色板為前景調色盤視窗具有輸入的焦點時。

### <a name="return-value"></a>傳回值

指標`CPalette`物件，可識別取代所指定的調色盤邏輯色板*pPalette*。 如果發生錯誤，它就會是 NULL。

### <a name="remarks"></a>備註

新的調色盤會成為用來顯示在裝置內容中的控制項色彩 GDI 調色盤物件，並取代先前的調色盤。

應用程式可以放入一個以上的裝置內容中選取邏輯調色盤。 不過，邏輯色板的變更會影響所有的已選取的裝置內容。 如果應用程式選取調色盤到一個以上的裝置內容，裝置內容必須全部屬於相同的實體裝置。

##  <a name="selectstockobject"></a>  CDC::SelectStockObject

選取[CGdiObject](../../mfc/reference/cgdiobject-class.md)對應至其中一個預先定義的內建畫筆、 筆刷或字型的物件。

```
virtual CGdiObject* SelectStockObject(int nIndex);
```

### <a name="parameters"></a>參數

*nIndex*<br/>
指定所需的內建物件的類型。 它可以是下列值之一：

- BLACK_BRUSH 黑色筆刷。

- DKGRAY_BRUSH 暗灰色的筆刷。

- GRAY_BRUSH 灰色筆刷。

- HOLLOW_BRUSH 空心的筆刷。

- LTGRAY_BRUSH 淺灰色筆刷。

- NULL_BRUSH Null 筆刷。

- WHITE_BRUSH 白色筆刷。

- BLACK_PEN 黑色畫筆。

- NULL_PEN Null 的畫筆。

- WHITE_PEN 白色畫筆。

- 已修正系統字型的 ANSI_FIXED_FONT ANSI。

- ANSI_VAR_FONT ANSI 變數的系統字型。

- DEVICE_DEFAULT_FONT 裝置而異的字型。

- 固定字型 OEM_FIXED_FONT OEM 相依。

- SYSTEM_FONT 系統字型。 根據預設，Windows 會使用系統字型來繪製功能表、 對話方塊控制項和其他文字。 它是最好的方式，不過，不依賴 SYSTEM_FONT 取得對話方塊和視窗所使用的字型。 請改用`SystemParametersInfo`函式搭配 SPI_GETNONCLIENTMETRICS 參數來擷取目前的字型。 `SystemParametersInfo` 會考量目前的佈景主題，並提供標題、 功能表和訊息對話方塊中的字型資訊。

- SYSTEM_FIXED_FONT Windows 使用 3.0 版之前的固定寬度系統字型。 此物件可供與舊版 Windows 的相容性。

- DEFAULT_PALETTE 預設色彩調色盤。 這個調色盤是由系統調色盤中的 20 靜態色彩所組成。

### <a name="return-value"></a>傳回值

指標`CGdiObject`函式成功時，已被取代的物件。 實際指向的物件是[CPen](../../mfc/reference/cpen-class.md)， [CBrush](../../mfc/reference/cbrush-class.md)，或[CFont](../../mfc/reference/cfont-class.md)物件。 如果呼叫不成功，則傳回的值會是 NULL。

##  <a name="setabortproc"></a>  CDC::SetAbortProc

安裝列印工作的中止程序。

```
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```

### <a name="parameters"></a>參數

*lpfn*<br/>
若要安裝與中止程序中止函式的指標。 如需詳細資訊的回呼函式，請參閱 < [cdc:: setabortproc 的回呼函式](callback-functions-used-by-mfc.md#setabortproc)。

### <a name="return-value"></a>傳回值

指定結果的`SetAbortProc`函式。 下列的值包括更可能比其他項目，但所有有可能發生。

- SP_ERROR 一般錯誤。

- SP_OUTOFDISK 不足夠的磁碟空間目前適用於多工緩衝處理，並沒有更多的空間會變成可用。

- SP_OUTOFMEMORY 不足夠的記憶體可供多工緩衝處理。

- SP_USERABORT 使用者結束作業，透過列印管理員。

### <a name="remarks"></a>備註

如果應用程式以允許列印多工緩衝處理期間取消作業，它就必須設定中止函式，列印工作開始之前[StartDoc](#startdoc)成員函式。 列印管理員允許應用程式來取消列印工作或處理外的磁碟空間條件的多工緩衝處理期間，呼叫的中止函式。 如果沒有中止函式設定，列印工作將會失敗，如果沒有足夠的磁碟空間的多工緩衝處理。

請注意 Microsoft Visual c + + 的功能，簡化傳遞至回呼函式建立`SetAbortProc`。 位址傳遞給`EnumObjects`成員函式是使用匯出的函式的指標`__declspec(dllexport)`與`__stdcall`呼叫慣例。

您也不必匯出中的函式名稱**匯出**應用程式的模組定義檔中的陳述式。 您可以改用**匯出**函式中的修飾詞，

**BOOL 回呼匯出**AFunction ( **HDC**， `int` **);**

若要讓編譯器發出適當的匯出記錄匯出沒有別名的名稱。 這適用於大部分的需求。 某些特殊的情況下，例如匯出的函式的序數或別名的匯出，您仍然需要使用**匯出**模組定義檔中的陳述式。

回呼註冊介面現在是型別安全 （您必須指向正確類型的特定回呼函式的函式指標傳遞）。

也請注意所有的回呼函式必須 Mfc 例外狀況設陷然後再回到 Windows，因為無法跨回呼界限擲回例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。

##  <a name="setarcdirection"></a>  CDC::SetArcDirection

設定要用於弧線和矩形函式的繪製方向。

```
int SetArcDirection(int nArcDirection);
```

### <a name="parameters"></a>參數

*nArcDirection*<br/>
指定新的反方向。 這個參數可以是下列值：

- 以逆時針方向繪製 AD_COUNTERCLOCKWISE 數字。

- 依順時針方向繪製 AD_CLOCKWISE 數字。

### <a name="return-value"></a>傳回值

如果成功，，指定舊的弧形方向，否則為 0。

### <a name="remarks"></a>備註

預設方向是逆時針算起。 `SetArcDirection`函式會指定下列函式繪製的方向：

|Arc|圓形圖|
|---------|---------|
|`ArcTo`|`Rectangle`|
|`Chord`|`RoundRect`|
|`Ellipse`||

##  <a name="setattribdc"></a>  CDC::SetAttribDC

呼叫此函式來設定屬性的裝置內容`m_hAttribDC`。

```
virtual void SetAttribDC(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
Windows 裝置內容。

### <a name="remarks"></a>備註

此成員函式不會附加到的裝置內容`CDC`物件。 僅輸出裝置內容會附加至`CDC`物件。

##  <a name="setbkcolor"></a>  CDC::SetBkColor

將目前的背景色彩設定為指定的色彩。

```
virtual COLORREF SetBkColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定新的背景色彩。

### <a name="return-value"></a>傳回值

先前的背景色彩為 RGB 色彩值。 如果發生錯誤，則傳回的值會為 0x80000000。

### <a name="remarks"></a>備註

如果背景模式是不透明，則系統會使用背景色彩來填滿樣式的行中的間隙中的字元儲存格的背景筆刷中的規劃的線條之間的間距。 轉換點陣圖的色彩與單色裝置內容時，系統也會使用背景色彩。

如果裝置無法顯示指定的色彩，系統就會設定為最接近的實體色彩的背景色彩。

##  <a name="setbkmode"></a>  CDC::SetBkMode

設定 背景模式。

```
int SetBkMode(int nBkMode);
```

### <a name="parameters"></a>參數

*nBkMode*<br/>
指定要設定的模式。 這個參數可以是下列值：

- 不透明的背景會填入目前的背景色彩之前的文字，規劃的筆刷, 或畫筆繪製。 這是預設背景模式。

- 繪製前，不會變更透明背景。

### <a name="return-value"></a>傳回值

先前的背景模式中。

### <a name="remarks"></a>備註

背景模式會定義系統是否會繪製文字、 規劃的筆刷或不是一條實線任何畫筆樣式之前移除現有的繪圖介面上的背景色彩。

### <a name="example"></a>範例

  範例，請參閱[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。

##  <a name="setboundsrect"></a>  CDC::SetBoundsRect

控制指定的裝置內容的週框矩形資訊的累積。

```
UINT SetBoundsRect(
    LPCRECT lpRectBounds,
    UINT flags);
```

### <a name="parameters"></a>參數

*lpRectBounds*<br/>
指向`RECT`結構或`CRect`物件，用來設定週框矩形。 矩形的維度都指定在邏輯座標。 這個參數可以是 NULL。

*flags*<br/>
指定新的矩形，累積的矩形的組合方式。 這個參數可以是下列值的組合：

- DCB_ACCUMULATE 新增所指定的矩形*lpRectBounds*至周框 （使用矩形等位作業）。

- DCB_DISABLE 關閉界限累積。

- DCB_ENABLE 開啟界限累積。 （界限累積的預設設定已停用。）

### <a name="return-value"></a>傳回值

週框的矩形，函式成功時的目前狀態。 像是*旗標*，傳回的值可以是組成**DCB_** 值：

- DCB_ACCUMULATE 周框不是空的。 一律會設定此值。

- DCB_DISABLE 界限累積為關閉。

- DCB_ENABLE 界限累積所在。

### <a name="remarks"></a>備註

Windows 可以維護所有繪圖作業的周框。 這個矩形可以用於查詢及重設應用程式。 繪製界限可用於讓點陣圖快取失效。

##  <a name="setbrushorg"></a>  CDC::SetBrushOrg

指定的 GDI 會將指派給應用程式便可選取的裝置內容的下一步 筆刷的原點。

```
CPoint SetBrushOrg(
    int x,
    int y);

CPoint SetBrushOrg(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定新原點的 x 座標 （以裝置為單位）。 此值必須是範圍 0-7。

*y*<br/>
指定新原點的 y 座標 （以裝置為單位）。 此值必須是範圍 0-7。

*point*<br/>
指定新原點的 x 和 y 座標。 每個值必須是範圍 0-7。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

先前以裝置為單位的筆刷的原點。

### <a name="remarks"></a>備註

預設值的筆刷的原點座標為 （0，0）。 若要改變的筆刷的原點，呼叫`UnrealizeObject`函式`CBrush`物件，請呼叫`SetBrushOrg`，然後呼叫`SelectObject`選擇放入裝置內容的筆刷的成員函式。

請勿使用`SetBrushOrg`庫存與`CBrush`物件。

##  <a name="setcoloradjustment"></a>  CDC::SetColorAdjustment

設定裝置內容，使用指定的值的色彩調整值。

```
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```

### <a name="parameters"></a>參數

*lpColorAdjust*<br/>
指向[COLORADJUSTMENT](/windows/desktop/api/wingdi/ns-wingdi-tagcoloradjustment)包含色彩調整值的資料結構。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

色彩調整值會用來調整輸入的呼叫的來源點陣圖的色彩`CDC::StretchBlt`半色調模式設定時的成員函式。

##  <a name="setdcbrushcolor"></a>  CDC::SetDCBrushColor

為指定的色彩值設定為目前的裝置內容 (DC) 筆刷色彩。

```
COLORREF SetDCBrushColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定新的筆刷色彩。

### <a name="return-value"></a>傳回值

如果此函數成功，傳回的值會指定前一個 DC 的筆刷色彩為 COLORREF 值。

如果函式失敗，則傳回的值會是 CLR_INVALID。

### <a name="remarks"></a>備註

這個方法的函式會模擬[SetDCBrushColor](/windows/desktop/api/wingdi/nf-wingdi-setdcbrushcolor)、 Windows SDK 中所述。

##  <a name="setdcpencolor"></a>  CDC::SetDCPenColor

為指定的色彩值設定為目前的裝置內容 (DC) 畫筆顏色。

```
COLORREF SetDCPenColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定新的畫筆顏色。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此成員函式會利用 Win32 函式[SetDCPenColor](/windows/desktop/api/wingdi/nf-wingdi-setdcpencolor)、 Windows SDK 中所述。

##  <a name="setgraphicsmode"></a>  CDC::SetGraphicsMode

設定指定的裝置內容的圖形模式。

```
int SetGraphicsMode(int iMode);
```

### <a name="parameters"></a>參數

*iMode*<br/>
指定的圖形模式。 如需這個參數可以接受的值，請參閱[SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode)。

### <a name="return-value"></a>傳回值

成功時傳回舊的圖形模式。

在失敗時傳回 0。 若要取得延伸錯誤資訊，請呼叫[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函式[SetGraphicsMode](/windows/desktop/api/wingdi/nf-wingdi-setgraphicsmode)。

##  <a name="setlayout"></a>  CDC::SetLayout

呼叫此成員函式可將文字和圖形裝置內容的配置變更為右到左，如阿拉伯文和希伯來文的文化特性的標準版面配置。

```
DWORD SetLayout(DWORD dwLayout);
```

### <a name="parameters"></a>參數

*dwLayout*<br/>
裝置內容版面配置和點陣圖控制旗標。 它可以是下列值的組合。

|值|意義|
|-----------|-------------|
|LAYOUT_BITMAPORIENTATIONPRESERVED|停用呼叫任何反射[cdc:: bitblt](#bitblt)並[CDC::StretchBlt](#stretchblt)。|
|LAYOUT_RTL|設定預設水平版面配置是由右至左。|
|LAYOUT_LTR|設定要由左到右的預設配置。|

### <a name="return-value"></a>傳回值

如果成功，裝置內容的前一個版面配置。

如果不成功，GDI_ERROR。 若要取得延伸錯誤資訊，請呼叫[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>備註

一般來說，您不會呼叫`SetLayout`視窗。 相反地，您從右至左配置，在視窗中的設定控制[延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)WS_EX_RTLREADING 等。 裝置內容，例如印表機或中繼檔，不會繼承這個版面配置。 從右至左的配置是藉由呼叫設定的裝置內容的唯一辦法`SetLayout`。

如果您呼叫**SetLayout (LAYOUT_RTL** )，`SetLayout`自動將此對應模式變更為 MM_ISOTROPIC。 如此一來，後續呼叫[GetMapMode](#getmapmode)會傳回而不是 MM_TEXT MM_ISOTROPIC。

在某些情況下，例如與許多點陣圖，您可能想要保留左到右配置。 在這些情況下，請藉由呼叫中呈現映像`BitBlt`或`StretchBlt`，然後將設定的點陣圖控制旗標*dwLayout* LAYOUT_BITMAPORIENTATIONPRESERVED 到。

一旦變更 LAYOUT_RTL 旗標的配置，通常指定的旗標左右會反轉。 為了避免混淆，您可能想要定義之標準的旗標的替代名稱。 如需建議替代的旗標名稱的清單，請參閱 < [SetLayout](/windows/desktop/api/wingdi/nf-wingdi-setlayout) Windows SDK 中。

##  <a name="setmapmode"></a>  CDC::SetMapMode

設定對應模式。

```
virtual int SetMapMode(int nMapMode);
```

### <a name="parameters"></a>參數

*nMapMode*<br/>
指定新的對應模式。 它可以是下列值之一：

- 具有任意規模的軸，MM_ANISOTROPIC 邏輯單元會轉換為任意的單位。 將此對應模式設定為 MM_ANISOTROPIC 不會變更目前的視窗或檢視區設定。 若要變更單位，方向以及縮放比例，呼叫[SetWindowExt](#setwindowext)並[SetViewportExt](#setviewportext)成員函式。

- MM_HIENGLISH 每個邏輯單元會轉換為 0.001 英吋。 正 x 是右邊;正 y 已啟動。

- MM_HIMETRIC 每個邏輯單元會轉換為 0.01 公釐。 正 x 是右邊;正 y 已啟動。

- MM_ISOTROPIC 邏輯單元時，會轉換成任意的單位上，與平均縮放軸;也就是沿著 x 軸的 1 個單位等於 1 個單位沿著 y 軸。 使用`SetWindowExt`和`SetViewportExt`成員函式，以指定的所需的單位，以及這兩個軸的方向。 GDI 視會調整的 x 和 y，確認單位會保持相同的大小。

- MM_LOENGLISH 每個邏輯單元會轉換為 0.01 英吋。 正 x 是右邊;正 y 已啟動。

- MM_LOMETRIC 每個邏輯單元會轉換為 0.1 公釐。 正 x 是右邊;正 y 已啟動。

- MM_TEXT 每個邏輯單元會轉換成 1 部裝置像素。 正 x 是右邊;正 y 已關閉。

- MM_TWIPS 每個邏輯單元會轉換為 1/20 的點。 （原因是點 1/72 英吋，twip 是 1/1440年英吋）。正 x 是右邊;正 y 已啟動。

### <a name="return-value"></a>傳回值

先前的對應模式。

### <a name="remarks"></a>備註

此對應模式會定義用來將邏輯單元轉換成裝置單位; 量值的單位它也會定義裝置的 x 軸和 y 軸的方向。 GDI 邏輯座標轉換為適當的裝置座標，使用此對應模式。 MM_TEXT 模式可讓應用程式來處理裝置的像素，其中 1 個單位等於 1 個像素。 像素的實體大小而異的裝置。

MM_HIENGLISH、 MM_HIMETRIC、 MM_LOENGLISH、 MM_LOMETRIC 和 MM_TWIPS 模式適合用於必須繪製在實體上有意義的單位 （例如英吋或公釐為單位） 的應用程式。 MM_ISOTROPIC 模式可確保 1:1 外觀比例，請務必保留影像的確切圖形時，這很有用。 MM_ANISOTROPIC 模式可讓 x 和 y 座標獨立調整。

> [!NOTE]
>  如果您呼叫[SetLayout](#setlayout)若要將 DC （裝置內容） 變更為從右至左的配置，`SetLayout`自動將此對應模式變更為 MM_ISOTROPIC。

### <a name="example"></a>範例

  範例，請參閱[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setmapperflags"></a>  CDC::SetMapperFlags

變更時就轉換成實體字型的邏輯字型的字型對應工具所使用的方法。

```
DWORD SetMapperFlags(DWORD dwFlag);
```

### <a name="parameters"></a>參數

*dwFlag*<br/>
指定是否字型對應工具會嘗試比對字型的外觀高度和寬度，以裝置。 ASPECT_FILTERING 此值時，對應工具會選取其長寬的 x 和 y 方面完全符合指定之裝置的唯一字型。

### <a name="return-value"></a>傳回值

字型對應程式旗標先前的值。

### <a name="remarks"></a>備註

應用程式可以使用`SetMapperFlags`導致嘗試選擇只有完全符合指定之裝置的長寬比實體字型的字型對應程式。

使用僅點陣字型的應用程式可以使用`SetMapperFlags`函式，以確保字型對應工具所選取的字型是吸引人且有指定的裝置上閱讀。 使用應用程式可調整的 (TrueType) 字型通常不用`SetMapperFlags`。

如果沒有實體字型有符合的邏輯字型中的規格的外觀比例，GDI 選擇新的長寬比，並選取符合這個新的長寬比的字型。

##  <a name="setmiterlimit"></a>  CDC::SetMiterLimit

設定斜接角聯結裝置內容的長度限制。

```
BOOL SetMiterLimit(float fMiterLimit);
```

### <a name="parameters"></a>參數

*fMiterLimit*<br/>
指定裝置內容的新斜接限制。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

斜接面長度定義為從聯結的內側上列背景牆的交集列背景牆，外部聯結的交集的距離。 斜接限制時的最大的允許的線條寬度斜接面長度比例。 預設斜接限制為 10.0。

##  <a name="setoutputdc"></a>  CDC::SetOutputDC

呼叫此成員函式，來設定輸出裝置內容`m_hDC`。

```
virtual void SetOutputDC(HDC hDC);
```

### <a name="parameters"></a>參數

*hDC*<br/>
Windows 裝置內容。

### <a name="remarks"></a>備註

此成員函式只能呼叫，當裝置內容未連接至`CDC`物件。 此成員函式會將`m_hDC`但不會附加到的裝置內容`CDC`物件。

##  <a name="setpixel"></a>  CDC::SetPixel

設定到最接近的近似值，所指定之色彩的指定點的像素*crColor*。

```
COLORREF SetPixel(
    int x,
    int y,
    COLORREF crColor);

COLORREF SetPixel(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>參數

*x*<br/>
指定要設定點的邏輯 x 座標。

*y*<br/>
指定要設定點的邏輯 y 座標。

*crColor*<br/>
COLORREF RGB 值，指定用來繪製點的色彩。 請參閱[COLORREF](/windows/desktop/gdi/colorref) Windows SDK 中針對此值的描述。

*point*<br/>
指定邏輯 x 和 y 座標點設定。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

實際繪製點的色彩 RGB 值。 此值可能會不同於所指定*crColor*如果使用該顏色的近似值。 如果函式會失敗 （如果點外的裁剪區域），則傳回的值為-1。

### <a name="remarks"></a>備註

裁剪區域必須是點。 重點不是裁剪區域中，如果函式沒有任何作用。

並非所有的裝置皆支援 `SetPixel` 函式。 若要判斷裝置是否支援`SetPixel`，呼叫`GetDeviceCaps`成員函式具有 RASTERCAPS 索引，並檢查傳回的值，RC_BITBLT 旗標。

##  <a name="setpixelv"></a>  CDC::SetPixelV

將像素設定在指定的座標，來指定色彩的最接近的近似值。

```
BOOL SetPixelV(
    int x,
    int y,
    COLORREF crColor);

BOOL SetPixelV(
    POINT point,
    COLORREF crColor);
```

### <a name="parameters"></a>參數

*x*<br/>
指定 x 軸座標，以邏輯單位，要設定的點。

*y*<br/>
指定 y 軸座標，以邏輯單位，要設定的點。

*crColor*<br/>
指定要用來繪製點的色彩。

*point*<br/>
指定邏輯 x 和 y 座標點設定。 您可以傳遞[點](/windows/desktop/api/windef/ns-windef-tagpoint)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)此參數的物件。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

裁剪區域和裝置介面的可見部分必須是點。 並非所有裝置都支援此成員函式。 如需詳細資訊，請參閱中的 RC_BITBLT 功能`CDC::GetDeviceCaps`成員函式。 `SetPixelV` 速度比`SetPixel`因為不需要傳回實際繪製點的色彩值。

##  <a name="setpolyfillmode"></a>  CDC::SetPolyFillMode

將多邊形填滿模式。

```
int SetPolyFillMode(int nPolyFillMode);
```

### <a name="parameters"></a>參數

*nPolyFillMode*<br/>
指定新的填滿模式。 此值可能替代或捲繞。 在 Windows 中設定的預設模式是替代。

### <a name="return-value"></a>傳回值

前一個填滿模式中，如果登錄成功。否則為 0。

### <a name="remarks"></a>備註

替代的多邊形填滿模式時，系統就會填入掃描一行奇數和偶數的多邊形側邊之間的區域。 亦即，系統會填滿區域之間的第一個和第二個邊，等第三個和第四個側邊之間。 此模式是預設值。

當捲繞多邊形填滿模式時，系統就會使用以判斷是否要填滿區域已繪製圖形的方向。 順時針或逆時針方向會繪製多邊形中的每個直線線段。 每當從括住的區域繪製到圖表的外部虛構線段通過順時針方向的線段的計數會遞增。 當行通過逆時針算起的直線線段時，計數會遞減。 如果計數為非零值，在線條數到達外部的圖時，會填滿區域。

##  <a name="setrop2"></a>  CDC::SetROP2

設定目前的繪製模式。

```
int SetROP2(int nDrawMode);
```

### <a name="parameters"></a>參數

*nDrawMode*<br/>
指定新的繪圖模式。 它可以是下列值之一：

- R2_BLACK 像素一律為黑色。

- R2_WHITE 像素一律為白色。

- R2_NOP 像素會維持不變。

- R2_NOT 像素是螢幕色彩的反向作業。

- R2_COPYPEN 像素都是畫筆顏色。

- R2_NOTCOPYPEN 像素是畫筆顏色的反向作業。

- R2_MERGEPENNOT 像素都是組合的畫筆顏色和螢幕色彩的反向 (最後一個像素 = （不是螢幕像素），或手寫筆)。

- R2_MASKPENNOT 像素都是通用的同時的畫筆色彩組合和螢幕的反向 (最後一個像素 = （不是螢幕像素），以及觸控筆)。

- R2_MERGENOTPEN 像素都是一連串的畫面色彩和畫筆顏色的反向 (最後一個像素 = （而不是手寫筆），或畫面像素)。

- R2_MASKNOTPEN 像素都是通用的同時螢幕色彩的組合和畫筆的反向 (最後一個像素 = （不是畫筆） 和螢幕像素)。

- R2_MERGEPEN 像素都是畫筆顏色和螢幕色彩的組合 (最後一個像素 = 畫筆 OR 螢幕像素)。

- R2_NOTMERGEPEN 像素是 R2_MERGEPEN 色彩的反向作業 (最後一個像素 = 未 （手寫筆 OR 螢幕像素）)。

- R2_MASKPEN 像素都是通用的畫筆和螢幕色彩的組合 (最後一個像素 = 畫筆與螢幕像素)。

- R2_NOTMASKPEN 像素是 R2_MASKPEN 色彩的反向作業 (最後一個像素 = 未 （手寫筆與螢幕像素）)。

- R2_XORPEN 像素都是色彩的畫筆或在畫面中，但不是能在兩者的組合 (最後一個像素 = 畫筆 XOR 螢幕像素)。

- R2_NOTXORPEN 像素是 R2_XORPEN 色彩的反向作業 (最後一個像素 = 未 （畫筆 XOR 螢幕像素）)。

### <a name="return-value"></a>傳回值

先前的繪製模式。

它可以是任何 Windows SDK 所提供的值。

### <a name="remarks"></a>備註

繪製模式會指定如何與已經在顯示介面上的色彩結合色彩的畫筆和填滿物件的內部。

繪製模式是僅適用於點陣裝置;不適用於向量裝置之用。 繪圖模式會代表所有可能的布林值組合的兩個變數，不使用二元運算子 AND、 OR 和 XOR (互斥 OR)，一元運算的二進位的點陣作業程式碼。

##  <a name="setstretchbltmode"></a>  CDC::SetStretchBltMode

設定的點陣圖縮放模式`StretchBlt`成員函式。

```
int SetStretchBltMode(int nStretchMode);
```

### <a name="parameters"></a>參數

*nStretchMode*<br/>
指定的縮放模式。 它可以是下列值之一：

|值|描述|
|-----------|-----------------|
|BLACKONWHITE|執行布林值 AND 運算，用於已排除的和現有的像素的色彩值。 如果點陣圖是單色點陣圖，這個模式會保留黑色像素，但會犧牲白色像素為單位。|
|COLORONCOLOR|刪除的像素為單位。 此模式會刪除所有已排除像素行，但不會嘗試保留他們的資訊。|
|半色調|會從來源矩形的像素對應到目的地矩形中的像素的區塊中。 透過像素為單位的目標區塊的平均色彩基本原則而論來源像素的色彩。|
||設定自動縮放模式半色調之後, 應用程式必須呼叫 Win32 函式[SetBrushOrgEx](/windows/desktop/api/wingdi/nf-wingdi-setbrushorgex)設定筆刷的原點。 如果它無法這麼做，就會發生筆刷對齊錯誤。|
|STRETCH_ANDSCANS|**Windows 95/98**:BLACKONWHITE 相同|
|STRETCH_DELETESCANS|**Windows 95/98**:COLORONCOLOR 相同|
|STRETCH_HALFTONE|**Windows 95/98**:與 半色調相同。|
|STRETCH_ORSCANS|**Windows 95/98**:WHITEONBLACK 相同|
|WHITEONBLACK|執行布林值 OR 運算，用於已排除的和現有的像素的色彩值。 如果點陣圖是單色點陣圖，這個模式會保留白色像素，但會犧牲黑色像素。|

### <a name="return-value"></a>傳回值

先前的縮放模式。 它可以是 STRETCH_ANDSCANS、 STRETCH_DELETESCANS 或 STRETCH_ORSCANS。

### <a name="remarks"></a>備註

點陣圖縮放模式會定義如何從使用函式就會進行壓縮的點陣圖中移除資訊。

BLACKONWHITE (STRETCH_ANDSCANS) 和 WHITEONBLACK (STRETCH_ORSCANS) 模式通常用來保留前景中單色點陣圖的像素。 COLORONCOLOR (STRETCH_DELETESCANS) 模式通常用來保留在色彩點陣圖的色彩。

半色調模式需要更多的來源映像處理比其他三個的模式;它低於其他人，但會產生較高品質的影像。 也請注意，`SetBrushOrgEx`必須設定 半色調模式，以避免筆刷對齊錯誤之後呼叫。

可能也會根據裝置驅動程式功能提供額外的延伸模式。

##  <a name="settextalign"></a>  CDC::SetTextAlign

設定文字對齊方式的旗標。

```
UINT SetTextAlign(UINT nFlags);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指定文字對齊方式的旗標。 旗標會指定一個點和限定文字界限的矩形之間的關聯性。 點可以是目前的位置或文字輸出函式所指定的座標。 限定文字界限的矩形是相鄰的字元儲存格的文字字串中所定義。 *NFlags*參數可以是下列三個類別的一或多個旗標。 選擇每個類別只有一個旗標。 第一個類別會影響在 x 方向的文字對齊方式：

- TA_CENTER 對齊的週框的水平中央的點。

- TA_LEFT 對齊的週框的點的左側。 這是預設設定。

- TA_RIGHT 對齊的週框的右側的點。

第二個類別會影響文字在 y 方向的對齊方式：

- TA_BASELINE 符合所選字型的基準線的點。

- TA_BOTTOM 對齊的週框矩形底端的點。

- TA_TOP 對齊的週框矩形頂端的點。 這是預設設定。

第三個類別會決定是否要在寫入文字時，更新目前的位置：

- TA_NOUPDATECP 不會更新目前的位置之後的文字輸出函式每次呼叫。 這是預設設定。

- 文字輸出函式每次呼叫之後 TA_UPDATECP 更新目前的 x 位置。 新位置是在文字的週框矩形右側。 當這個旗標設定，在呼叫中指定的座標`TextOut`成員函式都會被忽略。

### <a name="return-value"></a>傳回值

先前文字對齊方式的設定，如果成功。 低序位位元組包含水平的設定，而高序位位元組包含垂直的設定;否則為 0。

### <a name="remarks"></a>備註

`TextOut`和`ExtTextOut`定位在顯示或裝置上的文字字串時，成員函式會使用這些旗標。 旗標會指定特定的點與限定文字界限的矩形之間的關聯性。 此端點的座標傳遞做為參數`TextOut`成員函式。 限定文字界限的矩形是文字字串中的相鄰的字元儲存格所形成的。

##  <a name="settextcharacterextra"></a>  CDC::SetTextCharacterExtra

設定 intercharacter 的間距數量。

```
int SetTextCharacterExtra(int nCharExtra);
```

### <a name="parameters"></a>參數

*nCharExtra*<br/>
指定要加入至每個字元的 （以邏輯單位表示） 的額外空間數量。 如果不是目前的對應模式`MM_TEXT`， *nCharExtra*轉換和捨入到最接近像素。

### <a name="return-value"></a>傳回值

先前的 intercharacter 間距數量。

### <a name="remarks"></a>備註

GDI 會將每個字元，包括分行符號字元，當它將一行文字寫入至裝置內容中的此間距。 Intercharacter 間距所需的預設值為 0。

##  <a name="settextcolor"></a>  CDC::SetTextColor

為指定的色彩設定的文字色彩。

```
virtual COLORREF SetTextColor(COLORREF crColor);
```

### <a name="parameters"></a>參數

*crColor*<br/>
指定文字的色彩為 RGB 色彩值。

### <a name="return-value"></a>傳回值

先前的文字色彩的 RGB 值。

### <a name="remarks"></a>備註

將文字寫入至這個裝置內容，以及當之間的轉換點陣圖的色彩和單色裝置內容時，系統會使用此文字色彩。

如果裝置無法表示指定的色彩，系統就會設定為最接近的實體色彩的文字色彩。 所指定字元的背景色彩`SetBkColor`和`SetBkMode`成員函式。

### <a name="example"></a>範例

  範例，請參閱[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。

##  <a name="settextjustification"></a>  CDC::SetTextJustification

將字串中的分行符號字元空間。

```
int SetTextJustification(
    int nBreakExtra,
    int nBreakCount);
```

### <a name="parameters"></a>參數

*nBreakExtra*<br/>
指定要加入至的一行 （以邏輯單位表示） 的文字的總計額外空間。 如果不是目前的對應模式`MM_TEXT`，此參數給定的值會轉換為目前的對應模式，並四捨五入到最接近的裝置單位。

*nBreakCount*<br/>
指定行中的分行符號字元數目。

### <a name="return-value"></a>傳回值

其中一個函式是否成功;否則為 0。

### <a name="remarks"></a>備註

應用程式可以使用`GetTextMetrics`成員函式來擷取字型的中斷字元。

在後`SetTextJustification`成員函式呼叫時，文字輸出函式的呼叫 (例如`TextOut`) 分散指定額外的空間，平均分配給指定的符號字元數。 分行符號字元通常是空格字元 (ASCII 32)，但可能與其他某些字元的字型所定義。

此成員函式`GetTextExtent`一般會搭配使用`SetTextJustification`。 `GetTextExtent` 計算在對齊之前指定線條的寬度。 應用程式可以判斷多少空間來指定*nBreakExtra*參數所傳回的值中減去`GetTextExtent`從寬度對齊之後的字串。

`SetTextJustification`函式可以用來對齊包含多個執行不同的字型中的列。 在此情況下，必須分次建立列藉由對齊，並分別撰寫每次執行。

因為對齊期間可能會發生捨入錯誤，系統就會保留定義目前錯誤的執行錯誤詞彙。 當對齊行，其中包含多個回合，`GetTextExtent`會自動使用這個錯誤詞彙，它會計算下一次執行的範圍。 這可讓文字輸出函式，以融入新的執行中的錯誤。

已對齊每一行之後，必須清除這個錯誤的詞彙，以防止它被合併到下一行。 藉由呼叫，就可以清除詞彙`SetTextJustification`具有*nBreakExtra*設為 0。

##  <a name="setviewportext"></a>  CDC::SetViewportExt

設定 x-和 y-範圍的裝置內容的檢視區。

```
virtual CSize SetViewportExt(
    int cx,
    int cy);

CSize SetViewportExt(SIZE size);
```

### <a name="parameters"></a>參數

*cx*<br/>
指定檢視區 （以裝置為單位） x 範圍。

*cy*<br/>
指定 y 範圍的檢視區 （以裝置為單位）。

*size*<br/>
指定 x-和 y-範圍的檢視區 （以裝置為單位）。

### <a name="return-value"></a>傳回值

做為檢視區前一個範圍[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。 在錯誤發生時，x 和 y 座標傳回`CSize`物件都設為 0。

### <a name="remarks"></a>備註

檢視區，以及裝置內容 視窗中，定義 GDI 在實際裝置之點的座標系統中所對應的邏輯座標系統中的點。 也就是說，它們會定義 GDI 如何將邏輯座標轉換成裝置座標。

當下列的對應模式設定時，呼叫`SetWindowExt`和`SetViewportExt`都會被忽略：

|MM_HIENGLISH|MM_LOMETRIC|
|-------------------|------------------|
|MM_HIMETRIC|MM_TEXT|
|MM_LOENGLISH|MM_TWIPS|

應用程式設定 MM_ISOTROPIC 模式時，必須呼叫`SetWindowExt`成員函式之前它會呼叫`SetViewportExt`。

### <a name="example"></a>範例

  範例，請參閱[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setviewportorg"></a>  CDC::SetViewportOrg

設定裝置內容的檢視區原點。

```
virtual CPoint SetViewportOrg(
    int x,
    int y);

CPoint SetViewportOrg(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定的檢視區原點的 x 座標 （以裝置為單位）。 值必須是裝置座標系統的範圍內。

*y*<br/>
指定的檢視區原點的 y 座標 （以裝置為單位）。 值必須是裝置座標系統的範圍內。

*point*<br/>
指定檢視區的來源。 值必須是裝置座標系統的範圍內。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

先前的 （以裝置座標表示） 做為檢視區原點`CPoint`物件。

### <a name="remarks"></a>備註

檢視區，以及裝置內容 視窗中，定義 GDI 在實際裝置之點的座標系統中所對應的邏輯座標系統中的點。 也就是說，它們會定義 GDI 如何將邏輯座標轉換成裝置座標。

檢視區原點標示 GDI 對應視窗原點的點，在邏輯座標系統中所指定裝置座標系統中的點`SetWindowOrg`成員函式。 GDI 對應遵循相同的程序對應至檢視區原點的視窗原點所需的所有其他點。 比方說，在視窗原點的點周圍的圓圈中所有資料點會在檢視區原點的點周圍的圓形。 同樣地，通過視窗原點的列中的所有點都會通過檢視區原點的列。

### <a name="example"></a>範例

  範例，請參閱[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setwindowext"></a>  CDC::SetWindowExt

設定 x-和 y-範圍相關聯的裝置內容的視窗。

```
virtual CSize SetWindowExt(
    int cx,
    int cy);

CSize SetWindowExt(SIZE size);
```

### <a name="parameters"></a>參數

*cx*<br/>
指定 x-程度 （以邏輯單位表示） 的視窗。

*cy*<br/>
指定 y-程度 （以邏輯單位表示） 的視窗。

*size*<br/>
指定 x-和 y-範圍 （以邏輯單位表示） 的視窗。

### <a name="return-value"></a>傳回值

做為間隔 （以邏輯單位表示） 的前一個範圍`CSize`物件。 如果發生錯誤，x 和 y 座標傳回`CSize`物件都設為 0。

### <a name="remarks"></a>備註

視窗中的，裝置內容檢視區，以及定義 GDI 在裝置座標系統中的點所對應的邏輯座標系統中的點。

當下列的對應模式設定時，呼叫`SetWindowExt`和`SetViewportExt`會忽略函式：

- MM_HIENGLISH

- MM_HIMETRIC

- MM_LOENGLISH

- MM_LOMETRIC

- MM_TEXT

- MM_TWIPS

應用程式設定 MM_ISOTROPIC 模式時，必須呼叫`SetWindowExt`成員函式，然後再呼叫`SetViewportExt`。

### <a name="example"></a>範例

  範例，請參閱[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。

##  <a name="setwindoworg"></a>  CDC::SetWindowOrg

設定裝置內容的視窗原點。

```
CPoint SetWindowOrg(
    int x,
    int y);

CPoint SetWindowOrg(POINT point);
```

### <a name="parameters"></a>參數

*x*<br/>
指定視窗的新來源的邏輯 x 座標。

*y*<br/>
指定視窗的新來源的邏輯 y 座標。

*point*<br/>
指定新來源 視窗的邏輯座標。 您可以傳遞`POINT`結構或`CPoint`此參數的物件。

### <a name="return-value"></a>傳回值

為視窗的上一個來源`CPoint`物件。

### <a name="remarks"></a>備註

視窗中的，裝置內容檢視區，以及定義 GDI 在裝置座標系統中的點所對應的邏輯座標系統中的點。

視窗原點將標記在邏輯座標系統中的 GDI 對應檢視區原點的點，在裝置座標系統中所指定的點`SetWindowOrg`函式。 GDI 對應遵循相同的程序對應至檢視區原點的視窗原點所需的所有其他點。 比方說，在視窗原點的點周圍的圓圈中所有資料點會在檢視區原點的點周圍的圓形。 同樣地，通過視窗原點的列中的所有點都會通過檢視區原點的列。

##  <a name="setworldtransform"></a>  CDC::SetWorldTransform

設定全局空間與指定的裝置內容的分頁空間之間的二維線性轉換。 此轉換可調整、 旋轉、 傾斜或轉譯的圖形輸出。

```
BOOL SetWorldTransform(const XFORM& rXform);
```

### <a name="parameters"></a>參數

*rXform*<br/>
若要參考[XFORM](/windows/desktop/api/wingdi/ns-wingdi-tagxform)結構，其中包含轉換資料。

### <a name="return-value"></a>傳回值

成功時傳回非零值。

在失敗時傳回 0。

若要取得延伸錯誤資訊，請呼叫[GetLastError](https://msdn.microsoft.com/library/windows/desktop/ms679360)。

### <a name="remarks"></a>備註

這個方法會包裝 Windows GDI 函式[SetWorldTransform](/windows/desktop/api/wingdi/nf-wingdi-setworldtransform)。

##  <a name="startdoc"></a>  CDC::StartDoc

通知新的列印工作正在啟動的裝置驅動程式，所有後續`StartPage`並`EndPage`呼叫應該在相同的作業，直到多工緩衝`EndDoc`呼叫，就會發生。

```
int StartDoc(LPDOCINFO lpDocInfo);
int StartDoc(LPCTSTR lpszDocName);
```

### <a name="parameters"></a>參數

*lpDocInfo*<br/>
指向[DOCINFO](/windows/desktop/api/wingdi/ns-wingdi-_docinfoa)結構，包含文件檔案的名稱和輸出檔的名稱。

*lpszDocName*<br/>
字串，包含文件檔案名稱的指標。

### <a name="return-value"></a>傳回值

此函數成功，傳回的值小於或等於零。 這個值會是文件的列印工作識別碼。

函式失敗，傳回的值小於或等於零。

### <a name="remarks"></a>備註

這可確保不會與其他工作顛倒長度大於一頁的文件。

針對 Windows 3.1 和更新版本的版本，此函數會取代 STARTDOC 印表機逸出。 使用此函式，可確保包含多個頁面的文件不會穿插其他列印工作。

`StartDoc` 不應該使用中繼檔內。

### <a name="example"></a>範例

此程式碼片段會取得預設印表機，開啟 列印工作，並多工緩衝處理"Hello World ！"的單一頁面 它。 因為此程式碼所列印的文字不縮放至印表機的邏輯單位，所以輸出文字可能無法以這類的小寫字母的結果是無法讀取。 調整函式，例如 CDC `SetMapMode`， `SetViewportOrg`，和`SetWindowExt`，可用來修正的縮放比例。

[!code-cpp[NVC_MFCDocView#41](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]

##  <a name="startpage"></a>  CDC::StartPage

呼叫此成員函式，以準備印表機驅動程式來接收資料。

```
int StartPage();
```

### <a name="return-value"></a>傳回值

大於或等於 0，如果函式成功或為負數值，如果發生錯誤。

### <a name="remarks"></a>備註

`StartPage` 取代 NEWFRAME 和 BANDINFO 逸出字元。

如需列印的呼叫順序的概觀，請參閱 < [StartDoc](#startdoc)成員函式。

系統會停用`ResetDC`成員函式呼叫之間`StartPage`和`EndPage`。

### <a name="example"></a>範例

  範例，請參閱[CDC::StartDoc](#startdoc)。

##  <a name="stretchblt"></a>  CDC::StretchBlt

將來源矩形的點陣圖複製到目的地矩形，必要時可延伸或壓縮點陣圖，使其符合目的地矩形的維度。

```
BOOL StretchBlt(
    int x,
    int y,
    int nWidth,
    int nHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    DWORD dwRop);
```

### <a name="parameters"></a>參數

*x*<br/>
指定目的地矩形左上角的 X 座標 (以邏輯單位表示)。

*y*<br/>
指定目的地矩形左上角的 Y 座標 (以邏輯單位表示)。

*nWidth*<br/>
指定目的地矩形的寬度 (以邏輯單位表示)。

*nHeight*<br/>
指定目的地矩形的高度 (以邏輯單位表示)。

*pSrcDC*<br/>
指定來源裝置內容。

*xSrc*<br/>
指定來源矩形左上角的 X 座標 (以邏輯單位表示)。

*ySrc*<br/>
指定來源矩形左上角的 Y 座標 (以邏輯單位表示)。

*nSrcWidth*<br/>
指定來源矩形的寬度 (以邏輯單位表示)。

*nSrcHeight*<br/>
指定來源矩形的高度 (以邏輯單位表示)。

*dwRop*<br/>
指定待執行的點陣作業。 點陣作業程式碼定義 GDI 在輸出作業中結合色彩的方式；該輸出作業與目前的筆刷、可能的來源點陣圖和目的地點陣圖相關。 這個參數可以是下列其中一個值：

- 將所有輸出黑色 BLACKNESS 變成。

- DSTINVERT 反轉目的地點陣圖。

- MERGECOPY 合併模式和來源點陣圖使用布林值 AND 運算子。

- MERGEPAINT 合併反轉的來源點陣圖和目的地點陣圖使用布林值 OR 運算子。

- NOTSRCCOPY 將反轉的來源點陣圖複製到目的地。

- NOTSRCERASE 反轉合併目的地點陣圖和來源點陣圖使用布林值 OR 運算子的結果。

- PATCOPY 將模式複製到目的地點陣圖。

- PATINVERT 模式使用布林值 XOR 運算子合併目的地點陣圖。

- PATPAINT 會合併反轉的來源點陣圖與模式使用布林值 OR 運算子。 使用布林值 OR 運算子合併此作業的結果與目的地點陣圖。

- 使用布林值 AND 運算子的目的地和來源點陣圖的 SRCAND 結合的像素。

- SRCCOPY 會將來源點陣圖複製到目的地點陣圖。

- SRCERASE 反轉目的地點陣圖和來源點陣圖使用布林值 AND 運算子結合的結果。

- 使用布林值 XOR 運算子的目的地和來源點陣圖的 SRCINVERT 結合的像素。

- 使用布林值 OR 運算子的目的地和來源點陣圖的 SRCPAINT 結合的像素。

- 將所有輸出白色 WHITENESS 變成。

### <a name="return-value"></a>傳回值

如果繪製了點陣圖即為非零，否則為 0。

### <a name="remarks"></a>備註

此函式使用目的地裝置內容 (以 `SetStretchBltMode` 設定) 的縮放模式判斷如何縮放或壓縮點陣圖。

`StretchBlt`函式會從所指定的來源裝置移點陣圖*pSrcDC*呼叫其成員函式的裝置內容物件所代表的目的地裝置。 *XSrc*， *ySrc*， *nSrcWidth*，以及*nSrcHeight*參數定義的左上角和維度的來源矩形. *x*， *y*， *nWidth*，以及*nHeight*參數指定的左上角和維度的目的矩形。 所指定的點陣作業*dwRop*定義如何合併來源點陣圖和已在目的地裝置上的位元。

`StretchBlt`函式會建立點陣圖的鏡像映像，如果的跡象*nSrcWidth*並*nWidth*或是*nSrcHeight*和*nHeight*參數不同。 如果*nSrcWidth*並*nWidth*的符號不同，此函數便會沿著 x 軸點陣圖的鏡像映像。 如果*nSrcHeight*並*nHeight*的符號不同，此函數便會沿著 y 軸點陣圖的鏡像映像。


  `StretchBlt` 函式會延伸或壓縮記憶體中的來源點陣圖，然後將結果複製到目的地。 如果要合併模式和結果，除非將延伸的來源點陣圖複製到目的地，否則不會進行合併。 如果使用筆刷，會使用在目的地裝置內容中選取的筆刷。 目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。

如果目的地、來源和模式點陣圖的色彩格式不同，`StretchBlt` 會轉換來源和模式點陣圖以符合目的地點陣圖。 轉換中會使用目的地裝置内容的前景和背景色彩。

如果 `StretchBlt` 必須將單色點陣圖轉換為彩色，會將白色位元 (1) 設為背景色彩，並將黑色位元 (0) 設為前景色彩。 若要將彩色轉換為單色，則會將符合背景色彩的像素轉換成白色 (1)，並將其他所有像素設為黑色 (0)。 會使用彩色裝置內容的前景和背景色彩。

並非所有的裝置皆支援 `StretchBlt` 函式。 若要判斷裝置是否支援`StretchBlt`，呼叫`GetDeviceCaps`成員函式具有 RASTERCAPS 索引，並檢查傳回的值，RC_STRETCHBLT 旗標。

##  <a name="strokeandfillpath"></a>  CDC::StrokeAndFillPath

關閉任何開啟的圖形路徑中，使用目前的畫筆，strokes 外框的路徑並填滿其內部使用目前的筆刷。

```
BOOL StrokeAndFillPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

裝置內容必須包含已關閉的路徑。 `StrokeAndFillPath`成員函式已關閉所有開放的圖形，在路徑中，相同的效果和畫筆繪製，並分別填入路徑，不同之處在於填滿的區域不會重疊，繪製的區域，即使是寬。

##  <a name="strokepath"></a>  CDC::StrokePath

使用目前的畫筆，以呈現指定的路徑。

```
BOOL StrokePath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

裝置內容必須包含已關閉的路徑。

##  <a name="tabbedtextout"></a>  CDC::TabbedTextOut

呼叫此成員函式可寫入的字元字串，在指定的位置，展開索引標籤來指定陣列中的定位停駐點位置的值。

```
virtual CSize TabbedTextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);

CSize TabbedTextOut(
    int x,
    int y,
    const CString& str,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
```

### <a name="parameters"></a>參數

*x*<br/>
指定之字串的起始點的邏輯 x 座標。

*y*<br/>
指定之字串的起始點的邏輯 y 座標。

*lpszString*<br/>
指向要繪製的字元字串。 您可以將指標傳遞至字元陣列或[CString](../../atl-mfc-shared/reference/cstringt-class.md)此參數的物件。

*nCount*<br/>
指定字串中的字元數。 如果*nCount*為-1，長度會計算。

*nTabPositions*<br/>
指定陣列中的定位停駐點位置的值數目。

*lpnTabStopPositions*<br/>
指向陣列，其中包含定位停駐點位置 （以邏輯單位表示）。 定位停駐點必須以遞增順序排序最小的 x 值應該在陣列中的第一個項目。

*nTabOrigin*<br/>
指定要從中索引標籤會展開 （以邏輯單位表示） 的開始位置的 x 座標。

*str*<br/>
A`CString`物件，其中包含指定的字元。

### <a name="return-value"></a>傳回值

形式的字串 （以邏輯單位表示） 的維度`CSize`物件。

### <a name="remarks"></a>備註

文字是以目前選取的字型。 如果*nTabPositions*為 0 並*lpnTabStopPositions*是 NULL 時，索引標籤會展開至八倍的平均字元寬度。

如果*nTabPositions*為 1，以在第一個值所指定的距離分隔停駐點的索引標籤*lpnTabStopPositions*陣列。 如果*lpnTabStopPositions*陣列包含多個值，定位停駐點會設定每個值在陣列中，最多指定數目*nTabPositions*。 *NTabOrigin*參數可讓應用程式呼叫`TabbedTextOut`多次對於某一行的函式。 如果應用程式呼叫此函式一次以上*nTabOrigin*每次設定為相同的值，函式會展開所有的索引標籤相對於所指定的位置*nTabOrigin*。

根據預設，函式不會使用或更新目前的位置。 如果應用程式需要更新目前的位置，它會呼叫此函式時，應用程式可以呼叫[SetTextAlign](#settextalign)成員函式*nFlags*設 TA_UPDATECP。 設定此旗標時，Windows 會略過*x*並*y*參數，在後續呼叫`TabbedTextOut`，改為使用目前的位置。

##  <a name="textout"></a>  CDC::TextOut

使用目前選取的字型，在指定的位置寫入字元字串。

```
virtual BOOL TextOut(
    int x,
    int y,
    LPCTSTR lpszString,
    int nCount);

BOOL TextOut(
    int x,
    int y,
    const CString& str);
```

### <a name="parameters"></a>參數

*x*<br/>
指定文字起點的邏輯 X 座標。

*y*<br/>
指定文字起點的邏輯 Y 座標。

*lpszString*<br/>
指向要繪製的字元字串。

*nCount*<br/>
指定字串中的字元數。

*str*<br/>

  `CString` 物件，其中包含要繪製的字元。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

字元原點在字元儲存格的左上角。 根據預設，函式不會使用或更新目前的位置。

如果應用程式需要呼叫時，更新目前的位置`TextOut`，應用程式可以呼叫`SetTextAlign`成員函式*nFlags*設 TA_UPDATECP。 設定此旗標時，Windows 會略過*x*並*y*參數，在後續呼叫`TextOut`，改為使用目前的位置。

### <a name="example"></a>範例

  範例，請參閱[cdc:: beginpath](#beginpath)。

##  <a name="transparentblt"></a>  CDC::TransparentBlt

呼叫此成員函式來轉移到目的地裝置內容對應到像素矩形從指定的來源裝置內容中，色彩資料位元區塊。

```
BOOL TransparentBlt(
    int xDest,
    int yDest,
    int nDestWidth,
    int nDestHeight,
    CDC* pSrcDC,
    int xSrc,
    int ySrc,
    int nSrcWidth,
    int nSrcHeight,
    UINT clrTransparent);
```

### <a name="parameters"></a>參數

*xDest*<br/>
指定的 x 座標，以邏輯單位，目的地矩形左上角。

*yDest*<br/>
指定 y 軸座標，以邏輯單位，目的地矩形左上角。

*nDestWidth*<br/>
指定寬度，以目的地矩形的邏輯單位。

*nDestHeight*<br/>
指定高度，以目的地矩形的邏輯單位。

*pSrcDC*<br/>
來源裝置內容指標。

*xSrc*<br/>
指定 x 軸座標，以邏輯單位，來源矩形。

*ySrc*<br/>
指定 y 軸座標，以邏輯單位，來源矩形。

*nSrcWidth*<br/>
指定寬度，以邏輯單位，來源矩形。

*nSrcHeight*<br/>
指定高度，以邏輯單位，來源矩形。

*clrTransparent*<br/>
中要視為透明的來源點陣圖的 RGB 色彩。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

`TransparentBlt` 可讓透明度;也就是 RGB 色彩會由*clrTransparent*呈現透明傳輸。

如需詳細資訊，請參閱 < [TransparentBlt](/windows/desktop/api/wingdi/nf-wingdi-transparentblt) Windows SDK 中。

##  <a name="updatecolors"></a>  CDC::UpdateColors

更新裝置內容比對目前的工作區中系統調色盤像素 x 像素為基礎的用戶端區域的色彩。

```
void UpdateColors();
```

### <a name="remarks"></a>備註

可能會呼叫非現用視窗的具現化的邏輯色板`UpdateColors`作為系統調色盤變更時，重繪其工作區的替代方案。

如需使用色彩調色盤的詳細資訊，請參閱[UpdateColors](/windows/desktop/api/wingdi/nf-wingdi-updatecolors) Windows SDK 中。

`UpdateColors`成員函式通常會更新工作區比重新繪製的區域更快。 不過，因為函式會執行系統調色盤變更之前，根據每個像素色彩的色彩轉譯，每個呼叫此函式就會導致某些色彩精確度。

##  <a name="widenpath"></a>  CDC::WidenPath

如果路徑圖案使用目前選取的裝置內容到畫筆會繪製的區域來重新定義目前的路徑。

```
BOOL WidenPath();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此函式會成功，只有當目前的畫筆的第二個版本所建立的幾何畫筆`CreatePen`成員函式，或如果使用的第一個版本建立畫筆`CreatePen`且寬度，以裝置為單位，大於 1。 裝置內容必須包含已關閉的路徑。 在路徑中的任何 Bzier 曲線轉換成將逼近擴大的曲線的直線，線條的序列。 因此，沒有 Bzier 曲線處於後面的路徑`WidenPath`呼叫。

## <a name="see-also"></a>另請參閱

[CObject 類別](../../mfc/reference/cobject-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[CPaintDC 類別](../../mfc/reference/cpaintdc-class.md)<br/>
[CWindowDC 類別](../../mfc/reference/cwindowdc-class.md)<br/>
[CClientDC 類別](../../mfc/reference/cclientdc-class.md)<br/>
[CMetaFileDC 類別](../../mfc/reference/cmetafiledc-class.md)
