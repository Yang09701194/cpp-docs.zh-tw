---
title: "CDC 類別 |Microsoft 文件"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CDC
- AFXWIN/CDC
- AFXWIN/CDC::CDC
- AFXWIN/CDC::AbortDoc
- AFXWIN/CDC::AbortPath
- AFXWIN/CDC::AddMetaFileComment
- AFXWIN/CDC::AlphaBlend
- AFXWIN/CDC::AngleArc
- AFXWIN/CDC::Arc
- AFXWIN/CDC::ArcTo
- AFXWIN/CDC::Attach
- AFXWIN/CDC::BeginPath
- AFXWIN/CDC::BitBlt
- AFXWIN/CDC::Chord
- AFXWIN/CDC::CloseFigure
- AFXWIN/CDC::CreateCompatibleDC
- AFXWIN/CDC::CreateDC
- AFXWIN/CDC::CreateIC
- AFXWIN/CDC::DeleteDC
- AFXWIN/CDC::DeleteTempMap
- AFXWIN/CDC::Detach
- AFXWIN/CDC::DPtoHIMETRIC
- AFXWIN/CDC::DPtoLP
- AFXWIN/CDC::Draw3dRect
- AFXWIN/CDC::DrawDragRect
- AFXWIN/CDC::DrawEdge
- AFXWIN/CDC::DrawEscape
- AFXWIN/CDC::DrawFocusRect
- AFXWIN/CDC::DrawFrameControl
- AFXWIN/CDC::DrawIcon
- AFXWIN/CDC::DrawState
- AFXWIN/CDC::DrawText
- AFXWIN/CDC::DrawTextEx
- AFXWIN/CDC::Ellipse
- AFXWIN/CDC::EndDoc
- AFXWIN/CDC::EndPage
- AFXWIN/CDC::EndPath
- AFXWIN/CDC::EnumObjects
- AFXWIN/CDC::Escape
- AFXWIN/CDC::ExcludeClipRect
- AFXWIN/CDC::ExcludeUpdateRgn
- AFXWIN/CDC::ExtFloodFill
- AFXWIN/CDC::ExtTextOut
- AFXWIN/CDC::FillPath
- AFXWIN/CDC::FillRect
- AFXWIN/CDC::FillRgn
- AFXWIN/CDC::FillSolidRect
- AFXWIN/CDC::FlattenPath
- AFXWIN/CDC::FloodFill
- AFXWIN/CDC::FrameRect
- AFXWIN/CDC::FrameRgn
- AFXWIN/CDC::FromHandle
- AFXWIN/CDC::GetArcDirection
- AFXWIN/CDC::GetAspectRatioFilter
- AFXWIN/CDC::GetBkColor
- AFXWIN/CDC::GetBkMode
- AFXWIN/CDC::GetBoundsRect
- AFXWIN/CDC::GetBrushOrg
- AFXWIN/CDC::GetCharABCWidths
- AFXWIN/CDC::GetCharABCWidthsI
- AFXWIN/CDC::GetCharacterPlacement
- AFXWIN/CDC::GetCharWidth
- AFXWIN/CDC::GetCharWidthI
- AFXWIN/CDC::GetClipBox
- AFXWIN/CDC::GetColorAdjustment
- AFXWIN/CDC::GetCurrentBitmap
- AFXWIN/CDC::GetCurrentBrush
- AFXWIN/CDC::GetCurrentFont
- AFXWIN/CDC::GetCurrentPalette
- AFXWIN/CDC::GetCurrentPen
- AFXWIN/CDC::GetCurrentPosition
- AFXWIN/CDC::GetDCBrushColor
- AFXWIN/CDC::GetDCPenColor
- AFXWIN/CDC::GetDeviceCaps
- AFXWIN/CDC::GetFontData
- AFXWIN/CDC::GetFontLanguageInfo
- AFXWIN/CDC::GetGlyphOutline
- AFXWIN/CDC::GetGraphicsMode
- AFXWIN/CDC::GetHalftoneBrush
- AFXWIN/CDC::GetKerningPairs
- AFXWIN/CDC::GetLayout
- AFXWIN/CDC::GetMapMode
- AFXWIN/CDC::GetMiterLimit
- AFXWIN/CDC::GetNearestColor
- AFXWIN/CDC::GetOutlineTextMetrics
- AFXWIN/CDC::GetOutputCharWidth
- AFXWIN/CDC::GetOutputTabbedTextExtent
- AFXWIN/CDC::GetOutputTextExtent
- AFXWIN/CDC::GetOutputTextMetrics
- AFXWIN/CDC::GetPath
- AFXWIN/CDC::GetPixel
- AFXWIN/CDC::GetPolyFillMode
- AFXWIN/CDC::GetROP2
- AFXWIN/CDC::GetSafeHdc
- AFXWIN/CDC::GetStretchBltMode
- AFXWIN/CDC::GetTabbedTextExtent
- AFXWIN/CDC::GetTextAlign
- AFXWIN/CDC::GetTextCharacterExtra
- AFXWIN/CDC::GetTextColor
- AFXWIN/CDC::GetTextExtent
- AFXWIN/CDC::GetTextExtentExPointI
- AFXWIN/CDC::GetTextExtentPointI
- AFXWIN/CDC::GetTextFace
- AFXWIN/CDC::GetTextMetrics
- AFXWIN/CDC::GetViewportExt
- AFXWIN/CDC::GetViewportOrg
- AFXWIN/CDC::GetWindow
- AFXWIN/CDC::GetWindowExt
- AFXWIN/CDC::GetWindowOrg
- AFXWIN/CDC::GetWorldTransform
- AFXWIN/CDC::GradientFill
- AFXWIN/CDC::GrayString
- AFXWIN/CDC::HIMETRICtoDP
- AFXWIN/CDC::HIMETRICtoLP
- AFXWIN/CDC::IntersectClipRect
- AFXWIN/CDC::InvertRect
- AFXWIN/CDC::InvertRgn
- AFXWIN/CDC::IsPrinting
- AFXWIN/CDC::LineTo
- AFXWIN/CDC::LPtoDP
- AFXWIN/CDC::LPtoHIMETRIC
- AFXWIN/CDC::MaskBlt
- AFXWIN/CDC::ModifyWorldTransform
- AFXWIN/CDC::MoveTo
- AFXWIN/CDC::OffsetClipRgn
- AFXWIN/CDC::OffsetViewportOrg
- AFXWIN/CDC::OffsetWindowOrg
- AFXWIN/CDC::PaintRgn
- AFXWIN/CDC::PatBlt
- AFXWIN/CDC::Pie
- AFXWIN/CDC::PlayMetaFile
- AFXWIN/CDC::PlgBlt
- AFXWIN/CDC::PolyBezier
- AFXWIN/CDC::PolyBezierTo
- AFXWIN/CDC::PolyDraw
- AFXWIN/CDC::Polygon
- AFXWIN/CDC::Polyline
- AFXWIN/CDC::PolylineTo
- AFXWIN/CDC::PolyPolygon
- AFXWIN/CDC::PolyPolyline
- AFXWIN/CDC::PtVisible
- AFXWIN/CDC::RealizePalette
- AFXWIN/CDC::Rectangle
- AFXWIN/CDC::RectVisible
- AFXWIN/CDC::ReleaseAttribDC
- AFXWIN/CDC::ReleaseOutputDC
- AFXWIN/CDC::ResetDC
- AFXWIN/CDC::RestoreDC
- AFXWIN/CDC::RoundRect
- AFXWIN/CDC::SaveDC
- AFXWIN/CDC::ScaleViewportExt
- AFXWIN/CDC::ScaleWindowExt
- AFXWIN/CDC::ScrollDC
- AFXWIN/CDC::SelectClipPath
- AFXWIN/CDC::SelectClipRgn
- AFXWIN/CDC::SelectObject
- AFXWIN/CDC::SelectPalette
- AFXWIN/CDC::SelectStockObject
- AFXWIN/CDC::SetAbortProc
- AFXWIN/CDC::SetArcDirection
- AFXWIN/CDC::SetAttribDC
- AFXWIN/CDC::SetBkColor
- AFXWIN/CDC::SetBkMode
- AFXWIN/CDC::SetBoundsRect
- AFXWIN/CDC::SetBrushOrg
- AFXWIN/CDC::SetColorAdjustment
- AFXWIN/CDC::SetDCBrushColor
- AFXWIN/CDC::SetDCPenColor
- AFXWIN/CDC::SetGraphicsMode
- AFXWIN/CDC::SetLayout
- AFXWIN/CDC::SetMapMode
- AFXWIN/CDC::SetMapperFlags
- AFXWIN/CDC::SetMiterLimit
- AFXWIN/CDC::SetOutputDC
- AFXWIN/CDC::SetPixel
- AFXWIN/CDC::SetPixelV
- AFXWIN/CDC::SetPolyFillMode
- AFXWIN/CDC::SetROP2
- AFXWIN/CDC::SetStretchBltMode
- AFXWIN/CDC::SetTextAlign
- AFXWIN/CDC::SetTextCharacterExtra
- AFXWIN/CDC::SetTextColor
- AFXWIN/CDC::SetTextJustification
- AFXWIN/CDC::SetViewportExt
- AFXWIN/CDC::SetViewportOrg
- AFXWIN/CDC::SetWindowExt
- AFXWIN/CDC::SetWindowOrg
- AFXWIN/CDC::SetWorldTransform
- AFXWIN/CDC::StartDoc
- AFXWIN/CDC::StartPage
- AFXWIN/CDC::StretchBlt
- AFXWIN/CDC::StrokeAndFillPath
- AFXWIN/CDC::StrokePath
- AFXWIN/CDC::TabbedTextOut
- AFXWIN/CDC::TextOut
- AFXWIN/CDC::TransparentBlt
- AFXWIN/CDC::UpdateColors
- AFXWIN/CDC::WidenPath
- AFXWIN/CDC::m_hAttribDC
- AFXWIN/CDC::m_hDC
dev_langs:
- C++
helpviewer_keywords:
- Windows [C++], device contexts
- Windows 95 [C++], screen coordinates
- device contexts [C++], CDC class
- screen coordinates in device contexts
- coordinates in Windows 95/98 [C++]
- Windows 98 [C++], screen coordinates
- CDC class
ms.assetid: 715b3334-cb2b-4c9c-8067-02eb7c66c8b2
caps.latest.revision: 21
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 0e0c08ddc57d437c51872b5186ae3fc983bb0199
ms.openlocfilehash: 80ccd3f8bed6bd74e22d4db5e176ee50528d3187
ms.lasthandoff: 02/24/2017

---
# <a name="cdc-class"></a>CDC 類別
定義裝置內容物件的類別。  
  
## <a name="syntax"></a>語法  
  
```  
class CDC : public CObject  
```  
  
## <a name="members"></a>Members  
  
### <a name="public-constructors"></a>公用建構函式  
  
|名稱|說明|  
|----------|-----------------|  
|[CDC::CDC](#cdc)|建構 `CDC` 物件。|  
  
### <a name="public-methods"></a>公用方法  
  
|名稱|說明|  
|----------|-----------------|  
|[CDC::AbortDoc](#abortdoc)|終止目前的列印工作，清除所有項目自上次呼叫的應用程式寫至裝置`StartDoc`成員函式。|  
|[CDC::AbortPath](#abortpath)|關閉並捨棄任何在裝置內容中的路徑。|  
|[CDC::AddMetaFileComment](#addmetafilecomment)|將註解緩衝區複製到指定的格式增強型中繼檔。|  
|[CDC::AlphaBlend](#alphablend)|顯示具有透明或半透明的像素的點陣圖。|  
|[CDC::AngleArc](#anglearc)|繪製的直線線段與弧形，並將目前位置移到弧形結束點。|  
|[CDC::Arc](#arc)|繪製橢圓弧形。|  
|[CDC::ArcTo](#arcto)|繪製橢圓弧形。 此函式是類似於`Arc`，除了目前的位置會更新。|  
|[CDC::Attach](#attach)|將 Windows 裝置內容附加至這個`CDC`物件。|  
|[Cdc:: beginpath](#beginpath)|裝置內容中開啟路徑括號。|  
|[CDC::BitBlt](#bitblt)|複製點陣圖，從指定的裝置內容。|  
|[CDC::Chord](#chord)|繪製弦 （橢圓形和直線線段的交集所繫結到封閉的圖表）。|  
|[CDC::CloseFigure](#closefigure)|關閉開放的圖形路徑中。|  
|[CDC::CreateCompatibleDC](#createcompatibledc)|建立與另一個裝置內容的記憶體裝置內容。 您可以使用它來準備映像在記憶體中。|  
|[CDC::CreateDC](#createdc)|建立特定裝置的裝置內容。|  
|[CDC::CreateIC](#createic)|建立特定裝置的資訊內容。 這提供快速的方式，來取得裝置的相關資訊，而建立的裝置內容。|  
|[CDC::DeleteDC](#deletedc)|刪除與此相關聯的 Windows 裝置內容`CDC`物件。|  
|[CDC::DeleteTempMap](#deletetempmap)|由呼叫`CWinApp`閒置時間處理常式，以刪除任何暫存`CDC`所建立物件`FromHandle`。 也會一併中斷裝置內容。|  
|[CDC::Detach](#detach)|中斷連結的 Windows 裝置內容，從這個`CDC`物件。|  
|[CDC::DPtoHIMETRIC](#dptohimetric)|將轉換成裝置單位**HIMETRIC**單位。|  
|[CDC::DPtoLP](#dptolp)|將裝置單位轉換成邏輯單元。|  
|[CDC::Draw3dRect](#draw3drect)|繪製&3;d 矩形。|  
|[CDC::DrawDragRect](#drawdragrect)|清除並重新繪製矩形，如拖曳。|  
|[CDC::DrawEdge](#drawedge)|繪製矩形邊緣。|  
|[CDC::DrawEscape](#drawescape)|繪製未直接提供的圖形裝置介面 (GDI) 視訊顯示功能的存取。|  
|[CDC::DrawFocusRect](#drawfocusrect)|用來指出焦點的樣式繪製的矩形。|  
|[CDC::DrawFrameControl](#drawframecontrol)|繪製框架控制項。|  
|[CDC::DrawIcon](#drawicon)|繪製圖示。|  
|[CDC::DrawState](#drawstate)|顯示影像，並套用視覺效果來指示狀態。|  
|[CDC::DrawText](#drawtext)|繪製格式化的文字中指定的矩形。|  
|[CDC::DrawTextEx](#drawtextex)|繪製格式化的文字中指定的矩形，使用其他格式。|  
|[CDC::Ellipse](#ellipse)|繪製橢圓形。|  
|[CDC::EndDoc](#enddoc)|結束所啟動的列印工作`StartDoc`成員函式。|  
|[CDC::EndPage](#endpage)|通知裝置驅動程式結束時的頁面。|  
|[CDC::EndPath](#endpath)|關閉路徑括號，並選取放入裝置內容以方括號所定義的路徑。|  
|[Cdc:: enumobjects](#enumobjects)|列舉畫筆和筆刷在裝置內容中使用。|  
|[CDC::Escape](#escape)|允許應用程式存取不是直接使用來自 GDI 透過特定裝置的功能。 也可讓 Windows 逸出功能的存取權。 應用程式所做的逸出呼叫會轉譯，並傳送到裝置的驅動程式。|  
|[CDC::ExcludeClipRect](#excludecliprect)|建立新的裁剪區域，其中包含現有的裁剪區域減去指定的矩形。|  
|[CDC::ExcludeUpdateRgn](#excludeupdatergn)|藉由從裁剪區域排除在視窗中的更新的區域，可防止無效視窗區域內的繪圖。|  
|[CDC::ExtFloodFill](#extfloodfill)|使用目前的筆刷，填滿某個區域。 提供更大的彈性比[CDC::FloodFill](#floodfill)成員函式。|  
|[CDC::ExtTextOut](#exttextout)|將矩形區域，使用目前選取的字型中的字元字串。|  
|[CDC::FillPath](#fillpath)|關閉任何開啟的圖形，在目前路徑，並使用目前的筆刷和填滿的多邊形模式填滿的路徑內部。|  
|[CDC::FillRect](#fillrect)|使用特定的筆刷填滿指定的矩形。|  
|[CDC::FillRgn](#fillrgn)|特定區域中填入指定的筆刷。|  
|[CDC::FillSolidRect](#fillsolidrect)|使用純色，填滿的矩形。|  
|[CDC::FlattenPath](#flattenpath)|轉換到目前的裝置內容中，選取的路徑中的任何型曲線，並將每個曲線轉成一連串的程式碼行。|  
|[CDC::FloodFill](#floodfill)|使用目前的筆刷，填滿某個區域。|  
|[CDC::FrameRect](#framerect)|繪製矩形周圍的框線。|  
|[CDC::FrameRgn](#framergn)|使用筆刷的特定區域周圍繪製框線。|  
|[CDC::FromHandle](#fromhandle)|若要將指標傳回`CDC`物件指定的裝置內容控制代碼時。 如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。|  
|[CDC::GetArcDirection](#getarcdirection)|傳回目前弧線方向裝置內容。|  
|[CDC::GetAspectRatioFilter](#getaspectratiofilter)|擷取目前的長寬比篩選條件的設定。|  
|[CDC::GetBkColor](#getbkcolor)|擷取目前的背景色彩。|  
|[CDC::GetBkMode](#getbkmode)|擷取背景模式。|  
|[CDC::GetBoundsRect](#getboundsrect)|傳回指定之的裝置內容的目前累積週框。|  
|[CDC::GetBrushOrg](#getbrushorg)|擷取目前的筆刷的原點。|  
|[CDC::GetCharABCWidths](#getcharabcwidths)|擷取的寬度，以邏輯單位，指定的範圍從目前的字型中的連續字元。|  
|[CDC::GetCharABCWidthsI](#getcharabcwidthsi)|擷取的寬度，以邏輯單位，從目前的 TrueType 字型在指定範圍中的連續圖像索引。|  
|[CDC::GetCharacterPlacement](#getcharacterplacement)|擷取各種類型的字元字串的詳細資訊。|  
|[CDC::GetCharWidth](#getcharwidth)|擷取目前字型的特定範圍中的連續字元分數的寬度。|  
|[CDC::GetCharWidthI](#getcharwidthi)|擷取的寬度，以邏輯座標，從目前字型的指定範圍內的連續圖像索引。|  
|[CDC::GetClipBox](#getclipbox)|擷取目前裁剪界限周圍 tightest 週框的維度。|  
|[CDC::GetColorAdjustment](#getcoloradjustment)|擷取裝置內容的色彩調整值。|  
|[CDC::GetCurrentBitmap](#getcurrentbitmap)|將指標傳回至目前選取之`CBitmap`物件。|  
|[CDC::GetCurrentBrush](#getcurrentbrush)|將指標傳回至目前選取之`CBrush`物件。|  
|[CDC::GetCurrentFont](#getcurrentfont)|將指標傳回至目前選取之`CFont`物件。|  
|[CDC::GetCurrentPalette](#getcurrentpalette)|將指標傳回至目前選取之`CPalette`物件。|  
|[CDC::GetCurrentPen](#getcurrentpen)|將指標傳回至目前選取之`CPen`物件。|  
|[CDC::GetCurrentPosition](#getcurrentposition)|擷取目前的畫筆位置 （以邏輯座標表示）。|  
|[CDC::GetDCBrushColor](#getdcbrushcolor)|擷取目前的筆刷色彩。|  
|[CDC::GetDCPenColor](#getdcpencolor)|擷取目前的畫筆顏色。|  
|[Rastercaps](#getdevicecaps)|擷取指定的特定的顯示裝置的功能的裝置特定資訊種類。|  
|[CDC::GetFontData](#getfontdata)|擷取可調式字型檔案中的字型度量資訊。 指定位移至字型檔案，以及要傳回的資訊來識別要擷取之資訊。|  
|[CDC::GetFontLanguageInfo](#getfontlanguageinfo)|傳回指定的顯示內容的目前選取字型的相關資訊。|  
|[CDC::GetGlyphOutline](#getglyphoutline)|擷取大綱曲線或大綱中的字元之目前字型的點陣圖。|  
|[CDC::GetGraphicsMode](#getgraphicsmode)|擷取指定之的裝置內容中目前的圖形模式。|  
|[CDC::GetHalftoneBrush](#gethalftonebrush)|取得半色調筆刷。|  
|[CDC::GetKerningPairs](#getkerningpairs)|擷取的字元間距調整組指定的裝置內容中目前選取的字型。|  
|[CDC::GetLayout](#getlayout)|擷取裝置內容 (DC) 的配置。 從左至右 （預設值） 或由右至左配置是可保留 （鏡像）。|  
|[CDC::GetMapMode](#getmapmode)|擷取目前的對應模式。|  
|[CDC::GetMiterLimit](#getmiterlimit)|傳回斜裝置內容。|  
|[CDC::GetNearestColor](#getnearestcolor)|擷取最接近指定的裝置可以表示為指定邏輯色彩邏輯色彩。|  
|[CDC::GetOutlineTextMetrics](#getoutlinetextmetrics)|擷取 TrueType 字型的字型度量資訊。|  
|[CDC::GetOutputCharWidth](#getoutputcharwidth)|擷取目前使用的輸出裝置內容的字型顯示連續的字元群組中的個別字元的寬度。|  
|[CDC::GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|計算字元字串輸出裝置內容上的高度與寬度。|  
|[CDC::GetOutputTextExtent](#getoutputtextextent)|計算使用來決定維度的目前字型的輸出裝置內容上的文字行的高度與寬度。|  
|[CDC::GetOutputTextMetrics](#getoutputtextmetrics)|擷取輸出裝置內容中的目前字型度量資訊。|  
|[CDC::GetPath](#getpath)|擷取定義線條的端點和選入裝置內容的路徑中找到的曲線的控制點的座標。|  
|[CDC::GetPixel](#getpixel)|擷取位於指定點的像素的 RGB 色彩值。|  
|[CDC::GetPolyFillMode](#getpolyfillmode)|擷取目前的多邊形填滿模式。|  
|[CDC::GetROP2](#getrop2)|擷取目前的繪圖模式。|  
|[CDC::GetSafeHdc](#getsafehdc)|傳回[CDC::m_hDC](#m_hdc)，輸出裝置內容。|  
|[CDC::GetStretchBltMode](#getstretchbltmode)|擷取目前的點陣圖自動縮放模式。|  
|[CDC::GetTabbedTextExtent](#gettabbedtextextent)|計算的寬度和高度屬性裝置內容上的字元字串。|  
|[CDC::GetTextAlign](#gettextalign)|擷取文字對齊方式的旗標。|  
|[CDC::GetTextCharacterExtra](#gettextcharacterextra)|擷取 intercharacter 間距所需的目前設定。|  
|[CDC::GetTextColor](#gettextcolor)|擷取目前的文字色彩。|  
|[CDC::GetTextExtent](#gettextextent)|計算來決定維度使用目前的字型屬性裝置內容上的文字行的高度與寬度。|  
|[CDC::GetTextExtentExPointI](#gettextextentexpointi)|擷取指定的字串，將符合指定的空間內，且陣列填入每個字元的文字範圍中的字元數。|  
|[CDC::GetTextExtentPointI](#gettextextentpointi)|擷取指定之陣列的圖像 （glyph） 索引的高度與寬度。|  
|[CDC::GetTextFace](#gettextface)|複製到緩衝區的目前字型的字樣名稱以 null 終止字串。|  
|[CDC::GetTextMetrics](#gettextmetrics)|擷取屬性的裝置內容中的目前字型度量資訊。|  
|[CDC::GetViewportExt](#getviewportext)|擷取 x-和 y-範圍檢視區。|  
|[CDC::GetViewportOrg](#getviewportorg)|擷取檢視區原點 x 和 y 座標。|  
|[CDC::GetWindow](#getwindow)|傳回顯示裝置內容相關聯的視窗。|  
|[CDC::GetWindowExt](#getwindowext)|擷取 x-和 y-範圍相關聯的視窗。|  
|[CDC::GetWindowOrg](#getwindoworg)|擷取相關聯的視窗原點 x 和 y 座標。|  
|[CDC::GetWorldTransform](#getworldtransform)|擷取目前頁面空間轉換到全球空白字元。|  
|[CDC::GradientFill](#gradientfill)|矩形和三角形結構填入 gradating 的色彩。|  
|[Cdc:: graystring](#graystring)|繪製呈現暗灰色 （灰色） 在指定位置的文字。|  
|[CDC::HIMETRICtoDP](#himetrictodp)|將轉換**HIMETRIC**成裝置單位的單位。|  
|[CDC::HIMETRICtoLP](#himetrictolp)|將轉換**HIMETRIC**成邏輯單元的單位。|  
|[CDC::IntersectClipRect](#intersectcliprect)|藉由形成目前區域和矩形的交集來建立新的裁剪區域。|  
|[CDC::InvertRect](#invertrect)|反轉矩形的內容。|  
|[CDC::InvertRgn](#invertrgn)|反轉區域中的色彩。|  
|[CDC::IsPrinting](#isprinting)|判斷是否正在使用的裝置內容進行列印。|  
|[CDC::LineTo](#lineto)|從目前的位置，但不是包括、 點繪製直線。|  
|[CDC::LPtoDP](#lptodp)|將邏輯單元轉換成裝置單位。|  
|[CDC::LPtoHIMETRIC](#lptohimetric)|將轉換成邏輯單元**HIMETRIC**單位。|  
|[CDC::MaskBlt](#maskblt)|結合使用指定的遮罩與點陣化操作的來源和目的地點陣圖的色彩資料。|  
|[CDC::ModifyWorldTransform](#modifyworldtransform)|變更裝置內容中使用指定的模式的自然轉換。|  
|[CDC::MoveTo](#moveto)|移動目前的位置。|  
|[CDC::OffsetClipRgn](#offsetcliprgn)|移動指定的裝置的裁剪區域。|  
|[CDC::OffsetViewportOrg](#offsetviewportorg)|修改檢視區原點，相對於目前的檢視區原點座標。|  
|[CDC::OffsetWindowOrg](#offsetwindoworg)|修改視窗原點，相對於目前視窗原點座標。|  
|[CDC::PaintRgn](#paintrgn)|與選取的筆刷，填滿區域。|  
|[CDC::PatBlt](#patblt)|建立一個位元模式。|  
|[CDC::Pie](#pie)|繪製派形的楔形。|  
|[CDC::PlayMetaFile](#playmetafile)|指定的裝置上播放指定的中繼檔的內容。 增強型的版本`PlayMetaFile`不會儲存在指定的加強格式中繼檔中的圖片。 中繼檔可以播放次數不限。|  
|[CDC::PlgBlt](#plgblt)|執行從來源裝置內容中指定的矩形的色彩資料位元的位元區塊轉送，來指定的裝置內容中指定的平行四邊形。|  
|[CDC::PolyBezier](#polybezier)|繪製一個或多個 Bzier 曲線。 目前的位置不是使用或更新。|  
|[CDC::PolyBezierTo](#polybezierto)|繪製一個或多個 Bzier 曲線，並將目前位置移至最後一個 Bzier 曲線結束點。|  
|[CDC::PolyDraw](#polydraw)|繪製一組直線線段和 Bzier 曲線。 此函式會更新目前的位置。|  
|[CDC::Polygon](#polygon)|繪製多邊形，其中包含兩個或多個點 （端點） 以折線連接。|  
|[CDC::Polyline](#polyline)|繪製一組連接的指定的點之直線線段。|  
|[CDC::PolylineTo](#polylineto)|會繪製一個或多個直線，目前位置移到最後一行的結束位置。|  
|[CDC::PolyPolygon](#polypolygon)|建立兩個或多個使用目前的多邊形填滿模式會填滿的多邊形。 多邊形可能不相鄰，或可能會重疊。|  
|[CDC::PolyPolyline](#polypolyline)|繪製連接的直線線段的多個數列。 目前的位置不是使用或更新此函式。|  
|[CDC::PtVisible](#ptvisible)|指定的裁剪區域中指定的點。|  
|[CDC::RealizePalette](#realizepalette)|將目前的邏輯調色盤中的調色盤項目對應至系統調色盤。|  
|[CDC::Rectangle](#rectangle)|使用目前的畫筆繪製矩形，並填滿它使用目前的筆刷。|  
|[CDC::RectVisible](#rectvisible)|判斷指定的任何的矩形部分是否位於裁剪區域。|  
|[CDC::ReleaseAttribDC](#releaseattribdc)|版本`m_hAttribDC`，屬性的裝置內容。|  
|[CDC::ReleaseOutputDC](#releaseoutputdc)|版本`m_hDC`，輸出裝置內容。|  
|[CDC::ResetDC](#resetdc)|更新`m_hAttribDC`裝置內容。|  
|[CDC::RestoreDC](#restoredc)|將裝置內容還原成先前的狀態，以儲存`SaveDC`。|  
|[CDC::RoundRect](#roundrect)|繪製具有圓角使用目前的畫筆，並使用目前的筆刷填滿的矩形。|  
|[CDC::SaveDC](#savedc)|儲存裝置內容的目前狀態。|  
|[CDC::ScaleViewportExt](#scaleviewportext)|修改檢視區範圍相對於目前的值。|  
|[CDC::ScaleWindowExt](#scalewindowext)|修改視窗範圍相對於目前的值。|  
|[CDC::ScrollDC](#scrolldc)|水平及垂直捲動的位元的矩形。|  
|[CDC::SelectClipPath](#selectclippath)|選取目前的路徑做為裝置內容中，使用指定的模式結合使用任何現有的裁剪區域的新區域的裁剪區域。|  
|[CDC::SelectClipRgn](#selectcliprgn)|使用指定的模式會結合指定的區域與目前裁剪區域。|  
|[CDC::SelectObject](#selectobject)|選取的 GDI 繪圖物件，例如畫筆。|  
|[CDC::SelectPalette](#selectpalette)|選取邏輯調色盤。|  
|[CDC::SelectStockObject](#selectstockobject)|選取其中一個預先定義的內建畫筆、 筆刷或由 Windows 所提供的字型。|  
|[Cdc:: setabortproc](#setabortproc)|設定 Windows 呼叫如果必須中止列印工作的程式設計人員提供的回呼函式。|  
|[CDC::SetArcDirection](#setarcdirection)|設定要用於弧線和矩形函式的繪圖方向。|  
|[CDC::SetAttribDC](#setattribdc)|設定`m_hAttribDC`，屬性的裝置內容。|  
|[CDC::SetBkColor](#setbkcolor)|設定目前的背景色彩。|  
|[CDC::SetBkMode](#setbkmode)|設定背景模式。|  
|[CDC::SetBoundsRect](#setboundsrect)|控制累積的週框矩形指定之的裝置內容的資訊。|  
|[CDC::SetBrushOrg](#setbrushorg)|指定下一步的筆刷選入裝置內容的來源。|  
|[CDC::SetColorAdjustment](#setcoloradjustment)|設定裝置內容，使用指定的值的色彩調整值。|  
|[CDC::SetDCBrushColor](#setdcbrushcolor)|設定目前的筆刷色彩。|  
|[CDC::SetDCPenColor](#setdcpencolor)|設定目前的畫筆顏色。|  
|[CDC::SetGraphicsMode](#setgraphicsmode)|設定指定之的裝置內容的目前圖形模式。|  
|[CDC::SetLayout](#setlayout)|裝置內容 (DC) 的配置變更。|  
|[CDC::SetMapMode](#setmapmode)|設定目前的對應模式。|  
|[CDC::SetMapperFlags](#setmapperflags)|改變時則會對應至實體字型的邏輯字型字型對應器所使用的演算法。|  
|[CDC::SetMiterLimit](#setmiterlimit)|設定斜接角聯結裝置內容的長度限制。|  
|[CDC::SetOutputDC](#setoutputdc)|設定`m_hDC`，輸出裝置內容。|  
|[CDC::SetPixel](#setpixel)|設定以指定的色彩最接近指定點上的像素。|  
|[CDC::SetPixelV](#setpixelv)|設定以指定的色彩最接近指定座標上的像素。 `SetPixelV`速度比`SetPixel`因為不需傳回實際繪製點的色彩值。|  
|[CDC::SetPolyFillMode](#setpolyfillmode)|將多邊形填滿模式設定。|  
|[CDC::SetROP2](#setrop2)|設定目前的繪圖模式。|  
|[CDC::SetStretchBltMode](#setstretchbltmode)|設定點陣圖縮放模式。|  
|[CDC::SetTextAlign](#settextalign)|設定文字對齊方式的旗標。|  
|[CDC::SetTextCharacterExtra](#settextcharacterextra)|設定 intercharacter 的間距數量。|  
|[CDC::SetTextColor](#settextcolor)|設定文字色彩。|  
|[CDC::SetTextJustification](#settextjustification)|分行符號字元在字串中加上空格。|  
|[CDC::SetViewportExt](#setviewportext)|設定 x-和 y-範圍檢視區。|  
|[CDC::SetViewportOrg](#setviewportorg)|設定檢視區原點。|  
|[CDC::SetWindowExt](#setwindowext)|設定 x-和 y-範圍相關聯的視窗。|  
|[CDC::SetWindowOrg](#setwindoworg)|設定裝置內容的視窗原點。|  
|[CDC::SetWorldTransform](#setworldtransform)|將目前的世界空間設定分頁空間轉換。|  
|[CDC::StartDoc](#startdoc)|正在啟動新的列印工作的裝置驅動程式，就會通知。|  
|[CDC::StartPage](#startpage)|通知裝置驅動程式正在啟動新的頁面。|  
|[CDC::StretchBlt](#stretchblt)|將點陣圖從來源矩形和裝置移到目的地矩形，自動縮放或壓縮點陣圖，如有必要符合目的地矩形的尺寸。|  
|[CDC::StrokeAndFillPath](#strokeandfillpath)|關閉任何開啟的圖形路徑中，使用目前的畫筆，可達到的路徑外框，填滿它的內部使用目前的筆刷。|  
|[CDC::StrokePath](#strokepath)|使用目前的畫筆轉譯指定的路徑。|  
|[CDC::TabbedTextOut](#tabbedtextout)|將指定的位置，並展開索引標籤的定位停駐點位置陣列中指定的值在字元字串。|  
|[CDC::TextOut](#textout)|將字元字串，在指定的位置，使用目前選取的字型。|  
|[CDC::TransparentBlt](#transparentblt)|從指定的來源裝置內容的色彩資料位元區塊傳輸入轉譯指定的色彩透明在傳送到目的地裝置內容中。|  
|[CDC::UpdateColors](#updatecolors)|更新工作區會比對目前的裝置內容的系統調色盤像素 x 像素為基礎的用戶端區域中的色彩。|  
|[CDC::WidenPath](#widenpath)|如果路徑圖案使用目前選取到裝置內容的畫筆會繪製的區域來重新定義目前的路徑。|  
  
### <a name="public-operators"></a>公用運算子  
  
|名稱|描述|  
|----------|-----------------|  
|[CDC::operator HDC](#operator_hdc)|擷取裝置內容的控制代碼。|  
  
### <a name="public-data-members"></a>公用資料成員  
  
|名稱|說明|  
|----------|-----------------|  
|[CDC::m_hAttribDC](#m_hattribdc)|使用此屬性內容`CDC`物件。|  
|[CDC::m_hDC](#m_hdc)|這所使用的輸出裝置內容`CDC`物件。|  
  
## <a name="remarks"></a>備註  
 `CDC`物件提供成員函式使用的裝置內容，例如顯示器或印表機，以及成員使用的視窗工作區相關聯的顯示內容。  
  
 執行所有的繪圖，透過成員函式的`CDC`物件。 此類別提供成員函式的裝置內容的作業，使用繪圖工具，型別安全圖形裝置介面 (GDI) 物件選取範圍，以及使用色彩與調色盤。 它也提供成員函式，取得或設定繪製屬性，對應、 使用檢視區中，使用視窗範圍內，轉換座標、 使用區域，裁剪、 繪製線條，和繪製簡單圖形、 橢圓形和多邊形。 成員函式也會提供來繪製文字、 使用字型、 使用印表機逸出字元、 向下捲動，以及玩中繼檔。  
  
 若要使用`CDC`物件，建構它，然後呼叫其成員的平行使用裝置內容的 Windows 函式的函式。  
  
> [!NOTE]
>  在 Windows 95/98，所有的螢幕座標會限制為 16 位元。 因此，`int`傳遞至`CDC`成員函式必須介於-32768 到 32767 之間。  
  
 針對特定用途，Mfc 程式庫提供數個類別衍生自`CDC`。 `CPaintDC`封裝呼叫`BeginPaint`和`EndPaint`。 `CClientDC`管理視窗的工作區相關聯的顯示內容。 `CWindowDC`管理整個視窗，包括其框架與控制項相關聯的顯示內容。 `CMetaFileDC`關聯中繼檔裝置內容。  
  
 `CDC`提供兩個成員函式， [GetLayout](#getlayout)和[SetLayout](#setlayout)，破裝置內容，不會繼承其配置從視窗的配置。 這種由右至左的方向就必須撰寫的文化特性，例如阿拉伯文或希伯來文字元配置並不是歐洲的標準應用程式。  
  
 `CDC`包含兩種裝置內容， [m_hDC](#m_hdc)和[m_hAttribDC](#m_hattribdc)，它會在建立`CDC`物件，請參閱在相同的裝置。 `CDC`將導向所有輸出 GDI 呼叫`m_hDC`和大部分屬性 GDI 呼叫`m_hAttribDC`。 (屬性呼叫的範例是`GetTextColor`，雖然`SetTextColor`是輸出呼叫。)  
  
 比方說，架構會使用這兩個裝置的內容來實作`CMetaFileDC`會將輸出傳送到中繼檔從實體裝置讀取的屬性時的物件。 預覽列印中的架構類似的方式實作。 您也可以使用兩個裝置的內容類似的方式，在您的應用程式特定程式碼。  
  
 當您需要同時從文字度量資訊有時候`m_hDC`和`m_hAttribDC`裝置內容。 下列函式的括號會提供這項功能︰  
  
|使用 m_hAttribDC|使用 m_hDC|  
|-----------------------|-----------------|  
|[GetTextExtent](#gettextextent)|[GetOutputTextExtent](#getoutputtextextent)|  
|[GetTabbedTextExtent](#gettabbedtextextent)|[GetOutputTabbedTextExtent](#getoutputtabbedtextextent)|  
|[GetTextMetrics](#gettextmetrics)|[GetOutputTextMetrics](#getoutputtextmetrics)|  
|[GetCharWidth](#getcharwidth)|[GetOutputCharWidth](#getoutputcharwidth)|  
  
 如需有關`CDC`，請參閱[裝置內容](../../mfc/device-contexts.md)。  
  
## <a name="inheritance-hierarchy"></a>繼承階層  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 `CDC`  
  
## <a name="requirements"></a>需求  
 **標題:** afxwin.h  
  
##  <a name="abortdoc"></a>CDC::AbortDoc  
 結束目前的列印工作，並清除應用程式已自上次呼叫來寫入裝置的所有項目[Cdc](#startdoc)成員函式。  
  
```  
int AbortDoc();
```  
  
### <a name="return-value"></a>傳回值  
 值大於或等於 0，如果成功或如果發生錯誤的負值。 下列清單顯示常見的錯誤值和其意義︰  
  
- **SP_ERROR**一般錯誤。  
  
- **SP_OUTOFDISK**沒有足夠磁碟空間目前適用於多工緩衝處理，但沒有更多的空間將會變成可用。  
  
- **SP_OUTOFMEMORY**沒有足夠的記憶體可供多工緩衝處理。  
  
- **SP_USERABORT**使用者終止列印管理員該工作。  
  
### <a name="remarks"></a>備註  
 這個成員函式取代`ABORTDOC`印表機逸出。  
  
 **AbortDoc**應該用來終止下列︰  
  
-   未指定中止函式使用的列印作業[SetAbortProc](#setabortproc)。  
  
-   列印作業尚未到達其第一個**NEWFRAME**或**NEXTBAND**逸出呼叫。  
  
 如果應用程式發生列印錯誤或已取消的列印作業時，它必須嘗試將終止作業使用[EndDoc](#enddoc)或**AbortDoc**類別成員函式`CDC`。 GDI 自動終止作業，再傳回錯誤值。  
  
 如果應用程式顯示對話方塊，讓使用者取消列印作業，則必須呼叫**AbortDoc**之前終結對話方塊。  
  
 如果列印管理員用來開始列印工作，則呼叫**AbortDoc**清除整個多工緩衝處理工作，印表機會收到 nothing。 如果列印管理員不用來開始列印工作，資料可能已傳送至印表機之前**AbortDoc**呼叫。 在此情況下，印表機驅動程式會重設印表機 （自動），並關閉列印工作。  
  
### <a name="example"></a>範例  
  請參閱範例[CDC::StartDoc](#startdoc)。  
  
##  <a name="abortpath"></a>CDC::AbortPath  
 關閉並捨棄任何在裝置內容中的路徑。  
  
```  
BOOL AbortPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 如果在裝置內容中有開放的路徑括號，路徑括號會關閉，而路徑則會捨棄。 如果在裝置內容中沒有封閉的路徑，路徑會被捨棄。  
  
##  <a name="addmetafilecomment"></a>CDC::AddMetaFileComment  
 將註解緩衝區複製到指定的格式增強型中繼檔。  
  
```  
BOOL AddMetaFileComment(
    UINT nDataSize,  
    const BYTE* pCommentData);
```  
  
### <a name="parameters"></a>參數  
 *nDataSize*  
 指定的註解緩衝區長度，以位元組為單位。  
  
 *pCommentData*  
 包含註解的緩衝區的指標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 註解可以包含任何私人資訊 — 例如，圖片和日期的來源建立。 註解的開頭應該應用程式簽章，後面接著資料。 註解不應包含位置特定資料。 位置特定的資料指定記錄的位置，則不應該包含一個中繼檔可能會內嵌在另一個中繼檔，因為。 此函式僅能使用增強型中繼檔。  
  
##  <a name="alphablend"></a>CDC::AlphaBlend  
 呼叫此成員函式，以顯示具有透明或半透明的像素的點陣圖。  
  
```  
BOOL AlphaBlend(
    int xDest,  
    int yDest,  
    int nDestWidth,  
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    BLENDFUNCTION blend);
```  
  
### <a name="parameters"></a>參數  
 `xDest`  
 指定邏輯單元，目的矩形左上角的 x 座標。  
  
 `yDest`  
 指定邏輯單元，目的矩形左上角的 y 軸座標。  
  
 `nDestWidth`  
 目的矩形的邏輯單位中指定的寬度。  
  
 `nDestHeight`  
 目的矩形的邏輯單位中指定的高度。  
  
 `pSrcDC`  
 來源裝置內容指標。  
  
 `xSrc`  
 指定邏輯單元，來源矩形左上角的 x 座標。  
  
 `ySrc`  
 指定邏輯單元，來源矩形左上角的 y 座標。  
  
 `nSrcWidth`  
 指定邏輯單元，來源矩形的寬度。  
  
 `nSrcHeight`  
 來源矩形的邏輯單位中指定的高度。  
  
 *blend*  
 指定[BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393)結構。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果成功，否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 請參閱[alphablend，還有旁邊](http://msdn.microsoft.com/library/windows/desktop/dd183351)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需詳細資訊。  
  
##  <a name="anglearc"></a>CDC::AngleArc  
 繪製的直線線段與圓弧。  
  
```  
BOOL AngleArc(
    int x,  
    int y,  
    int nRadius,  
    float fStartAngle,  
    float fSweepAngle);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定圓形的中心的邏輯 x 座標。  
  
 *y*  
 指定圓形的中心的邏輯 y 座標。  
  
 *nRadius*  
 指定圓形的半徑，以邏輯單位表示。 此值必須是正數。  
  
 *fStartAngle*  
 指定的開始角度，以度為單位的相對 x 軸。  
  
 *fSweepAngle*  
 指定掃掠角度，以度為單位的相對的開始角度。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 從目前的位置繪製直線線段弧形的開頭。 繪製弧形沿著指定的 radius 與中心圓的周邊。 指定的開始和掃掠角度均弧形的長度。  
  
 `AngleArc`目前的位置移到弧形結束點。 此函式來繪製弧形似乎橢圓，根據目前的轉換和對應模式而定。 繪製弧形之前, 此函式會繪製直線線段，從目前位置到弧形開始。 藉由建構繞著指定的中心點的指定半徑虛數圓形繪製弧形。 以逆時針方向從圓形的 x 軸測量的開始角度的度數取決於弧形的起點。 同樣地結束點位於測量以逆時針方向從起點掃掠角度的度數。  
  
 如果掃掠角度大於 360 度弧線是清理多次。 此函式使用目前畫筆繪製線條。 此圖不會填滿。  
  
##  <a name="arc"></a>CDC::Arc  
 繪製橢圓弧形。  
  
```  
BOOL Arc(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Arc(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示），這個周框左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示），這個周框左上角的 y 座標。  
  
 `x2`  
 指定週框 （以邏輯單位表示） 的右下角的 x 座標。  
  
 `y2`  
 指定週框 （以邏輯單位表示） 的右下角的 y 座標。  
  
 *x3*  
 指定定義弧形的點的 x 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `y3`  
 指定定義弧形的點的 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `x4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 x 座標。 此時沒有完全位於弧線。  
  
 `y4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 y 座標。 此時沒有完全位於弧線。  
  
 `lpRect`  
 指定週框 （以邏輯單位表示）。 您可以傳遞`LPRECT`或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `ptStart`  
 指定定義弧形的點 x 和 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。 您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
 `ptEnd`  
 指定定義的弧形結束點 （以邏輯單位表示） 的點 x 和 y 座標。 此時沒有完全位於弧線。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 使用此函式來繪製圓弧是橢圓形的一段指定的周框所定義。  
  
 弧線的實際起始點是取自透過指定的起點，這個周框 center 光線與交集橢圓形的點。 實際弧形結束點是取自透過指定的結束點，這個周框 center 光線與交集橢圓形的點。 以逆時針方向繪製弧形。 弧形，不是封閉的圖表，因為它不會填入。 寬度和矩形的高度必須大於 2 個單位且小於 32767 個單位。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&29;](../../mfc/codesnippet/cpp/cdc-class_1.cpp)]  
  
##  <a name="arcto"></a>CDC::ArcTo  
 繪製橢圓弧形。  
  
```  
BOOL ArcTo(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL ArcTo(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示），這個周框左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示），這個周框左上角的 y 座標。  
  
 `x2`  
 指定週框 （以邏輯單位表示） 的右下角的 x 座標。  
  
 `y2`  
 指定週框 （以邏輯單位表示） 的右下角的 y 座標。  
  
 *x3*  
 指定定義弧形的點的 x 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `y3`  
 指定定義弧形的點的 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。  
  
 `x4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 x 座標。 此時沒有完全位於弧線。  
  
 `y4`  
 指定定義弧線的端點 （以邏輯單位表示） 的點的 y 座標。 此時沒有完全位於弧線。  
  
 `lpRect`  
 指定週框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](../../mfc/reference/rect-structure1.md)資料結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `ptStart`  
 指定定義弧形的點 x 和 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弧線。 您可以傳遞[點](../../mfc/reference/point-structure1.md)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
 `ptEnd`  
 指定定義的弧形結束點 （以邏輯單位表示） 的點 x 和 y 座標。 此時沒有完全位於弧線。 您可以傳遞**點**資料結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式是類似於`CDC::Arc`，除了目前的位置會更新。 點 ( `x1`， `y1`) 和 ( `x2`， `y2`) 指定的周框矩形。 指定的周框所形成的橢圓形定義曲線的弧線。 弧線以逆時針方向延伸 （預設反方向） 從它交集星形行至週框的中心點 ( *x3*， `y3`)。 它與交集從地球中心到，這個周框的星形一行弧形結束 ( `x4`， `y4`)。 如果起始點和結束點相同，會繪製完整橢圓形。  
  
 從目前的位置繪製一條線到弧形開始點。 如果沒有發生錯誤，目前位置設定到弧形結束點。 使用目前的畫筆繪製弧形不填滿。  
  
##  <a name="attach"></a>CDC::Attach  
 使用此成員函式附加`hDC`到`CDC`物件。  
  
```  
BOOL Attach(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 Windows 裝置內容。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 `hDC`會儲存在`m_hDC`，輸出裝置內容，然後在`m_hAttribDC`，屬性的裝置內容。  
  
##  <a name="beginpath"></a>Cdc:: beginpath  
 裝置內容中開啟路徑括號。  
  
```  
BOOL BeginPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 開啟路徑括號後，應用程式可以開始呼叫 GDI 繪圖函式定義之間的點的路徑中。 應用程式可以呼叫關閉開放的路徑括號`EndPath`成員函式。 當應用程式呼叫`BeginPath`，任何先前的路徑會被捨棄。  
  
 請參閱[BeginPath](http://msdn.microsoft.com/library/windows/desktop/dd183363)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]點定義路徑中的繪圖功能的清單。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&30;](../../mfc/codesnippet/cpp/cdc-class_2.cpp)]  
  
##  <a name="bitblt"></a>CDC::BitBlt  
 來源裝置內容的點陣圖複製到這個目前的裝置內容。  
  
```  
BOOL BitBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定目的地矩形的左上角的邏輯 x 座標。  
  
 *y*  
 指定目的地矩形的左上角的邏輯 y 座標。  
  
 `nWidth`  
 指定目的地矩形和來源點陣圖的寬度 （以邏輯單位表示）。  
  
 `nHeight`  
 指定目的地矩形和來源點陣圖的高度 （以邏輯單位表示）。  
  
 `pSrcDC`  
 指標`CDC`識別複製點陣圖的裝置內容的物件。 它必須是**NULL**如果*dwRop*指定不包含來源點陣作業。  
  
 `xSrc`  
 指定邏輯來源點陣圖的左上角的 x 座標。  
  
 `ySrc`  
 指定邏輯來源點陣圖的左上角的 y 座標。  
  
 *dwRop*  
 指定待執行的點陣作業。 點陣作業程式碼定義 GDI 結合輸出操作，包括目前的筆刷、 可能的來源點陣圖和目的地點陣圖中色彩的方式。 請參閱[BitBlt](http://msdn.microsoft.com/library/windows/desktop/dd183370)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]為一系列的點陣作業程式碼*dwRop*及其描述  
  
 點陣作業程式碼的完整清單，請參閱[點陣化操作程式碼的相關](http://msdn.microsoft.com/library/windows/desktop/dd162892)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 應用程式可以在 windows 或工作區，確保位元組界限上的對齊`BitBlt`位元組對齊矩形上進行作業。 (設定**CS_BYTEALIGNWINDOW**或**CS_BYTEALIGNCLIENT**旗標，當您註冊視窗類別。)  
  
 `BitBlt`位元組對齊矩形上的作業會明顯比`BitBlt`不是位元組對齊的矩形上的作業。 如果您想要指定類別樣式，例如您自己的裝置內容的位元組對齊，您必須註冊視窗類別而不需依賴 Microsoft Foundation 類別來為您執行此動作。 使用全域函式[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)。  
  
 GDI 轉換`nWidth`和`nHeight`，一次使用目的地裝置內容，以及一次使用來源裝置內容。 如果不相符結果的範圍，GDI 會使用 Windows`StretchBlt`函式，若要壓縮或延伸所需的來源點陣圖。  
  
 如果目的地、 來源和模式點陣圖沒有相同的色彩格式`BitBlt`函式轉換來源和模式點陣圖以符合目的地。 轉換會使用目的地點陣圖的前景和背景色彩。  
  
 當`BitBlt`函式將單色點陣圖轉換成色彩、 將白色位元 (1) 的背景色彩與黑色的位元 (0) 設為前景色彩。 會使用目的地裝置內容的前景和背景色彩。 若要將色彩轉換為單色，`BitBlt`將符合背景色彩為白色像素，並將其他所有像素設為黑色。 `BitBlt`若要將色彩轉換為單色，會使用彩色裝置內容的前景和背景色彩。  
  
 請注意，並非所有的裝置內容支援`BitBlt`。 若要檢查是否支援指定的裝置內容`BitBlt`，使用`GetDeviceCaps`成員函式，並指定**RASTERCAPS**索引。  
  
### <a name="example"></a>範例  
  請參閱範例[CDC::CreateCompatibleDC](#createcompatibledc)。  
  
##  <a name="cdc"></a>CDC::CDC  
 建構 `CDC` 物件。  
  
```  
CDC();
```  
  
##  <a name="chord"></a>CDC::Chord  
 繪製弦 （橢圓形和直線線段的交集所繫結到封閉的圖表）。  
  
```  
BOOL Chord(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Chord(
    LPCRECT lpRect,  
    POINT ptStart,  
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定週框弦左上角的 x 座標 （以邏輯單位表示） 的矩形。  
  
 `y1`  
 指定週框弦左上角的 y 座標 （以邏輯單位表示） 的矩形。  
  
 `x2`  
 指定週框弦右下角的 x 座標 （以邏輯單位表示） 的矩形。  
  
 `y2`  
 指定週框弦右下角的 y 座標 （以邏輯單位表示） 的矩形。  
  
 *x3*  
 指定定義弦點的 x 座標的起點 （以邏輯單位表示）。  
  
 `y3`  
 指定定義弦點的 y 座標的起點 （以邏輯單位表示）。  
  
 `x4`  
 指定定義弦端點 （以邏輯單位表示） 的點的 x 座標。  
  
 `y4`  
 指定定義弦端點 （以邏輯單位表示） 的點的 y 座標。  
  
 `lpRect`  
 指定週框 （以邏輯單位表示）。 您可以傳遞`LPRECT`或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `ptStart`  
 指定定義弦點 x 和 y 座標的起點 （以邏輯單位表示）。 此時沒有完全位於弦。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
 `ptEnd`  
 指定定義弦 （以邏輯單位表示） 的結束點的點 x 和 y 座標。 此時沒有完全位於弦。 您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 ( `x1`， `y1`) 和 ( `x2`， `y2`) 參數的左上角和右下角，分別指定週框屬於弦橢圓形的矩形。 ( *X3*， `y3`) 和 ( `x4`， `y4`) 參數指定相交橢圓形的線條的端點。 弦是使用所選的畫筆繪製，並使用選取的筆刷填滿。  
  
 所繪製的圖`Chord`函式會擴充到，但不包含右側和底端座標。 這表示圖表的高度是`y2`–`y1`圖表的寬度，而且`x2`– `x1`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&31;](../../mfc/codesnippet/cpp/cdc-class_3.cpp)]  
  
##  <a name="closefigure"></a>CDC::CloseFigure  
 關閉開放的圖形路徑中。  
  
```  
BOOL CloseFigure();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 函式會關閉此圖中繪製一條線從目前位置的第一個圖中點 (通常，將最新的呼叫所指定的點`MoveTo`成員函式)，並使用線條聯結樣式連接程式碼行。 如果關閉圖形時使用`LineTo`成員函式，而不是`CloseFigure`，端點用來建立而不是聯結的角。 `CloseFigure`應該只呼叫的裝置內容中開啟路徑括號時。  
  
 除非明確地使用這個函式關閉開放的路徑中的圖形。 （即使目前點和圖形的起始點是相同的圖表可能會開啟）。任何線條或曲線加入路徑後`CloseFigure`開始新的圖形。  
  
##  <a name="createcompatibledc"></a>CDC::CreateCompatibleDC  
 建立與所指定的裝置相容的記憶體裝置內容`pDC`。  
  
```  
BOOL CreateCompatibleDC(CDC* pDC);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 裝置內容的指標。 如果`pDC`是**NULL**，此函數便會與系統顯示記憶體裝置內容。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 記憶體裝置內容是記憶體的代表顯示介面區塊。 它可以用來準備在記憶體中的映像之前將它們複製到相容的裝置的實際裝置介面。  
  
 建立記憶體裝置內容時，GDI 會自動為其選取 1-1 的單色股票點陣圖。 GDI 輸出函式可以搭配記憶體裝置內容，如果已經建立點陣圖，並選取放入該內容。  
  
 此函式只可以用於建立相容的裝置內容之裝置的支援點陣作業。 請參閱[CDC::BitBlt](#bitblt)成員函式，取得關於裝置內容之間的位元區塊傳輸的資訊。 若要判斷裝置的內容是否支援點陣化操作，請參閱**RC_BITBLT**在成員函式中的使用點陣化功能`CDC::GetDeviceCaps`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&32;](../../mfc/codesnippet/cpp/cdc-class_4.cpp)]  
  
##  <a name="createdc"></a>CDC::CreateDC  
 建立指定之裝置的裝置內容。  
  
```  
BOOL CreateDC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>參數  
 `lpszDriverName`  
 指向以 null 結束的字串，指定的檔名 （不含副檔名） 的裝置驅動程式 (例如，「 EPSON 」)。 您也可以傳遞`CString`這個參數的物件。  
  
 `lpszDeviceName`  
 指向以 null 結束的字串，指定要支援特定裝置 （例如，"EPSON FX-80"） 的名稱。 `lpszDeviceName`會使用參數，如果此模組支援多個裝置。 您也可以傳遞`CString`這個參數的物件。  
  
 `lpszOutput`  
 指向以 null 結束的字串，指定實體輸出媒介 （檔案或輸出連接埠） 的檔案或裝置名稱。 您也可以傳遞`CString`這個參數的物件。  
  
 `lpInitData`  
 指向`DEVMODE`包含裝置驅動程式的裝置特定的初始化資料結構。 Windows **DocumentProperties**函式會擷取指定裝置自動填入此結構。 `lpInitData`參數必須是**NULL**裝置驅動程式是否使用使用者透過控制台所指定的預設初始化 （如果有的話）。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 列印。如果 H 標頭檔，則需要[DEVMODE](http://msdn.microsoft.com/library/windows/desktop/dd183565)使用結構。  
  
 裝置名稱遵循下列慣例︰ 結尾的冒號 （:） 是建議，但為選用。 Windows 會去除終止冒號，以便將裝置名稱結尾冒號對應不含冒號的名稱相同的連接埠。 驅動程式和連接埠的名稱不能包含前置或尾端空格。 GDI 輸出函式不能與內容資訊。  
  
##  <a name="createic"></a>CDC::CreateIC  
 建立指定之裝置的資訊內容。  
  
```  
BOOL CreateIC(
    LPCTSTR lpszDriverName,  
    LPCTSTR lpszDeviceName,  
    LPCTSTR lpszOutput,  
    const void* lpInitData);
```  
  
### <a name="parameters"></a>參數  
 `lpszDriverName`  
 指向以 null 結束的字串，指定的檔名 （不含副檔名） 的裝置驅動程式 (例如，「 EPSON 」)。 您可以傳遞`CString`這個參數的物件。  
  
 `lpszDeviceName`  
 指向以 null 結束的字串，指定要支援特定裝置 （例如，"EPSON FX-80"） 的名稱。 `lpszDeviceName`會使用參數，如果此模組支援多個裝置。 您可以傳遞`CString`這個參數的物件。  
  
 `lpszOutput`  
 指向以 null 結束的字串，指定實體輸出媒介 （檔案或連接埠） 的檔案或裝置名稱。 您可以傳遞`CString`這個參數的物件。  
  
 `lpInitData`  
 裝置驅動程式的裝置特定的初始化資料點。 `lpInitData`參數必須是**NULL**裝置驅動程式是否使用使用者透過控制台所指定的預設初始化 （如果有的話）。 請參閱`CreateDC`裝置特定的初始化資料格式。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 資訊內容提供快速的方式，來取得裝置的相關資訊，而建立的裝置內容。  
  
 裝置名稱遵循下列慣例︰ 結尾的冒號 （:） 是建議，但為選用。 Windows 會去除終止冒號，以便將裝置名稱結尾冒號對應不含冒號的名稱相同的連接埠。 驅動程式和連接埠的名稱不能包含前置或尾端空格。 GDI 輸出函式不能與內容資訊。  
  
##  <a name="deletedc"></a>CDC::DeleteDC  
 一般情況下，不會呼叫此函式。解構函式會替您。  
  
```  
BOOL DeleteDC();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零否則為 0。  
  
### <a name="remarks"></a>備註  
 `DeleteDC`成員函式會刪除相關聯的 Windows 裝置內容`m_hDC`目前`CDC`物件。 如果這個`CDC`物件是最後一個作用中的裝置內容指定的裝置，裝置會收到通知時釋放所有裝置所使用的儲存體和系統資源。  
  
 應用程式不應該呼叫`DeleteDC`如果已選取的物件放入裝置內容。 物件之前，必須先選擇從裝置內容就會刪除它。  
  
 應用程式就不能刪除裝置內容控制代碼的取得方式呼叫[CWnd::GetDC](../../mfc/reference/cwnd-class.md#getdc)。 相反地，它必須呼叫[CWnd::ReleaseDC](../../mfc/reference/cwnd-class.md#releasedc)釋放裝置內容。 [CClientDC](../../mfc/reference/cclientdc-class.md)和[CWindowDC](../../mfc/reference/cwindowdc-class.md)類別，可將這項功能。  
  
 `DeleteDC`函式通常用來刪除裝置內容以建立[CreateDC](#createdc)， [CreateIC](#createic)，或[CreateCompatibleDC](#createcompatibledc)。  
  
### <a name="example"></a>範例  
  請參閱範例[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。  
  
##  <a name="deletetempmap"></a>CDC::DeleteTempMap  
 自動呼叫`CWinApp`閒置時間處理常式，`DeleteTempMap`會刪除任何暫存`CDC`所建立的物件`FromHandle`，但不會終結裝置內容控制代碼 ( `hDC`s) 暫時聯`CDC`物件。  
  
```  
static void PASCAL DeleteTempMap();
```  
  
##  <a name="detach"></a>CDC::Detach  
 呼叫此函式可卸離`m_hDC`（輸出裝置內容） 從`CDC`物件，並同時設定`m_hDC`和`m_hAttribDC`至**NULL**。  
  
```  
HDC Detach();
```  
  
### <a name="return-value"></a>傳回值  
 Windows 裝置內容。  
  
##  <a name="dptohimetric"></a>CDC::DPtoHIMETRIC  
 使用此函式，當您為**HIMETRIC**至 OLE，轉換以像素大小**HIMETRIC**。  
  
```  
void DPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 裝置內容物件的對應模式是否`MM_LOENGLISH`， `MM_HIENGLISH`， `MM_LOMETRIC`，或`MM_HIMETRIC`，然後轉換為基礎的實體英吋的像素數目。 對應模式是一種其他非限制模式 (例如`MM_TEXT`)，然後轉換為基礎的邏輯英吋的像素數目。  
  
##  <a name="dptolp"></a>CDC::DPtoLP  
 將裝置單位轉換成邏輯單元。  
  
```  
void DPtoLP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void DPtoLP(LPRECT lpRect) const;
void DPtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
 `nCount`  
 陣列中的點數目。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 這個參數用於簡單的情況下，將一個矩形從裝置點轉換為邏輯點。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 函式對應的每個點座標或大小，從裝置座標系統到 GDI 的邏輯座標系統的維度。 轉換取決於目前的對應模式，以及設定來源和裝置的視窗和檢視區的範圍。  
  
##  <a name="draw3drect"></a>CDC::Draw3dRect  
 呼叫此成員函式，來繪製三維矩形。  
  
```  
void Draw3dRect(
    LPCRECT lpRect,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);

 
void Draw3dRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clrTopLeft,  
    COLORREF clrBottomRight);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指定週框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 *clrTopLeft*  
 指定三維矩形的頂端和左側邊的色彩。  
  
 `clrBottomRight`  
 指定底部的色彩和三維矩形左右兩側。  
  
 *x*  
 指定邏輯三維矩形左上角的 x 座標。  
  
 *y*  
 指定三維矩形的左上角的邏輯 y 座標。  
  
 cx  
 指定三維矩形的寬度。  
  
 cy  
 指定三維矩形的高度。  
  
### <a name="remarks"></a>備註  
 將具有所指定的色彩在頂端和左側邊繪製的矩形*clrTopLeft*底端和右側所指定的色彩`clrBottomRight`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&33;](../../mfc/codesnippet/cpp/cdc-class_5.cpp)]  
  
##  <a name="drawdragrect"></a>CDC::DrawDragRect  
 呼叫此成員函式重複重繪拖曳矩形。  
  
```  
void DrawDragRect(
    LPCRECT lpRect,  
    SIZE size,  
    LPCRECT lpRectLast,  
    SIZE sizeLast,  
    CBrush* pBrush = NULL,  
    CBrush* pBrushLast = NULL);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)指定矩形的邏輯座標的物件 — 在此情況下，重繪的矩形的結束位置。  
  
 `size`  
 會指定從左上角的 外框左上角的矩形內部的框線 （也就是框線的粗細）。  
  
 `lpRectLast`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)指定矩形的位置的邏輯座標的物件 — 在此情況下，重繪矩形的原始位置。  
  
 *sizeLast*  
 會指定從左上角的外框左上角重繪原始矩形的內部框線 （也就是框線的粗細）。  
  
 `pBrush`  
 筆刷物件指標。 設定為**NULL**若要使用的預設半色調筆刷。  
  
 *pBrushLast*  
 使用的最後一筆刷物件的指標。 設定為**NULL**若要使用的預設半色調筆刷。  
  
### <a name="remarks"></a>備註  
 呼叫它在迴圈中，您才能為提供視覺化回應取樣滑鼠位置。 當您呼叫`DrawDragRect`、 都會清除先前的矩形和一個新的繪製。 例如，為使用者拖曳矩形在畫面上，`DrawDragRect`會清除原始矩形，然後重繪其新位置中的新的。 根據預設，`DrawDragRect`消除閃爍，並順利移動矩形的外觀，請使用半色調筆刷繪製的矩形。  
  
 第一次呼叫`DrawDragRect`、`lpRectLast`參數應該是**NULL**。  
  
##  <a name="drawedge"></a>CDC::DrawEdge  
 呼叫此成員函式，若要繪製的矩形，以指定的型別和樣式的邊緣。  
  
```  
BOOL DrawEdge(
    LPRECT lpRect,  
    UINT nEdge,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指標**RECT**結構，其中包含矩形的邏輯座標。  
  
 *nEdge*  
 指定要繪製的內部和外部邊緣類型。 這個參數必須是一個內部框線旗標和一個外框旗標的組合。 請參閱[DrawEdge](http://msdn.microsoft.com/library/windows/desktop/dd162477)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]參數的型別資料表。  
  
 `nFlags`  
 旗標，指定要繪製的框線類型。 請參閱`DrawEdge`中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]參數值的資料表。 針對斜**BF_RECT**旗標會指定向量的矩形參數所繫結的端點。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
##  <a name="drawescape"></a>CDC::DrawEscape  
 繪製未直接提供的圖形裝置介面 (GDI) 視訊顯示功能的存取。  
  
```  
int DrawEscape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData);
```  
  
### <a name="parameters"></a>參數  
 `nEscape`  
 指定要執行的逸出函數。  
  
 `nInputSize`  
 指定之資料所指向的位元組數`lpszInputData`參數。  
  
 `lpszInputData`  
 指定逸出所需的輸入結構的指標。  
  
### <a name="return-value"></a>傳回值  
 指定函式的結果。 大於零，如果成功，除了**QUERYESCSUPPORT**繪製逸出，而哪些檢查實作; 或如果未實作逸出; 或小於零，如果錯誤發生。  
  
### <a name="remarks"></a>備註  
 當應用程式呼叫`DrawEscape`，所識別的資料`nInputSize`和`lpszInputData`會直接傳遞至指定的顯示驅動程式。  
  
##  <a name="drawfocusrect"></a>CDC::DrawFocusRect  
 用來表示矩形具有焦點的樣式繪製的矩形。  
  
```  
void DrawFocusRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件，指定要繪製矩形的邏輯座標。  
  
### <a name="remarks"></a>備註  
 由於這是布林值 XOR 函式，呼叫這個函式具有相同的矩形的第二次在顯示中移除的矩形。 無法捲動此函式所繪製的矩形。 若要捲動的區域包含此函式所繪製的矩形，請先呼叫`DrawFocusRect`以移除顯示矩形，然後捲動區域，然後呼叫`DrawFocusRect`即可在新的位置繪製矩形。  
  
> [!CAUTION]
> `DrawFocusRect`只適用於`MM_TEXT`模式。 在其他模式中，此函式不能正確地繪製焦點矩形，但不會傳回錯誤值。  
  
##  <a name="drawframecontrol"></a>CDC::DrawFrameControl  
 呼叫此成員函式來繪製框架控制項的指定型別和樣式。  
  
```  
BOOL DrawFrameControl(
    LPRECT lpRect,  
    UINT nType,  
    UINT nState);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指標**RECT**結構，其中包含矩形的邏輯座標。  
  
 `nType`  
 指定要繪製的框控制項的類型。 請參閱*uType*中的參數[DrawFrameControl](http://msdn.microsoft.com/library/windows/desktop/dd162480)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需此參數的可能值的清單。  
  
 `nState`  
 指定框架控制項的初始狀態。 一或多個描述的值可以是*uState*中的參數`DrawFrameControl`中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 使用`nState`值**DFCS_ADJUSTRECT**調整以排除 [推送] 按鈕的周圍邊緣，這個周框。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 在許多情況下，`nState`取決於`nType`參數。 下列清單顯示四個之間的關聯性`nType`值和`nState`:  
  
- **DFC_BUTTON**  
  
    - **DFCS_BUTTON3STATE**三種狀態的按鈕  
  
    - **DFCS_BUTTONCHECK**核取方塊  
  
    - **DFCS_BUTTONPUSH**按鈕  
  
    - **DFCS_BUTTONRADIO**選項按鈕  
  
    - **DFCS_BUTTONRADIOIMAGE**選項按鈕的影像 （非方形需要映像）。  
  
    - **DFCS_BUTTONRADIOMASK**遮罩選項按鈕 （非方形需要遮罩）。  
  
- **DFC_CAPTION**  
  
    - **DFCS_CAPTIONCLOSE** [關閉] 按鈕  
  
    - **DFCS_CAPTIONHELP**說明 按鈕  
  
    - **DFCS_CAPTIONMAX**最大化 按鈕  
  
    - **DFCS_CAPTIONMIN**最小化按鈕  
  
    - **DFCS_CAPTIONRESTORE**還原 按鈕  
  
- **DFC_MENU**  
  
    - **DFCS_MENUARROW**子功能表箭號  
  
    - **DFCS_MENUBULLET**項目符號  
  
    - **DFCS_MENUCHECK**核取記號  
  
- **DFC_SCROLL**  
  
    - **DFCS_SCROLLCOMBOBOX**下拉式方塊捲軸  
  
    - **DFCS_SCROLLDOWN**向下捲軸的箭號  
  
    - **DFCS_SCROLLLEFT**捲軸向左箭號  
  
    - **DFCS_SCROLLRIGHT**捲軸上的向右箭號  
  
    - **DFCS_SCROLLSIZEGRIP**右下角的視窗調整大小底框  
  
    - **DFCS_SCROLLUP**向上捲軸的箭號  
  
### <a name="example"></a>範例  
 此程式碼繪製大小移駐夾右下角的視窗。 這適合`OnPaint`對話方塊，其中有沒有樣式，且通常不包含其他控制項 （例如狀態列） 可以提供其大小的移駐夾的處理常式。  
  
 [!code-cpp[NVC_MFCDocView #&34;](../../mfc/codesnippet/cpp/cdc-class_6.cpp)]  
  
##  <a name="drawicon"></a>CDC::DrawIcon  
 代表目前的裝置上繪製一個圖示`CDC`物件。  
  
```  
BOOL DrawIcon(
    int x,  
    int y,  
    HICON hIcon);

 
BOOL DrawIcon(
    POINT point,  
    HICON hIcon);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定邏輯圖示的左上角的 x 座標。  
  
 *y*  
 指定邏輯圖示的左上角的 y 座標。  
  
 `hIcon`  
 識別要繪製圖示的控制代碼。  
  
 `point`  
 指定邏輯 x 和 y 座標的左上角的圖示。 您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零否則為 0。  
  
### <a name="remarks"></a>備註  
 函式會圖示的左上角放置在所指定的位置*x*和*y*。 目前的裝置內容的對應模式受限於位置。  
  
 「 圖示 」 資源必須先前已載入使用的函式`CWinApp::LoadIcon`， `CWinApp::LoadStandardIcon`，或`CWinApp::LoadOEMIcon`。 `MM_TEXT`必須使用此函式之前選取的對應模式。  
  
### <a name="example"></a>範例  
  請參閱範例[CWnd::IsIconic](../../mfc/reference/cwnd-class.md#isiconic)。  
  
##  <a name="drawstate"></a>CDC::DrawState  
 呼叫此成員函式，來顯示影像，並套用視覺效果來指示狀態，例如已停用或預設狀態。  
  
> [!NOTE]
>  所有`nFlag`狀態除了**DSS_NORMAL**，影像轉換為單色之前套用的視覺效果。  
  
```  
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HBITMAP hBitmap,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    CBitmap* pBitmap,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    HICON hIcon,  
    UINT nFlags,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    LPCTSTR lpszText,  
    UINT nFlags,  
    BOOL bPrefixText = TRUE,  
    int nTextLen = 0,  
    CBrush* pBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    HBRUSH hBrush = NULL);

 
BOOL DrawState(
    CPoint pt,  
    CSize size,  
    DRAWSTATEPROC lpDrawProc,  
    LPARAM lData,  
    UINT nFlags,  
    CBrush* pBrush = NULL);
```  
  
### <a name="parameters"></a>參數  
 `pt`  
 指定映像的位置。  
  
 `size`  
 指定影像的大小。  
  
 `hBitmap`  
 點陣圖控制代碼。  
  
 `nFlags`  
 指定的映像類型和狀態的旗標。 請參閱[DrawState](http://msdn.microsoft.com/library/windows/desktop/dd162496)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]取得可能達到的`nFlags`類型及狀態。  
  
 `hBrush`  
 筆刷控制代碼。  
  
 `pBitmap`  
 CBitmap 物件的指標。  
  
 `pBrush`  
 CBrush 物件的指標。  
  
 `hIcon`  
 圖示的控制代碼。  
  
 `lpszText`  
 文字指標。  
  
 *bPrefixText*  
 可能包含加速器助憶鍵的文字。 `lData`參數會指定字串的位址和`nTextLen`參數指定的長度。 如果`nTextLen`是 0，則會假設是以 null 結尾字串。  
  
 `nTextLen`  
 文字字串的長度所指`lpszText`。 如果`nTextLen`是 0，則會假設是以 null 結尾字串。  
  
 *lpDrawProc*  
 用來呈現影像的回呼函式指標。 此參數是必要的如果映像輸入`nFlags`是**DST_COMPLEX**。 它是選擇性的而且可以是**NULL**映像類型是否**DST_TEXT**。 對於所有其他的映像類型，會忽略此參數。 如需詳細的回呼函式的詳細資訊，請參閱[DrawStateProc](http://msdn.microsoft.com/library/windows/desktop/dd162497)函式中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `lData`  
 指定映像的相關資訊。 這個參數的意義取決於影像類型。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
##  <a name="drawtext"></a>CDC::DrawText  
 呼叫此成員函式，可以格式化文字方塊中指定的矩形。 若要指定其他格式設定選項，請使用[CDC::DrawTextEx](#drawtextex)。  
  
```  
virtual int DrawText(
    LPCTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat);

 
int DrawText(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat);
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向要繪製的字串。 如果`nCount`為 –&1;，此字串必須以 null 結束。  
  
 `nCount`  
 在字串中指定字元的數目。 如果`nCount`是 –&1;，則`lpszString`假設為以 null 終止字串的長度指標和`DrawText`自動計算的字元計數。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)包含的矩形 （以邏輯座標表示） 中的文字是要格式化的物件。  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製指定的字元。  
  
 `nFormat`  
 指定的格式化文字的方法。 它可以是任何組合所述之值的`uFormat`中的參數[DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 （結合使用位元 OR 運算子）︰  
  
> [!NOTE]
>  某些`uFormat`旗標的組合可能會導致修改傳遞的字串。 使用**DT_MODIFYSTRING**與**DT_END_ELLIPSIS**或**DT_PATH_ELLIPSIS**可能會導致要修改字串造成的判斷提示`CString`覆寫。 值`DT_CALCRECT`， `DT_EXTERNALLEADING`， **DT_INTERNAL**， `DT_NOCLIP`，和`DT_NOPREFIX`無法搭配`DT_TABSTOP`值。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功之文字的高度。  
  
### <a name="remarks"></a>備註  
 它會將文字格式化成適當的空格，左、 右文字對齊或置指定的矩形中，展開索引標籤，並分為放入指定的矩形內的行中的文字。 所指定的格式類型`nFormat`。  
  
 此成員函式會使用裝置內容選取的字型、 文字色彩和背景色彩來繪製文字。 除非`DT_NOCLIP`使用格式，`DrawText`裁剪，讓文字未出現在指定的矩形外的文字。 所有的格式設定會假設為包含多個程式碼行，除非`DT_SINGLELINE`格式指定。  
  
 如果選取的字型太大而無法針對指定的矩形，`DrawText`成員函式不會嘗試以替代較小的字型。  
  
 如果`DT_CALCRECT`指定旗標，所指定的矩形`lpRect`將會更新以反映所需繪製文字的高度與寬度。  
  
 如果**TA_UPDATECP**文字對齊方式的旗標已設定 (請參閱[CDC::SetTextAlign](#settextalign))，`DrawText`就會顯示目前的位置，而不在指定的矩形的左邊開始的文字。 `DrawText`不會換行文字時**TA_UPDATECP**設定旗標 (也就是`DT_WORDBREAK`旗標會有任何作用)。  
  
 文字色彩可能會設定[CDC::SetTextColor](#settextcolor)。  
  
##  <a name="drawtextex"></a>CDC::DrawTextEx  
 將指定的矩形中的文字。  
  
```  
virtual int DrawTextEx(
    LPTSTR lpszString,  
    int nCount,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);

 
int DrawTextEx(
    const CString& str,  
    LPRECT lpRect,  
    UINT nFormat,
    LPDRAWTEXTPARAMS lpDTParams);
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向要繪製的字串。 如果`nCount`為 –&1;，此字串必須結束的 null。  
  
 `nCount`  
 在字串中指定字元的數目。 如果`nCount`是 –&1;，則`lpszString`假設為以 null 終止字串的長度指標和`DrawText`自動計算的字元計數。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)包含的矩形 （以邏輯座標表示） 中的文字是要格式化的物件。  
  
 `str`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md)物件，其中包含要繪製指定的字元。  
  
 `nFormat`  
 指定的格式化文字的方法。 它可以是任何組合所述之值的`uFormat`中的參數[DrawText](http://msdn.microsoft.com/library/windows/desktop/dd162498)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 (結合使用位元`OR`運算子):  
  
> [!NOTE]
>  某些`uFormat`旗標的組合可能會導致修改傳遞的字串。 使用**DT_MODIFYSTRING**與**DT_END_ELLIPSIS**或**DT_PATH_ELLIPSIS**可能會導致要修改字串造成的判斷提示`CString`覆寫。 值`DT_CALCRECT`， `DT_EXTERNALLEADING`， **DT_INTERNAL**， `DT_NOCLIP`，和`DT_NOPREFIX`無法搭配`DT_TABSTOP`值。  
  
 `lpDTParams`  
 指標[DRAWTEXTPARAMS](http://msdn.microsoft.com/library/windows/desktop/dd162500)結構，指定其他格式選項。 這個參數可以是**NULL**。  
  
### <a name="remarks"></a>備註  
 它會將文字格式化成適當的空格，左、 右文字對齊或置指定的矩形中，展開索引標籤，並分為放入指定的矩形內的行中的文字。 所指定的格式類型`nFormat`和`lpDTParams`。 如需詳細資訊，請參閱[CDC::DrawText](#drawtext)和[DrawTextEx](http://msdn.microsoft.com/library/windows/desktop/dd162499)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 文字色彩可能會設定[CDC::SetTextColor](#settextcolor)。  
  
##  <a name="ellipse"></a>CDC::Ellipse  
 繪製橢圓形。  
  
```  
BOOL Ellipse(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Ellipse(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定邏輯橢圓形之周框左上角的 x 座標。  
  
 `y1`  
 指定邏輯橢圓形之周框左上角的 y 座標。  
  
 `x2`  
 指定邏輯橢圓形之周框矩形右下角的 x 座標。  
  
 `y2`  
 指定邏輯橢圓形之周框矩形右下角的 y 座標。  
  
 `lpRect`  
 指定的橢圓形的周框矩形。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 橢圓形的中心是由指定週框的中心`x1`， `y1`， `x2`，和`y2`，或`lpRect`。 使用目前的畫筆繪製橢圓形和目前的筆刷填滿它的內部。  
  
 此函式所繪製的圖延伸到，但不包含，右側和底端座標。 這表示圖表的高度是`y2`–`y1`圖表的寬度，而且`x2`– `x1`。  
  
 如果寬度或高度，這個周框為 0，會繪製沒有橢圓形。  
  
##  <a name="enddoc"></a>CDC::EndDoc  
 結束呼叫所啟動的列印工作[Cdc](#startdoc)成員函式。  
  
```  
int EndDoc();
```  
  
### <a name="return-value"></a>傳回值  
 大於或等於 0，如果函式成功或如果發生錯誤的負值。  
  
### <a name="remarks"></a>備註  
 這個成員函式取代**ENDDOC**印表機逸出字元，並完成印刷作業順利完成之後立即呼叫。  
  
 如果應用程式發生列印錯誤或已取消的列印作業時，它必須嘗試將終止作業使用`EndDoc`或[AbortDoc](#abortdoc)。 GDI 自動終止作業，再傳回錯誤值。  
  
 此函式不應在中繼檔。  
  
### <a name="example"></a>範例  
  請參閱範例[CDC::StartDoc](#startdoc)。  
  
##  <a name="endpage"></a>CDC::EndPage  
 通知裝置的應用程式已完成寫入頁面。  
  
```  
int EndPage();
```  
  
### <a name="return-value"></a>傳回值  
 大於或等於 0，如果函式成功或如果發生錯誤的負值。  
  
### <a name="remarks"></a>備註  
 此成員函式通常用來直接前往新頁面上的裝置驅動程式。  
  
 這個成員函式取代**NEWFRAME**印表機逸出。 不同於**NEWFRAME**，一律會呼叫此函數之後列印的頁面。  
  
### <a name="example"></a>範例  
  請參閱範例[CDC::StartDoc](#startdoc)。  
  
##  <a name="endpath"></a>CDC::EndPath  
 關閉路徑括號，並選取放入裝置內容以方括號所定義的路徑。  
  
```  
BOOL EndPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="example"></a>範例  
  請參閱範例[cdc:: beginpath](#beginpath)。  
  
##  <a name="enumobjects"></a>Cdc:: enumobjects  
 列舉畫筆和筆刷在裝置內容中使用。  
  
```  
int EnumObjects(
    int nObjectType,  
    int (CALLBACK* lpfn)(
    LPVOID,
    LPARAM),  
    LPARAM lpData);
```  
  
### <a name="parameters"></a>參數  
 *nObjectType*  
 指定的物件類型。 它可以包含值**OBJ_BRUSH**或**OBJ_PEN**。  
  
 `lpfn`  
 是應用程式所提供的回呼函式的程序執行個體位址。 請參閱 < 備註 > 一節。  
  
 `lpData`  
 應用程式所提供的資料點。 資料會傳遞至回呼函式，以及物件資訊。  
  
### <a name="return-value"></a>傳回值  
 指定所傳回的最後一個值[回呼函式](../../mfc/reference/callback-function-for-cdc-enumobjects.md)。 其意義是使用者定義的。  
  
### <a name="remarks"></a>備註  
 指定型別的每個物件，您傳遞回呼函式呼叫該物件的資訊。 系統會呼叫回呼函式，直到沒有任何物件，或者回呼函式會傳回 0。  
  
 請注意，Microsoft Visual c + + 的新功能可讓您使用一般函式的函式傳遞至`EnumObjects`。 位址傳遞至`EnumObjects`與匯出的函式的指標**匯出**和呼叫慣例 pascal 命名法。 在保護模式應用程式，您不必使用 Windows MakeProcInstance 函式建立此函式或函式釋放之後 FreeProcInstance Windows 函式搭配使用。  
  
 您也沒有要匯出的函式名稱，在**匯出**應用程式的模組定義檔中的陳述式。 您可以改為使用**匯出**中做為函式修飾詞，  
  
 **int 回呼匯出**AFunction **(LPSTR**， **LPSTR);**  
  
 若要使編譯器發出不含別名名稱所匯出的適當匯出記錄。 這適用於大部分的需求。 對於某些特殊情況下，例如匯出的函式，序數或別名匯出、 您仍需要使用**匯出**模組定義檔中的陳述式。  
  
 編譯 Mfc 程式，您通常會使用 /GA 和 /GEs 編譯器選項。 /Gw 編譯器選項不是 Microsoft Foundation classes 搭配使用。 (如果您使用 Windows 函式**MakeProcInstance**，您必須明確轉型從傳回的函式指標**FARPROC**這個 API 中所需的類型。)回呼註冊介面現在是型別安全 （您必須指向正確類型的特定回呼的函式的函式指標傳遞）。  
  
 也請注意所有的回呼函式必須傳回對 Windows 而言，因為無法跨越界限回呼擲回例外狀況之前設陷 Mfc 例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&35;](../../mfc/codesnippet/cpp/cdc-class_7.cpp)]  
  
##  <a name="escape"></a>CDC::Escape  
 此成員函式是 Win32 程式設計幾乎已經過時。  
  
```  
virtual int Escape(
    int nEscape,  
    int nCount,  
    LPCSTR lpszInData,  
    LPVOID lpOutData);

 
int Escape(
    int nEscape,  
    int nInputSize,  
    LPCSTR lpszInputData,  
    int nOutputSize,  
    LPSTR lpszOutputData);
```  
  
### <a name="parameters"></a>參數  
 `nEscape`  
 指定要執行的逸出函數。  
  
 如需逸出函式的完整清單，請參閱[逸出](http://msdn.microsoft.com/library/windows/desktop/dd162701)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `nCount`  
 指定之資料所指向的位元組數`lpszInData`。  
  
 `lpszInData`  
 此逸出所需的輸入的資料結構的指標。  
  
 `lpOutData`  
 指向要從這個逸出接收輸出的結構。 `lpOutData`參數是**NULL**如果未不傳回任何資料。  
  
 `nInputSize`  
 指定之資料所指向的位元組數`lpszInputData`參數。  
  
 `lpszInputData`  
 指定逸出所需的輸入結構的指標。  
  
 `nOutputSize`  
 指定之資料所指向的位元組數`lpszOutputData`參數。  
  
 `lpszOutputData`  
 從這個逸出接收輸出的結構的指標。 這個參數應該是**NULL**如果未不傳回任何資料。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，除了傳回正值**QUERYESCSUPPORT**逸出字元，只會檢查實作。 如果未實作逸出，則會傳回零。 如果發生錯誤，則會傳回負數值。 以下是常見的錯誤值︰  
  
- **SP_ERROR**一般錯誤。  
  
- **SP_OUTOFDISK**沒有足夠磁碟空間目前適用於多工緩衝處理，但沒有更多的空間將會變成可用。  
  
- **SP_OUTOFMEMORY**沒有足夠的記憶體可供多工緩衝處理。  
  
- **SP_USERABORT**使用者結束透過列印管理員工作。  
  
### <a name="remarks"></a>備註  
 原始印表機逸出字元，只能**QUERYESCSUPPORT**支援 Win32 應用程式。 所有其他印表機逸出已經過時，僅支援 16 位元應用程式相容性。  
  
 Win32 程式設計`CDC`現在提供六個成員函式取代其對應的印表機逸出的應用程式︰  
  
- [CDC::AbortDoc](#abortdoc)  
  
- [CDC::EndDoc](#enddoc)  
  
- [CDC::EndPage](#endpage)  
  
- [Cdc:: setabortproc](#setabortproc)  
  
- [CDC::StartDoc](#startdoc)  
  
- [CDC::StartPage](#startpage)  
  
 此外， [rastercaps](#getdevicecaps)支援 Win32 索引取代其他印表機逸出的應用程式。 請參閱[GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需詳細資訊。  
  
 此成員函式可讓應用程式存取的特定裝置不是直接透過 GDI 的設備。  
  
 如果您的應用程式會使用預先定義的逸出值，請使用第一個版本。 如果您的應用程式定義私用的逸出的值，請使用第二個版本。 請參閱[ExtEscape](http://msdn.microsoft.com/library/windows/desktop/dd162708)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]的第二個版本的詳細資訊。  
  
##  <a name="excludecliprect"></a>CDC::ExcludeClipRect  
 建立新的裁剪區域，其中包含現有的裁剪區域減去指定的矩形。  
  
```  
int ExcludeClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int ExcludeClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定之矩形左上角的邏輯 x 座標。  
  
 `y1`  
 指定之矩形左上角的邏輯 y 座標。  
  
 `x2`  
 指定矩形右下角的邏輯 x 座標。  
  
 `y2`  
 指定矩形右下角的邏輯 y 座標。  
  
 `lpRect`  
 指定的矩形。 也可以是`CRect`物件。  
  
### <a name="return-value"></a>傳回值  
 指定新的裁剪區域類型。 它可以是下列值之一︰  
  
- **COMPLEXREGION**區域有重疊的框線。  
  
- **錯誤**所建立的任何區域。  
  
- **NULLREGION**區域是空白。  
  
- **SIMPLEREGION**區域有沒有重疊的框線。  
  
### <a name="remarks"></a>備註  
 數值的絕對值所指定的矩形的寬度`x2`– `x1`，不能超過 32767 的單位。 這項限制適用於以及矩形的高度。  
  
##  <a name="excludeupdatergn"></a>CDC::ExcludeUpdateRgn  
 從相關聯的裁剪區域排除在視窗中的更新的區域，以防止無效視窗區域內的繪圖`CDC`物件。  
  
```  
int ExcludeUpdateRgn(CWnd* pWnd);
```  
  
### <a name="parameters"></a>參數  
 `pWnd`  
 正在更新其視窗的視窗物件的點。  
  
### <a name="return-value"></a>傳回值  
 排除的區域類型。 它可以是下列值之一︰  
  
- **COMPLEXREGION**區域有重疊的框線。  
  
- **錯誤**所建立的任何區域。  
  
- **NULLREGION**區域是空白。  
  
- **SIMPLEREGION**區域有沒有重疊的框線。  
  
##  <a name="extfloodfill"></a>CDC::ExtFloodFill  
 填入目前的筆刷顯示介面的區域。  
  
```  
BOOL ExtFloodFill(
    int x,  
    int y,  
    COLORREF crColor,  
    UINT nFillType);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定填滿的起始位置的點的邏輯 x 座標。  
  
 *y*  
 指定填滿的起始位置的點的邏輯 y 座標。  
  
 `crColor`  
 指定的色彩或填滿區域的界限。 解譯`crColor`的值而定`nFillType`。  
  
 `nFillType`  
 指定要執行的大量封包填滿類型。 它必須是下列值之一︰  
  
- **FLOODFILLBORDER**填滿區域會受限於所指定的色彩`crColor`。 這個樣式等同於所執行的填滿`FloodFill`。  
  
- **FLOODFILLSURFACE**定義所指定的色彩填滿區域`crColor`。 填滿所有方向中繼續向外，只要遇到色彩。 這個樣式可用於以彩色界限填滿區域。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零否則為 0，如果填滿無法完成，如果指定的點的界限所指定色彩`crColor`(如果**FLOODFILLBORDER**要求)，如果指定的點並沒有所指定的色彩`crColor`(如果**FLOODFILLSURFACE**要求)，或如果點外的裁剪區域。  
  
### <a name="remarks"></a>備註  
 此成員函式提供更多的彈性比`FloodFill`因為您可以指定在填滿類型`nFillType`。  
  
 如果`nFillType`設為**FLOODFILLBORDER**，區域會假設為完全受限於所指定的色彩`crColor`。 函式從所指定的點開始*x*和*y* ，並在所有方向中色彩界限填滿。  
  
 如果`nFillType`設為**FLOODFILLSURFACE**，函式從所指定的點開始*x*和*y*並持續在所有方向中，所有的相鄰區域，其中包含所指定的色彩填滿`crColor`。  
  
 只有記憶體裝置內容和支援點陣顯示技術支援的裝置`ExtFloodFill`。 如需詳細資訊，請參閱[GetDeviceCaps](#getdevicecaps)成員函式。  
  
##  <a name="exttextout"></a>CDC::ExtTextOut  
 呼叫此成員函式，將使用目前選取的字型的矩形區域中的字元字串。  
  
```  
virtual BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    LPCTSTR lpszString,  
    UINT nCount,  
    LPINT lpDxWidths);

 
BOOL ExtTextOut(
    int x,  
    int y,  
    UINT nOptions,  
    LPCRECT lpRect,  
    const CString& str,  
    LPINT lpDxWidths);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 將指定字串中指定的第一個字元在字元儲存格的邏輯 x 座標。  
  
 *y*  
 將指定字串中指定的第一個字元在字元儲存格的頂端的邏輯 y 座標。  
  
 `nOptions`  
 指定矩形的型別。 這個參數可以是其中一個、 兩者，或兩者皆非的下列值︰  
  
- **ETO_CLIPPED**指定文字會被裁剪矩形。  
  
- **ETO_OPAQUE**指定目前的背景色彩填滿的矩形。 (您可以設定及查詢目前的背景色彩與[SetBkColor](#setbkcolor)和[GetBkColor](#getbkcolor)成員函式。)  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構，決定矩形的維度。 這個參數可以是**NULL**。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `lpszString`  
 指向要繪製指定的字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。  
  
 `lpDxWidths`  
 指向陣列，這個值表示來源的相鄰的字元儲存格之間的距離。 比方說， `lpDxWidths`[*我*] 邏輯單元會分隔字元儲存格的原始來源*我*和字元儲存格*我*+ 1。 如果`lpDxWidths`是**NULL**，`ExtTextOut`會使用字元的預設間距。  
  
 `str`  
 A`CString`物件，其中包含要繪製指定的字元。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 矩形區域可以是不透明 （填滿目前的背景色彩），而且可以裁剪區域。  
  
 如果`nOptions`為 0 和`lpRect`是**NULL**，函式將文字寫入至裝置內容而不需使用矩形區域。 根據預設，函式不會使用或更新目前的位置。 如果應用程式需要更新目前的位置時，它會呼叫`ExtTextOut`，應用程式可以呼叫`CDC`成員函式[SetTextAlign](#settextalign)與`nFlags`設**TA_UPDATECP**。 當設定這個旗標時，Windows 會略過*x*和*y*的後續呼叫`ExtTextOut`，並改為使用目前的位置。 當應用程式時，使用**TA_UPDATECP**更新目前的位置，`ExtTextOut`設定的目前位置到文字的上一行的結尾，或指向陣列的最後一個項目所指定的位置`lpDxWidths`，何者較大。  
  
##  <a name="fillpath"></a>CDC::FillPath  
 關閉任何開啟的圖形，在目前路徑，並使用目前的筆刷和填滿的多邊形模式填滿的路徑內部。  
  
```  
BOOL FillPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 填入其內部之後，就會捨棄裝置內容的路徑。  
  
##  <a name="fillrect"></a>CDC::FillRect  
 呼叫此成員函式，以填滿指定的矩形，使用指定的筆刷。  
  
```  
void FillRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構，其中包含要填滿的矩形的邏輯座標。 您也可以傳遞[CRect](../../atl-mfc-shared/reference/crect-class.md)這個參數的物件。  
  
 `pBrush`  
 識別用來填滿之矩形的筆刷。  
  
### <a name="remarks"></a>備註  
 函式會填滿完整的矩形中，包括左側和頂端的框線，但不會填滿的右邊緣和下框線。  
  
 筆刷必須為建立使用[CBrush](../../mfc/reference/cbrush-class.md)成員函式[CreateHatchBrush](../../mfc/reference/cbrush-class.md#createhatchbrush)， [CreatePatternBrush](../../mfc/reference/cbrush-class.md#createpatternbrush)，和[createsolidbrush 以](../../mfc/reference/cbrush-class.md#createsolidbrush)，或擷取`GetStockObject`Windows 函式。  
  
 填滿指定的矩形時`FillRect`不包含矩形的右邊緣和下面。 GDI 去，填滿的矩形，但不包含，右邊資料行和底部資料列，不論目前的對應模式。 `FillRect`比較的值**頂端**，**下**，**左**，和**右**指定矩形的成員。 如果**下**是否小於或等於**頂端**，或者如果**右**是否小於或等於**左**，不繪製矩形。  
  
 `FillRect`類似於[CDC::FillSolidRect](#fillsolidrect); 不過，`FillRect`採用筆刷，因此可以用來使用純色、 遞色的色彩、 規劃筆刷或圖樣填滿矩形。 `FillSolidRect`使用僅純色 (由**COLORREF**參數)。 `FillRect`通常會比慢`FillSolidRect`。  
  
##  <a name="fillrgn"></a>CDC::FillRgn  
 填滿指定的區域`pRgn`與所指定的筆刷`pBrush`。  
  
```  
BOOL FillRgn(
    CRgn* pRgn,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 要填滿區域的指標。 指定區域的座標會指定以邏輯單位表示。  
  
 `pBrush`  
 識別用來填滿區域的筆刷。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 筆刷必須建立使用`CBrush`成員函式`CreateHatchBrush`， `CreatePatternBrush`， `CreateSolidBrush`，或擷取**GetStockObject**。  
  
### <a name="example"></a>範例  
  請參閱範例[CRgn::CreateRoundRectRgn](../../mfc/reference/crgn-class.md#createroundrectrgn)。  
  
##  <a name="fillsolidrect"></a>CDC::FillSolidRect  
 呼叫此成員函式的指定純色填滿指定的矩形。  
  
```  
void FillSolidRect(
    LPCRECT lpRect,  
    COLORREF clr);

 
void FillSolidRect(
    int x,  
    int y,  
    int cx,  
    int cy,  
    COLORREF clr);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指定週框 （以邏輯單位表示）。 您可以傳遞指標給[RECT](../../mfc/reference/rect-structure1.md)資料結構或`CRect`這個參數的物件。  
  
 `clr`指定要用來填滿矩形的色彩。  
  
 *x*  
 指定之矩形左上角的邏輯 x 座標。  
  
 *y*  
 指定目的地矩形的左上角的邏輯 y 座標。  
  
 `cx`  
 指定矩形的寬度。  
  
 `cy`  
 指定的矩形的高度。  
  
### <a name="remarks"></a>備註  
 `FillSolidRect`非常類似於[CDC::FillRect](#fillrect); 不過，`FillSolidRect`使用只有純色 (由**COLORREF**參數)，而`FillRect`採用筆刷，因此可以用來使用純色、 遞色的色彩、 規劃筆刷或圖樣填滿矩形。 `FillSolidRect`通常會較快， `FillRect`。  
  
> [!NOTE]
>  當您呼叫`FillSolidRect`，背景色彩，先前已設定使用[SetBkColor](#setbkcolor)，設定為所指示的顏色`clr`。  
  
##  <a name="flattenpath"></a>CDC::FlattenPath  
 轉換到目前的裝置內容中，選取的路徑中的任何型曲線，並將每個曲線轉成一連串的程式碼行。  
  
```  
BOOL FlattenPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="floodfill"></a>CDC::FloodFill  
 填入目前的筆刷顯示介面的區域。  
  
```  
BOOL FloodFill(
    int x,  
    int y,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定填滿的起始位置的點的邏輯 x 座標。  
  
 *y*  
 指定填滿的起始位置的點的邏輯 y 座標。  
  
 `crColor`  
 指定邊界的色彩。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零否則會傳回 0 無法完成填入，指定是否點所指定的邊界色彩`crColor`，或是點外的裁剪區域。  
  
### <a name="remarks"></a>備註  
 區域會假設所受到限制，以指定`crColor`。 `FloodFill`函式所指定的點開始*x*和*y*並持續在所有方向中色彩的界限。  
  
 只有記憶體裝置內容和支援點陣顯示技術支援的裝置`FloodFill`成員函式。 如需有關資訊**RC_BITBLT**功能，請參閱`GetDeviceCaps`成員函式。  
  
 `ExtFloodFill`函數會提供類似的功能，但更大的彈性。  
  
##  <a name="framerect"></a>CDC::FrameRect  
 繪製框線所指定的矩形`lpRect`。  
  
```  
void FrameRect(
    LPCRECT lpRect,  
    CBrush* pBrush);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)包含矩形的左上角和右下角的邏輯座標的物件。 您也可以傳遞`CRect`這個參數的物件。  
  
 `pBrush`  
 識別要用於框架矩形的筆刷。  
  
### <a name="remarks"></a>備註  
 此函數會使用指定的筆刷繪製框線。 框線的高度與寬度永遠是 1 的邏輯單元。  
  
 如果矩形的**下**座標小於或等於**頂端**，或者如果**右**是否小於或等於**左**，不繪製矩形。  
  
 所繪製的框線`FrameRect`位於相同位置繪製框線**矩形**成員函式使用相同的座標 (如果**矩形**使用畫筆的 1 個邏輯單位寬)。 不會填入的矩形內部`FrameRect`。  
  
##  <a name="framergn"></a>CDC::FrameRgn  
 所指定的區域周圍繪製框線`pRgn`使用所指定的筆刷`pBrush`。  
  
```  
BOOL FrameRgn(
    CRgn* pRgn,  
    CBrush* pBrush,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 指向`CRgn`物件，可識別要加上框線的區域。 指定區域的座標會指定以邏輯單位表示。  
  
 `pBrush`  
 指向`CBrush`物件，可識別用來繪製框線的筆刷。  
  
 `nWidth`  
 在垂直的筆刷筆劃，以裝置為單位指定框線的寬度。  
  
 `nHeight`  
 在水平的筆刷筆劃，以裝置為單位指定框線的高度。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="example"></a>範例  
  請參閱範例[CRgn::CombineRgn](../../mfc/reference/crgn-class.md#combinergn)。  
  
##  <a name="fromhandle"></a>CDC::FromHandle  
 若要將指標傳回`CDC`物件指定的裝置內容控制代碼時。  
  
```  
static CDC* PASCAL FromHandle(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 包含 Windows 裝置內容控制代碼。  
  
### <a name="return-value"></a>傳回值  
 指標可能是暫時性的不會儲存超過立即使用。  
  
### <a name="remarks"></a>備註  
 如果 `CDC` 物件沒有附加至控制代碼，會建立並附加暫存 `CDC` 物件。  
  
### <a name="example"></a>範例  
  請參閱範例[CPrintDialog::GetPrinterDC](../../mfc/reference/cprintdialog-class.md#getprinterdc)。  
  
##  <a name="getarcdirection"></a>CDC::GetArcDirection  
 傳回目前弧線方向裝置內容。  
  
```  
int GetArcDirection() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功，請指定目前的反方向。 以下是有效的傳回值︰  
  
- **AD_COUNTERCLOCKWISE**弧形和以逆時針方向繪製的矩形。  
  
- **AD_CLOCKWISE**弧形和朝順時針方向繪製的矩形。  
  
 如果發生錯誤，則傳回值為零。  
  
### <a name="remarks"></a>備註  
 弧形和矩形函式會使用反方向。  
  
##  <a name="getaspectratiofilter"></a>CDC::GetAspectRatioFilter  
 擷取目前的長寬比篩選條件的設定。  
  
```  
CSize GetAspectRatioFilter() const;  
```  
  
### <a name="return-value"></a>傳回值  
 A`CSize`物件，代表目前的長寬比篩選所使用的長寬比。  
  
### <a name="remarks"></a>備註  
 外觀比例是由裝置的像素寬度和高度的比例。 裝置的外觀比例的資訊用於建立、 選取及顯示的字型。 Windows 提供特殊的篩選器，長寬比篩選器，並選取專為特定的長寬比從所有可用的字型所設計的字型。 篩選器會使用所指定的長寬比`SetMapperFlags`成員函式。  
  
##  <a name="getbkcolor"></a>CDC::GetBkColor  
 傳回目前的背景色彩。  
  
```  
COLORREF GetBkColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 RGB 色彩值。  
  
### <a name="remarks"></a>備註  
 如果背景模式是**不透明**，系統會使用背景色彩填滿樣式的行間距、 字元儲存格的背景筆刷，規劃的行之間間距。 轉換點陣圖色彩與單色裝置內容時，系統也會使用背景色彩。  
  
##  <a name="getbkmode"></a>CDC::GetBkMode  
 傳回背景模式。  
  
```  
int GetBkMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 目前的背景模式可以是**不透明**或**透明**。  
  
### <a name="remarks"></a>備註  
 背景模式會定義系統是否會移除現有的背景色彩，在繪圖介面上繪製文字、 規劃筆刷或不是實線任何畫筆樣式之前。  
  
##  <a name="getboundsrect"></a>CDC::GetBoundsRect  
 傳回指定之的裝置內容的目前累積週框。  
  
```  
UINT GetBoundsRect(
    LPRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>參數  
 `lpRectBounds`  
 指出將會收到目前週框的緩衝區。 傳回矩形的邏輯座標。  
  
 `flags`  
 指定是否要清除在傳回的週框。 此參數應為零，否則設定為下列值︰  
  
- **DCB_RESET**強制清除在傳回的週框。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，請指定週框的目前狀態。 它可以是下列值的組合︰  
  
- **DCB_ACCUMULATE**周框矩形累積發生。  
  
- **DCB_RESET**是空的週框。  
  
- **DCB_SET**不是空的週框。  
  
- **DCB_ENABLE**週框累積為開啟。  
  
- **DCB_DISABLE**週框累積為關閉。  
  
##  <a name="getbrushorg"></a>CDC::GetBrushOrg  
 擷取目前選取的裝置內容的筆刷的原點 （以裝置為單位）。  
  
```  
CPoint GetBrushOrg() const;  
```  
  
### <a name="return-value"></a>傳回值  
 （以裝置為單位） 的筆刷，做為目前的原點[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
### <a name="remarks"></a>備註  
 初始的筆刷的原點位於 (0，0) 的工作區。 傳回值指定相對於的桌面視窗原點裝置單位為止。  
  
##  <a name="getcharacterplacement"></a>CDC::GetCharacterPlacement  
 擷取各種類型的字元字串的詳細資訊。  
  
```  
DWORD GetCharacterPlacement(
    LPCTSTR lpString,  
    int nCount,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
  
DWORD GetCharacterPlacement(
    CString& str,  
    int nMaxExtent,  
    LPGCP_RESULTS lpResults,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpString`  
 要處理的字元字串指標。  
  
 `nCount`  
 指定字串的長度。 ANSI 版本，它是位元組計數和 Unicode 函式是字數統計。 如需詳細資訊，請參閱[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)。  
  
 `nMaxExtent`  
 指定最大範圍 （以邏輯單位表示） 來處理字串。 如果處理訊息，會超過此範圍的字元會被忽略。 任何需要的順序或圖像陣列的計算方式只適用於包含的字元。 在指定的 GCP_MAXEXTENT 值時才使用這個參數`dwFlags`參數。 函式會處理輸入的字串，每個字元，其範圍被加入輸出、 範圍，以及其他陣列才總範圍尚未超過上限。 一旦達到限制時，將會停止處理。  
  
 lpResults  
 指標[GCP_Results](http://msdn.microsoft.com/library/windows/desktop/dd144842\(v=vs.85\).aspx)接收函式的結果的結構。  
  
 `dwFlags`  
 指定如何處理字串到所需的陣列。 這個參數可以是其中一個或多個值中列出`dwFlags`區段[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)主題。  
  
 `str`  
 指標[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件傳遞給程序。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回的值是以邏輯單位表示字串的高度與寬度。  
  
 如果此函式失敗，則傳回值為零。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetCharacterPlacement](http://msdn.microsoft.com/library/windows/desktop/dd144860\(v=vs.85\).aspx)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getcharabcwidths"></a>CDC::GetCharABCWidths  
 擷取目前的 TrueType 字型在指定範圍中的連續字元的寬度。  
  
```  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABC lpabc) const;  
  
BOOL GetCharABCWidths(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPABCFLOAT lpABCF) const;  
```  
  
### <a name="parameters"></a>參數  
 `nFirstChar`  
 從目前的字型字元寬度為其傳回的字元範圍中指定的第一個字元。  
  
 `nLastChar`  
 從目前的字型字元寬度為其傳回的字元範圍中指定的最後一個字元。  
  
 `lpabc`  
 指向陣列[ABC](../../mfc/reference/abc-structure.md)函式傳回時，收到字元寬度的結構。 此陣列必須包含至少盡可能**ABC**結構中所指定的範圍有字元`nFirstChar`和`nLastChar`參數。  
  
 *lpABCF*  
 指向陣列的一個應用程式所提供的緩衝區[ABCFLOAT](../../mfc/reference/abcfloat-structure.md)結構，以接收函式傳回的字元寬度。 此函數所傳回的寬，以 IEEE 浮點格式。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 寬度會傳回以邏輯單位表示。 此函式成功只能使用 TrueType 字型。  
  
 已選取的特定點大小之後，TrueType 用於提供"ABC"字元間距。 "A"間距是放圖像之前加入至目前位置的距離。 "B"間距是圖像的黑色的組件的寬度。 "C"間距會加入至目前位置的泛空白字元，右邊的圖像。 提供的進階寬度總計 + B + c。  
  
 當`GetCharABCWidths`成員函式會擷取負"A"或"C"寬字元，而該字元包括 underhangs 或突出部分。  
  
 若要轉換 ABC 寬度為字型設計單位時，應用程式應該建立字型的高度 (中所指定**lfHeight**的成員[LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037)結構) 中儲存的值等於**ntmSizeEM**成員[NEWTEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162741)結構。 (值**ntmSizeEM**成員可以藉由呼叫擷取[EnumFontFamilies](http://msdn.microsoft.com/library/windows/desktop/dd162619) Windows 函式。)  
  
 ABC 寬度的預設字元用於目前選取字型的範圍之外的字元。  
  
 若要擷取非 TrueType 字型中的字元寬度，應用程式應使用[GetCharWidth](http://msdn.microsoft.com/library/windows/desktop/dd144861) Windows 函式。  
  
##  <a name="getcharabcwidthsi"></a>CDC::GetCharABCWidthsI  
 擷取的寬度，以邏輯單位，從目前的 TrueType 字型在指定範圍中的連續圖像索引。  
  
```  
BOOL GetCharABCWidthsI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPABC lpabc) const;  
```  
  
### <a name="parameters"></a>參數  
 `giFirst`  
 指定第一個圖像 （glyph） 索引群組中的所有連續的圖像索引，從目前的字型。 這個參數才會使用`pgi`參數是**NULL**。  
  
 `cgi`  
 指定圖像 （glyph） 的索引的數目。  
  
 `pgi`  
 包含圖像索引的陣列指標。 如果值為**NULL**、`giFirst`改為使用參數。 `cgi`參數指定此陣列中的圖像 （glyph） 索引鍵的數目。  
  
 `lpabc`  
 陣列的指標[ABC](http://msdn.microsoft.com/library/windows/desktop/dd162454)結構接收字元寬度。 此陣列必須包含至少盡可能**ABC**結構時所指定的圖像索引`cgi`參數。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetCharABCWidthsI](http://msdn.microsoft.com/library/windows/desktop/dd144859)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getcharwidth"></a>CDC::GetCharWidth  
 從目前的字型，擷取的連續字元的群組中的個別字元寬度使用`m_hAttribDC`，輸入的裝置內容。  
  
```  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
  
BOOL GetCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    float* lpFloatBuffer) const;  
```  
  
### <a name="parameters"></a>參數  
 `nFirstChar`  
 指定連續的目前字型中的字元群組中的第一個字元。  
  
 `nLastChar`  
 指定連續的目前字型中的字元群組中的最後一個字元。  
  
 `lpBuffer`  
 指出將會收到一組連續字元的寬度值之目前字型的緩衝區。  
  
 *lpFloatBuffer*  
 接收字元寬度之緩衝區的指標。 傳回的寬度是 32 位元 IEEE 浮點數格式。 （沿著基準線的字元被測量寬度）。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 例如，如果`nFirstChar`識別字母 'a' 和`nLastChar`識別代號 'z'、 函式擷取的所有小寫字元寬度。  
  
 函式所指向的緩衝區中儲存的值`lpBuffer`。 這個緩衝區必須夠大，無法保存所有的寬度。 也就是必須有至少 26 項目中指定的範例。  
  
 如果連續的字元群組中的字元不存在於特定字型，則會指派預設字元寬度值。  
  
##  <a name="getcharwidthi"></a>CDC::GetCharWidthI  
 擷取的寬度，以邏輯座標，從目前字型的指定範圍內的連續圖像索引。  
  
```  
BOOL GetCharWidthI(
    UINT giFirst,  
    UINT cgi,  
    LPWORD pgi,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>參數  
 `giFirst`  
 指定第一個圖像 （glyph） 索引群組中的所有連續的圖像索引，從目前的字型。 這個參數才會使用`pgi`參數是**NULL**。  
  
 `cgi`  
 指定圖像 （glyph） 的索引的數目。  
  
 `pgi`  
 包含圖像索引的陣列指標。 如果值為**NULL**、`giFirst`改為使用參數。 `cgi`參數指定此陣列中的圖像 （glyph） 索引鍵的數目。  
  
 `lpBuffer`  
 寬度會接收緩衝區的指標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetCharWidthI](http://msdn.microsoft.com/library/windows/desktop/dd144864)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getclipbox"></a>CDC::GetClipBox  
 擷取目前裁剪界限周圍 tightest 週框的維度。  
  
```  
virtual int GetClipBox(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)要接收的矩形維度的物件。  
  
### <a name="return-value"></a>傳回值  
 裁剪區域的類型。 它可以是下列值之一︰  
  
- **COMPLEXREGION**裁剪區域有重疊的框線。  
  
- **錯誤**裝置內容不正確。  
  
- **NULLREGION**裁剪區域是空的。  
  
- **SIMPLEREGION**裁剪區域有沒有重疊的框線。  
  
### <a name="remarks"></a>備註  
 維度會複製到緩衝區所指`lpRect`。  
  
##  <a name="getcoloradjustment"></a>CDC::GetColorAdjustment  
 擷取裝置內容的色彩調整值。  
  
```  
BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpColorAdjust`  
 指向[COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md)接收色彩調整值的資料結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="getcurrentbitmap"></a>CDC::GetCurrentBitmap  
 將指標傳回至目前選取之`CBitmap`物件。  
  
```  
CBitmap* GetCurrentBitmap() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CBitmap`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentbrush"></a>CDC::GetCurrentBrush  
 將指標傳回至目前選取之`CBrush`物件。  
  
```  
CBrush* GetCurrentBrush() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CBrush`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentfont"></a>CDC::GetCurrentFont  
 將指標傳回至目前選取之`CFont`物件。  
  
```  
CFont* GetCurrentFont() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CFont`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentpalette"></a>CDC::GetCurrentPalette  
 將指標傳回至目前選取之`CPalette`物件。  
  
```  
CPalette* GetCurrentPalette() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CPalette`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentpen"></a>CDC::GetCurrentPen  
 將指標傳回至目前選取之`CPen`物件。  
  
```  
CPen* GetCurrentPen() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CPen`物件，如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式可能會傳回暫存物件。  
  
##  <a name="getcurrentposition"></a>CDC::GetCurrentPosition  
 擷取目前的位置 （以邏輯座標表示）。  
  
```  
CPoint GetCurrentPosition() const;  
```  
  
### <a name="return-value"></a>傳回值  
 目前的位置，以`CPoint`物件。  
  
### <a name="remarks"></a>備註  
 目前的位置可以設定的`MoveTo`成員函式。  
  
##  <a name="getdcbrushcolor"></a>CDC::GetDCBrushColor  
 擷取目前的筆刷色彩。  
  
```  
COLORREF GetDCBrushColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回的值是[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)目前的筆刷色彩的值。  
  
 如果函式失敗，傳回的值是**CLR_INVALID**。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd144872)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getdcpencolor"></a>CDC::GetDCPenColor  
 擷取目前的畫筆顏色。  
  
```  
COLORREF GetDCPenColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回的值是[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)目前的畫筆顏色的值。  
  
 如果函式失敗，傳回的值是**CLR_INVALID**。  
  
### <a name="remarks"></a>備註  
 此成員函式會利用 Win32 函式[GetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd144875)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getdevicecaps"></a>Rastercaps  
 擷取各種不同的顯示裝置的裝置特定資訊。  
  
```  
int GetDeviceCaps(int nIndex) const;  
```  
  
### <a name="parameters"></a>參數  
 `nIndex`  
 指定要傳回資料的類型。 請參閱[GetDeviceCaps](http://msdn.microsoft.com/library/windows/desktop/dd144877)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]值的清單。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功的要求功能的值。  
  
### <a name="example"></a>範例  
  請參閱範例[CPrintDialog::GetDefaults](../../mfc/reference/cprintdialog-class.md#getdefaults)。  
  
##  <a name="getfontdata"></a>CDC::GetFontData  
 擷取可調式字型檔案中的字型度量資訊。  
  
```  
DWORD GetFontData(
    DWORD dwTable,  
    DWORD dwOffset,  
    LPVOID lpData,  
    DWORD cbData) const;  
```  
  
### <a name="parameters"></a>參數  
 `dwTable`  
 指定要傳回之度量資料表的名稱。 這個參數可以是 Microsoft Corporation 所發行的 TrueType 字型檔案規格中所述的度量資料表。 如果此參數為 0，字型檔的開頭開始擷取的資訊。  
  
 `dwOffset`  
 指定從資料表中要開始擷取資訊的開始位移。 如果此參數為 0，會擷取資訊所指定之資料表的開頭開始`dwTable`參數。 如果這個值是大於或等於資料表大小`GetFontData`會傳回 0。  
  
 `lpData`  
 指出將會收到字型資訊的緩衝區。 如果這個值是**NULL**，函數會傳回在指定的字型資料所需的緩衝區大小`dwTable`參數。  
  
 `cbData`  
 指定長度，以位元組為單位來擷取資訊。 如果這個參數是 0，`GetFontData`會傳回在指定的資料大小`dwTable`參數。  
  
### <a name="return-value"></a>傳回值  
 指定指向的緩衝區中傳回的位元組數目`lpData`函式是否成功; 否則為-1。  
  
### <a name="remarks"></a>備註  
 指定位移至字型檔案，以及要傳回的資訊來識別要擷取之資訊。  
  
 應用程式有時也可以使用`GetFontData`TrueType 字型儲存的文件的成員函式。 若要這樣做，應用程式會決定是否可以內嵌並接著會擷取整個字型檔案中，指定為 0 的字型`dwTable`， `dwOffset`，和`cbData`參數。  
  
 應用程式可以決定是否可以藉由檢查中內嵌字型**otmfsType**成員[OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)結構。 如果位元 1 **otmfsType**已經設定，內嵌的字型不允許。 如果清除位元 1，就可以內嵌字型。 如果設定位元 2，內嵌為唯讀。  
  
 如果應用程式嘗試使用這個函數來擷取資訊，對於非 TrueType 字型`GetFontData`成員函式會傳回 –&1;。  
  
##  <a name="getfontlanguageinfo"></a>CDC::GetFontLanguageInfo  
 傳回指定的顯示內容的目前選取字型的相關資訊。  
  
```  
DWORD GetFontLanguageInfo() const;  
```  
  
### <a name="return-value"></a>傳回值  
 傳回值會指出目前選取的字型特性。 如需可能值的完整清單，請參閱[GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetFontLanguageInfo](http://msdn.microsoft.com/library/windows/desktop/dd144886)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getglyphoutline"></a>CDC::GetGlyphOutline  
 擷取大綱曲線或大綱中的字元之目前字型的點陣圖。  
  
```  
DWORD GetGlyphOutline(
    UINT nChar,  
    UINT nFormat,  
    LPGLYPHMETRICS lpgm,  
    DWORD cbBuffer,  
    LPVOID lpBuffer,  
    const MAT2* lpmat2) const;  
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定要傳回資訊的字元。  
  
 `nFormat`  
 指定的功能為傳回資訊的格式。 它可以是下列值之一或 0:  
  
|值|意義|  
|-----------|-------------|  
|**GGO_BITMAP**|傳回圖像點陣圖。 當函式傳回時，所指向的緩衝區`lpBuffer`包含其資料列開始 doubleword 界限的 1 位元-每個像素點陣圖。|  
|**GGO_NATIVE**|傳回資料點的曲線，以用於原生格式，使用裝置的單位。 中指定此值時，指定任何轉換`lpmat2`會被忽略。|  
  
 時數`nFormat`是 0，則函式會填入[GLYPHMETRICS](http://msdn.microsoft.com/library/windows/desktop/dd144955)結構，但未傳回字符外框的資料。  
  
 *lpgm*  
 指向**GLYPHMETRICS**該結構描述位置的字元儲存格的圖像。  
  
 `cbBuffer`  
 指定函式會大綱字元的相關資訊複製到其中的緩衝區的大小。 如果此值為 0，`nFormat`參數是**GGO_BITMAP**或**GGO_NATIVE**值，函數會傳回必要的緩衝區大小。  
  
 `lpBuffer`  
 指向函式會大綱字元的相關資訊複製到其中的緩衝區。 如果`nFormat`指定**GGO_NATIVE**值，資訊會複製的形式**TTPOLYGONHEADER**和**TTPOLYCURVE**結構。 如果這個值是**NULL**和`nFormat`是**GGO_BITMAP**或**GGO_NATIVE**值，函數會傳回必要的緩衝區大小。  
  
 `lpmat2`  
 指向[MAT2](http://msdn.microsoft.com/library/windows/desktop/dd145048)結構，其中包含轉換矩陣的字元。 這個參數不能**NULL**，即使**GGO_NATIVE**為指定值`nFormat`。  
  
### <a name="return-value"></a>傳回值  
 大小 （位元組），如果已擷取之資訊所需的緩衝區`cbBuffer`為 0 或`lpBuffer`是**NULL**。 否則，它是正值函式如果成功，則為 –&1;，如果發生錯誤。  
  
### <a name="remarks"></a>備註  
 應用程式可以藉由指定 2-2 的轉換矩陣所指向的結構中擷取以點陣圖格式的字元來旋轉`lpmat2`。  
  
 字符外框會傳回一系列的分佈。 定義每個分佈[TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158)結構盡可能後面**TTPOLYCURVE**結構描述所需。 所有資料點會以傳回[POINTFX](http://msdn.microsoft.com/library/windows/desktop/dd162806)結構，而且代表絕對位置，而非相對的移動。 開始點給定**pfxStart**成員[TTPOLYGONHEADER](http://msdn.microsoft.com/library/windows/desktop/dd145158)結構是分佈的大綱開始的點。 [TTPOLYCURVE](http://msdn.microsoft.com/library/windows/desktop/dd145157)記錄聚合線條或曲線記錄，可遵循的結構。 聚合線條記錄是一連串的點。點之間繪製資料行描述字元外的框。 曲線記錄代表 TrueType （也就是二次方 b-曲線） 所使用的二次方曲線。  
  
##  <a name="getgraphicsmode"></a>CDC::GetGraphicsMode  
 擷取指定之的裝置內容中目前的圖形模式。  
  
```  
int GetGraphicsMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功，傳回目前的圖形模式。 如需這個方法可以傳回的值，請參閱[GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)。  
  
 在失敗時傳回 0。  
  
 若要取得擴充的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[GetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd144892)。  
  
##  <a name="gethalftonebrush"></a>CDC::GetHalftoneBrush  
 呼叫此成員函式擷取半色調筆刷。  
  
```  
static CBrush* PASCAL GetHalftoneBrush();
```  
  
### <a name="return-value"></a>傳回值  
 指標`CBrush`物件如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 半色調筆刷顯示交替的遞色圖樣的前景和背景色彩的像素為單位。 以下是建立半色調筆刷的遞色圖樣的範例。  
  
 ![遞色的畫筆筆劃的詳細資料](../../mfc/reference/media/vc318s1.gif "vc318s1")  
  
##  <a name="getkerningpairs"></a>CDC::GetKerningPairs  
 擷取的字元間距調整組指定的裝置內容中目前選取的字型。  
  
```  
int GetKerningPairs(
    int nPairs,  
    LPKERNINGPAIR lpkrnpair) const;  
```  
  
### <a name="parameters"></a>參數  
 `nPairs`  
 指定的數目[KERNINGPAIR](http://msdn.microsoft.com/library/windows/desktop/dd145024)結構所指`lpkrnpair`。 函式將不會複製比所指定的多個 kerning 組`nPairs`。  
  
 `lpkrnpair`  
 指向陣列**KERNINGPAIR**函式傳回時，接收字元間距調整的結構配對。 此陣列必須包含所指定的數目，至少結構`nPairs`。 如果這個參數是**NULL**，函式傳回的字元間距調整組字型的總數。  
  
### <a name="return-value"></a>傳回值  
 指定的字元間距調整擷取的配對數目或總數字元間距調整組在字型中，如果函式成功。 如果函式失敗，或沒有 kerning 成對的字型，則會傳回零。  
  
##  <a name="getlayout"></a>CDC::GetLayout  
 呼叫此成員函式，來決定文字和圖形裝置內容，例如印表機或中繼檔的配置。  
  
```  
DWORD GetLayout() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功，版面配置旗標目前的裝置內容。 否則， **GDI_ERROR**。 擴充的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。 如需配置旗標的清單，請參閱[CDC::SetLayout](#setlayout)。  
  
### <a name="remarks"></a>備註  
 預設的版面配置是由左至右。  
  
##  <a name="getmapmode"></a>CDC::GetMapMode  
 擷取目前的對應模式。  
  
```  
int GetMapMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 此對應模式。  
  
### <a name="remarks"></a>備註  
 如需對應模式的說明，請參閱`SetMapMode`成員函式。  
  
> [!NOTE]
>  如果您呼叫[SetLayout](#setlayout) DC 變成由右至左配置**SetLayout**會自動變更的對應模式`MM_ISOTROPIC`。 因此，任何後續呼叫`GetMapMode`會傳回`MM_ISOTROPIC`。  
  
##  <a name="getmiterlimit"></a>CDC::GetMiterLimit  
 傳回斜裝置內容。  
  
```  
float GetMiterLimit() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 包含繪製幾何行儀表聯結時，會使用斜。  
  
##  <a name="getnearestcolor"></a>CDC::GetNearestColor  
 傳回最符合指定的邏輯色彩的實心色彩。  
  
```  
COLORREF GetNearestColor(COLORREF crColor) const;  
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定要比對的色彩。  
  
### <a name="return-value"></a>傳回值  
 定義實線 （紅色、 綠色、 藍色） 的 RGB 色彩值色彩最接近`crColor`裝置可以表示的值。  
  
### <a name="remarks"></a>備註  
 指定的裝置必須能夠代表這個色彩。  
  
##  <a name="getoutlinetextmetrics"></a>CDC::GetOutlineTextMetrics  
 擷取 TrueType 字型度量資訊。  
  
```  
UINT GetOutlineTextMetrics(
    UINT cbData,  
    LPOUTLINETEXTMETRIC lpotm) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpotm`  
 指向陣列[OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)結構。 如果這個參數是**NULL**，函數會傳回所擷取的度量資料所需的緩衝區大小。  
  
 `cbData`  
 指定的大小，以位元組為單位傳回資訊的緩衝區。  
  
 `lpotm`  
 指向**OUTLINETEXTMETRIC**結構。 如果這個參數是**NULL**，函數會傳回已擷取的度量資訊所需的緩衝區大小。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 [OUTLINETEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd162755)結構包含大部分的 TrueType 格式時，所提供的字型度量資訊包括[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)結構。 最後四個成員**OUTLINETEXTMETRIC**結構都是字串指標。 應用程式應該針對這些字串，除了其他成員所需的空間配置空間。 因為沒有任何系統加諸限制字串的大小，最簡單的方法配置的記憶體是藉由指定擷取所需的大小**NULL**的`lpotm`中的第一個呼叫`GetOutlineTextMetrics`函式。  
  
##  <a name="getoutputcharwidth"></a>CDC::GetOutputCharWidth  
 輸出裝置內容中，會使用`m_hDC`，並擷取從目前的字型顯示連續的字元群組中的個別字元的寬度。  
  
```  
BOOL GetOutputCharWidth(
    UINT nFirstChar,  
    UINT nLastChar,  
    LPINT lpBuffer) const;  
```  
  
### <a name="parameters"></a>參數  
 `nFirstChar`  
 指定連續的目前字型中的字元群組中的第一個字元。  
  
 `nLastChar`  
 指定連續的目前字型中的字元群組中的最後一個字元。  
  
 `lpBuffer`  
 指出將會收到一組連續字元的寬度值之目前字型的緩衝區。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 例如，如果`nFirstChar`識別字母 'a' 和`nLastChar`識別代號 'z'、 函式擷取的所有小寫字元寬度。  
  
 函式所指向的緩衝區中儲存的值`lpBuffer`。 這個緩衝區必須夠大，無法保存所有的寬度。也就是必須有至少 26 項目中指定的範例。  
  
 如果連續的字元群組中的字元不存在於特定字型，則會指派預設字元寬度值。  
  
##  <a name="getoutputtabbedtextextent"></a>CDC::GetOutputTabbedTextExtent  
 呼叫此成員函式，來計算的寬度和高度的字元字串使用[m_hDC](#m_hdc)，輸出裝置內容。  
  
```  
CSize GetOutputTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetOutputTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向要測量的字元字串。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為 –&1;，長度會計算。  
  
 `nTabPositions`  
 指定指向陣列中的定位停駐點位置數`lpnTabStopPositions`。  
  
 `lpnTabStopPositions`  
 包含邏輯單位中的定位停駐點位置的整數的陣列指標。 必須以遞增順序排序定位停駐點最小的 x 值應該在陣列中的第一個項目。 不允許回復 索引標籤。  
  
 `str`  
 A`CString`物件，其中包含要測量指定的字元。  
  
### <a name="return-value"></a>傳回值  
 維度中的字串 （以邏輯單位表示） 的[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 如果字串包含一個或多個 tab 字元，字串的寬度為基礎所指定的定位點`lpnTabStopPositions`。 函式會使用目前選取的字型，計算字串的維度。  
  
 為目前裁剪區域不位移所傳回的高度與寬度`GetOutputTabbedTextExtent`函式。  
  
 由於某些裝置並將字元放在一般的資料格陣列中 （也就是它們微調字元），將字串中字元的範圍的總和可能不等於字串的範圍。  
  
 如果`nTabPositions`為 0 和`lpnTabStopPositions`是**NULL**，索引標籤會展開為八個平均字元寬度。 如果`nTabPositions`為 1，第一個值的陣列中所指定的距離會分開定位停駐點`lpnTabStopPositions`點。 如果`lpnTabStopPositions`點到多個單一值，最多指定的數字陣列中每個值設定定位停駐點`nTabPositions`。  
  
##  <a name="getoutputtextextent"></a>CDC::GetOutputTextExtent  
 呼叫此成員函式會使用輸出的裝置內容， [m_hDC](#m_hdc)，並計算行的文字，使用目前字型的高度與寬度。  
  
```  
CSize GetOutputTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetOutputTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 字元字串的指標。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為 –&1;，長度會計算。  
  
 `str`  
 A`CString`物件，其中包含要測量指定的字元。  
  
### <a name="return-value"></a>傳回值  
 傳回的字串 （以邏輯單位表示） 的維度[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 為目前裁剪區域不會影響所傳回的高度與寬度`GetOutputTextExtent`。  
  
 由於某些裝置並將字元放在一般的資料格陣列中 （也就是它們執行字元間距調整），請在字串中的字元範圍的總和可能不等於字串的範圍。  
  
##  <a name="getoutputtextmetrics"></a>CDC::GetOutputTextMetrics  
 擷取目前的字型使用的度量`m_hDC`，輸出裝置內容。  
  
```  
BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpMetrics`  
 指向[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)接收度量的結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="getpath"></a>CDC::GetPath  
 擷取定義線條的端點和選入裝置內容的路徑中找到的曲線的控制點的座標。  
  
```  
int GetPath(
    LPPOINT lpPoints,  
    LPBYTE lpTypes,  
    int nCount) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)資料結構或`CPoint`線條端點和曲線控制點的物件。  
  
 `lpTypes`  
 放置頂點類型位元組的陣列指標。 值可以是下列其中一項︰  
  
- **PT_MOVETO**中相對應點的指定`lpPoints`開始脫離圖形。  
  
- **PT_LINETO**先前點與對應端點的指定`lpPoints`線條的端點。  
  
- **PT_BEZIERTO**中相對應點的指定`lpPoints`控制點或 Bzier 曲線的結束點。  
  
 **PT_BEZIERTO**類型一定會發生在三個集合中。 立即前面加上路徑中的點定義 Bzier 曲線的開始點。 前兩個**PT_BEZIERTO**點是第三個控制點， **PT_BEZIERTO**點是結束點 (如果硬式編碼)。  
  
     A **PT_LINETO**或**PT_BEZIERTO**型別可能會與下列旗標結合 (使用位元運算子`OR`) 來表示對應的點是在圖中的最後一個點和圖應該先關閉︰  
  
- **PT_CLOSEFIGURE**指定相對應的行之後，會自動關閉圖或繪製曲線。 圖就會被從線條或曲線結束點繪製一條線到對應的最後一個點關閉**PT_MOVETO**。  
  
 `nCount`  
 指定的總數[點](../../mfc/reference/point-structure1.md)資料結構，可能會放置於`lpPoints`陣列。 此值必須是相同的位元組數目，可能會放置於`lpTypes`陣列。  
  
### <a name="return-value"></a>傳回值  
 如果`nCount`參數不是零，點列舉數目。 如果`nCount`為 0，在路徑中的點總數 (和`GetPath`緩衝區寫入 nothing)。 如果`nCount`為非零值，而且小於點數目在路徑中，傳回值為-1。  
  
### <a name="remarks"></a>備註  
 裝置內容必須包含已關閉的路徑。 在邏輯座標中，會傳回路徑的點。 因此點儲存之路徑中裝置座標`GetPath`所使用的目前轉換為邏輯座標變更點從裝置座標。 `FlattenPath`之前，可能會呼叫成員函式`GetPath`，若要在路徑中的所有曲線都轉換成直線線段。  
  
### <a name="example"></a>範例  
  請參閱範例[cdc:: beginpath](#beginpath)。  
  
##  <a name="getpixel"></a>CDC::GetPixel  
 擷取所指定的點的像素的 RGB 色彩值*x*和*y*。  
  
```  
COLORREF GetPixel(
    int x,  
    int y) const;  
  
COLORREF GetPixel(POINT point) const;  
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要檢查點的邏輯 x 座標。  
  
 *y*  
 指定要檢查點的邏輯 y 座標。  
  
 `point`  
 指定邏輯 x 和 y 座標的檢查點。  
  
### <a name="return-value"></a>傳回值  
 針對函式指定點的色彩的 RGB 色彩值的其中一個版本。 如果座標的裁剪區域中未指定的點，它會是 –&1;。  
  
### <a name="remarks"></a>備註  
 點必須位於裁剪區域。 如果端點不裁剪區域中，函式沒有任何作用，而且會傳回 –&1;。  
  
 並非所有裝置都支援**GetPixel**函式。 如需詳細資訊，請參閱**RC_BITBLT**點陣功能下的[GetDeviceCaps](#getdevicecaps)成員函式。  
  
 **GetPixel**成員函式有兩種形式。 第一個會採用兩個座標值。第二個會[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
##  <a name="getpolyfillmode"></a>CDC::GetPolyFillMode  
 擷取目前的多邊形填滿模式。  
  
```  
int GetPolyFillMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 目前的多邊形填滿模式，**替代**或**彎曲**、 函式是否成功。  
  
### <a name="remarks"></a>備註  
 請參閱`SetPolyFillMode`成員函式的多邊形填滿模式的描述。  
  
##  <a name="getrop2"></a>CDC::GetROP2  
 擷取目前的繪圖模式。  
  
```  
int GetROP2() const;  
```  
  
### <a name="return-value"></a>傳回值  
 繪圖模式。 如需繪圖模式值的清單，請參閱`SetROP2`成員函式。  
  
### <a name="remarks"></a>備註  
 繪圖模式指定如何將畫筆的色彩和填滿物件內部合併使用已經在顯示介面上的色彩。  
  
##  <a name="getsafehdc"></a>CDC::GetSafeHdc  
 呼叫此成員函式可取得[m_hDC](#m_hdc)，輸出裝置內容。  
  
```  
HDC GetSafeHdc() const;  
```  
  
### <a name="return-value"></a>傳回值  
 裝置內容控制代碼。  
  
### <a name="remarks"></a>備註  
 此成員函式也可以搭配 null 指標。  
  
##  <a name="getstretchbltmode"></a>CDC::GetStretchBltMode  
 擷取目前的點陣圖自動縮放模式。  
  
```  
int GetStretchBltMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 傳回的值會指定目前的點陣圖自動縮放模式 — **STRETCH_ANDSCANS**， **STRETCH_DELETESCANS**，或**STRETCH_ORSCANS** — 如果函式成功。  
  
### <a name="remarks"></a>備註  
 點陣圖自動縮放模式可讓您定義如何從自動縮放或壓縮點陣圖中移除資訊`StretchBlt`成員函式。  
  
 **STRETCH_ANDSCANS**和**STRETCH_ORSCANS**模式通常用於保留前景單色點陣圖的像素。 **STRETCH_DELETESCANS**模式通常用來保留色彩點陣圖中的色彩。  
  
##  <a name="gettabbedtextextent"></a>CDC::GetTabbedTextExtent  
 呼叫此成員函式，來計算的寬度和高度的字元字串使用[m_hAttribDC](#m_hattribdc)，屬性的裝置內容。  
  
```  
CSize GetTabbedTextExtent(
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
  
CSize GetTabbedTextExtent(
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 字元字串的指標。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為 –&1;，長度會計算。  
  
 `nTabPositions`  
 指定指向陣列中的定位停駐點位置數`lpnTabStopPositions`。  
  
 `lpnTabStopPositions`  
 包含邏輯單位中的定位停駐點位置的整數的陣列指標。 必須以遞增順序排序定位停駐點最小的 x 值應該在陣列中的第一個項目。 不允許回復 索引標籤。  
  
 `str`  
 A`CString`物件，其中包含要繪製指定的字元。  
  
### <a name="return-value"></a>傳回值  
 維度中的字串 （以邏輯單位表示） 的[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 如果字串包含一個或多個 tab 字元，字串的寬度為基礎所指定的定位點`lpnTabStopPositions`。 函式會使用目前選取的字型，計算字串的維度。  
  
 為目前裁剪區域不位移所傳回的高度與寬度`GetTabbedTextExtent`函式。  
  
 由於某些裝置並將字元放在一般的資料格陣列中 （也就是它們微調字元），將字串中字元的範圍的總和可能不等於字串的範圍。  
  
 如果`nTabPositions`為 0 和`lpnTabStopPositions`是**NULL**，索引標籤會展開成 8 倍的平均字元寬度。 如果`nTabPositions`為 1，第一個值的陣列中所指定的距離會分開定位停駐點`lpnTabStopPositions`點。 如果`lpnTabStopPositions`點到多個單一值，最多指定的數字陣列中每個值設定定位停駐點`nTabPositions`。  
  
##  <a name="gettextalign"></a>CDC::GetTextAlign  
 擷取裝置內容的文字對齊方式旗標的狀態。  
  
```  
UINT GetTextAlign() const;  
```  
  
### <a name="return-value"></a>傳回值  
 文字對齊方式的旗標的狀態。 傳回值是一或多個下列值︰  
  
- **TA_BASELINE**指定對齊 x 軸和字型周框矩形內的基準線。  
  
- **TA_BOTTOM**指定 x 軸，這個周框底部對齊方式。  
  
- **TA_CENTER**指定週框的中間和 y 軸的對齊方式。  
  
- **TA_LEFT**指定對齊 y 軸，左邊算的起，這個周框。  
  
- **TA_NOUPDATECP**指定不會更新目前的位置。  
  
- **TA_RIGHT**指定對齊 y 軸的右側，這個周框。  
  
- **TA_TOP**指定 x 軸和周框矩形頂端對齊。  
  
- **TA_UPDATECP**指定更新目前的位置。  
  
### <a name="remarks"></a>備註  
 文字對齊方式的旗標決定如何`TextOut`和`ExtTextOut`成員函式對齊關於字串的起始點的文字字串。 文字對齊方式的旗標不是一定的單一位元旗標，且可能會等於 0。 若要測試是否已設定旗標，應用程式應該遵循下列步驟︰  
  
1.  將位元 OR 運算子套用至旗標和其相關的旗標，組成群組，如下所示︰  
  
    - **TA_LEFT**， **TA_CENTER**，和**TA_RIGHT**  
  
    - **TA_BASELINE**， **TA_BOTTOM**，和**TA_TOP**  
  
    - **TA_NOUPDATECP**和**TA_UPDATECP**  
  
2.  適用於位元-和結果的傳回值的運算子`GetTextAlign`。  
  
3.  測試結果和旗標相等。  
  
##  <a name="gettextcharacterextra"></a>CDC::GetTextCharacterExtra  
 擷取 intercharacter 間距所需的目前設定。  
  
```  
int GetTextCharacterExtra() const;  
```  
  
### <a name="return-value"></a>傳回值  
 Intercharacter 的間距數量。  
  
### <a name="remarks"></a>備註  
 GDI 新增這個間距，包括分行符號字元，當一行文字寫入裝置內容的每個字元。  
  
 Intercharacter 間距所需的預設值為 0。  
  
##  <a name="gettextcolor"></a>CDC::GetTextColor  
 擷取目前的文字色彩。  
  
```  
COLORREF GetTextColor() const;  
```  
  
### <a name="return-value"></a>傳回值  
 RGB 色彩值為目前的文字色彩。  
  
### <a name="remarks"></a>備註  
 文字色彩是使用 GDI 文字輸出成員函式來繪製的字元的前景色彩[TextOut](#textout)， [ExtTextOut](#exttextout)，和[TabbedTextOut](#tabbedtextout)。  
  
##  <a name="gettextextent"></a>CDC::GetTextExtent  
 呼叫此成員函式，來計算一行文字，以判斷維度的目前字型的高度與寬度。  
  
```  
CSize GetTextExtent(
    LPCTSTR lpszString,  
    int nCount) const;  
  
CSize GetTextExtent(const CString& str) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 字元字串的指標。 您也可以傳遞[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。  
  
 `str`  
 A`CString`物件，其中包含指定的字元。  
  
### <a name="return-value"></a>傳回值  
 維度中的字串 （以邏輯單位表示） 的[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 資訊擷取自[m_hAttribDC](#m_hattribdc)，屬性的裝置內容。  
  
 根據預設，`GetTextExtent`假設它會擷取維度的文字設定水平對齊 （也就是斜度為 0）。 如果您建立時指定非零斜度字型，您必須轉換明確地取得維度的字串文字的角度。  
  
 為目前裁剪區域不會影響所傳回的高度與寬度`GetTextExtent`。  
  
 由於某些裝置並將字元放在一般的資料格陣列中 （也就是它們執行字元間距調整），請在字串中的字元範圍的總和可能不等於字串的範圍。  
  
##  <a name="gettextextentexpointi"></a>CDC::GetTextExtentExPointI  
 擷取指定的字串，將符合指定的空間內，且陣列填入每個字元的文字範圍中的字元數。  
  
```  
BOOL GetTextExtentExPointI(
    LPWORD pgiIn,  
    int cgi,  
    int nMaxExtent,  
    LPINT lpnFit,  
    LPINT alpDx,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `pgiIn`  
 要擷取範圍的圖像索引的陣列指標。  
  
 `cgi`  
 指定指向陣列中的圖像數目`pgiIn`。  
  
 `nMaxExtent`  
 指定的最大可允許的寬度，以邏輯單位，格式化字串。  
  
 `lpnFit`  
 接收的最大中所指定的空間可容納的字元數計數的整數的指標`nMaxExtent`。 當`lpnFit`是**NULL**，`nMaxExtent`會被忽略。  
  
 *alpDx*  
 接收部分圖像範圍整數的陣列指標。 陣列中的每個項目提供的距離，以邏輯單位，表示圖像 （glyph） 的索引陣列的開頭與符合所指定的空間中的圖像`nMaxExtent`。 雖然這個陣列都應該至少多的項目所指定的圖像索引`cgi`，函式會填入陣列所使用最多的圖像索引時所指定的範圍`lpnFit`。 如果*lpnDx*是**NULL**，函式不會計算部分字串的寬度。  
  
 `lpSize`  
 指標[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)以邏輯單位表示收到的圖像 （glyph） 的索引陣列維度的結構。 這個值不能**NULL**。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetTextExtentExPointI](http://msdn.microsoft.com/library/windows/desktop/dd144936)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="gettextextentpointi"></a>CDC::GetTextExtentPointI  
 擷取指定之陣列的圖像 （glyph） 索引的高度與寬度。  
  
```  
BOOL GetTextExtentPointI(
    LPWORD pgiIn,  
    int cgi,  
    LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `pgiIn`  
 要擷取範圍的圖像索引的陣列指標。  
  
 `cgi`  
 指定指向陣列中的圖像數目`pgiIn`。  
  
 `lpSize`  
 指標[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)以邏輯單位表示收到的圖像 （glyph） 的索引陣列維度的結構。 這個值不能**NULL**。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetTextExtentPointI](http://msdn.microsoft.com/library/windows/desktop/dd144939)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="gettextface"></a>CDC::GetTextFace  
 呼叫此成員函式複製到緩衝區的目前字型的字樣名稱。  
  
```  
int GetTextFace(
    int nCount,  
    LPTSTR lpszFacename) const;  
  
int GetTextFace(CString& rString) const;  
```  
  
### <a name="parameters"></a>參數  
 `nCount`  
 指定緩衝區的大小 （以位元組為單位）。 如果超過此參數所指定的位元組數目的字樣名稱，名稱會截斷。  
  
 *lpszFacename*  
 指向的字樣名稱的緩衝區。  
  
 `rString`  
 參考[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。  
  
### <a name="return-value"></a>傳回值  
 複製到緩衝區，不包括結束的 null 字元的位元組數目。 如果發生錯誤時，它會為 0。  
  
### <a name="remarks"></a>備註  
 以 null 結束的字串會複製的字樣名稱。  
  
##  <a name="gettextmetrics"></a>CDC::GetTextMetrics  
 擷取目前使用屬性的裝置內容的字型度量資訊。  
  
```  
BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpMetrics`  
 指向[TEXTMETRIC](http://msdn.microsoft.com/library/windows/desktop/dd145132)接收度量的結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="getviewportext"></a>CDC::GetViewportExt  
 擷取 x-和 y-範圍的裝置內容的檢視區。  
  
```  
CSize GetViewportExt() const;  
```  
  
### <a name="return-value"></a>傳回值  
 X-和 y 的範圍 （以裝置為單位） 為`CSize`物件。  
  
##  <a name="getviewportorg"></a>CDC::GetViewportOrg  
 擷取裝置內容相關聯的檢視區原點 x 和 y 座標。  
  
```  
CPoint GetViewportOrg() const;  
```  
  
### <a name="return-value"></a>傳回值  
 （以裝置座標表示） 做為檢視區原點`CPoint`物件。  
  
##  <a name="getwindow"></a>CDC::GetWindow  
 傳回顯示裝置內容相關聯的視窗。  
  
```  
CWnd* GetWindow() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CWnd`物件如果成功，否則**NULL**。  
  
### <a name="remarks"></a>備註  
 這是進階的函式。 例如，此成員函式不會傳回 [檢視] 視窗時列印或預覽列印。 它一律會傳回與 output 相關聯的視窗。 使用指定的 DC 的輸出函式會繪製到這個視窗。  
  
##  <a name="getwindowext"></a>CDC::GetWindowExt  
 擷取 x-和 y-範圍相關聯的裝置內容的視窗。  
  
```  
CSize GetWindowExt() const;  
```  
  
### <a name="return-value"></a>傳回值  
 X-和 y 的範圍 （以邏輯單位表示） 做為`CSize`物件。  
  
##  <a name="getwindoworg"></a>CDC::GetWindowOrg  
 擷取視窗相關聯的裝置內容的原點 x 和 y 座標。  
  
```  
CPoint GetWindowOrg() const;  
```  
  
### <a name="return-value"></a>傳回值  
 間隔 （以邏輯座標表示） 做為原點`CPoint`物件。  
  
##  <a name="getworldtransform"></a>CDC::GetWorldTransform  
 擷取目前頁面空間轉換到全球空白字元。  
  
```  
BOOL GetWorldTransform(XFORM& rXform) const;  
```  
  
### <a name="parameters"></a>參數  
 `rXform`  
 若要參考[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)接收目前頁面空間轉換到全球-空間的結構。  
  
### <a name="return-value"></a>傳回值  
 如果成功，傳回非零值。  
  
 在失敗時傳回 0。  
  
 若要取得擴充的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[GetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd144953)。  
  
##  <a name="gradientfill"></a>CDC::GradientFill  
 呼叫此成員函式以順暢其他淡從一端的色彩填滿的矩形和三角形的結構。  
  
```  
BOOL GradientFill(
    TRIVERTEX* pVertices,  
    ULONG nVertices,  
    void* pMesh,  
    ULONG nMeshElements,  
    DWORD dwMode);
```  
  
### <a name="parameters"></a>參數  
 *pVertices*  
 陣列的指標[TRIVERTEX](http://msdn.microsoft.com/library/windows/desktop/dd145142)結構，每個定義三角形頂點。  
  
 *nVertices*  
 頂點數目。  
  
 `pMesh`  
 陣列[GRADIENT_TRIANGLE](http://msdn.microsoft.com/library/windows/desktop/dd144959)三角形模式或陣列中的結構[GRADIENT_RECT](http://msdn.microsoft.com/library/windows/desktop/dd144958)矩形模式中的結構。  
  
 *nMeshElements*  
 中的元素數目 （三角形或矩形） `pMesh`。  
  
 `dwMode`  
 指定漸層填滿模式。 如需可能的值，請參閱[GradientFill](http://msdn.microsoft.com/library/windows/desktop/dd144957)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果成功，否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 如需詳細資訊，請參閱`GradientFill`中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="graystring"></a>Cdc:: graystring  
 繪製寫入記憶體點陣圖中的文字，變暗點陣圖，然後將點陣圖複製到顯示灰色 （灰色） 在指定位置的文字。  
  
```  
virtual BOOL GrayString(
    CBrush* pBrush,  
    BOOL (CALLBACK* lpfnOutput)(
    HDC,
    LPARAM,
    int),  
    LPARAM lpData,  
    int nCount,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `pBrush`  
 識別要用於變暗 （對於） 筆刷。  
  
 `lpfnOutput`  
 指定將會繪製字串的應用程式所提供的回呼函式的程序執行個體位址。 如需詳細資訊，請參閱 Windows 說明**OutputFunc** [回呼函式](../../mfc/reference/callback-function-for-cdc-graystring.md)。 如果這個參數是**NULL**，系統會使用 Windows`TextOut`繪製字串的函式和`lpData`假設為輸出的字元字串的長指標。  
  
 `lpData`  
 指定要傳遞至輸出函式資料的遠端指標。 如果`lpfnOutput`是**NULL**，`lpData`必須是長時間來輸出字串的指標。  
  
 `nCount`  
 指定要輸出的字元數。 如果這個參數是 0，`GrayString`計算字串的長度 (假設`lpData`是字串的指標)。 如果`nCount`是 – 1 和所指向之函式`lpfnOutput`傳回 0 時，映像時顯示，但是未呈現灰色。  
  
 *x*  
 指定矩形包圍字串的起始位置的邏輯 x 座標。  
  
 *y*  
 指定矩形包圍字串的起始位置的邏輯 y 座標。  
  
 `nWidth`  
 指定包圍字串的矩形的寬度 （以邏輯單位表示）。 如果`nWidth`為 0，`GrayString`計算區域的寬度假設`lpData`是字串的指標。  
  
 `nHeight`  
 指定包圍字串的矩形的高度 （以邏輯單位表示）。 如果`nHeight`為 0，`GrayString`計算區域的高度假設`lpData`是字串的指標。  
  
### <a name="return-value"></a>傳回值  
 繪製字串時，如果為非零或 0，如果`TextOut`函式或應用程式所提供的輸出函式傳回 0，或如果發生記憶體不足，無法建立記憶體點陣圖變暗。  
  
### <a name="remarks"></a>備註  
 函式變暗不論選取的筆刷和背景的文字。 `GrayString`成員函式會使用目前選取的字型。 `MM_TEXT`您必須選取對應模式，才能使用這個函式。  
  
 應用程式可以支援灰色純色，而不需呼叫的裝置上繪製呈現暗灰色 （灰色） 字串`GrayString`成員函式。 系統色彩**COLOR_GRAYTEXT**是用來繪製已停用的文字的實線灰色系統色彩。 應用程式可以呼叫**GetSysColor** Windows 函式可擷取的色彩值**COLOR_GRAYTEXT**。 如果色彩為 0 （黑色） 以外，應用程式可以呼叫`SetTextColor`成員函式來設定文字色彩的色彩值，然後直接繪製字串。 如果擷取的色彩為黑色，應用程式必須呼叫`GrayString`變暗的方法 （灰色） 文字。  
  
 如果`lpfnOutput`是**NULL**，GDI 會使用 Windows [TextOut](http://msdn.microsoft.com/library/windows/desktop/dd145133)函式，和`lpData`假設為輸出字元的遠端指標。 如果要輸出的字元不能由處理`TextOut`成員函式 （例如，字串會儲存為點陣圖，） 應用程式必須提供自己的輸出函式。  
  
 也請注意所有的回呼函式必須傳回對 Windows 而言，因為無法跨越界限回呼擲回例外狀況之前設陷 Mfc 例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。  
  
 回呼函式傳遞至`GrayString`必須使用`__stdcall`呼叫慣例，而且必須使用匯出`__declspec`。  
  
 當架構是在預覽模式中，呼叫`GrayString`成員函式會轉譯為`TextOut`呼叫時，並回呼函式不會呼叫。  
  
##  <a name="himetrictodp"></a>CDC::HIMETRICtoDP  
 使用此函式，當您轉換**HIMETRIC** OLE 像素為單位的大小。  
  
```  
void HIMETRICtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 裝置內容物件的對應模式是否`MM_LOENGLISH`， `MM_HIENGLISH`，`MM_LOMETRIC`或`MM_HIMETRIC`，然後轉換為基礎的實體英吋的像素數目。 對應模式是一種其他非限制模式 (例如`MM_TEXT`)，然後轉換為基礎的邏輯英吋的像素數目。  
  
##  <a name="himetrictolp"></a>CDC::HIMETRICtoLP  
 呼叫此函式轉換**HIMETRIC**成邏輯單元的單位。  
  
```  
void HIMETRICtoLP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 使用此函式，當您取得**HIMETRIC**大小來自 OLE 且想要將它們轉換成您的應用程式的自然對應模式。  
  
 轉換透過第一個轉換**HIMETRIC**單位為像素為單位，然後再將這些單位轉換成使用裝置內容的目前對應單位的邏輯單元。 請注意，裝置的視窗和檢視區的範圍會影響結果。  
  
##  <a name="intersectcliprect"></a>CDC::IntersectClipRect  
 藉由形成目前區域和所指定的矩形的交集來建立新的裁剪區域`x1`， `y1`， `x2`，和`y2`。  
  
```  
int IntersectClipRect(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
int IntersectClipRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定之矩形左上角的邏輯 x 座標。  
  
 `y1`  
 指定之矩形左上角的邏輯 y 座標。  
  
 `x2`  
 指定矩形右下角的邏輯 x 座標。  
  
 `y2`  
 指定矩形右下角的邏輯 y 座標。  
  
 `lpRect`  
 指定的矩形。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
### <a name="return-value"></a>傳回值  
 新的裁剪區域類型。 它可以是下列值之一︰  
  
- **COMPLEXREGION**新裁剪區域有重疊的框線。  
  
- **錯誤**裝置內容不正確。  
  
- **NULLREGION**新裁剪區域是空的。  
  
- **SIMPLEREGION**新裁剪區域有沒有重疊的框線。  
  
### <a name="remarks"></a>備註  
 GDI 裁剪以納入新的界限內的所有後續輸出。 寬度和高度不能超過 32767。  
  
##  <a name="invertrect"></a>CDC::InvertRect  
 反轉指定矩形的內容。  
  
```  
void InvertRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向`RECT`，其中包含要反轉矩形的邏輯座標。 您也可以傳遞`CRect`這個參數的物件。  
  
### <a name="remarks"></a>備註  
 反轉是邏輯作業，並是每個像素的位元翻轉。 在單色顯示器，此函式對於白色像素的黑色和黑色的像素白色。 色彩顯示反轉取決於如何顯示產生的色彩。 呼叫`InvertRect`兩次以相同的矩形會顯示還原至其先前的色彩。  
  
 如果是空的矩形，不繪製。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&36;](../../mfc/codesnippet/cpp/cdc-class_8.cpp)]  
  
##  <a name="invertrgn"></a>CDC::InvertRgn  
 反轉所指定的區域中的色彩`pRgn`。  
  
```  
BOOL InvertRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 識別要反轉的區域。 以邏輯單位表示指定之區域的座標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 在單色顯示器，此函式對於白色像素的黑色和黑色的像素白色。 色彩顯示反轉取決於如何顯示產生的色彩。  
  
##  <a name="isprinting"></a>CDC::IsPrinting  
 判斷是否正在使用的裝置內容進行列印。  
  
```  
BOOL IsPrinting() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果為非零`CDC`物件是印表機 DC，否則傳回 0。  
  
##  <a name="lineto"></a>CDC::LineTo  
 從目前的位置，但不是包括、 指定的點繪製一條線*x*和*y* (或`point`)。  
  
```  
BOOL LineTo(
    int x,  
    int y);  
  
BOOL LineTo(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定線條端點的邏輯 x 座標。  
  
 *y*  
 指定線條端點的邏輯 y 座標。  
  
 `point`  
 指定線條的端點。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 這條線繪製; 如果為非零否則為 0。  
  
### <a name="remarks"></a>備註  
 使用所選的畫筆繪製線條。 目前的位置會設定為*x*， *y*或`point`。  
  
### <a name="example"></a>範例  
  請參閱範例[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。  
  
##  <a name="lptodp"></a>CDC::LPtoDP  
 將邏輯單元轉換成裝置單位。  
  
```  
void LPtoDP(
    LPPOINT lpPoints,  
    int nCount = 1) const;  
  
void LPtoDP(LPRECT lpRect) const;
void LPtoDP(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 點的陣列指標。 陣列中的每個點都[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。  
  
 `nCount`  
 陣列中的點數目。  
  
 `lpRect`  
 指向[RECT](../../mfc/reference/rect-structure1.md)結構或[CRect](../../atl-mfc-shared/reference/crect-class.md)物件。 使用這個參數是對應到裝置單位矩形從邏輯的常見案例。  
  
 `lpSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。  
  
### <a name="remarks"></a>備註  
 函式對應的每個點座標或大小，從裝置座標系統到 GDI 的邏輯座標系統的維度。 轉換取決於目前的對應模式和原始來源的設定和裝置的視窗和檢視區的範圍。  
  
 X 和 y 座標的點是 2 位元組帶正負號的整數 – 32768 到 32767 範圍內。 在其中的對應模式會導致值大於這些限制的情況下，系統將值設定為 – 32768 與 32767，分別。  
  
##  <a name="lptohimetric"></a>CDC::LPtoHIMETRIC  
 呼叫此函式轉換成邏輯單元**HIMETRIC**單位。  
  
```  
void LPtoHIMETRIC(LPSIZE lpSize) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpSize`  
 指向**大小**結構或`CSize`物件。  
  
### <a name="remarks"></a>備註  
 使用此函式，當您為**HIMETRIC**至 OLE，從您的應用程式的自然對應模式轉換的大小。 請注意，裝置的視窗和檢視區的範圍會影響結果。  
  
 轉換透過第一個轉換的邏輯單位使用的裝置內容的目前對應單位，再將轉換成這些單位為像素**HIMETRIC**單位。  
  
##  <a name="m_hattribdc"></a>CDC::m_hAttribDC  
 這個屬性的裝置內容`CDC`物件。  
  
```  
HDC m_hAttribDC;  
```  
  
### <a name="remarks"></a>備註  
 根據預設，這個裝置內容是等於`m_hDC`。 一般而言，`CDC`要求資訊從裝置內容的 GDI 呼叫會導向至`m_hAttribDC`。 請參閱[CDC](../../mfc/reference/cdc-class.md)類別如需使用的這兩個裝置內容的描述。  
  
##  <a name="m_hdc"></a>CDC::m_hDC  
 輸出裝置內容，這個`CDC`物件。  
  
```  
HDC m_hDC;  
```  
  
### <a name="remarks"></a>備註  
 根據預設，`m_hDC`等於`m_hAttribDC`，其他所包裝的裝置內容`CDC`。 一般而言， `CDC` GDI 呼叫建立輸出，請移至`m_hDC`裝置內容。 您可以初始化`m_hDC`和`m_hAttribDC`指向不同的裝置。 請參閱[CDC](../../mfc/reference/cdc-class.md)類別如需使用的這兩個裝置內容的描述。  
  
##  <a name="maskblt"></a>CDC::MaskBlt  
 結合使用指定的遮罩與點陣化操作的來源和目的地點陣圖的色彩資料。  
  
```  
BOOL MaskBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定目的地矩形的左上角的邏輯 x 座標。  
  
 *y*  
 指定目的地矩形的左上角的邏輯 y 座標。  
  
 `nWidth`  
 指定邏輯單元，目的地矩形和來源點陣圖的寬度。  
  
 `nHeight`  
 指定邏輯單元，目的地矩形和來源點陣圖的高度。  
  
 `pSrcDC`  
 識別來源點陣圖已複製的裝置內容。 它必須是零*dwRop*參數會指定不包含來源點陣化操作。  
  
 `xSrc`  
 指定邏輯來源點陣圖的左上角的 x 座標。  
  
 `ySrc`  
 指定邏輯來源點陣圖的左上角的 y 座標。  
  
 `maskBitmap`  
 識別色彩點陣圖來源裝置內容中與結合黑白遮罩點陣圖。  
  
 `xMask`  
 指定所指定的遮罩點陣圖的水平像素位移`maskBitmap`參數。  
  
 `yMask`  
 指定所指定的遮罩點陣圖的像素垂直位移`maskBitmap`參數。  
  
 *dwRop*  
 指定前景和背景三元點陣化操作程式碼，用來控制的來源和目的地資料組合的函式。 背景的點陣作業程式碼會儲存在此值; 高字其高位元前景點陣作業程式碼會儲存在此值; 高 word 的低位元組此值低序位文字會被忽略，而且必須為零。 巨集**MAKEROP4**點陣化操作程式碼會建立這類的前景和背景的組合。 請參閱 < 備註 > 一節討論的前景和背景，此函式的內容中。 請參閱`BitBlt`常見點陣化操作程式碼清單的成員函式。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 值為 1 中所指定的遮罩`maskBitmap`表示前景點陣作業程式碼會指定由*dwRop*應該套用該位置。 遮罩中的 0 值表示所指定背景點陣作業程式碼*dwRop*應該套用該位置。 點陣作業需要來源，如果遮罩矩形必須涵蓋來源矩形。 如果不存在，此函式會失敗。 點陣作業則不需要為來源，如果遮罩矩形必須涵蓋目的矩形。 如果不存在，此函式會失敗。  
  
 如果旋轉或傾斜轉換是作用中來源裝置內容中，呼叫此函式時，發生錯誤。 不過，允許其他類型的轉換。  
  
 如果來源、 模式和目的地點陣圖的色彩格式不同，此函式會將模式或來源格式，或兩者，以符合目的格式。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 記錄的增強型中繼檔時，發生錯誤 （和函式會傳回 0） 如果來源裝置內容會識別使用增強型中繼檔裝置內容。 並非所有裝置都支援`MaskBlt`。 應用程式應該呼叫`GetDeviceCaps`來判斷裝置是否支援此函式。 如果沒有提供任何遮罩點陣圖，此函式的行為完全相同`BitBlt`，使用前景點陣作業程式碼。 來源裝置內容的點陣圖中的點 (0，0) 的遮罩點陣圖對應中位移的像素。 這是包含一系列遮罩; 之遮罩點陣圖的情況下很有用應用程式可以輕鬆地套用其中任何一個遮罩單色工作藉由調整像素位移和矩形大小傳送至`MaskBlt`。  
  
##  <a name="modifyworldtransform"></a>CDC::ModifyWorldTransform  
 變更裝置內容中使用指定的模式的自然轉換。  
  
```  
BOOL ModifyWorldTransform(
    const XFORM& rXform,  
    DWORD iMode);
```  
  
### <a name="parameters"></a>參數  
 `rXform`  
 若要參考[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)結構，用來修改全局轉換指定的裝置內容。  
  
 `iMode`  
 指定如何轉換資料修改目前全局轉換。 如需這個參數可以接受的值，請參閱[ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)。  
  
### <a name="return-value"></a>傳回值  
 如果成功，傳回非零值。  
  
 在失敗時傳回 0。  
  
 若要取得擴充的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[ModifyWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145060)。  
  
##  <a name="moveto"></a>CDC::MoveTo  
 目前的位置移至指定的點*x*和*y* (或由`point`)。  
  
```  
CPoint MoveTo(
    int x,  
    int y);  
  
CPoint MoveTo(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新位置的邏輯 x 座標。  
  
 *y*  
 指定新位置的邏輯 y 座標。  
  
 `point`  
 指定新位置。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 先前的位置，以 x 和 y 座標`CPoint`物件。  
  
### <a name="example"></a>範例  
  請參閱範例[CRect::CenterPoint](../../atl-mfc-shared/reference/crect-class.md#centerpoint)。  
  
##  <a name="offsetcliprgn"></a>CDC::OffsetClipRgn  
 將指定之位移的裝置內容的裁剪區域。  
  
```  
int OffsetClipRgn(
    int x,  
    int y);  
  
int OffsetClipRgn(SIZE size);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要向左移動，或向右的邏輯單元數。  
  
 *y*  
 指定要上移或下移的邏輯單元數。  
  
 `size`  
 指定位移的數量。  
  
### <a name="return-value"></a>傳回值  
 新的區域類型。 它可以是下列值之一︰  
  
- **COMPLEXREGION**裁剪區域有重疊的框線。  
  
- **錯誤**裝置內容不正確。  
  
- **NULLREGION**裁剪區域是空的。  
  
- **SIMPLEREGION**裁剪區域有沒有重疊的框線。  
  
### <a name="remarks"></a>備註  
 函式將移區域*x*沿著 x 軸單位並*y*沿著 y 軸的單位。  
  
##  <a name="offsetviewportorg"></a>CDC::OffsetViewportOrg  
 修改檢視區原點，相對於目前的檢視區原點座標的座標。  
  
```  
virtual CPoint OffsetViewportOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `nWidth`  
 指定將新增至目前的原點的 x 座標裝置單位數目。  
  
 `nHeight`  
 指定裝置將加入至目前的原點的 y 座標的單位數目。  
  
### <a name="return-value"></a>傳回值  
 上一個檢視區的原點 （以裝置座標表示） 做為`CPoint`物件。  
  
##  <a name="offsetwindoworg"></a>CDC::OffsetWindowOrg  
 修改視窗原點，相對於目前視窗原點座標的座標。  
  
```  
CPoint OffsetWindowOrg(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `nWidth`  
 指定將新增至目前的原點的 x 座標的邏輯單元數。  
  
 `nHeight`  
 指定將新增至目前的原點的 y 座標的邏輯單元數。  
  
### <a name="return-value"></a>傳回值  
 做為 （以邏輯座標表示） 上一個視窗原點`CPoint`物件。  
  
##  <a name="operator_hdc"></a>CDC::operator HDC  
 使用這個運算子來擷取的裝置內容控制代碼`CDC`物件。  
  
```  
operator HDC() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功，控制代碼的裝置內容物件。否則， **NULL**。  
  
### <a name="remarks"></a>備註  
 若要直接呼叫 Windows Api，您可以使用控制代碼。  
  
##  <a name="paintrgn"></a>CDC::PaintRgn  
 填滿指定的區域`pRgn`使用目前的筆刷。  
  
```  
BOOL PaintRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 識別要填滿區域。 指定區域的座標會指定以邏輯單位表示。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="patblt"></a>CDC::PatBlt  
 裝置上建立一個位元模式。  
  
```  
BOOL PatBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要接收模式的矩形的左上角的邏輯 x 座標。  
  
 *y*  
 指定要接收模式的矩形的左上角的邏輯 y 座標。  
  
 `nWidth`  
 指定要接收模式的矩形的寬度 （以邏輯單位表示）。  
  
 `nHeight`  
 指定要接收模式的矩形的高度 （以邏輯單位表示）。  
  
 *dwRop*  
 指定的點陣作業程式碼。 點陣作業程式碼 (ROPs) 定義 GDI 結合輸出操作，包括目前的筆刷、 可能的來源點陣圖和目的地點陣圖中色彩的方式。 這個參數可以是下列值之一︰  
  
- **PATCOPY**複製到目的地點陣圖的模式。  
  
- **PATINVERT**結合目的地點陣圖與模式中使用布林值 XOR 運算子。  
  
- **DSTINVERT**反轉目的地點陣圖。  
  
- **BLACKNESS**將所有輸出變成黑色。  
  
- **亮度**所有將輸出的變成白色。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 模式是選取的筆刷和已在裝置上的模式的組合。 所指定的點陣作業程式碼*dwRop*定義模式的組合方式。 這個函式所列的點陣作業會完整 256 的三元點陣化操作程式碼; 的有限的子集特別是，不能用於參考來源的點陣作業程式碼。  
  
 並非所有的裝置內容支援`PatBlt`函式。 若要判斷裝置的內容是否支援`PatBlt`，呼叫`GetDeviceCaps`成員函式**RASTERCAPS**編製索引，並檢查傳回值**RC_BITBLT**旗標。  
  
##  <a name="pie"></a>CDC::Pie  
 藉由繪製橢圓弧形為中心和兩個端點聯結在一起的線條繪製派形的楔形。  
  
```  
BOOL Pie(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3,  
    int x4,  
    int y4);

 
BOOL Pie(
    LPCRECT lpRect,
    POINT ptStart,
    POINT ptEnd);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示），這個周框左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示），這個周框左上角的 y 座標。  
  
 `x2`  
 指定週框 （以邏輯單位表示） 的右下角的 x 座標。  
  
 `y2`  
 指定週框 （以邏輯單位表示） 的右下角的 y 座標。  
  
 *x3*  
 指定 （以邏輯單位表示） 的弧形開始點的 x 座標。 此時沒有完全位於弧線。  
  
 `y3`  
 指定 （以邏輯單位表示） 的弧形開始點的 y 座標。 此時沒有完全位於弧線。  
  
 `x4`  
 指定 （以邏輯單位表示） 的弧形結束點的 x 座標。 此時沒有完全位於弧線。  
  
 `y4`  
 指定 （以邏輯單位表示） 的弧形結束點的 y 座標。 此時沒有完全位於弧線。  
  
 `lpRect`  
 指定週框。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
 `ptStart`  
 指定圓弧的起點。 此時沒有完全位於弧線。 您可以傳遞[點](../../mfc/reference/point-structure1.md)結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
 `ptEnd`  
 指定弧形結束的點。 此時沒有完全位於弧線。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 弧線的中心是由指定週框的中央`x1`， `y1`， `x2`，和`y2`(或由`lpRect`)。 所指定的起點和終點的圓弧*x3*， `y3`， `x4`，和`y4`(或由`ptStart`和`ptEnd`)。  
  
 繪製弧形使用所選的畫筆，以逆時針方向移動。 兩個額外的線條會繪製弧形的中心從每個端點。 目前的筆刷填滿的派形區域。 如果*x3*等於`x4`和`y3`等於`y4`，結果就是從橢圓形的中心點為單行的橢圓形 ( *x3*， `y3`) 或 ( `x4`， `y4`)。  
  
 此函式所繪製的圖最多會擴充，但不包含右側和底端座標。 這表示圖表的高度是`y2`–`y1`圖表的寬度，而且`x2`– `x1`。 週框的高度和寬度必須大於 2 個單位且小於 32767 個單位。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&37;](../../mfc/codesnippet/cpp/cdc-class_9.cpp)]  
  
##  <a name="playmetafile"></a>CDC::PlayMetaFile  
 裝置內容上播放指定的中繼檔的內容。  
  
```  
BOOL PlayMetaFile(HMETAFILE hMF);

 
BOOL PlayMetaFile(
    HENHMETAFILE hEnhMetaFile,  
    LPCRECT lpBounds);
```  
  
### <a name="parameters"></a>參數  
 *hMF*  
 識別要播放的中繼檔。  
  
 *hEnhMetaFile*  
 識別增強型中繼檔。  
  
 `lpBounds`  
 指向`RECT`結構或`CRect`物件，其中包含用來顯示圖片，這個周框的座標。 以邏輯單位表示指定座標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 中繼檔可以播放次數不限。  
  
 第二版`PlayMetaFile`不會儲存在指定的加強格式中繼檔中的圖片。 當應用程式呼叫第二版`PlayMetaFile`，Windows 使用增強型中繼檔標頭中要對應到所指的矩形的圖片圖片框`lpBounds`參數。 (這張圖片可能修剪或旋轉輸出裝置，然後再呼叫中設定全局轉換`PlayMetaFile`。)邊緣的矩形的點包含在圖片中。 增強型中繼檔圖片也可裁剪播放增強型中繼檔之前，在輸出裝置中定義的裁剪區域。  
  
 增強型中繼檔包含選擇性的調色盤，如果應用程式可以藉由設定輸出裝置的調色盤，然後再呼叫第二版達到一致的色彩`PlayMetaFile`。 若要擷取選擇性的調色盤，請使用**GetEnhMetaFilePaletteEntries** Windows 函式。 增強型中繼檔可以內嵌在新建立的增強型中繼檔中，藉由呼叫第二版`PlayMetaFile`並放入裝置內容的來源增強型中繼檔播放新的增強型中繼檔。  
  
 輸出裝置內容的狀態會保留此函式。 此函式會刪除任何物件建立，但不是刪除增強型中繼檔中。 若要停止此函式，應用程式可以呼叫**CancelDC** Windows 函式，從另一個執行緒終止作業。 在此情況下，函數會傳回零。  
  
##  <a name="plgblt"></a>CDC::PlgBlt  
 執行從來源裝置內容中指定的矩形的色彩資料位元的位元區塊轉送，來指定的裝置內容中指定的平行四邊形。  
  
```  
BOOL PlgBlt(
    LPPOINT lpPoint,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nWidth,  
    int nHeight,  
    CBitmap& maskBitmap,  
    int xMask,  
    int yMask);
```  
  
### <a name="parameters"></a>參數  
 `lpPoint`  
 識別目的地平行四邊形的三個角的邏輯空間中的三個點的陣列指標。 來源矩形左上角對應到這個陣列、 至這個陣列中的第二個點的右上角和左下角，第三個點的第一個點。 來源矩形的右下角會對應至的平行四邊形中隱含的第四個點。  
  
 `pSrcDC`  
 識別來源裝置內容。  
  
 `xSrc`  
 指定邏輯單元，來源矩形左上角的 x 座標。  
  
 `ySrc`  
 指定邏輯單元，來源矩形左上角的 y 座標。  
  
 `nWidth`  
 指定邏輯單元，來源矩形的寬度。  
  
 `nHeight`  
 來源矩形的邏輯單位中指定的高度。  
  
 `maskBitmap`  
 識別用來遮罩來源矩形的色彩選擇性單色點陣圖。  
  
 `xMask`  
 指定單色點陣圖左上角的 x 座標。  
  
 `yMask`  
 指定單色點陣圖左上角的 y 座標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 如果指定的位元遮罩的控制代碼識別有效的單色點陣圖，此函數會使用這個點陣圖遮罩從來源矩形的色彩資料位元。  
  
 藉由將前三個定義的第四個頂點 (D) 的平行四邊形的點 （A、 B 和 C） 做為向量和運算 D = B + C-a。  
  
 如果存在位元遮罩，1 遮罩中的值會指出來源像素色彩，應該複製到目的地。 遮罩中的 0 表示目的地像素色彩就是不能變更。  
  
 如果遮罩矩形小於來源和目的矩形，函式會將複寫遮罩模式。  
  
 在 來源裝置內容中，允許縮放、 轉移和反映轉換不過，旋轉及傾斜轉換不。 如果遮罩點陣圖不是單色點陣圖，就會發生錯誤。 目的地裝置內容的縮放模式用來判斷如何縮放或壓縮的像素為單位，這是必要。 記錄的增強型中繼檔時，如果來源裝置內容會識別使用增強型中繼檔裝置內容，就會發生錯誤。  
  
 目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。 如果來源轉換旋轉或傾斜，則會傳回錯誤。 如果目的地和來源矩形的色彩格式不同，不需要`PlgBlt`將來源矩形以符合目的地矩形的轉換。 並非所有裝置都支援`PlgBlt`。 如需詳細資訊，請參閱的描述**RC_BITBLT**點陣功能`CDC::GetDeviceCaps`成員函式。  
  
 如果來源和目的地裝置內容代表不相容的裝置，`PlgBlt`會傳回錯誤。  
  
##  <a name="polybezier"></a>CDC::PolyBezier  
 繪製一個或多個 Bzier 曲線。  
  
```  
BOOL PolyBezier(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)資料結構，其中包含端點，並控制 spline(s) 的點。  
  
 `nCount`  
 指定的資料點數目`lpPoints`陣列。 此值必須是其中一個要繪製曲線的數目超過三次，因為每個 Bzier 曲線需要兩個控點和結束點，以及初始曲線需要額外的起始點。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式使用的端點和所指定的控點繪製三次方 Bzier 曲線`lpPoints`參數。 第一次的曲線會使用第二個和第三個點做為控制點，從第一個點繪製到第四個點。 序列中的每個後續曲線需要剛好三個重點︰ 先前曲線結束點做為起始點、 序列中的下面兩個點控點，以及第三個是結束點。  
  
 目前的位置不會使用或更新`PolyBezier`函式。 此圖不會填滿。 此函式使用目前畫筆繪製線條。  
  
##  <a name="polybezierto"></a>CDC::PolyBezierTo  
 繪製一個或多個 Bzier 曲線。  
  
```  
BOOL PolyBezierTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)點包含在端點和控制項的資料結構。  
  
 `nCount`  
 指定的資料點數目`lpPoints`陣列。 此值必須是要繪製曲線的數目三次，因為每個 Bzier 曲線需要兩個控點和結束點。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式使用所指定的控點來繪製三次方 Bzier 曲線`lpPoints`參數。 第一次的曲線會使用前兩個點做為控制點，從目前的位置繪製到第三個點。 針對每個後續的曲線，函式需要剛好三個點，並使用先前的曲線結束點做為起點下, 一個。 `PolyBezierTo`將目前位置移至最後一個 Bzier 曲線結束點。 此圖不會填滿。 此函式使用目前畫筆繪製線條。  
  
### <a name="example"></a>範例  
  請參閱範例[cdc:: beginpath](#beginpath)。  
  
##  <a name="polydraw"></a>CDC::PolyDraw  
 繪製一組直線線段和 Bzier 曲線。  
  
```  
BOOL PolyDraw(
    const POINT* lpPoints,  
    const BYTE* lpTypes,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)資料結構，其中包含端點，每個直線線段與端點，並控制每個 Bzier 曲線的點。  
  
 `lpTypes`  
 指向陣列，指定每個中的點`lpPoints`陣列使用的。 值可以是下列其中一項︰  
  
- **PT_MOVETO**指定這個點開始脫離圖形。 這個點會成為新的目前位置。  
  
- **PT_LINETO**指定要從目前位置到目前為止，就會變成新的目前位置繪製一條線。  
  
- **PT_BEZIERTO**指定此點控制點或 Bzier 曲線結束點。  
  
 **PT_BEZIERTO**類型一定會發生在三個集合中。 目前的位置定義 Bzier 曲線的開始點。 前兩個**PT_BEZIERTO**點是第三個控制點， **PT_BEZIERTO**點是結束點。 結束點會成為新的目前位置。 如果沒有三個連續**PT_BEZIERTO**點，會產生錯誤。  
  
     A **PT_LINETO**或**PT_BEZIERTO**類型可以使用下列常數結合使用位元運算子，或已關閉，表示對應的點是圖表與圖中的最後一點︰  
  
- **PT_CLOSEFIGURE**後自動關閉此圖中的指定**PT_LINETO**或**PT_BEZIERTO**輸入此點。 從這個點最新繪製線條**PT_MOVETO**或`MoveTo`點。  
  
     這個旗標結合**PT_LINETO**類型對於線條，或使用**PT_BEZIERTO** Bzier 曲線的點結束使用位元的型別`OR`運算子。 目前的位置設為結束點的結尾行。  
  
 `nCount`  
 指定的資料點總數`lpPoints`陣列中的位元組數目相同`lpTypes`陣列。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式可以用來繪製不相鄰的數字來取代連續呼叫`CDC::MoveTo`， `CDC::LineTo`，和`CDC::PolyBezierTo`成員函式。 線條和曲線會使用目前的畫筆繪製並不會填滿圖形。 如果沒有使用中路徑啟動藉由呼叫`CDC::BeginPath`成員函式，`PolyDraw`將加入路徑。 中所包含的點`lpPoints`陣列和`lpTypes`指出每個點是否屬於`CDC::MoveTo`、 `CDC::LineTo`，或**CDC::BezierTo**作業。 此外，也可以關閉數字。 此函式會更新目前的位置。  
  
### <a name="example"></a>範例  
  請參閱範例[cdc:: beginpath](#beginpath)。  
  
##  <a name="polygon"></a>CDC::Polygon  
 繪製多邊形，其中包含兩個或多個 （頂點） 以折線連接點，使用目前的畫筆。  
  
```  
BOOL Polygon(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指定多邊形的頂點的點的陣列指標。 陣列中的每個點都**點**結構或`CPoint`物件。  
  
 `nCount`  
 陣列中指定頂點的數目。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 系統多邊形會自動關閉，必要時，所繪製一條線從最後一個頂點，第一個。  
  
 目前的多邊形填滿模式可擷取或設定使用`GetPolyFillMode`和`SetPolyFillMode`成員函式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&38;](../../mfc/codesnippet/cpp/cdc-class_10.cpp)]  
  
##  <a name="polyline"></a>CDC::Polyline  
 繪製連接所指定的點之直線線段的一組`lpPoints`。  
  
```  
BOOL Polyline(
    LPPOINT lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列**點**結構或`CPoint`連接物件。  
  
 `nCount`  
 陣列中指定點的數目。 此值必須至少為 2。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 線條會繪製從透過使用目前的畫筆後續點的第一個點。 不同於`LineTo`成員函式，`Polyline`函式不會使用，也不會更新目前的位置。  
  
 如需詳細資訊，請參閱[聚合線條](http://msdn.microsoft.com/library/windows/desktop/dd162815)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="polylineto"></a>CDC::PolylineTo  
 繪製一個或多個直線。  
  
```  
BOOL PolylineTo(
    const POINT* lpPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列[點](../../mfc/reference/point-structure1.md)資料結構，包含線條的頂點。  
  
 `nCount`  
 陣列中指定點的數目。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 從目前位置所指定的第一個點來繪製線條`lpPoints`參數使用目前的畫筆。 對於每個額外的一行，函式用來繪製從結束點上一行的下一個所指定的點`lpPoints`。 `PolylineTo`將目前位置移至最後一行的結束點。 如果此函式所繪製之直線線段形成封閉的圖表，此圖不會填滿。  
  
##  <a name="polypolygon"></a>CDC::PolyPolygon  
 建立兩個或多個使用目前的多邊形填滿模式會填滿的多邊形。  
  
```  
BOOL PolyPolygon(
    LPPOINT lpPoints,  
    LPINT lpPolyCounts,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 指向陣列**點**結構或`CPoint`物件，以定義多邊形的頂點。  
  
 `lpPolyCounts`  
 整數的陣列指標，其中每個指定的點數內之多邊形的其中一個`lpPoints`陣列。  
  
 `nCount`  
 中的項目數`lpPolyCounts`陣列。 此數字會指定要繪製多邊形的數目。 此值必須至少為 2。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 多邊形可能脫離或重疊。  
  
 若要在呼叫中指定每個多邊形`PolyPolygon`函式必須先關閉。 不同於所建立的多邊形**多邊形**成員函式，所建立之多邊形`PolyPolygon`未自動關閉。  
  
 函式會建立兩個或多個多邊形。 若要建立單一的多邊形，應用程式應該使用**多邊形**成員函式。  
  
 目前的多邊形填滿模式可擷取或設定使用`GetPolyFillMode`和`SetPolyFillMode`成員函式。  
  
##  <a name="polypolyline"></a>CDC::PolyPolyline  
 繪製連接的直線線段的多個數列。  
  
```  
BOOL PolyPolyline(
    const POINT* lpPoints,  
    const DWORD* lpPolyPoints,  
    int nCount);
```  
  
### <a name="parameters"></a>參數  
 `lpPoints`  
 結構，其中包含的多線條端點的陣列指標。 連續指定多線條。  
  
 `lpPolyPoints`  
 陣列的指定點數目的變數會指向`lpPoints`陣列中對應的多邊形。 每個項目必須是大於或等於 2。  
  
 `nCount`  
 指定總數的計數中`lpPolyPoints`陣列。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 使用目前畫筆繪製之直線線段。 區段的格式的數字不會填滿。 目前的位置不是使用或更新此函式。  
  
##  <a name="ptvisible"></a>CDC::PtVisible  
 判斷指定的點是否在裝置內容的裁剪區域內。  
  
```  
virtual BOOL PtVisible(
    int x,  
    int y) const;  
  
BOOL PtVisible(POINT point) const;  
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定點的邏輯 x 座標。  
  
 *y*  
 指定點的邏輯 y 座標。  
  
 `point`  
 指定要檢查的邏輯座標的點。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果指定的點中的裁剪區域中，為非零否則為 0。  
  
##  <a name="queryabort"></a>CDC::QueryAbort  
 所安裝的中止函式會呼叫[SetAbortProc](#setabortproc)是否應該終止列印成員函式列印應用程式和查詢。  
  
```  
BOOL QueryAbort() const;  
```  
  
### <a name="return-value"></a>傳回值  
 傳回值為非零，如果應該繼續列印，或沒有中止程序。 如果應終止列印工作，它會為 0。 Abort 函式提供所傳回的值。  
  
##  <a name="realizepalette"></a>CDC::RealizePalette  
 將對應從目前的邏輯調色盤到系統調色盤項目。  
  
```  
UINT RealizePalette();
```  
  
### <a name="return-value"></a>傳回值  
 表示邏輯調色盤中的項目數量已對應至不同系統調色盤中的項目。 這表示此函式重新對應至配合系統調色盤中的變更，因為邏輯調色盤上一次已發現的項目數。  
  
### <a name="remarks"></a>備註  
 邏輯調色盤做為緩衝區色彩密集的應用程式與系統，讓應用程式使用許多視需要而不會影響使用它自己的色彩顯示色彩之間，或以其他視窗所顯示的色彩。  
  
 當視窗具有輸入的焦點並呼叫`RealizePalette`，Windows 可確保視窗會顯示所有要求的色彩，最多同時可在螢幕上的最大數目。 Windows 也會顯示找不到視窗的調色盤中的比它們對可用色彩的色彩。  
  
 此外，Windows 會比對要求的可用色彩儘可能密集地呼叫的函式的非使用中視窗的色彩。 這會大幅降低非預期的變更，在非使用中視窗所顯示的色彩。  
  
##  <a name="rectangle"></a>CDC::Rectangle  
 繪製矩形，使用目前的畫筆。  
  
```  
BOOL Rectangle(
    int x1,  
    int y1,  
    int x2,  
    int y2);  
  
BOOL Rectangle(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 y 座標。  
  
 `x2`  
 指定 （以邏輯單位表示） 的矩形右下角的 x 座標。  
  
 `y2`  
 指定 （以邏輯單位表示） 的矩形右下角的 y 座標。  
  
 `lpRect`  
 以邏輯單位表示指定的矩形。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 矩形內部會使用目前的筆刷填滿。  
  
 矩形會擴充到，但不包含，右側和底端座標。 這表示的矩形的高度是`y2`–`y1`矩形的寬度，而且`x2`– `x1`。 矩形的高度和寬度必須大於 2 個單位且小於 32767 個單位。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&39;](../../mfc/codesnippet/cpp/cdc-class_11.cpp)]  
  
##  <a name="rectvisible"></a>CDC::RectVisible  
 判斷指定的任何的矩形部分是否位於顯示內容的裁剪區域。  
  
```  
virtual BOOL RectVisible(LPCRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向`RECT`結構或`CRect`物件，其中包含指定的矩形的邏輯座標。  
  
### <a name="return-value"></a>傳回值  
 如果有任何非零值指定的矩形部分之內的裁剪區域。否則為 0。  
  
##  <a name="releaseattribdc"></a>CDC::ReleaseAttribDC  
 呼叫此成員函式設定`m_hAttribDC`至**NULL**。  
  
```  
virtual void ReleaseAttribDC();
```  
  
### <a name="remarks"></a>備註  
 這不會造成**卸離**發生。 僅輸出裝置內容會附加至`CDC`物件，而只是它可卸離。  
  
##  <a name="releaseoutputdc"></a>CDC::ReleaseOutputDC  
 呼叫此成員函式設定`m_hDC`成員**NULL**。  
  
```  
virtual void ReleaseOutputDC();
```  
  
### <a name="remarks"></a>備註  
 無法呼叫此成員函式，當輸出裝置內容附加到`CDC`物件。 使用**卸離**成員函式來卸離輸出裝置內容。  
  
##  <a name="resetdc"></a>CDC::ResetDC  
 呼叫此成員函式更新所包裝的裝置內容`CDC`物件。  
  
```  
BOOL ResetDC(const DEVMODE* lpDevMode);
```  
  
### <a name="parameters"></a>參數  
 *lpDevMode*  
 Windows 的指標`DEVMODE`結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 裝置內容會從指定的 Windows 中的資訊更新`DEVMODE`結構。 此成員函式只會重設屬性裝置內容。  
  
 應用程式通常會使用`ResetDC`成員函式 視窗中處理時`WM_DEVMODECHANGE`訊息。 您也可以使用此成員函式，若要在列印文件時變更紙張方向、 紙張紙匣。  
  
 若要變更驅動程式名稱、 裝置名稱或輸出連接埠，您無法使用此成員函式。 當使用者變更連接埠連線或裝置名稱時，您必須刪除原始的裝置內容，並使用新的資訊來建立新的裝置內容。  
  
 呼叫此成員函式之前，您必須確定外，已選取 （非內建物件） 選取放入裝置內容的所有物件。  
  
##  <a name="restoredc"></a>CDC::RestoreDC  
 還原先前的狀態所識別的裝置內容`nSavedDC`。  
  
```  
virtual BOOL RestoreDC(int nSavedDC);
```  
  
### <a name="parameters"></a>參數  
 `nSavedDC`  
 指定要還原的裝置內容。 它可以是先前所傳回的值`SaveDC`函式呼叫。 如果`nSavedDC`為 –&1;，最新的儲存裝置的內容就會回復。  
  
### <a name="return-value"></a>傳回值  
 非零，如果指定的內容已還原。否則為 0。  
  
### <a name="remarks"></a>備註  
 `RestoreDC`還原裝置內容提出由先前呼叫堆疊的狀態資訊`SaveDC`成員函式。  
  
 堆疊可以包含數種裝置內容的狀態資訊。 如果所指定內容`nSavedDC`不是在堆疊頂端`RestoreDC`刪除所指定的裝置內容之間的所有狀態資訊`nSavedDC`和堆疊的頂端。 已刪除的資訊都會遺失。  
  
##  <a name="roundrect"></a>CDC::RoundRect  
 具有圓角使用目前畫筆繪製矩形。  
  
```  
BOOL RoundRect(
    int x1,  
    int y1,  
    int x2,  
    int y2,  
    int x3,  
    int y3);

 
BOOL RoundRect(
    LPCRECT lpRect,
    POINT point);
```  
  
### <a name="parameters"></a>參數  
 `x1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 x 座標。  
  
 `y1`  
 指定 （以邏輯單位表示） 的矩形的左上角的 y 座標。  
  
 `x2`  
 指定 （以邏輯單位表示） 的矩形右下角的 x 座標。  
  
 `y2`  
 指定 （以邏輯單位表示） 的矩形右下角的 y 座標。  
  
 *x3*  
 指定用來繪製圓弧角的半徑 （以邏輯單位表示） 的橢圓形的寬度。  
  
 `y3`  
 指定用來繪製圓弧角的半徑 （以邏輯單位表示） 的橢圓形的高度。  
  
 `lpRect`  
 指定週框以邏輯單位表示。 您可以傳遞`CRect`物件或指標`RECT`結構為此參數。  
  
 `point`  
 X 軸座標`point`指定橢圓形的寬度 （以邏輯單位表示） 繪製圓的角。 Y 軸座標`point`指定的高度 （以邏輯單位表示） 繪製圓的角橢圓形。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 矩形內部會使用目前的筆刷填滿。  
  
 此函式會繪製的圖最多會擴充，但不包含右側和底端座標。 這表示圖表的高度是`y2`–`y1`圖表的寬度，而且`x2`– `x1`。 必須大於 2 個單位且小於 32767 個單位的高度和寬度，這個周框。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCDocView #&40;](../../mfc/codesnippet/cpp/cdc-class_12.cpp)]  
  
##  <a name="savedc"></a>CDC::SaveDC  
 藉由複製狀態資訊 （例如裁剪區域中，選取的物件和對應模式） 將內容堆疊維護 Windows 的裝置內容的目前狀態。  
  
```  
virtual int SaveDC();
```  
  
### <a name="return-value"></a>傳回值  
 識別已儲存的裝置內容的整數。 如果發生錯誤時，它會為 0。 這會傳回值可以用來還原裝置內容呼叫`RestoreDC`。  
  
### <a name="remarks"></a>備註  
 稍後可以還原已儲存的裝置內容使用`RestoreDC`。  
  
 `SaveDC`可以是用來儲存任意數目的裝置內容狀態的次數不限。  
  
##  <a name="scaleviewportext"></a>CDC::ScaleViewportExt  
 修改檢視區範圍相對於目前的值。  
  
```  
virtual CSize ScaleViewportExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>參數  
 `xNum`  
 指定所要乘以目前 x 範圍內。  
  
 `xDenom`  
 指定要除以的值相乘之目前 x 範圍內的量`xNum`參數。  
  
 `yNum`  
 指定所要乘以 y 目前範圍。  
  
 `yDenom`  
 指定要除以的值相乘 y 目前範圍的量`yNum`參數。  
  
### <a name="return-value"></a>傳回值  
 上一個檢視區範圍 （以裝置為單位） 為`CSize`物件。  
  
### <a name="remarks"></a>備註  
 這些公式會寫入，如下所示︰  
  
 `xNewVE = ( xOldVE * xNum ) / xDenom`  
  
 `yNewVE = ( yOldVE * yNum ) / yDenom`  
  
 新的檢視區範圍會計算的乘以指定分子中目前的範圍，然後除以指定的分母。  
  
##  <a name="scalewindowext"></a>CDC::ScaleWindowExt  
 修改視窗範圍相對於目前的值。  
  
```  
virtual CSize ScaleWindowExt(
    int xNum,  
    int xDenom,  
    int yNum,  
    int yDenom);
```  
  
### <a name="parameters"></a>參數  
 `xNum`  
 指定所要乘以目前 x 範圍內。  
  
 `xDenom`  
 指定要除以的值相乘之目前 x 範圍內的量`xNum`參數。  
  
 `yNum`  
 指定所要乘以 y 目前範圍。  
  
 `yDenom`  
 指定要除以的值相乘 y 目前範圍的量`yNum`參數。  
  
### <a name="return-value"></a>傳回值  
 前一個視窗中的範圍 （邏輯單位表示） 做為`CSize`物件。  
  
### <a name="remarks"></a>備註  
 這些公式會寫入，如下所示︰  
  
 `xNewWE = ( xOldWE * xNum ) / xDenom`  
  
 `yNewWE = ( yOldWE * yNum ) / yDenom`  
  
 新的視窗範圍會計算的乘以指定分子中目前的範圍，然後除以指定的分母。  
  
##  <a name="scrolldc"></a>CDC::ScrollDC  
 水平及垂直捲動的位元的矩形。  
  
```  
BOOL ScrollDC(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* pRgnUpdate,  
    LPRECT lpRectUpdate);
```  
  
### <a name="parameters"></a>參數  
 `dx`  
 指定水平捲軸的單位數目。  
  
 *dy*  
 指定垂直捲軸的單位的數。  
  
 `lpRectScroll`  
 指向`RECT`結構或`CRect`物件，其中包含捲動矩形的座標。  
  
 `lpRectClip`  
 指向`RECT`結構或`CRect`物件，其中包含的裁剪矩形的座標。 當這個矩形小於一所指的原始`lpRectScroll`，捲動只會發生在較小的矩形。  
  
 `pRgnUpdate`  
 識別捲動的程序未發現的區域。 `ScrollDC`函式會定義此區域; 它不一定是一個矩形。  
  
 `lpRectUpdate`  
 指向`RECT`結構或`CRect`物件會接收繫結捲動的更新區域的矩形座標。 這是最大需要重新繪製的矩形區域。 結構或物件的函式傳回的值是在工作區座標，無論指定的裝置內容的對應模式。  
  
### <a name="return-value"></a>傳回值  
 如果執行捲動則為非零否則為 0。  
  
### <a name="remarks"></a>備註  
 如果`lpRectUpdate`是**NULL**，Windows 不會計算更新矩形。 如果兩個`pRgnUpdate`和`lpRectUpdate`是**NULL**，Windows 不會計算更新區域。 如果`pRgnUpdate`不**NULL**，Windows 會假設它包含有效的指標以捲動的程序未發現的區域 (定義`ScrollDC`成員函式)。 更新區域中傳回`lpRectUpdate`可以傳遞至`CWnd::InvalidateRgn`必要。  
  
 應用程式應該使用`ScrollWindow`類別成員函式`CWnd`需要捲動視窗的整個用戶端區域。 否則，它應該使用`ScrollDC`。  
  
##  <a name="selectclippath"></a>CDC::SelectClipPath  
 選取目前的路徑做為裝置內容中，使用指定的模式結合使用任何現有的裁剪區域的新區域的裁剪區域。  
  
```  
BOOL SelectClipPath(int nMode);
```  
  
### <a name="parameters"></a>參數  
 `nMode`  
 指定要使用的路徑。 允許下列值︰  
  
- **RGN_AND**新裁剪區域包含了目前裁剪區域和目前的路徑 （重疊區域） 的交集。  
  
- **RGN_COPY**新裁剪區域是目前的路徑。  
  
- **RGN_DIFF**新裁剪區域包含目前裁剪區域的區域，並與目前的路徑排除。  
  
- **RGN_OR**新裁剪區域包含了目前裁剪區域和目前路徑的聯集 （結合區域）。  
  
- **RGN_XOR**新裁剪區域包含聯集為目前裁剪區域和目前的路徑，但不包含重疊的區域。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 識別的裝置內容必須包含已關閉的路徑。  
  
##  <a name="selectcliprgn"></a>CDC::SelectClipRgn  
 選取特定的區域做為目前裁剪區域的裝置內容。  
  
```  
int SelectClipRgn(CRgn* pRgn);

 
int SelectClipRgn(
    CRgn* pRgn,  
    int nMode);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 識別要選取的區域。  
  
-   此函式，如果此值的第一個版本**NULL**、 選取整個用戶端區域和輸出仍會被裁剪至視窗。  
  
-   此函式的第二個版本，此控制代碼可以是**NULL**時，才**RGN_COPY**指定模式。  
  
 `nMode`  
 指定要執行的作業。 它必須是下列值之一︰  
  
- **RGN_AND**新裁剪區域結合了目前裁剪區域和區域所識別的重疊區域`pRgn`。  
  
- **RGN_COPY**新裁剪區域是一份所識別的區域`pRgn`。 這是功能完全相同的第一個版本`SelectClipRgn`。 如果區域由`pRgn`是**NULL**，新的裁剪區域會成為預設的裁剪區域 （null 區域）。  
  
- **RGN_DIFF**新裁剪區域結合了目前裁剪區域排除的區域來識別這些區域的區域`pRgn`。  
  
- **RGN_OR**新裁剪區域結合了目前裁剪區域和區域來識別`pRgn`。  
  
- **RGN_XOR**新裁剪區域結合了目前裁剪區域和區域來識別`pRgn`但不包括任何重疊的區域。  
  
### <a name="return-value"></a>傳回值  
 此區域的類型。 它可以是下列值之一︰  
  
- **COMPLEXREGION**新裁剪區域有重疊的框線。  
  
- **錯誤**裝置內容或地區不正確。  
  
- **NULLREGION**新裁剪區域是空的。  
  
- **SIMPLEREGION**新裁剪區域有沒有重疊的框線。  
  
### <a name="remarks"></a>備註  
 使用所選區域的複本。 地區本身可以為任何數目的其他裝置內容中，選取或刪除它。  
  
 函式假設裝置單位中，指定特定區域的座標。 有些印表機裝置可以支援更高解析度的圖形輸出比以保留 express 文字度量所需的有效位數的文字輸出。 這些裝置報告裝置單位較高的解析度，也就是以文字為單位。 這些裝置然後調整圖形的座標，以便數個報告裝置單位對應到只有 1 圖形的單位。 您應該一律呼叫`SelectClipRgn`函式使用的文字單元。  
  
 GDI 中的圖形物件的縮放比例必須採取的應用程式可以使用**GETSCALINGFACTOR**印表機逸出，以判斷的縮放比例。 此縮放比例會影響裁剪。 如果區域用來裁剪圖形，GDI 會除以縮放比例的座標。 如果區域用來裁剪文字，GDI 會讓無縮放比例調整。 1 縮放比例會導致要除以 2; 座標2 倍的擴充會導致座標除以 4。然後依此類推。  
  
##  <a name="selectobject"></a>CDC::SelectObject  
 選取的物件放入裝置內容。  
  
```  
CPen* SelectObject(CPen* pPen);  
CBrush* SelectObject(CBrush* pBrush);  
virtual CFont* SelectObject(CFont* pFont);  
CBitmap* SelectObject(CBitmap* pBitmap);  
int SelectObject(CRgn* pRgn);  
CGdiObject* SelectObject(CGdiObject* pObject);
```  
  
### <a name="parameters"></a>參數  
 *pPen*  
 指標[CPen](../../mfc/reference/cpen-class.md)来選取的物件。  
  
 `pBrush`  
 指標[CBrush](../../mfc/reference/cbrush-class.md)来選取的物件。  
  
 `pFont`  
 指標[CFont](../../mfc/reference/cfont-class.md)来選取的物件。  
  
 `pBitmap`  
 指標[CBitmap](../../mfc/reference/cbitmap-class.md)来選取的物件。  
  
 `pRgn`  
 指標[CRgn](../../mfc/reference/crgn-class.md)来選取的物件。  
  
 `pObject`  
 指標[CGdiObject](../../mfc/reference/cgdiobject-class.md)来選取的物件。  
  
### <a name="return-value"></a>傳回值  
 要被取代的物件指標。 這是其中一項衍生自的類別物件的指標`CGdiObject`，例如`CPen`，取決於哪一個版本的函式使用。 傳回值是**NULL**如果發生錯誤。 此函式可能會傳回暫存物件的指標。 此暫存物件是唯一一個 Windows 訊息處理期間有效。 如需詳細資訊，請參閱`CGdiObject::FromHandle`。  
  
 成員函式參數的地區版執行相同的工作`SelectClipRgn`成員函式。 它的傳回值可以是下列其中一項︰  
  
- **COMPLEXREGION**新裁剪區域有重疊的框線。  
  
- **錯誤**裝置內容或地區不正確。  
  
- **NULLREGION**新裁剪區域是空的。  
  
- **SIMPLEREGION**新裁剪區域有沒有重疊的框線。  
  
### <a name="remarks"></a>備註  
 類別`CDC`提供五個版本，專門用於特定類型的 GDI 物件，其中包括畫筆、 筆刷、 字型、 點陣圖和區域。 新選取的物件會取代前一個相同型別的物件。 例如，如果`pObject`一般版本的`SelectObject`指向[CPen](../../mfc/reference/cpen-class.md)物件、 函式所指定的畫筆以取代目前的畫筆`pObject`。  
  
 應用程式只能選取一個點陣圖記憶體裝置內容至及放入裝置內容中只有一個記憶體一次。 點陣圖的格式必須是單色或相容的裝置內容。如果不是，`SelectObject`會傳回錯誤。  
  
 Windows 3.1 和更新版本，`SelectObject`函式會傳回相同的值，不管是否使用中繼檔中。 在舊版的 Windows，`SelectObject`傳回非零值給成功和失敗的 0 時，中繼檔中使用。  
  
##  <a name="selectpalette"></a>CDC::SelectPalette  
 選取所指定的邏輯調色盤`pPalette`裝置內容的所選的調色盤物件形式。  
  
```  
CPalette* SelectPalette(
    CPalette* pPalette,  
    BOOL bForceBackground);
```  
  
### <a name="parameters"></a>參數  
 `pPalette`  
 識別要選取的邏輯調色盤。 這個調色盤必須已經建立與`CPalette`成員函式[CreatePalette](../../mfc/reference/cpalette-class.md#createpalette)。  
  
 `bForceBackground`  
 指定是否強制邏輯調色盤是背景色板。 如果`bForceBackground`為非零值，選取的調色盤總是背景色板，不論視窗是否有輸入的焦點。 如果`bForceBackground`是 0 和裝置內容附加到視窗、 視窗具有輸入的焦點時，邏輯調色盤是前景調色盤。  
  
### <a name="return-value"></a>傳回值  
 指標`CPalette`物件，可識別邏輯取代為所指定的調色盤的調色盤`pPalette`。 它是**NULL**如果發生錯誤。  
  
### <a name="remarks"></a>備註  
 新的調色盤會變成 GDI 用來控制的裝置內容中所顯示的色彩調色盤物件，並取代前一個調色盤。  
  
 應用程式可以放入一個以上的裝置內容中選取邏輯調色盤。 但是，邏輯調色盤的變更會影響所有的裝置內容，它會選取。 如果應用程式選取放入一個以上的裝置內容的調色盤，裝置內容必須全部屬於同一部實體裝置。  
  
##  <a name="selectstockobject"></a>CDC::SelectStockObject  
 選取[CGdiObject](../../mfc/reference/cgdiobject-class.md)對應至其中一個預先定義的內建畫筆、 筆刷或字型的物件。  
  
```  
virtual CGdiObject* SelectStockObject(int nIndex);
```  
  
### <a name="parameters"></a>參數  
 `nIndex`  
 指定所需的內建物件的類型。 它可以是下列值之一︰  
  
- **BLACK_BRUSH**黑色筆刷。  
  
- **DKGRAY_BRUSH**暗灰色的筆刷。  
  
- **GRAY_BRUSH**灰色筆刷。  
  
- **HOLLOW_BRUSH**中空筆刷。  
  
- **LTGRAY_BRUSH**淺灰色的筆刷。  
  
- **NULL_BRUSH** Null 筆刷。  
  
- **WHITE_BRUSH**白色筆刷。  
  
- **BLACK_PEN**黑色畫筆。  
  
- **NULL_PEN** Null 畫筆。  
  
- **WHITE_PEN**白色畫筆。  
  
- **ANSI_FIXED_FONT** ANSI 固定的系統字型。  
  
- **ANSI_VAR_FONT** ANSI 變數系統字型。  
  
- **DEVICE_DEFAULT_FONT**裝置相關的字型。  
  
- **OEM_FIXED_FONT** OEM 相依固定字型。  
  
- **SYSTEM_FONT**系統字型。 根據預設，Windows 會使用系統字型來繪製功能表、 對話方塊控制項和其他文字。 它是最佳選擇，不過，不依賴 SYSTEM_FONT 取得對話方塊和視窗所使用的字型。 請改用`SystemParametersInfo`函式與 SPI_GETNONCLIENTMETRICS 參數來擷取目前的字型。 `SystemParametersInfo`會考量目前的主題，並提供標題、 功能表和訊息對話方塊中的字型資訊。  
  
- **SYSTEM_FIXED_FONT**前 3.0 版 Windows 中使用的固定寬度系統字型。 此物件可供與舊版 Windows 的相容性。  
  
- **DEFAULT_PALETTE**預設調色盤。 這個調色盤 20 的靜態色彩調色盤中的系統所組成。  
  
### <a name="return-value"></a>傳回值  
 指標`CGdiObject`函式如果成功更新已被取代的物件。 指向實際的物件是[CPen](../../mfc/reference/cpen-class.md)， [CBrush](../../mfc/reference/cbrush-class.md)，或[CFont](../../mfc/reference/cfont-class.md)物件。 如果呼叫失敗，則傳回值是**NULL**。  
  
##  <a name="setabortproc"></a>Cdc:: setabortproc  
 安裝列印工作的中止程序。  
  
```  
int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
```  
  
### <a name="parameters"></a>參數  
 `lpfn`  
 將安裝為中止程序中止函式的指標。 如需詳細資訊的回呼函式，請參閱[:: setabortproc 的回呼函式](../../mfc/reference/callback-function-for-cdc-setabortproc.md)。  
  
### <a name="return-value"></a>傳回值  
 指定結果的`SetAbortProc`函式。 下列值的一些更可能比其他功能，但所有。  
  
- **SP_ERROR**一般錯誤。  
  
- **SP_OUTOFDISK**沒有足夠磁碟空間目前適用於多工緩衝處理，但沒有更多的空間將會變成可用。  
  
- **SP_OUTOFMEMORY**沒有足夠的記憶體可供多工緩衝處理。  
  
- **SP_USERABORT**使用者結束透過列印管理員工作。  
  
### <a name="remarks"></a>備註  
 如果應用程式可讓多工緩衝處理期間取消列印工作時，它就必須設定的中止函式，才能開始列印工作[Cdc](#startdoc)成員函式。 列印管理員多工緩衝處理，讓應用程式來取消列印工作或處理外的磁碟空間狀況期間，呼叫的中止函式。 如果沒有中止函式設定，如果沒有足夠的磁碟空間的多工緩衝處理列印工作將失敗。  
  
 請注意 Microsoft Visual c + + 的功能，簡化傳遞至回呼函式建立`SetAbortProc`。 位址傳遞至`EnumObjects`成員函式是使用匯出的函式的指標**__declspec （dllexport)**與`__stdcall`呼叫慣例。  
  
 您也沒有要匯出的函式名稱，在**匯出**應用程式的模組定義檔中的陳述式。 您可以改為使用**匯出**中做為函式修飾詞，  
  
 **BOOL 回呼匯出**AFunction ( **HDC**， `int` **);**  
  
 若要使編譯器發出不含別名名稱所匯出的適當匯出記錄。 這適用於大部分的需求。 對於某些特殊情況下，例如匯出的函式，序數或別名匯出、 您仍需要使用**匯出**模組定義檔中的陳述式。  
  
 回呼註冊介面現在是型別安全 （您必須指向正確類型的特定回呼的函式的函式指標傳遞）。  
  
 也請注意所有的回呼函式必須傳回對 Windows 而言，因為無法跨越界限回呼擲回例外狀況之前設陷 Mfc 例外狀況。 如需例外狀況的詳細資訊，請參閱文章[例外狀況](../../mfc/exception-handling-in-mfc.md)。  
  
##  <a name="setarcdirection"></a>CDC::SetArcDirection  
 設定要用於弧線和矩形函式的繪圖方向。  
  
```  
int SetArcDirection(int nArcDirection);
```  
  
### <a name="parameters"></a>參數  
 *nArcDirection*  
 指定新的反方向。 這個參數可以是下列值之一︰  
  
- **AD_COUNTERCLOCKWISE**以逆時針方向繪製的圖形。  
  
- **AD_CLOCKWISE**朝順時針方向繪製的圖形。  
  
### <a name="return-value"></a>傳回值  
 如果成功;，指定舊的弧形方向，否則為 0。  
  
### <a name="remarks"></a>備註  
 預設的方向是逆時鐘方向。 `SetArcDirection`函式會指定下列函式繪製的方向︰  
  
|Arc|圓形圖|  
|---------|---------|  
|`ArcTo`|**矩形**|  
|`Chord`|`RoundRect`|  
|**橢圓形**||  
  
##  <a name="setattribdc"></a>CDC::SetAttribDC  
 呼叫此函式來設定屬性的裝置內容， `m_hAttribDC`。  
  
```  
virtual void SetAttribDC(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 Windows 裝置內容。  
  
### <a name="remarks"></a>備註  
 此成員函式不會附加裝置內容至`CDC`物件。 僅輸出裝置內容會附加至`CDC`物件。  
  
##  <a name="setbkcolor"></a>CDC::SetBkColor  
 將目前的背景色彩設定為指定的色彩。  
  
```  
virtual COLORREF SetBkColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定新的背景色彩。  
  
### <a name="return-value"></a>傳回值  
 RGB 色彩值為先前的背景色彩。 如果發生錯誤，則傳回的值會是 0x80000000。  
  
### <a name="remarks"></a>備註  
 如果背景模式是**不透明**，系統會使用背景色彩填滿樣式的行間距、 字元儲存格的背景筆刷，規劃的行之間間距。 轉換點陣圖色彩與單色裝置內容時，系統也會使用背景色彩。  
  
 如果裝置無法顯示指定的色彩，系統就會設定為最接近的實體色彩的背景色彩。  
  
##  <a name="setbkmode"></a>CDC::SetBkMode  
 設定背景模式。  
  
```  
int SetBkMode(int nBkMode);
```  
  
### <a name="parameters"></a>參數  
 *nBkMode*  
 指定要設定的模式。 這個參數可以是下列值之一︰  
  
- **不透明**背景填滿目前的背景色彩之前的文字，陰影的筆刷, 或畫筆會繪製。 這是預設背景模式。  
  
- **透明**繪製前不會變更背景。  
  
### <a name="return-value"></a>傳回值  
 先前的背景模式。  
  
### <a name="remarks"></a>備註  
 背景模式會定義系統是否會移除現有的背景色彩，在繪圖介面上繪製文字、 規劃筆刷或不是實線任何畫筆樣式之前。  
  
### <a name="example"></a>範例  
  請參閱範例[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。  
  
##  <a name="setboundsrect"></a>CDC::SetBoundsRect  
 控制累積的週框矩形指定之的裝置內容的資訊。  
  
```  
UINT SetBoundsRect(
    LPCRECT lpRectBounds,  
    UINT flags);
```  
  
### <a name="parameters"></a>參數  
 `lpRectBounds`  
 指向`RECT`結構或`CRect`物件，用來設定，這個周框。 矩形維度都指定在邏輯座標。 這個參數可以是**NULL**。  
  
 `flags`  
 指定新的矩形累積的矩形的組合方式。 這個參數可以是下列值的組合︰  
  
- **DCB_ACCUMULATE**加入所指定的矩形`lpRectBounds`至周框 （使用矩形等位作業）。  
  
- **DCB_DISABLE**關閉界限累積。  
  
- **DCB_ENABLE**開啟界限累積。 （累積範圍的預設設定會停用）。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，這個周框的目前狀態。 像`flags`，傳回的值可以是結合**DCB_**值︰  
  
- **DCB_ACCUMULATE**不是空的這個周框。 這個值一定會設定。  
  
- **DCB_DISABLE**界限累積為關閉。  
  
- **DCB_ENABLE**界限累積為開啟。  
  
### <a name="remarks"></a>備註  
 Windows 可以維護所有繪圖作業的周框矩形。 可以查詢這個矩形，並將它重設應用程式中。 繪製界限可用於使點陣圖快取失效。  
  
##  <a name="setbrushorg"></a>CDC::SetBrushOrg  
 指定的 GDI 會指派給應用程式便可選取的裝置內容的下一筆刷的原點。  
  
```  
CPoint SetBrushOrg(
    int x,  
    int y);  
  
CPoint SetBrushOrg(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新原點的 x 座標 （以裝置為單位）。 此值必須是範圍 0-7。  
  
 *y*  
 指定新原點的 y 座標 （以裝置為單位）。 此值必須是範圍 0-7。  
  
 `point`  
 指定新原點的 x 和 y 座標。 每個值必須是範圍 0-7。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 前一個裝置單位中的筆刷的原點。  
  
### <a name="remarks"></a>備註  
 預設的筆刷的原點座標為 （0，0）。 若要變更筆刷的原點，呼叫`UnrealizeObject`函式的`CBrush`物件，請呼叫`SetBrushOrg`，然後呼叫`SelectObject`成員函式來選取筆刷放入裝置內容。  
  
 請勿使用`SetBrushOrg`與內建`CBrush`物件。  
  
##  <a name="setcoloradjustment"></a>CDC::SetColorAdjustment  
 設定裝置內容，使用指定的值的色彩調整值。  
  
```  
BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
```  
  
### <a name="parameters"></a>參數  
 `lpColorAdjust`  
 指向[COLORADJUSTMENT](../../mfc/reference/coloradjustment-structure.md)資料結構，其中包含色彩調整值。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 色彩調整值用來調整輸入的呼叫的來源點陣圖的色彩`CDC::StretchBlt`成員函式時**半色調**模式設定。  
  
##  <a name="setdcbrushcolor"></a>CDC::SetDCBrushColor  
 將目前的裝置內容 (DC) 筆刷色彩設定為指定的色彩值。  
  
```  
COLORREF SetDCBrushColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定新的筆刷色彩。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回的值會指定做為前一個 DC 筆刷色彩`COLORREF`值。  
  
 如果函式失敗，傳回的值是`CLR_INVALID`。  
  
### <a name="remarks"></a>備註  
 這個方法會模擬函式的功能[SetDCBrushColor](http://msdn.microsoft.com/library/windows/desktop/dd162969)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="setdcpencolor"></a>CDC::SetDCPenColor  
 將目前的裝置內容 (DC) 畫筆顏色設定為指定的色彩值。  
  
```  
COLORREF SetDCPenColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 指定新的畫筆顏色。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式會利用 Win32 函式[SetDCPenColor](http://msdn.microsoft.com/library/windows/desktop/dd162970)所述，在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="setgraphicsmode"></a>CDC::SetGraphicsMode  
 設定指定之的裝置內容的圖形模式。  
  
```  
int SetGraphicsMode(int iMode);
```  
  
### <a name="parameters"></a>參數  
 `iMode`  
 指定的圖形模式。 如需這個參數可以接受的值，請參閱[SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)。  
  
### <a name="return-value"></a>傳回值  
 如果成功傳回舊的圖形模式。  
  
 在失敗時傳回 0。 若要取得擴充的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[SetGraphicsMode](http://msdn.microsoft.com/library/windows/desktop/dd162977)。  
  
##  <a name="setlayout"></a>CDC::SetLayout  
 呼叫此成員函式可將文字和圖形裝置內容的配置變更為右至左，如阿拉伯文和希伯來文的文化特性的標準版面配置。  
  
```  
DWORD SetLayout(DWORD dwLayout);
```  
  
### <a name="parameters"></a>參數  
 `dwLayout`  
 裝置內容版面配置和點陣圖控制旗標。 它可以是下列值的組合。  
  
|值|意義|  
|-----------|-------------|  
|LAYOUT_BITMAPORIENTATIONPRESERVED|停用任何反映發出的呼叫[CDC::BitBlt](#bitblt)和[CDC::StretchBlt](#stretchblt)。|  
|LAYOUT_RTL|設定預設的水平配置是由右至左。|  
|LAYOUT_LTR|設定預設的配置由左到右。|  
  
### <a name="return-value"></a>傳回值  
 如果成功，先前的版面配置的裝置內容。  
  
 如果不成功， **GDI_ERROR**。 若要取得擴充的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 一般而言，您不會呼叫**SetLayout**視窗。 相反地，您在視窗中的由右至左配置設定控制[延伸視窗樣式](../../mfc/reference/extended-window-styles.md)例如**WS_EX_RTLREADING**。 裝置內容，例如印表機或中繼檔，不會繼承這個版面配置。 由右至左配置是藉由呼叫設定裝置內容的唯一辦法**SetLayout**。  
  
 如果您呼叫**SetLayout (LAYOUT_RTL** )， **SetLayout**會自動變更的對應模式`MM_ISOTROPIC`。 如此一來，後續呼叫[GetMapMode](#getmapmode)會傳回**MM_ISOTROPIC**而不是`MM_TEXT`。  
  
 在某些情況下，例如使用許多點陣圖，可能會想要保留左到右配置。 在這些情況下，呈現影像藉由呼叫`BitBlt`或`StretchBlt`，然後設定點陣圖控制旗標，如`dwLayout`至**LAYOUT_BITMAPORIENTATIONPRESERVED**。  
  
 一旦變更版面配置與**LAYOUT_RTL**旗標，通常指定權限的旗標或左相反。 為了避免混淆，您可能要定義標準的旗標的替代名稱。 如需建議替代的旗標名稱的清單，請參閱[SetLayout](http://msdn.microsoft.com/library/windows/desktop/dd162979)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="setmapmode"></a>CDC::SetMapMode  
 設定對應模式。  
  
```  
virtual int SetMapMode(int nMapMode);
```  
  
### <a name="parameters"></a>參數  
 `nMapMode`  
 指定新的對應模式。 它可以是下列值之一︰  
  
- `MM_ANISOTROPIC`邏輯單元任意縮放座標軸會轉換到任意的單位。 若要設定的對應模式`MM_ANISOTROPIC`不會變更目前的視窗或檢視區設定。 若要變更單位，方向與調整，呼叫[SetWindowExt](#setwindowext)和[SetViewportExt](#setviewportext)成員函式。  
  
- `MM_HIENGLISH`每個邏輯單元會轉換為 0.001 英吋。 正 x 是右邊。正數 y 已啟動。  
  
- `MM_HIMETRIC`每個邏輯單元會轉換為 0.01 公釐。 正 x 是右邊。正數 y 已啟動。  
  
- `MM_ISOTROPIC`邏輯單元會轉換成任意單位同樣縮放軸。也就是 1 個單位沿著 x 軸會等於 1 沿著 y 軸的單位。 使用`SetWindowExt`和`SetViewportExt`成員函式以指定的所需的單位，以及這兩個軸的方向。 GDI 會視需要調整單位的 x 和 y，確保維持相同大小。  
  
- `MM_LOENGLISH`每個邏輯單元會轉換為 0.01 英吋。 正 x 是右邊。正數 y 已啟動。  
  
- `MM_LOMETRIC`每個邏輯單元會轉換成 0.1 公釐。 正 x 是右邊。正數 y 已啟動。  
  
- `MM_TEXT`每個邏輯單元會轉換成 1 部裝置像素。 正 x 是右邊。正數 y 已關閉。  
  
- `MM_TWIPS`每個邏輯單元會轉換成 1/20 的點。 （因為點 1/72 英吋，twip 是 1/1440年英吋）。正 x 是右邊。正數 y 已啟動。  
  
### <a name="return-value"></a>傳回值  
 先前的對應模式。  
  
### <a name="remarks"></a>備註  
 對應模式會定義用來將邏輯單元轉換成裝置單位; 的測量單位它也會定義裝置的 x 軸和 y 軸的方向。 GDI 會使用對應模式，將邏輯座標轉換為適當的裝置座標。 `MM_TEXT`模式可讓應用程式能夠以裝置像素為單位，其中 1 個單位等於 1 個像素。 像素的實際大小而異不同的裝置。  
  
 `MM_HIENGLISH`， `MM_HIMETRIC`， `MM_LOENGLISH`， `MM_LOMETRIC`，和`MM_TWIPS`模式適合用於必須繪製在實際有意義的單位 （例如英吋或公釐為單位） 的應用程式。 `MM_ISOTROPIC`模式可確保 1:1 長寬比，請務必保留映像的確切的形狀時，這是很有用。 `MM_ANISOTROPIC`模式可讓 x 和 y 座標獨立地調整。  
  
> [!NOTE]
>  如果您呼叫[SetLayout](#setlayout) DC （裝置內容） 變成由右至左配置**SetLayout**會自動變更的對應模式`MM_ISOTROPIC`。  
  
### <a name="example"></a>範例  
  請參閱範例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setmapperflags"></a>CDC::SetMapperFlags  
 變更時它會轉換成實體字型的邏輯字型字型對應器所使用的方法。  
  
```  
DWORD SetMapperFlags(DWORD dwFlag);
```  
  
### <a name="parameters"></a>參數  
 `dwFlag`  
 指定是否字型對應器會嘗試比對字型的長寬高度和寬度設為裝置。 當這個值是**ASPECT_FILTERING**，對應工具選取的唯一字型其 x 外觀並 y 層面的完全符合指定的裝置。  
  
### <a name="return-value"></a>傳回值  
 先前的字型對應器旗標值。  
  
### <a name="remarks"></a>備註  
 應用程式可以使用`SetMapperFlags`造成嘗試選擇只有完全符合指定之裝置的長寬比實體字型的字型對應程式。  
  
 使用點陣字型的應用程式可以使用`SetMapperFlags`函式，以確保字型對應器所選取的字型是吸引人也可以在指定的裝置上閱讀。 使用應用程式調整的明體字型通常不用`SetMapperFlags`。  
  
 如果沒有實體字型有符合邏輯字型中的規格，外觀比例，GDI 選擇新的長寬比，並選擇符合這個新的長寬比的字型。  
  
##  <a name="setmiterlimit"></a>CDC::SetMiterLimit  
 設定斜接角聯結裝置內容的長度限制。  
  
```  
BOOL SetMiterLimit(float fMiterLimit);
```  
  
### <a name="parameters"></a>參數  
 *fMiterLimit*  
 指定新斜裝置內容。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 斜接長度定義為內部聯結線牆面交集的外部聯結的直線牆交集的距離。 斜是斜接長度為線條寬度的最大允許的比率。 預設斜為 10.0。  
  
##  <a name="setoutputdc"></a>CDC::SetOutputDC  
 呼叫此成員函式，來設定輸出裝置內容， `m_hDC`。  
  
```  
virtual void SetOutputDC(HDC hDC);
```  
  
### <a name="parameters"></a>參數  
 `hDC`  
 Windows 裝置內容。  
  
### <a name="remarks"></a>備註  
 此成員函式只能呼叫，當裝置內容未連接至`CDC`物件。 此成員函式會將`m_hDC`但不會附加裝置內容至`CDC`物件。  
  
##  <a name="setpixel"></a>CDC::SetPixel  
 設定所指定的色彩最接近指定點的像素`crColor`。  
  
```  
COLORREF SetPixel(
    int x,  
    int y,  
    COLORREF crColor);

 
COLORREF SetPixel(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定要設定的點的邏輯 x 座標。  
  
 *y*  
 指定要設定的點的邏輯 y 座標。  
  
 `crColor`  
 A **COLORREF** RGB 值，指定用來繪製點的色彩。 請參閱[COLORREF](http://msdn.microsoft.com/library/windows/desktop/dd183449)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]這個值的說明。  
  
 `point`  
 指定邏輯 x 和 y 座標點，以設定。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 點的繪製時實際的色彩 RGB 值。 這個值可以不同於所指定`crColor`如果使用該色彩的近似值。 如果函式會失敗 （如果點外的裁剪區域），則傳回值為 –&1;。  
  
### <a name="remarks"></a>備註  
 點必須位於裁剪區域。 如果端點不裁剪區域中，函式沒有作用。  
  
 並非所有的裝置皆支援 `SetPixel` 函式。 若要判斷裝置是否支援`SetPixel`，呼叫`GetDeviceCaps`成員函式**RASTERCAPS**編製索引，並檢查傳回值**RC_BITBLT**旗標。  
  
##  <a name="setpixelv"></a>CDC::SetPixelV  
 設定以指定的色彩最接近指定座標上的像素。  
  
```  
BOOL SetPixelV(
    int x,  
    int y,  
    COLORREF crColor);

 
BOOL SetPixelV(
    POINT point,  
    COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定 x 軸座標，以邏輯單位，表示要設定的點。  
  
 *y*  
 指定以邏輯單位，表示要設定的點的 y 座標。  
  
 `crColor`  
 指定要用來繪製點的色彩。  
  
 `point`  
 指定邏輯 x 和 y 座標點，以設定。 您可以傳遞[點](../../mfc/reference/point-structure1.md)資料結構或[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 點必須位於裁剪區域和裝置介面的可見部分。 並非所有裝置都支援成員函式。 如需詳細資訊，請參閱**RC_BITBLT**功能`CDC::GetDeviceCaps`成員函式。 `SetPixelV`速度比`SetPixel`因為不需傳回實際繪製點的色彩值。  
  
##  <a name="setpolyfillmode"></a>CDC::SetPolyFillMode  
 將多邊形填滿模式設定。  
  
```  
int SetPolyFillMode(int nPolyFillMode);
```  
  
### <a name="parameters"></a>參數  
 `nPolyFillMode`  
 指定新的填滿模式。 這個值可以是**替代**或**彎曲**。 在 Windows 中設定的預設模式是**替代**。  
  
### <a name="return-value"></a>傳回值  
 上一個填滿模式中，如果登錄成功。否則為 0。  
  
### <a name="remarks"></a>備註  
 多邊形填滿模式時**替代**，系統會填滿上每個掃描線奇數和偶數多邊形側邊之間的區域。 也就是系統填滿區域的第一個和第二個端之間，第三個和第四個側邊之間等等。 此模式是預設值。  
  
 多邊形填滿模式時**彎曲**，系統會用來判斷是否要填滿的區域已繪製圖表的方向。 順時針或逆時針方向會繪製多邊形中的每個直線線段。 每當虛構的線圖外面括住的區域繪製出通過順時針直線線段，計數會漸增。 當行通過逆時針直線線段時，計數會遞減。 如果計數在線條數到達外的圖為非零，則會填滿區域。  
  
##  <a name="setrop2"></a>CDC::SetROP2  
 設定目前的繪圖模式。  
  
```  
int SetROP2(int nDrawMode);
```  
  
### <a name="parameters"></a>參數  
 `nDrawMode`  
 指定新的繪圖模式。 它可以是下列值之一︰  
  
- **R2_BLACK**像素永遠都是黑色。  
  
- **R2_WHITE**一律為白色像素。  
  
- **R2_NOP**像素會維持不變。  
  
- **R2_NOT**像素是螢幕色彩的反向作業。  
  
- **R2_COPYPEN**像素都是畫筆顏色。  
  
- **R2_NOTCOPYPEN**像素都是反向的畫筆顏色。  
  
- **R2_MERGEPENNOT**像素都是組合的畫筆顏色和螢幕色彩的反向 (最後一個像素 = （不像素螢幕） 或畫筆)。  
  
- **R2_MASKPENNOT**像素都是通用的同時的畫筆色彩組合的螢幕 (最後一個像素 = （不是畫面像素），而且畫筆)。  
  
- **R2_MERGENOTPEN**像素都是螢幕色彩組合的畫筆顏色 (最後一個像素 = （不是畫筆） 或畫面像素)。  
  
- **R2_MASKNOTPEN**像素都是通用的同時螢幕色彩組合的畫筆 (最後一個像素 = （不是畫筆） 和螢幕像素)。  
  
- **R2_MERGEPEN**像素都是畫筆顏色和螢幕色彩的組合 (最後一個像素 = 畫筆 OR 畫面像素)。  
  
- **R2_NOTMERGEPEN**像素都是反向**R2_MERGEPEN**色彩 (最後一個像素不 = （畫筆 OR 畫面像素）)。  
  
- **R2_MASKPEN**像素都是通用的畫筆和畫面色彩的組合 (最後一個像素 = 畫筆及螢幕像素)。  
  
- **R2_NOTMASKPEN**像素都是反向**R2_MASKPEN**色彩 (最後一個像素不 = （畫筆及螢幕像素）)。  
  
- **R2_XORPEN**像素都是色彩畫筆或在畫面中，但不在兩者的組合 (最後一個像素 = 畫筆 XOR 畫面像素)。  
  
- **R2_NOTXORPEN**像素都是反向**R2_XORPEN**色彩 (最後一個像素不 = （畫筆 XOR 畫面像素）)。  
  
### <a name="return-value"></a>傳回值  
 先前的繪圖模式。  
  
 它可以是任何值中指定的[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 繪圖模式指定如何將畫筆的色彩和填滿物件內部合併使用已經在顯示介面上的色彩。  
  
 繪圖模式是僅適用於點陣裝置。它不會套用到向量裝置。 繪圖模式會代表所有可能的布林值組合的兩個變數，不使用二元運算子 AND、 OR 和 XOR (排除 OR)，一元運算的二進位的點陣作業程式碼。  
  
##  <a name="setstretchbltmode"></a>CDC::SetStretchBltMode  
 設定點陣圖自動縮放模式`StretchBlt`成員函式。  
  
```  
int SetStretchBltMode(int nStretchMode);
```  
  
### <a name="parameters"></a>參數  
 *nStretchMode*  
 指定的縮放模式。 它可以是下列值之一︰  
  
|值|說明|  
|-----------|-----------------|  
|**BLACKONWHITE**|執行使用已排除的和現有的像素的色彩值的布林值 AND 運算。 如果點陣圖是單色點陣圖，這個模式會保留代價白色像素是黑色的像素。|  
|**COLORONCOLOR**|刪除的像素為單位。 此模式中刪除所有已排除的線的像素，而不想要保留其資訊。|  
|**半色調**|會從來源矩形的像素對應到目的地矩形的像素的區塊。 透過像素為單位的目的地區塊的平均色彩很接近來源像素色彩。|  
||設定後**半色調**自動縮放模式，應用程式必須呼叫 Win32 函式[SetBrushOrgEx](http://msdn.microsoft.com/library/windows/desktop/dd162967)設定筆刷的原點。 如果它無法這麼做，就會發生筆刷誤認為其已對齊。|  
|**STRETCH_ANDSCANS**|**Windows 95/98**︰ 相同**BLACKONWHITE**|  
|**STRETCH_DELETESCANS**|**Windows 95/98**︰ 相同**COLORONCOLOR**|  
|**STRETCH_HALFTONE**|**Windows 95/98**︰ 相同**半色調**。|  
|**STRETCH_ORSCANS**|**Windows 95/98**︰ 相同**WHITEONBLACK**|  
|**WHITEONBLACK**|執行使用已排除的和現有的像素的色彩值的布林值 OR 運算。 如果點陣圖是單色點陣圖，這個模式會保留白色像素，但代價是黑色的像素為單位。|  
  
### <a name="return-value"></a>傳回值  
 先前的縮放模式。 它可以是**STRETCH_ANDSCANS**， **STRETCH_DELETESCANS**，或**STRETCH_ORSCANS**。  
  
### <a name="remarks"></a>備註  
 點陣圖自動縮放模式會定義如何從使用函式會壓縮的點陣圖中移除資訊。  
  
 **BLACKONWHITE** ( **STRETCH_ANDSCANS**) 和**WHITEONBLACK** ( **STRETCH_ORSCANS**) 模式通常用於保留前景單色點陣圖的像素。 **COLORONCOLOR** ( **STRETCH_DELETESCANS**) 模式通常用來保留色彩點陣圖中的色彩。  
  
 **半色調**模式需要更多處理之來源影像比其他三種模式; 低於其他人，但會產生較高品質影像。 另外請注意， **SetBrushOrgEx**設定後，必須呼叫**半色調**模式，以避免筆刷誤認為其已對齊。  
  
 可能也會根據裝置驅動程式功能提供額外的自動縮放模式。  
  
##  <a name="settextalign"></a>CDC::SetTextAlign  
 設定文字對齊方式的旗標。  
  
```  
UINT SetTextAlign(UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 指定文字對齊方式的旗標。 旗標指定點與周圍文字的矩形之間的關聯性。 點可以是目前的位置或文字輸出函式所指定的座標。 繫結文字的矩形是相鄰的字元儲存格的文字字串中所定義。 `nFlags`參數可以是下列三個類別的一個或多個旗標。 選擇每一個類別只能有一個旗標。 第一個類別目錄會影響在 x 方向的文字對齊方式︰  
  
- **TA_CENTER**對齊水平中央點，這個周框。  
  
- **TA_LEFT**對齊左邊算起的點，這個周框。 這是預設設定。  
  
- **TA_RIGHT**對齊右上角的點，這個周框。  
  
 第二個類別會影響在 y 方向的文字對齊方式︰  
  
- **TA_BASELINE**對齊基準線的點的字型。  
  
- **TA_BOTTOM**對齊，這個周框底部的點。  
  
- **TA_TOP**對齊點的週框的頂端。 這是預設設定。  
  
 第三個類別會決定寫入文字時，是否要更新目前的位置︰  
  
- **TA_NOUPDATECP**不會更新目前的位置之後的文字輸出函式的每一個呼叫。 這是預設設定。  
  
- **TA_UPDATECP**文字輸出函式每次呼叫之後，會更新目前的 x 位置。 新的位置是在文字框的右側。 當這個旗標設定，在呼叫中指定的座標`TextOut`成員函式會被忽略。  
  
### <a name="return-value"></a>傳回值  
 先前文字對齊方式的設定，如果成功。 低序位位元組包含水平的設定，而高序位位元組包含垂直的設定。否則為 0。  
  
### <a name="remarks"></a>備註  
 `TextOut`和`ExtTextOut`定位的顯示或裝置上的文字字串時，成員函式會使用這些旗標。 旗標指定的特定點與周圍文字的矩形之間的關聯性。 此點的座標會做為參數傳遞`TextOut`成員函式。 繫結文字的矩形是相鄰的字元儲存格的文字字串中所構成。  
  
##  <a name="settextcharacterextra"></a>CDC::SetTextCharacterExtra  
 設定 intercharacter 的間距數量。  
  
```  
int SetTextCharacterExtra(int nCharExtra);
```  
  
### <a name="parameters"></a>參數  
 `nCharExtra`  
 指定要加入的每個字元的 （以邏輯單位表示） 的額外空間數量。 如果目前的對應模式不是`MM_TEXT`，`nCharExtra`轉換，並捨入至最接近像素。  
  
### <a name="return-value"></a>傳回值  
 先前 intercharacter 的間距數量。  
  
### <a name="remarks"></a>備註  
 GDI 新增這個間距，包括分行符號字元，當一行文字寫入裝置內容的每個字元。 Intercharacter 間距所需的預設值為 0。  
  
##  <a name="settextcolor"></a>CDC::SetTextColor  
 將文字的色彩設定為指定的色彩。  
  
```  
virtual COLORREF SetTextColor(COLORREF crColor);
```  
  
### <a name="parameters"></a>參數  
 `crColor`  
 以 RGB 色彩值，指定文字的色彩。  
  
### <a name="return-value"></a>傳回值  
 先前的文字色彩的 RGB 值。  
  
### <a name="remarks"></a>備註  
 將文字寫入至這個裝置內容以及之間的轉換點陣圖的色彩和單色裝置內容時，系統會使用此文字色彩。  
  
 如果裝置不能代表指定的色彩，系統就會設定為最接近的實體色彩的文字色彩。 所指定字元的背景色彩`SetBkColor`和`SetBkMode`成員函式。  
  
### <a name="example"></a>範例  
  請參閱範例[CWnd::OnCtlColor](../../mfc/reference/cwnd-class.md#onctlcolor)。  
  
##  <a name="settextjustification"></a>CDC::SetTextJustification  
 分行符號字元在字串中加上空格。  
  
```  
int SetTextJustification(
    int nBreakExtra,  
    int nBreakCount);
```  
  
### <a name="parameters"></a>參數  
 `nBreakExtra`  
 指定要加入至的一行文字 （以邏輯單位表示） 的總額外空間。 如果目前的對應模式不是`MM_TEXT`，此參數所指定的值會轉換為目前的對應模式，並捨入至最接近的裝置單位。  
  
 *nBreakCount*  
 行中指定符號字元的數。  
  
### <a name="return-value"></a>傳回值  
 其中一個函式是否成功。否則為 0。  
  
### <a name="remarks"></a>備註  
 應用程式可以使用`GetTextMetrics`成員函式來擷取字型的字元會中斷。  
  
 之後`SetTextJustification`成員函式呼叫時，文字輸出函式的呼叫 (例如`TextOut`) 發佈之間指定的符號字元數，平均指定額外的空間。 分行符號字元通常是空格字元 (ASCII 32)，但可能會當做其他某些字元的字型所定義。  
  
 成員函式`GetTextExtent`通常使用`SetTextJustification`。 `GetTextExtent`計算給定之前對齊線的寬度。 應用程式可以判斷多少空間，以指定在`nBreakExtra`參數所傳回的值中減去`GetTextExtent`從對齊後字串的寬度。  
  
 `SetTextJustification`函式可以用來對齊包含不同的字型中的多個回合的列。 在此情況下，必須分次建立列對齊，然後分別撰寫每次執行。  
  
 對齊期間可能會發生捨入錯誤，因為系統會保留執行錯誤詞彙定義目前的錯誤。 對齊線條，其中包含多個回合，當`GetTextExtent`會自動使用此錯誤碼詞彙，它會計算下一次執行的範圍。 這可讓文字輸出函式來融入新的執行中的錯誤。  
  
 已對齊每一行之後，必須清除這個錯誤的詞彙，以防止它被合併到下一行。 藉由呼叫，就可以清除一詞`SetTextJustification`與`nBreakExtra`設為 0。  
  
##  <a name="setviewportext"></a>CDC::SetViewportExt  
 設定 x-和 y-範圍的裝置內容的檢視區。  
  
```  
virtual CSize SetViewportExt(
    int cx,  
    int cy);  
  
CSize SetViewportExt(SIZE size);
```  
  
### <a name="parameters"></a>參數  
 `cx`  
 指定檢視區 （以裝置為單位） 的 x 程度。  
  
 `cy`  
 指定檢視區 （以裝置為單位） 的 y 程度。  
  
 `size`  
 指定 x-和 y 的範圍在檢視區 （以裝置為單位）。  
  
### <a name="return-value"></a>傳回值  
 先前的範圍做為檢視區的[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。 發生錯誤時，x 和 y 座標傳回`CSize`物件都設定為 0。  
  
### <a name="remarks"></a>備註  
 檢視區，以及裝置內容 視窗中，定義 GDI 在實際裝置之點的座標系統中所對應的邏輯座標系統中的點。 也就是說，它們會定義 GDI 將邏輯座標轉換成裝置座標的方式。  
  
 當設定下列的對應模式時，呼叫`SetWindowExt`和`SetViewportExt`會被忽略︰  
  
|MM_HIENGLISH|MM_LOMETRIC|  
|-------------------|------------------|  
|`MM_HIMETRIC`|`MM_TEXT`|  
|`MM_LOENGLISH`|`MM_TWIPS`|  
  
 當`MM_ISOTROPIC`模式設定，應用程式必須呼叫`SetWindowExt`成員函式之前，先`SetViewportExt`。  
  
### <a name="example"></a>範例  
  請參閱範例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setviewportorg"></a>CDC::SetViewportOrg  
 設定裝置內容的檢視區的原點。  
  
```  
virtual CPoint SetViewportOrg(
    int x,  
    int y);  
  
CPoint SetViewportOrg(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定檢視區原點的 x 座標 （以裝置為單位）。 值必須是裝置座標系統的範圍內。  
  
 *y*  
 指定檢視區原點的 y 座標 （以裝置為單位）。 值必須是裝置座標系統的範圍內。  
  
 `point`  
 指定檢視區的來源。 值必須是裝置座標系統的範圍內。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 檢視區 （以裝置座標表示） 做為前一個原點`CPoint`物件。  
  
### <a name="remarks"></a>備註  
 檢視區，以及裝置內容 視窗中，定義 GDI 在實際裝置之點的座標系統中所對應的邏輯座標系統中的點。 也就是說，它們會定義 GDI 將邏輯座標轉換成裝置座標的方式。  
  
 檢視區原點標示 GDI 對應視窗原點，在邏輯座標系統中所指定的點裝置座標系統中的點**SetWindowOrg**成員函式。 GDI 遵循相同的程序對應至檢視區原點視窗原點需要對應其他所有資料點。 例如，繞著視窗原點的點的圓形中的所有點都會環繞在檢視區原點的點。 同樣地，通過視窗原點的列中的所有點都都通過檢視區原點的列。  
  
### <a name="example"></a>範例  
  請參閱範例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setwindowext"></a>CDC::SetWindowExt  
 設定 x-和 y-範圍相關聯的裝置內容的視窗。  
  
```  
virtual CSize SetWindowExt(
    int cx,  
    int cy);  
  
CSize SetWindowExt(SIZE size);
```  
  
### <a name="parameters"></a>參數  
 `cx`  
 指定的 x-程度 （以邏輯單位表示） 的視窗。  
  
 `cy`  
 指定的 y-程度 （以邏輯單位表示） 的視窗。  
  
 `size`  
 指定 x-和 y 的範圍 （以邏輯單位表示） 的視窗。  
  
### <a name="return-value"></a>傳回值  
 間隔 （以邏輯單位表示） 做為前一個範圍`CSize`物件。 如果發生錯誤時，x 和 y 座標傳回`CSize`物件都設定為 0。  
  
### <a name="remarks"></a>備註  
 視窗中，裝置內容的檢視區，以及定義 GDI 裝置座標系統中的點所對應的邏輯座標系統中的點。  
  
 當設定下列的對應模式時，呼叫`SetWindowExt`和`SetViewportExt`函式會被忽略︰  
  
- `MM_HIENGLISH`  
  
- `MM_HIMETRIC`  
  
- `MM_LOENGLISH`  
  
- `MM_LOMETRIC`  
  
- `MM_TEXT`  
  
- `MM_TWIPS`  
  
 當`MM_ISOTROPIC`模式設定，應用程式必須呼叫`SetWindowExt`成員函式呼叫之前，先`SetViewportExt`。  
  
### <a name="example"></a>範例  
  請參閱範例[CView::OnPrepareDC](../../mfc/reference/cview-class.md#onpreparedc)。  
  
##  <a name="setwindoworg"></a>CDC::SetWindowOrg  
 設定裝置內容的視窗原點。  
  
```  
CPoint SetWindowOrg(
    int x,  
    int y);  
  
CPoint SetWindowOrg(POINT point);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新的視窗原點的邏輯 x 座標。  
  
 *y*  
 指定新的視窗原點的邏輯 y 座標。  
  
 `point`  
 指定新來源 視窗中的邏輯座標。 您可以傳遞**點**結構或`CPoint`這個參數的物件。  
  
### <a name="return-value"></a>傳回值  
 先前的視窗 做為來源`CPoint`物件。  
  
### <a name="remarks"></a>備註  
 視窗中，裝置內容的檢視區，以及定義 GDI 裝置座標系統中的點所對應的邏輯座標系統中的點。  
  
 視窗原點標示邏輯從中 GDI 對應的檢視區原點，在裝置座標系統中所指定的點的座標系統中的點**SetWindowOrg**函式。 GDI 遵循相同的程序對應至檢視區原點視窗原點需要對應其他所有資料點。 例如，繞著視窗原點的點的圓形中的所有點都會環繞在檢視區原點的點。 同樣地，通過視窗原點的列中的所有點都都通過檢視區原點的列。  
  
##  <a name="setworldtransform"></a>CDC::SetWorldTransform  
 設定全局空間與指定之的裝置內容的頁面空間之間的二維線性轉換。 此轉換可用來縮放、 旋轉、 傾斜或轉譯圖形輸出。  
  
```  
BOOL SetWorldTransform(const XFORM& rXform);
```  
  
### <a name="parameters"></a>參數  
 `rXform`  
 若要參考[XFORM](http://msdn.microsoft.com/library/windows/desktop/dd145228)結構，其中包含轉換資料。  
  
### <a name="return-value"></a>傳回值  
 如果成功，傳回非零值。  
  
 在失敗時傳回 0。  
  
 若要取得擴充的錯誤資訊，呼叫[GetLastError](http://msdn.microsoft.com/library/windows/desktop/ms679360)。  
  
### <a name="remarks"></a>備註  
 這個方法會包裝 Windows GDI 函式[SetWorldTransform](http://msdn.microsoft.com/library/windows/desktop/dd145104)。  
  
##  <a name="startdoc"></a>CDC::StartDoc  
 正在啟動新的列印工作的裝置驅動程式，就會通知，所有後續`StartPage`和`EndPage`呼叫應該在相同的作業，直到多工緩衝`EndDoc`呼叫就會發生。  
  
```  
int StartDoc(LPDOCINFO lpDocInfo);  
int StartDoc(LPCTSTR lpszDocName);
```  
  
### <a name="parameters"></a>參數  
 *lpDocInfo*  
 指向[DOCINFO](http://msdn.microsoft.com/library/windows/desktop/dd183574)結構，其中包含文件檔案的名稱和輸出檔的名稱。  
  
 *lpszDocName*  
 包含文件檔案的名稱之字串的指標。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回的值是大於零。 這個值會是文件的列印工作識別碼。  
  
 如果函式失敗，傳回的值小於或等於零。  
  
### <a name="remarks"></a>備註  
 這可確保不會與其他工作顛倒超過一頁的文件。  
  
 對於 Windows 3.1 和更新版本的版本，此函數會取代**CDC**印表機逸出。 使用此函式，可確保包含多個頁面的文件不會穿插其他列印工作。  
  
 `StartDoc`不應該使用中繼檔內。  
  
### <a name="example"></a>範例  
 此程式碼片段會取得預設印表機，開啟列印工作，再多工緩衝處理"Hello World ！"的單一頁面 它。 因為此程式碼來列印的文字不縮放至印表機的邏輯單元，所以輸出文字可能無法以這類小寫字母的結果是無法讀取。 調整功能，例如 CDC `SetMapMode`， `SetViewportOrg`，和`SetWindowExt`，可用來修正的縮放比例。  
  
 [!code-cpp[NVC_MFCDocView #&41;](../../mfc/codesnippet/cpp/cdc-class_13.cpp)]  
  
##  <a name="startpage"></a>CDC::StartPage  
 呼叫此成員函式，若要準備要接收資料的印表機驅動程式。  
  
```  
int StartPage();
```  
  
### <a name="return-value"></a>傳回值  
 大於或等於 0，如果函式成功或如果發生錯誤的負值。  
  
### <a name="remarks"></a>備註  
 `StartPage`取代**NEWFRAME**和**BANDINFO**逸出。  
  
 如需列印的呼叫順序的概觀，請參閱[Cdc](#startdoc)成員函式。  
  
 系統會停用`ResetDC`成員函式呼叫之間`StartPage`和`EndPage`。  
  
### <a name="example"></a>範例  
  請參閱範例[CDC::StartDoc](#startdoc)。  
  
##  <a name="stretchblt"></a>CDC::StretchBlt  
 將來源矩形的點陣圖複製到目的地矩形，必要時可延伸或壓縮點陣圖，使其符合目的地矩形的維度。  
  
```  
BOOL StretchBlt(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    DWORD dwRop);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定目的地矩形左上角的 X 座標 (以邏輯單位表示)。  
  
 *y*  
 指定目的地矩形左上角的 Y 座標 (以邏輯單位表示)。  
  
 `nWidth`  
 指定目的地矩形的寬度 (以邏輯單位表示)。  
  
 `nHeight`  
 指定目的地矩形的高度 (以邏輯單位表示)。  
  
 `pSrcDC`  
 指定來源裝置內容。  
  
 `xSrc`  
 指定來源矩形左上角的 X 座標 (以邏輯單位表示)。  
  
 `ySrc`  
 指定來源矩形左上角的 Y 座標 (以邏輯單位表示)。  
  
 `nSrcWidth`  
 指定來源矩形的寬度 (以邏輯單位表示)。  
  
 `nSrcHeight`  
 指定來源矩形的高度 (以邏輯單位表示)。  
  
 *dwRop*  
 指定待執行的點陣作業。 點陣作業程式碼定義 GDI 在輸出作業中結合色彩的方式；該輸出作業與目前的筆刷、可能的來源點陣圖和目的地點陣圖相關。 這個參數可以是下列其中一個值：  
  
- **BLACKNESS**將所有輸出變成黑色。  
  
- **DSTINVERT**反轉目的地點陣圖。  
  
- **MERGECOPY**模式和來源點陣圖使用布林值 AND 運算子。  
  
- **MERGEPAINT**反轉的來源點陣圖和目的地點陣圖使用布林值 OR 運算子。  
  
- **NOTSRCCOPY**將反轉的來源點陣圖複製到目的地。  
  
- **NOTSRCERASE**反轉結合使用布林值 OR 運算子的目的地和來源點陣圖的結果。  
  
- **PATCOPY**將模式複製到目的地點陣圖。  
  
- **PATINVERT**與模式中使用布林值 XOR 運算子合併目的地點陣圖。  
  
- **PATPAINT**反轉的來源點陣圖會結合使用布林值 OR 運算子的模式。 使用布林值 OR 運算子合併此作業的結果與目的地點陣圖。  
  
- **SRCAND**使用布林值 AND 運算子的目的地和來源點陣圖的像素。  
  
- **SRCCOPY**將來源點陣圖複製到目的地點陣圖。  
  
- **SRCERASE**反轉目的地點陣圖，並將結果與使用布林值 AND 運算子的來源點陣圖。  
  
- **SRCINVERT**使用布林值 XOR 運算子的目的地和來源點陣圖的像素。  
  
- **SRCPAINT**使用布林值 OR 運算子的目的地和來源點陣圖的像素。  
  
- **亮度**所有將輸出的變成白色。  
  
### <a name="return-value"></a>傳回值  
 如果繪製了點陣圖即為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式使用目的地裝置內容 (以 `SetStretchBltMode` 設定) 的縮放模式判斷如何縮放或壓縮點陣圖。  
  
 `StretchBlt` 函式會將點陣圖從 `pSrcDC` 指定的來源裝置移到裝置內容物件代表的目的地裝置 (此物件的成員函式會被呼叫)。 `xSrc`、`ySrc`、`nSrcWidth` 和 `nSrcHeight` 參數定義來源矩形的左上角和維度。 *x*， *y*， `nWidth`，和`nHeight`參數指定左上角和目的地矩形的維度。 所指定的點陣作業*dwRop*定義如何合併來源點陣圖和已在目的地裝置上的位元。  
  
 如果 `StretchBlt` 和 `nSrcWidth` 或 `nWidth` 和 `nSrcHeight` 參數的符號不同，`nHeight` 函式會建立點陣圖的鏡像。 如果 `nSrcWidth` and `nWidth` 的符號不同，函式會沿著 X 軸建立點陣圖的鏡像。 如果 `nSrcHeight` and `nHeight` 的符號不同，函式會沿著 Y 軸建立點陣圖的鏡像。  
  
 `StretchBlt` 函式會延伸或壓縮記憶體中的來源點陣圖，然後將結果複製到目的地。 如果要合併模式和結果，除非將延伸的來源點陣圖複製到目的地，否則不會進行合併。 如果使用筆刷，會使用在目的地裝置內容中選取的筆刷。 目的地座標會根據目的地裝置內容而轉換；來源座標會根據來源裝置內容而轉換。  
  
 如果目的地、來源和模式點陣圖的色彩格式不同，`StretchBlt` 會轉換來源和模式點陣圖以符合目的地點陣圖。 轉換中會使用目的地裝置内容的前景和背景色彩。  
  
 如果 `StretchBlt` 必須將單色點陣圖轉換為彩色，會將白色位元 (1) 設為背景色彩，並將黑色位元 (0) 設為前景色彩。 若要將彩色轉換為單色，則會將符合背景色彩的像素轉換成白色 (1)，並將其他所有像素設為黑色 (0)。 會使用彩色裝置內容的前景和背景色彩。  
  
 並非所有的裝置皆支援 `StretchBlt` 函式。 若要判斷裝置是否支援`StretchBlt`，呼叫`GetDeviceCaps`成員函式**RASTERCAPS**編製索引，並檢查傳回值**RC_STRETCHBLT**旗標。  
  
##  <a name="strokeandfillpath"></a>CDC::StrokeAndFillPath  
 關閉任何開啟的圖形路徑中，使用目前的畫筆 strokes 路徑的外框，填滿它的內部使用目前的筆刷。  
  
```  
BOOL StrokeAndFillPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 裝置內容必須包含已關閉的路徑。 `StrokeAndFillPath`成員函式具有相同的效果關閉所有開啟的圖表，在路徑中，並將畫筆繪製，並分別填入路徑，不同之處在於填滿的區域將不會重疊描圖外的區域，即使是寬。  
  
##  <a name="strokepath"></a>CDC::StrokePath  
 使用目前的畫筆轉譯指定的路徑。  
  
```  
BOOL StrokePath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 裝置內容必須包含已關閉的路徑。  
  
##  <a name="tabbedtextout"></a>CDC::TabbedTextOut  
 呼叫此成員函式可寫入的字元字串，在指定的位置中，展開索引標籤的定位停駐點位置陣列中指定的值。  
  
```  
virtual CSize TabbedTextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);

 
CSize TabbedTextOut(
    int x,  
    int y,  
    const CString& str,  
    int nTabPositions,  
    LPINT lpnTabStopPositions,  
    int nTabOrigin);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定字串的起始點的邏輯 x 座標。  
  
 *y*  
 指定字串的起始點的邏輯 y 座標。  
  
 `lpszString`  
 指向要繪製的字元字串。 您可以將指標傳遞至字元陣列或[CString](../../atl-mfc-shared/reference/cstringt-class.md)這個參數的物件。  
  
 `nCount`  
 指定字串中的字元數。 如果`nCount`為 –&1;，長度會計算。  
  
 `nTabPositions`  
 指定陣列中的定位停駐點位置的值數目。  
  
 `lpnTabStopPositions`  
 指向陣列，其中包含定位停駐點位置 （以邏輯單位表示）。 必須以遞增順序排序定位停駐點最小的 x 值應該在陣列中的第一個項目。  
  
 `nTabOrigin`  
 指定的索引標籤會展開 （以邏輯單位表示） 的開始位置的 x 座標。  
  
 `str`  
 A`CString`物件，其中包含指定的字元。  
  
### <a name="return-value"></a>傳回值  
 形式的字串 （以邏輯單位表示） 的維度`CSize`物件。  
  
### <a name="remarks"></a>備註  
 文字是以目前選取的字型。 如果`nTabPositions`為 0 和`lpnTabStopPositions`是**NULL**，索引標籤會展開成 8 倍的平均字元寬度。  
  
 如果`nTabPositions`為 1，[] 索引標籤中的第一個值所指定的距離隔開停駐點`lpnTabStopPositions`陣列。 如果`lpnTabStopPositions`陣列包含一個以上的值、 定位點設定為高達指定的數字陣列中每個值`nTabPositions`。 `nTabOrigin`參數可讓應用程式呼叫`TabbedTextOut`函式數次的單一行。 如果應用程式呼叫此函式一次以上與`nTabOrigin`每次設定為相同的值，函式會展開所有的索引標籤相對於所指定的位置`nTabOrigin`。  
  
 根據預設，函式不會使用或更新目前的位置。 如果應用程式需要更新目前的位置，它會呼叫此函式時，應用程式可以呼叫[SetTextAlign](#settextalign)成員函式`nFlags`設**TA_UPDATECP**。 當設定這個旗標時，Windows 會略過*x*和*y*參數的後續呼叫`TabbedTextOut`，改用目前的位置。  
  
##  <a name="textout"></a>CDC::TextOut  
 使用目前選取的字型，在指定的位置寫入字元字串。  
  
```  
virtual BOOL TextOut(
    int x,  
    int y,  
    LPCTSTR lpszString,  
    int nCount);

 
BOOL TextOut(
    int x,
    int y,
    const CString& str);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定文字起點的邏輯 X 座標。  
  
 *y*  
 指定文字起點的邏輯 Y 座標。  
  
 `lpszString`  
 指向要繪製的字元字串。  
  
 `nCount`  
 指定字串中的字元數。  
  
 `str`  
 `CString` 物件，其中包含要繪製的字元。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 字元原點在字元儲存格的左上角。 根據預設，函式不會使用或更新目前的位置。  
  
 如果應用程式需要更新目前的位置時，它會呼叫`TextOut`，應用程式可以呼叫`SetTextAlign`成員函式`nFlags`設**TA_UPDATECP**。 當設定這個旗標時，Windows 會略過*x*和*y*參數的後續呼叫`TextOut`，改用目前的位置。  
  
### <a name="example"></a>範例  
  請參閱範例[cdc:: beginpath](#beginpath)。  
  
##  <a name="transparentblt"></a>CDC::TransparentBlt  
 呼叫此成員函式，將對應從指定的來源裝置內容中，放入目的地裝置內容中像素矩形的色彩資料位元區塊。  
  
```  
BOOL TransparentBlt(
    int xDest,  
    int yDest,
    int nDestWidth,
    int nDestHeight,  
    CDC* pSrcDC,  
    int xSrc,  
    int ySrc,  
    int nSrcWidth,  
    int nSrcHeight,  
    UINT clrTransparent);
```  
  
### <a name="parameters"></a>參數  
 `xDest`  
 指定邏輯單元，目的矩形左上角的 x 座標。  
  
 `yDest`  
 指定邏輯單元，目的矩形左上角的 y 軸座標。  
  
 `nDestWidth`  
 目的矩形的邏輯單位中指定的寬度。  
  
 `nDestHeight`  
 目的矩形的邏輯單位中指定的高度。  
  
 `pSrcDC`  
 來源裝置內容的指標。  
  
 `xSrc`  
 指定來源矩形的邏輯單位中的 x 軸座標。  
  
 `ySrc`  
 指定來源矩形的邏輯單位中的 y 軸座標。  
  
 `nSrcWidth`  
 指定邏輯單元，來源矩形的寬度。  
  
 `nSrcHeight`  
 來源矩形的邏輯單位中指定的高度。  
  
 `clrTransparent`  
 中要視為透明的來源點陣圖的 RGB 色彩。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果成功，否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 `TransparentBlt`允許的透明度。也就是 RGB 色彩會由`clrTransparent`呈現透明傳輸。  
  
 如需詳細資訊，請參閱[TransparentBlt](http://msdn.microsoft.com/library/windows/desktop/dd145141)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="updatecolors"></a>CDC::UpdateColors  
 更新工作區會比對目前的裝置內容的系統調色盤像素 x 像素為基礎的用戶端區域中的色彩。  
  
```  
void UpdateColors();
```  
  
### <a name="remarks"></a>備註  
 可能會呼叫非使用中的視窗，以實現邏輯調色盤`UpdateColors`另一種系統調色盤變更時，重繪其工作區。  
  
 如需使用色板的詳細資訊，請參閱[UpdateColors](http://msdn.microsoft.com/library/windows/desktop/dd145166)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `UpdateColors`成員函式通常會更新用戶端區域較重繪的區域。 不過，因為函式會執行系統調色盤變更之前，根據每個像素色彩的色彩轉譯，每次呼叫此函數就會導致某些色彩精確度遺失。  
  
##  <a name="widenpath"></a>CDC::WidenPath  
 如果路徑圖案使用目前選取到裝置內容的畫筆會繪製的區域來重新定義目前的路徑。  
  
```  
BOOL WidenPath();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 此函式是成功只有目前的畫筆是幾何的畫筆的第二個版本所建立的`CreatePen`成員函式，如果使用的第一個版本建立畫筆或`CreatePen`且寬度，單位為大於 1 的裝置單位。 裝置內容必須包含已關閉的路徑。 在路徑中的任何 Bzier 曲線會轉換成將逼近加寬的曲線的直線，線條的序列。 因此，沒有 Bzier 曲線留在後面的路徑`WidenPath`呼叫。  
  
## <a name="see-also"></a>另請參閱  
 [CObject 類別](../../mfc/reference/cobject-class.md)   
 [階層架構圖表](../../mfc/hierarchy-chart.md)   
 [CPaintDC 類別](../../mfc/reference/cpaintdc-class.md)   
 [CWindowDC 類別](../../mfc/reference/cwindowdc-class.md)   
 [CClientDC 類別](../../mfc/reference/cclientdc-class.md)   
 [CMetaFileDC 類別](../../mfc/reference/cmetafiledc-class.md)

