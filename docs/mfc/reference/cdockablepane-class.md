---
title: CDockablePane 類別 |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-mfc
ms.topic: reference
f1_keywords:
- CDockablePane
- AFXDOCKABLEPANE/CDockablePane
- AFXDOCKABLEPANE/CDockablePane::CDockablePane
- AFXDOCKABLEPANE/CDockablePane::AttachToTabWnd
- AFXDOCKABLEPANE/CDockablePane::CalcFixedLayout
- AFXDOCKABLEPANE/CDockablePane::CanAcceptMiniFrame
- AFXDOCKABLEPANE/CDockablePane::CanAcceptPane
- AFXDOCKABLEPANE/CDockablePane::CanAutoHide
- AFXDOCKABLEPANE/CDockablePane::CanBeAttached
- AFXDOCKABLEPANE/CDockablePane::ConvertToTabbedDocument
- AFXDOCKABLEPANE/CDockablePane::CopyState
- AFXDOCKABLEPANE/CDockablePane::Create
- AFXDOCKABLEPANE/CDockablePane::CreateDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::CreateEx
- AFXDOCKABLEPANE/CDockablePane::CreateTabbedPane
- AFXDOCKABLEPANE/CDockablePane::DockPaneContainer
- AFXDOCKABLEPANE/CDockablePane::DockPaneStandard
- AFXDOCKABLEPANE/CDockablePane::DockToRecentPos
- AFXDOCKABLEPANE/CDockablePane::DockToWindow
- AFXDOCKABLEPANE/CDockablePane::EnableAutohideAll
- AFXDOCKABLEPANE/CDockablePane::EnableGripper
- AFXDOCKABLEPANE/CDockablePane::GetAHRestoredRect
- AFXDOCKABLEPANE/CDockablePane::GetAHSlideMode
- AFXDOCKABLEPANE/CDockablePane::GetCaptionHeight
- AFXDOCKABLEPANE/CDockablePane::GetDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::GetDockingStatus
- AFXDOCKABLEPANE/CDockablePane::GetDragSensitivity
- AFXDOCKABLEPANE/CDockablePane::GetLastPercentInPaneContainer
- AFXDOCKABLEPANE/CDockablePane::GetTabArea
- AFXDOCKABLEPANE/CDockablePane::GetTabbedPaneRTC
- AFXDOCKABLEPANE/CDockablePane::HasAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::HitTest
- AFXDOCKABLEPANE/CDockablePane::IsAutohideAllEnabled
- AFXDOCKABLEPANE/CDockablePane::IsAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::IsDocked
- AFXDOCKABLEPANE/CDockablePane::IsHideInAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::IsInFloatingMultiPaneFrameWnd
- AFXDOCKABLEPANE/CDockablePane::IsResizable
- AFXDOCKABLEPANE/CDockablePane::IsTabLocationBottom
- AFXDOCKABLEPANE/CDockablePane::IsTracked
- AFXDOCKABLEPANE/CDockablePane::IsVisible
- AFXDOCKABLEPANE/CDockablePane::OnAfterChangeParent
- AFXDOCKABLEPANE/CDockablePane::OnAfterDockFromMiniFrame
- AFXDOCKABLEPANE/CDockablePane::OnBeforeChangeParent
- AFXDOCKABLEPANE/CDockablePane::OnBeforeFloat
- AFXDOCKABLEPANE/CDockablePane::RemoveFromDefaultPaneDividier
- AFXDOCKABLEPANE/CDockablePane::ReplacePane
- AFXDOCKABLEPANE/CDockablePane::RestoreDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::SetAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::SetAutoHideParents
- AFXDOCKABLEPANE/CDockablePane::SetLastPercentInPaneContainer
- AFXDOCKABLEPANE/CDockablePane::SetRestoredDefaultPaneDivider
- AFXDOCKABLEPANE/CDockablePane::SetTabbedPaneRTC
- AFXDOCKABLEPANE/CDockablePane::ShowPane
- AFXDOCKABLEPANE/CDockablePane::Slide
- AFXDOCKABLEPANE/CDockablePane::ToggleAutoHide
- AFXDOCKABLEPANE/CDockablePane::UndockPane
- AFXDOCKABLEPANE/CDockablePane::CheckAutoHideCondition
- AFXDOCKABLEPANE/CDockablePane::CheckStopSlideCondition
- AFXDOCKABLEPANE/CDockablePane::DrawCaption
- AFXDOCKABLEPANE/CDockablePane::OnPressButtons
- AFXDOCKABLEPANE/CDockablePane::OnSlide
- AFXDOCKABLEPANE/CDockablePane::m_bDisableAnimation
- AFXDOCKABLEPANE/CDockablePane::m_bHideInAutoHideMode
- AFXDOCKABLEPANE/CDockablePane::m_nSlideSteps
dev_langs:
- C++
helpviewer_keywords:
- CDockablePane [MFC], CDockablePane
- CDockablePane [MFC], AttachToTabWnd
- CDockablePane [MFC], CalcFixedLayout
- CDockablePane [MFC], CanAcceptMiniFrame
- CDockablePane [MFC], CanAcceptPane
- CDockablePane [MFC], CanAutoHide
- CDockablePane [MFC], CanBeAttached
- CDockablePane [MFC], ConvertToTabbedDocument
- CDockablePane [MFC], CopyState
- CDockablePane [MFC], Create
- CDockablePane [MFC], CreateDefaultPaneDivider
- CDockablePane [MFC], CreateEx
- CDockablePane [MFC], CreateTabbedPane
- CDockablePane [MFC], DockPaneContainer
- CDockablePane [MFC], DockPaneStandard
- CDockablePane [MFC], DockToRecentPos
- CDockablePane [MFC], DockToWindow
- CDockablePane [MFC], EnableAutohideAll
- CDockablePane [MFC], EnableGripper
- CDockablePane [MFC], GetAHRestoredRect
- CDockablePane [MFC], GetAHSlideMode
- CDockablePane [MFC], GetCaptionHeight
- CDockablePane [MFC], GetDefaultPaneDivider
- CDockablePane [MFC], GetDockingStatus
- CDockablePane [MFC], GetDragSensitivity
- CDockablePane [MFC], GetLastPercentInPaneContainer
- CDockablePane [MFC], GetTabArea
- CDockablePane [MFC], GetTabbedPaneRTC
- CDockablePane [MFC], HasAutoHideMode
- CDockablePane [MFC], HitTest
- CDockablePane [MFC], IsAutohideAllEnabled
- CDockablePane [MFC], IsAutoHideMode
- CDockablePane [MFC], IsDocked
- CDockablePane [MFC], IsHideInAutoHideMode
- CDockablePane [MFC], IsInFloatingMultiPaneFrameWnd
- CDockablePane [MFC], IsResizable
- CDockablePane [MFC], IsTabLocationBottom
- CDockablePane [MFC], IsTracked
- CDockablePane [MFC], IsVisible
- CDockablePane [MFC], OnAfterChangeParent
- CDockablePane [MFC], OnAfterDockFromMiniFrame
- CDockablePane [MFC], OnBeforeChangeParent
- CDockablePane [MFC], OnBeforeFloat
- CDockablePane [MFC], RemoveFromDefaultPaneDividier
- CDockablePane [MFC], ReplacePane
- CDockablePane [MFC], RestoreDefaultPaneDivider
- CDockablePane [MFC], SetAutoHideMode
- CDockablePane [MFC], SetAutoHideParents
- CDockablePane [MFC], SetLastPercentInPaneContainer
- CDockablePane [MFC], SetRestoredDefaultPaneDivider
- CDockablePane [MFC], SetTabbedPaneRTC
- CDockablePane [MFC], ShowPane
- CDockablePane [MFC], Slide
- CDockablePane [MFC], ToggleAutoHide
- CDockablePane [MFC], UndockPane
- CDockablePane [MFC], CheckAutoHideCondition
- CDockablePane [MFC], CheckStopSlideCondition
- CDockablePane [MFC], DrawCaption
- CDockablePane [MFC], OnPressButtons
- CDockablePane [MFC], OnSlide
- CDockablePane [MFC], m_bDisableAnimation
- CDockablePane [MFC], m_bHideInAutoHideMode
- CDockablePane [MFC], m_nSlideSteps
ms.assetid: e2495f4c-765f-48f9-a2e2-e45e47608d91
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 05d7897bf7b18d804d787f865b80b615b7564919
ms.sourcegitcommit: 76fd30ff3e0352e2206460503b61f45897e60e4f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/13/2018
ms.locfileid: "39028287"
---
# <a name="cdockablepane-class"></a>CDockablePane Class
實作可以停駐在固定位置或包含於索引標籤式窗格的窗格。  
  
## <a name="syntax"></a>語法  
  
```  
class CDockablePane : public CPane  
```  
  
## <a name="members"></a>成員  
  
### <a name="public-constructors"></a>公用建構函式  
  
|名稱|描述|  
|----------|-----------------|  
|[CDockablePane::CDockablePane](#cdockablepane)|建構並初始化 `CDockablePane` 物件。|  
  
### <a name="public-methods"></a>公用方法  
  
|名稱|描述|  
|----------|-----------------|  
|[Cdockablepane:: Attachtotabwnd](#attachtotabwnd)|將一個窗格附加到另一個窗格。 這會建立索引標籤式的窗格。|  
|[CDockablePane::CalcFixedLayout](#calcfixedlayout)|傳回窗格矩形的大小。|  
|[CDockablePane::CanAcceptMiniFrame](#canacceptminiframe)|判斷指定的迷你框架是否可以停駐窗格。|  
|[CDockablePane::CanAcceptPane](#canacceptpane)|判斷另一個窗格是否可以固定到目前的窗格。|  
|[CDockablePane::CanAutoHide](#canautohide)|判斷窗格是否支援自動隱藏模式。 (覆寫[CBasePane::CanAutoHide](../../mfc/reference/cbasepane-class.md#canautohide)。)|  
|[CDockablePane::CanBeAttached](#canbeattached)|判斷目前的窗格是否可以停駐到另一個窗格。|  
|[CDockablePane::ConvertToTabbedDocument](#converttotabbeddocument)|MDI 索引標籤式文件會將一或多個可停駐窗格。|  
|[CDockablePane::CopyState](#copystate)|複製可停駐窗格的狀態。|  
|[CDockablePane::Create](#create)|建立 Windows 控制項，並將它附加至`CDockablePane`物件。|  
|[CDockablePane::CreateDefaultPaneDivider](#createdefaultpanedivider)|它所停駐在框架視窗將會建立預設分割線的窗格。|  
|[Cdockablepane:: Createex](#createex)|建立 Windows 控制項，並將它附加至`CDockablePane`物件。|  
|[CDockablePane::CreateTabbedPane](#createtabbedpane)|從目前的窗格中建立索引標籤式的窗格。|  
|[CDockablePane::DockPaneContainer](#dockpanecontainer)|窗格停駐的容器。|  
|[CDockablePane::DockPaneStandard](#dockpanestandard)|使用 外框 （標準） 的停駐停駐窗格。|  
|`CDockablePane::DockToFrameWindow`|在內部使用。 若要停駐窗格，請使用[CPane::DockPane](../../mfc/reference/cpane-class.md#dockpane)或是[CDockablePane::DockToWindow](#docktowindow)。|  
|[CDockablePane::DockToRecentPos](#docktorecentpos)|窗格停駐於其預存的最新的停駐位置。|  
|[CDockablePane::DockToWindow](#docktowindow)|一個停駐窗格停駐於停駐的另一個窗格。|  
|[CDockablePane::EnableAutohideAll](#enableautohideall)|啟用或停用此窗格，以及在容器中的其他窗格的 自動隱藏模式。|  
|[CDockablePane::EnableGripper](#enablegripper)|顯示或隱藏標題 (gripper)。|  
|[CDockablePane::GetAHRestoredRect](#getahrestoredrect)|指定當自動隱藏模式中顯示 窗格的位置。|  
|[CDockablePane::GetAHSlideMode](#getahslidemode)|擷取窗格的 [自動隱藏投影片] 模式。|  
|`CDockablePane::GetAutoHideButton`|在內部使用。|  
|`CDockablePane::GetAutoHideToolBar`|在內部使用。|  
|[CDockablePane::GetCaptionHeight](#getcaptionheight)|傳回目前的標題的高度。|  
|[CDockablePane::GetDefaultPaneDivider](#getdefaultpanedivider)|傳回預設值 窗格分割線，窗格的容器。|  
|[CDockablePane::GetDockingStatus](#getdockingstatus)|判斷提供的指標位置為基礎的停駐窗格的能力。|  
|[CDockablePane::GetDragSensitivity](#getdragsensitivity)|傳回停駐窗格拖曳機密性。|  
|[CDockablePane::GetLastPercentInPaneContainer](#getlastpercentinpanecontainer)|擷取其容器中的窗格所佔用的空間百分比。|  
|[CDockablePane::GetTabArea](#gettabarea)|擷取窗格 索引標籤區域。|  
|[CDockablePane::GetTabbedPaneRTC](#gettabbedpanertc)|傳回目前的窗格停駐於另一個窗格時，會建立索引標籤式視窗的執行階段類別資訊。|  
|[CDockablePane::HasAutoHideMode](#hasautohidemode)|指定是否可以停駐窗格切換為自動隱藏模式。|  
|[CDockablePane::HitTest](#hittest)|在使用者按一下滑鼠的位置 窗格中指定特定的位置。|  
|`CDockablePane::IsAccessibilityCompatible`|在內部使用。|  
|[CDockablePane::IsAutohideAllEnabled](#isautohideallenabled)|指出是否停駐窗格和容器中的所有其他窗格可以放在 自動隱藏模式。|  
|[CDockablePane::IsAutoHideMode](#isautohidemode)|決定是否自動隱藏模式中的窗格。|  
|`CDockablePane::IsChangeState`|在內部使用。|  
|[CDockablePane::IsDocked](#isdocked)|判斷目前的窗格是否停駐。|  
|[CDockablePane::IsHideInAutoHideMode](#ishideinautohidemode)|決定的窗格是 自動隱藏模式中，如果它是顯示 （或隱藏） 藉由呼叫行為`ShowPane`。|  
|[CDockablePane::IsInFloatingMultiPaneFrameWnd](#isinfloatingmultipaneframewnd)|指定是否在多窗格框架視窗中窗格。|  
|[CDockablePane::IsResizable](#isresizable)|指定是否可調整大小的窗格。|  
|[CDockablePane::IsTabLocationBottom](#istablocationbottom)|指定是否位在頂端或底部窗格的索引標籤。|  
|[CDockablePane::IsTracked](#istracked)|指定一個窗格由使用者拖曳。|  
|[CDockablePane::IsVisible](#isvisible)|判斷目前的窗格是否可見。|  
|[Cdockablepane:: Loadstate](http://msdn.microsoft.com/96110136-4f46-4764-8a76-3b4abaf77917)|在內部使用。|  
|[CDockablePane::OnAfterChangeParent](#onafterchangeparent)|當一個窗格的父代變更時由架構呼叫。 (覆寫[CPane::OnAfterChangeParent](../../mfc/reference/cpane-class.md#onafterchangeparent)。)|  
|[CDockablePane::OnAfterDockFromMiniFrame](#onafterdockfromminiframe)|在框架視窗停駐浮動的停駐列時，由架構呼叫。|  
|[CDockablePane::OnBeforeChangeParent](#onbeforechangeparent)|若要變更窗格的父代時，由架構呼叫。 (覆寫[CPane::OnBeforeChangeParent](../../mfc/reference/cpane-class.md#onbeforechangeparent)。)|  
|[CDockablePane::OnBeforeFloat](#onbeforefloat)|當窗格即將浮點數時，由架構呼叫。 (覆寫[CPane::OnBeforeFloat](../../mfc/reference/cpane-class.md#onbeforefloat)。)|  
|[為 Cdockablepane](#removefromdefaultpanedividier)|當窗格能卸除時，架構會呼叫這個方法。|  
|[CDockablePane::ReplacePane](#replacepane)|取代指定的窗格中的窗格。|  
|[CDockablePane::RestoreDefaultPaneDivider](#restoredefaultpanedivider)|還原預設的窗格分割線的窗格是還原序列化，架構會呼叫這個方法。|  
|`CDockablePane::SaveState`|在內部使用。|  
|`CDockablePane::Serialize`|將序列化的窗格。 (覆寫 `CBasePane::Serialize`。)|  
|[CDockablePane::SetAutoHideMode](#setautohidemode)|切換之間顯示停駐窗格和 自動隱藏模式。|  
|[CDockablePane::SetAutoHideParents](#setautohideparents)|設定自動隱藏按鈕和 [] 窗格中的自動隱藏工具列。|  
|`CDockablePane::SetDefaultPaneDivider`|在內部使用。|  
|[CDockablePane::SetLastPercentInPaneContainer](#setlastpercentinpanecontainer)|設定其容器中的窗格所佔用的空間百分比。|  
|`CDockablePane::SetResizeMode`|在內部使用。|  
|[CDockablePane::SetRestoredDefaultPaneDivider](#setrestoreddefaultpanedivider)|設定還原的預設的窗格分割線。|  
|[Cdockablepane:: Settabbedpanertc](#settabbedpanertc)|設定兩個窗格停駐在一起時，會建立索引標籤式視窗的執行階段類別資訊。|  
|[CDockablePane::ShowPane](#showpane)|顯示或隱藏窗格。|  
|[CDockablePane::Slide](#slide)|顯示或隱藏窗格中的，滑動動畫顯示] 窗格處於 [自動隱藏模式時，才使用。|  
|[CDockablePane::ToggleAutoHide](#toggleautohide)|切換自動隱藏模式。 (覆寫[CPane::ToggleAutoHide](../../mfc/reference/cpane-class.md#toggleautohide) 。)|  
|[CDockablePane::UndockPane](#undockpane)|從主框架視窗或迷你視窗容器窗格可以卸除。|  
|`CDockablePane::UnSetAutoHideMode`|在內部使用。 若要設定自動隱藏模式，請使用[CDockablePane::SetAutoHideMode](#setautohidemode)|  
  
### <a name="protected-methods"></a>保護方法  
  
|名稱|描述|  
|----------|-----------------|  
|[CDockablePane::CheckAutoHideCondition](#checkautohidecondition)|決定是否要停駐窗格隱藏 （處於自動隱藏模式）。|  
|[CDockablePane::CheckStopSlideCondition](#checkstopslidecondition)|決定何時自動隱藏固定窗格應該停止滑動。|  
|[CDockablePane::DrawCaption](#drawcaption)|繪製停駐窗格標題 (gripper)。|  
|[CDockablePane::OnPressButtons](#onpressbuttons)|當使用者按下標題按鈕而非 AFX_HTCLOSE 和 AFX_HTMAXBUTTON 按鈕時呼叫。|  
|[CDockablePane::OnSlide](#onslide)|由架構呼叫以呈現自動隱藏投影片效果，當顯示或隱藏窗格時。|  
  
### <a name="data-members"></a>資料成員  
  
|名稱|描述|  
|----------|-----------------|  
|[CDockablePane::m_bDisableAnimation](#m_bdisableanimation)|指定是否要停用自動隱藏可停駐窗格的動畫。|  
|[CDockablePane::m_bHideInAutoHideMode](#m_bhideinautohidemode)|[] 窗格處於自動隱藏模式時，請決定窗格的行為。|  
|[CDockablePane::m_nSlideSteps](#m_nslidesteps)|指定動畫速度的窗格中，當顯示或隱藏在 自動隱藏模式。|  
  
## <a name="remarks"></a>備註  
 `CDockablePane` 實作下列功能：  
  
-   主框架視窗的停駐窗格。  
  
-   切換自動隱藏模式的窗格。  
  
-   將一個窗格附加至索引標籤式視窗中。  
  
-   浮動迷你框架中的窗格。  
  
-   浮動迷你框架中的另一個窗格的停駐窗格。  
  
-   調整窗格的大小。  
  
-   載入和儲存狀態的停駐窗格。  
  
    > [!NOTE]
    >  狀態資訊會儲存到 Windows 登錄中。  
  
-   包含或不含標題，請建立一個窗格。 標題可以有文字標籤，並填入的漸層色彩。  
  
-   顯示窗格的內容時拖曳窗格  
  
-   您可以拖曳窗格時顯示拖曳矩形。  
  
 若要在您的應用程式中使用的停駐窗格，衍生您的窗格類別，從`CDockablePane`類別。 主框架視窗物件或視窗物件可控制您的窗格中的執行個體，可能被內嵌衍生的物件。 然後呼叫[CDockablePane::Create](#create)方法或[cdockablepane:: Createex](#createex)方法，當您處理主框架視窗中的 WM_CREATE 訊息。 最後，設定窗格物件，藉由呼叫[CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)， [cbasepane:: Dockpane](../../mfc/reference/cbasepane-class.md#dockpane)，或[cdockablepane:: Attachtotabwnd](#attachtotabwnd)。  
  
## <a name="customization-tips"></a>自訂秘訣  
 下列秘訣適用於`CDockablePane`物件：  
  
-   如果您呼叫[cdockablepane:: Attachtotabwnd](#attachtotabwnd)兩個非索引標籤，可停駐窗格的索引標籤式視窗的指標將會傳回*ppTabbedControlBar*參數。 您可以繼續使用此參數，將索引標籤新增至索引標籤式視窗。  
  
-   索引標籤式窗格所建立的種類[cdockablepane:: Attachtotabwnd](#attachtotabwnd)取決`CDockablePane`物件*pTabControlBarAttachTo*參數。 您可以呼叫[cdockablepane:: Settabbedpanertc](#settabbedpanertc)若要設定的索引標籤式窗格類型`CDockablePane`會建立。 預設類型取決於`dwTabbedStyle`的[CDockablePane::Create](#create)當您第一次建立`CDockablePane`。 如果*dwTabbedStyle*是預設的類型是的 AFX_CBRS_OUTLOOK_TABS [CMFCOutlookBar 類別](../../mfc/reference/cmfcoutlookbar-class.md); 如果*dwTabbedStyle* AFX_CBRS_REGULAR_TABS 預設類型是[CTabbedPane 類別](../../mfc/reference/ctabbedpane-class.md)。  
  
-   如果您想要將其中一個可停駐窗格停駐到另一個，呼叫[CDockablePane::DockToWindow](#docktowindow)方法。 [原始] 窗格，必須停駐位置之前呼叫這個方法。  
  
-   成員變數[CDockablePane::m_bHideInAutoHideMode](#m_bhideinautohidemode)控制項的方式可停駐窗格行為中自動隱藏模式當您呼叫[CDockablePane::ShowPane](#showpane)。 如果此成員變數設定為 TRUE，將隱藏可停駐窗格和其自動隱藏按鈕。 否則，它們會投影片縮小和相應放大。  
  
-   您可以藉由設定停用自動隱藏動畫[CDockablePane::m_bDisableAnimation](#m_bdisableanimation)成員變數設為 TRUE。  
  
## <a name="example"></a>範例  
 下列範例示範如何設定`CDockablePane`使用中的各種方法的物件`CDockablePane`類別。 此範例說明如何啟用自動隱藏可停駐窗格的所有功能，都啟用標題 」 或 「 移駐夾，都啟用自動隱藏模式、 顯示窗格中，並以動畫顯示自動隱藏模式中的窗格。 此程式碼片段是一部分[Visual Studio 示範範例](../../visual-cpp-samples.md)。  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo#27](../../mfc/codesnippet/cpp/cdockablepane-class_1.cpp)]  
[!code-cpp[NVC_MFC_VisualStudioDemo#28](../../mfc/codesnippet/cpp/cdockablepane-class_2.cpp)]  
  
## <a name="inheritance-hierarchy"></a>繼承階層  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 [CCmdTarget](../../mfc/reference/ccmdtarget-class.md)  
  
 [CWnd](../../mfc/reference/cwnd-class.md)  
  
 [CBasePane](../../mfc/reference/cbasepane-class.md)  
  
 [CPane](../../mfc/reference/cpane-class.md)  
  
 [CDockablePane](../../mfc/reference/cdockablepane-class.md)  
  
## <a name="requirements"></a>需求  
 **標頭：** afxDockablePane.h  
  
##  <a name="attachtotabwnd"></a>  Cdockablepane:: Attachtotabwnd  
 將目前的窗格附加至 [目標] 窗格中，建立索引標籤式的窗格。  
  
```  
virtual CDockablePane* AttachToTabWnd(
    CDockablePane* pTabControlBarAttachTo,  
    AFX_DOCK_METHOD dockMethod,  
    BOOL bSetActive= TRUE,  
    CDockablePane** ppTabbedControlBar = NULL);  
```  
  
### <a name="parameters"></a>參數  
 [in][out]*pTabControlBarAttachTo*  
 指定目前的窗格會將附加至 [目標] 窗格。 [目標] 窗格中必須是可停駐窗格。  
  
 [in]*dockMethod*  
 指定的停駐的方法。  
  
 [in]*bSetActive*  
 若要啟用索引標籤式的窗格在附加作業; 之後，則為 TRUE否則為 FALSE。  
  
 [out]*ppTabbedControlBar*  
 包含附加作業所產生的索引標籤式的窗格。  
  
### <a name="return-value"></a>傳回值  
 指向目前的窗格，如果不是索引標籤式的窗格;否則附加作業所產生的索引標籤式窗格的指標。 如果無法連接目前的窗格，或發生錯誤時，傳回的值會是 NULL。  
  
### <a name="remarks"></a>備註  
 一個可停駐窗格將附加至使用此方法的另一個窗格中，會發生下列情況：  
  
1.  Framework 檢查是否 [目標] 窗格*pTabControlBarAttachTo*一般停駐窗格，或如果它衍生自[CBaseTabbedPane](../../mfc/reference/cbasetabbedpane-class.md)。  
  
2.  如果目標是索引標籤式的窗格，則架構會將加入其中目前的窗格以索引標籤。  
  
3.  如果 [目標] 窗格的一般停駐窗格時，framework 就會建立索引標籤式的窗格。  
  
    -   這個架構會呼叫`pTabControlBarAttachTo->CreateTabbedPane`。 新的索引標籤式窗格的樣式取決於`m_pTabbedControlBarRTC`成員。 根據預設，這個成員會設定為執行階段類別的[CTabbedPane](../../mfc/reference/ctabbedpane-class.md)。 如果您傳遞做為 AFX_CBRS_OUTLOOK_TABS 樣式*dwTabbedStyle*參數來[CDockablePane::Create](#create)方法，設定執行階段類別物件的執行階段類別[CMFCOutlookBar](../../mfc/reference/cmfcoutlookbar-class.md)。 您可以在任何時間，若要變更新的窗格樣式來變更這個成員。  
  
    -   當這個方法會建立索引標籤式的窗格時，架構會取代指標*pTabControlBarAttachTo* （ 窗格是否停駐或浮動多迷你 視窗中） 與新的索引標籤式窗格的指標。  
  
    -   Framework 中新增*pTabControlBarAttachTo*為第一個索引標籤索引標籤式窗格的窗格。然後，架構會將目前的窗格新增為第二個索引標籤。  
  
4.  如果目前的窗格衍生自`CBaseTabbedPane`，其索引標籤的所有已移至*pTabControlBarAttachTo*和終結目前的窗格。 因此，要特別小心時呼叫這個方法，因為在方法傳回時，目前的窗格的指標可能不正確。  
  
 如果建置停駐的配置時，您可以附加到另一個的其中一個窗格，設定`dockMethod`DM_SHOW 到。  
  
 您將另一個窗格附加到它之前，應停駐的第一個窗格。  
  
##  <a name="calcfixedlayout"></a>  CDockablePane::CalcFixedLayout  
 傳回窗格矩形的大小。  
  
```  
virtual CSize CalcFixedLayout(
    BOOL bStretch,  
    BOOL bHorz);
```  
  
### <a name="parameters"></a>參數  
 [in]*bStretch*  
 未使用。  
  
 [in]*bHorz*  
 未使用。  
  
### <a name="return-value"></a>傳回值  
 A`CSize`物件，其中包含窗格矩形的大小。  
  
##  <a name="canacceptminiframe"></a>  CDockablePane::CanAcceptMiniFrame  
 判斷指定的迷你框架是否可以停駐窗格。  
  
```  
virtual BOOL CanAcceptMiniFrame(CPaneFrameWnd* pMiniFrame) const;  
```  
  
### <a name="parameters"></a>參數  
 [in]*pMiniFrame*  
 指向 `CPaneFrameWnd` 物件的指標。  
  
### <a name="return-value"></a>傳回值  
 則為 TRUE *pMiniFrame*可停駐於窗格中; 否則為 FALSE。  
  
##  <a name="canacceptpane"></a>  CDockablePane::CanAcceptPane  
 判斷另一個窗格是否可以固定到目前的窗格。  
  
```  
virtual BOOL CanAcceptPane(const CBasePane* pBar) const;  
```  
  
### <a name="parameters"></a>參數  
 [in]*pBar*  
 指定目前的窗格停駐窗格。  
  
### <a name="return-value"></a>傳回值  
 如果可以停駐此窗格中，指定的窗格，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 之前的窗格即停駐到目前的窗格，架構會呼叫這個方法。  
  
 若要啟用或停用特定窗格停駐在衍生類別中的此函式會覆寫。  
  
 根據預設，這個方法會傳回 TRUE 如果任一*pBar*或其父代類型`CDockablePane`。  
  
##  <a name="canautohide"></a>  CDockablePane::CanAutoHide  
 決定是否窗格可以自動隱藏。  
  
```  
virtual BOOL CanAutoHide() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果窗格可以自動隱藏則為 TRUE;否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 `CDockablePane::CanAutoHide` 在下列情況下，會傳回 FALSE:  
  
-   窗格就會有沒有父代。  
  
-   停駐的管理員不允許以自動隱藏窗格。  
  
-   未停駐窗格。  
  
##  <a name="canbeattached"></a>  CDockablePane::CanBeAttached  
 判斷目前的窗格是否可以停駐到另一個窗格。  
  
```  
virtual BOOL CanBeAttached() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果可停駐窗格可停駐到另一個窗格或主框架視窗中，則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 根據預設，此方法一律會傳回 TRUE。 若要啟用或停用而不需呼叫停駐在衍生類別中置換此方法[CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking)。  
  
##  <a name="cdockablepane"></a>  CDockablePane::CDockablePane  
 建構並初始化[CDockablePane](../../mfc/reference/cdockablepane-class.md)物件。  
  
```  
CDockablePane();
```  
  
### <a name="remarks"></a>備註  
 建構可停駐窗格物件之後，請呼叫[CDockablePane::Create](#create)或是[cdockablepane:: Createex](#createex)來建立它。  
  
##  <a name="converttotabbeddocument"></a>  CDockablePane::ConvertToTabbedDocument  
 MDI 索引標籤式文件會將一或多個可停駐窗格。  
  
```  
virtual void ConvertToTabbedDocument(BOOL bActiveTabOnly = TRUE);
```  
  
### <a name="parameters"></a>參數  
 [in]*bActiveTabOnly*  
 當您將轉換`CTabbedPane`，指定 TRUE，以轉換是使用索引標籤。指定為 FALSE，則轉換在窗格中的所有索引標籤。  
  
##  <a name="checkautohidecondition"></a>  CDockablePane::CheckAutoHideCondition  
 判斷是否停駐窗格為隱藏狀態 （也稱為自動隱藏模式）。  
  
```  
virtual BOOL CheckAutoHideCondition();
```  
  
### <a name="return-value"></a>傳回值  
 如果隱藏條件符合時，則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 架構會使用計時器定期檢查是否要隱藏自動隱藏可停駐窗格。 不在使用中 窗格，窗格不正在調整大小，和滑鼠指標不是移至窗格上方時，這個方法會傳回 TRUE。  
  
 如果符合所有先前的條件，架構會呼叫[CDockablePane::Slide](#slide)隱藏窗格。  
  
##  <a name="checkstopslidecondition"></a>  CDockablePane::CheckStopSlideCondition  
 決定何時自動隱藏固定窗格應該停止滑動。  
  
```  
virtual BOOL CheckStopSlideCondition(BOOL bDirection);
```  
  
### <a name="parameters"></a>參數  
 [in]*bDirection*  
 如果窗格為可見;，則為 TRUE。如果隱藏的窗格中，則為 FALSE。  
  
### <a name="return-value"></a>傳回值  
 如果符合的停止條件;，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 當可停駐窗格設定為自動隱藏模式時，架構會使用滑動效果以顯示或隱藏窗格。 在滑動窗格時，架構會呼叫此函式。 `CheckStopSlideCondition` 完整可見窗格時，或完全隱藏時，會傳回 TRUE。  
  
 覆寫此方法在衍生類別來實作自訂的自動隱藏效果。  
  
##  <a name="copystate"></a>  CDockablePane::CopyState  
 複製可停駐窗格的狀態。  
  
```  
virtual void CopyState(CDockablePane* pOrgBar);
```  
  
### <a name="parameters"></a>參數  
 [in]*pOrgBar*  
 指標，可停駐窗格。  
  
### <a name="remarks"></a>備註  
 `CDockablePane::CopyState` 將複製的狀態*pOrgBar*到目前的窗格，藉由呼叫下列方法：  
  
- [CPane::CopyState](../../mfc/reference/cpane-class.md#copystate)  
  
- [CDockablePane::GetAHRestoredRect](#getahrestoredrect)  
  
- [CDockablePane::GetAHSlideMode](#getahslidemode)  
  
- [CDockablePane::GetLastPercentInPaneContainer](#getlastpercentinpanecontainer)  
  
- [CDockablePane::IsAutohideAllEnabled](#isautohideallenabled)  
  
##  <a name="create"></a>  CDockablePane::Create  
 建立 Windows 控制項，並將它附加至[CDockablePane](../../mfc/reference/cdockablepane-class.md)物件。  
  
```  
virtual BOOL Create(
    LPCTSTR lpszCaption,  
    CWnd* pParentWnd,  
    const RECT& rect,  
    BOOL bHasGripper,  
    UINT nID,  
    DWORD dwStyle,  
    DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS,  
    DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE,  
    CCreateContext* pContext = NULL);

 
virtual BOOL Create(
    LPCTSTR lpszWindowName,  
    CWnd* pParentWnd,  
    CSize sizeDefault,  
    BOOL bHasGripper,  
    UINT nID,  
    DWORD dwStyle = WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_HIDE_INPLACE,  
    DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS,  
    DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE);
```  
  
### <a name="parameters"></a>參數  
 [in]*lpszCaption*  
 指定視窗名稱。  
  
 [in][out]*pParentWnd*  
 指定父視窗。  
  
 [in]*rect*  
 在用戶端座標中指定的大小和位置 視窗中， *pParentWnd*。  
  
 [in]*bHasGripper*  
 若要建立窗格使用的標題;，則為 TRUE否則為 FALSE。  
  
 [in]*nID*  
 指定的子視窗的識別碼。 此值必須是唯一，如果您想要儲存此停駐窗格的停駐狀態。  
  
 [in]*cheaderctrl:: Create*  
 指定視窗的樣式屬性。  
  
 [in]*dwTabbedStyle*  
 指定使用者在此窗格的標題拖曳窗格時，會建立索引標籤式視窗的索引標籤式的樣式。  
  
 [in]*dwControlBarStyle*  
 指定其他的樣式屬性。  
  
 [in][out]*pContext*  
 指定視窗的建立內容。  
  
 [in]*lpszWindowName*  
 指定視窗名稱。  
  
 [in]*sizeDefault*  
 指定視窗的大小。  
  
### <a name="return-value"></a>傳回值  
 如果已成功建立可停駐窗格;，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 建立 Windows 窗格，並將它附加至`CDockablePane`物件。  
  
 如果*cheaderctrl:: Create*視窗樣式 CBRS_FLOAT_MULTI 旗標，迷你視窗可以浮動迷你框架中的其他窗格。 根據預設，停駐窗格可以只在浮動個別。  
  
 如果*dwTabbedStyle*參數指定 AFX_CBRS_OUTLOOK_TABS 旗標，窗格建立 Outlook 樣式索引標籤式窗格，當另一個窗格附加到這個窗格使用[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法。 根據預設，可停駐窗格建立一般的索引標籤式的窗格的型別[CTabbedPane](../../mfc/reference/ctabbedpane-class.md)。  
  
##  <a name="createdefaultpanedivider"></a>  CDockablePane::CreateDefaultPaneDivider  
 它所停駐在框架視窗將會建立預設分割線的窗格。  
  
```  
static CPaneDivider* __stdcall CreateDefaultPaneDivider(
    DWORD dwAlignment,  
    CWnd* pParent,  
    CRuntimeClass* pSliderRTC = NULL);
```  
  
### <a name="parameters"></a>參數  
 [in]*dwAlignment*  
 指定主要畫面格的正固定窗格的側邊。 如果*dwAlignment*包含了 CBRS_ALIGN_LEFT 或 CBRS_ALIGN_RIGHT 旗標，這個方法會建立垂直 (`CPaneDivider::SS_VERT`) 分隔線; 否則這個方法會建立水平 (`CPaneDivider::SS_HORZ`) 分割線。  
  
 [in]*pParent*  
 父框架指標。  
  
 [in]*pSliderRTC*  
 未使用。  
  
### <a name="return-value"></a>傳回值  
 如果分割線建立失敗，這個方法會傳回指標至新建立的分割線或 NULL。  
  
### <a name="remarks"></a>備註  
 *dwAlignment*可以是下列值之一：  
  
|值|描述|  
|-----------|-----------------|  
|CBRS_ALIGN_TOP|正在加入的框架視窗工作區頂端停駐窗格。|  
|CBRS_ALIGN_BOTTOM|框架視窗的工作區底部所停駐窗格。|  
|CBRS_ALIGN_LEFT|正在工作區框架視窗的左側停駐窗格。|  
|CBRS_ALIGN_RIGHT|要到右邊，框架視窗的工作區的停駐窗格。|  
  
##  <a name="createex"></a>  Cdockablepane:: Createex  
 建立 Windows 控制項，並將它附加至[CDockablePane](../../mfc/reference/cdockablepane-class.md)物件。  
  
```  
virtual BOOL CreateEx(
    DWORD dwStyleEx,  
    LPCTSTR lpszCaption,  
    CWnd* pParentWnd,  
    const RECT& rect,  
    BOOL bHasGripper,  
    UINT nID,  
    DWORD dwStyle,  
    DWORD dwTabbedStyle = AFX_CBRS_REGULAR_TABS,  
    DWORD dwControlBarStyle = AFX_DEFAULT_DOCKING_PANE_STYLE,  
    CCreateContext* pContext = NULL);
```  
  
### <a name="parameters"></a>參數  
 [in]*dwStyleEx*  
 指定新的視窗的延伸的樣式屬性。  
  
 [in]*lpszCaption*  
 指定視窗名稱。  
  
 [in][out]*pParentWnd*  
 指定父視窗。  
  
 [in]*rect*  
 在用戶端座標中指定的大小和位置 視窗中， *pParentWnd*。  
  
 [in]*bHasGripper*  
 若要建立窗格使用的標題;，則為 TRUE否則為 FALSE。  
  
 [in]*nID*  
 指定的子視窗的識別碼。 此值必須是唯一，如果您想要儲存此停駐窗格的停駐狀態。  
  
 [in]*cheaderctrl:: Create*  
 指定視窗的樣式屬性。  
  
 [in]*dwTabbedStyle*  
 指定使用者在此窗格的標題拖曳窗格時，會建立索引標籤式視窗的索引標籤式的樣式。  
  
 [in]*dwControlBarStyle*  
 指定的其他樣式屬性。  
  
 [in][out]*pContext*  
 指定視窗的建立內容。  
  
### <a name="return-value"></a>傳回值  
 如果已成功建立可停駐窗格;，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 建立 Windows 窗格，並將它附加至`CDockablePane`物件。  
  
 如果*cheaderctrl:: Create*視窗樣式 CBRS_FLOAT_MULTI 旗標，迷你視窗可以浮動迷你框架中的其他窗格。 根據預設，停駐窗格可以只在浮動個別。  
  
 如果*dwTabbedStyle*參數指定 AFX_CBRS_OUTLOOK_TABS 旗標，窗格建立 Outlook 樣式索引標籤式窗格，當另一個窗格附加到這個窗格使用[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法。 根據預設，可停駐窗格建立一般的索引標籤式的窗格的型別[CTabbedPane](../../mfc/reference/ctabbedpane-class.md)。  
  
##  <a name="createtabbedpane"></a>  CDockablePane::CreateTabbedPane  
 從目前的窗格中建立索引標籤式的窗格。  
  
```  
virtual CTabbedPane* CreateTabbedPane();
```  
  
### <a name="return-value"></a>傳回值  
 新索引標籤式的窗格中或如果建立作業失敗則為 NULL。  
  
### <a name="remarks"></a>備註  
 建立索引標籤式的窗格來取代此窗格時，架構會呼叫這個方法。 如需詳細資訊，請參閱 < [cdockablepane:: Attachtotabwnd](#attachtotabwnd)。  
  
 覆寫衍生類別來自訂如何索引標籤式的窗格中，這個方法會建立並初始化。  
  
 索引標籤式的窗格根據儲存在執行階段類別資訊建立`m_pTabbedControlBarRTC`成員，初始化[cdockablepane:: Createex](#createex)方法。  
  
##  <a name="dockpanecontainer"></a>  CDockablePane::DockPaneContainer  
 窗格停駐的容器。  
  
```  
virtual BOOL DockPaneContainer(
    CPaneContainerManager& barContainerManager,  
    DWORD dwAlignment,  
    AFX_DOCK_METHOD dockMethod);
```  
  
### <a name="parameters"></a>參數  
 [in]*barContainerManager*  
 正在停駐容器的容器管理員的參考。  
  
 [in]*dwAlignment*  
 指定的容器所停駐的窗格的側邊的 DWORD。  
  
 [in]*dockMethod*  
 未使用。  
  
### <a name="return-value"></a>傳回值  
 如果容器已成功停駐窗格;，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 *dwAlignment*可以是下列值之一：  
  
|值|描述|  
|-----------|-----------------|  
|CBRS_ALIGN_TOP|容器是所停駐窗格的頂端。|  
|CBRS_ALIGN_BOTTOM|窗格的底部所停駐容器。|  
|CBRS_ALIGN_LEFT|正在向左窗格的停駐容器。|  
|CBRS_ALIGN_RIGHT|在右邊窗格的停駐容器。|  
  
##  <a name="dockpanestandard"></a>  CDockablePane::DockPaneStandard  
 使用 外框 （標準） 的停駐停駐窗格。  
  
```  
virtual CPane* DockPaneStandard(BOOL& bWasDocked);
```  
  
### <a name="parameters"></a>參數  
 [in]*bWasDocked*  
 方法傳回時，這個值為 true，則包含若窗格已成功停駐;否則，它會為 FALSE。  
  
### <a name="return-value"></a>傳回值  
 如果窗格已停駐索引標籤式視窗中，或如果已建立索引標籤式的視窗停駐，則這個方法會傳回指標至索引標籤式視窗。 如果窗格卻已成功停駐，則這個方法會傳回**這**指標。 如果停駐失敗，則這個方法會傳回 NULL。  
  
##  <a name="docktorecentpos"></a>  CDockablePane::DockToRecentPos  
 窗格停駐於其預存的停駐位置。  
  
```  
BOOL CDockablePane::DockToRecentPos();
```  
  
### <a name="return-value"></a>傳回值  
 如果已成功停駐窗格;，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 可停駐窗格最近停駐資訊儲存在[CRecentDockSiteInfo](../../mfc/reference/crecentdocksiteinfo-class.md)物件。  
  
##  <a name="docktowindow"></a>  CDockablePane::DockToWindow  
 一個停駐窗格停駐於停駐的另一個窗格。  
  
```  
virtual BOOL DockToWindow(
    CDockablePane* pTargetWindow,  
    DWORD dwAlignment,  
    LPCRECT lpRect = NULL);
```  
  
### <a name="parameters"></a>參數  
 [in][out]*pTargetWindow*  
 指定停駐此窗格可停駐窗格。  
  
 [in]*dwAlignment*  
 指定 [] 窗格的停駐對齊方式。 可能是 CBRS_ALIGN_LEFT、 CBRS_ALIGN_TOP、 CBRS_ALIGN_RIGHT、 CBRS_ALIGN_BOTTOM 或 CBRS_ALIGN_ANY 之一。 （在 afxres.h 中定義。）  
  
 [in]*lpRect*  
 指定停駐窗格的矩形。  
  
### <a name="return-value"></a>傳回值  
 如果已順利停駐窗格，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 呼叫這個方法來將一個窗格停駐到另一個窗格所指定的對齊*dwAlignment*。  
  
##  <a name="drawcaption"></a>  CDockablePane::DrawCaption  
 繪製標題的停駐窗格 （也稱為 「 移駐夾 」）。  
  
```  
virtual void DrawCaption(
    CDC* pDC,  
    CRect rectCaption);
```  
  
### <a name="parameters"></a>參數  
 [in]*pDC*  
 表示用於繪製的裝置內容。  
  
 [in]*rectCaption*  
 指定的週框的窗格的標題。  
  
### <a name="remarks"></a>備註  
 架構會呼叫這個方法，以繪製可停駐窗格的標題。  
  
 覆寫此方法在衍生類別來自訂標題的外觀。  
  
##  <a name="enableautohideall"></a>  CDockablePane::EnableAutohideAll  
 啟用或停用自動隱藏模式，針對此窗格和其他容器中的窗格。  
  
```  
void EnableAutohideAll(BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>參數  
 [in]*bEnable*  
 TRUE 表示啟用自動隱藏可停駐窗格; 的所有功能否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 當使用者保留**Ctrl**金鑰，並按一下 釘選 按鈕，切換到 自動隱藏模式中，相同的容器中的所有其他窗格的窗格也會切換為自動隱藏模式。  
  
 呼叫這個方法時*bEnable*設定為 FALSE 以停用此功能適用於特定的窗格。  
  
##  <a name="enablegripper"></a>  CDockablePane::EnableGripper  
 顯示或隱藏標題 （也稱為 「 移駐夾 」）。  
  
```  
virtual void EnableGripper(BOOL bEnable);
```  
  
### <a name="parameters"></a>參數  
 [in]*bEnable*  
 若要啟用標題;，則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 當架構建立可停駐窗格時，它們並沒有 WS_STYLE 視窗樣式，即使指定。 這表示窗格的標題是由 framework，控制非工作區，但這方面不同於標準的視窗標題。  
  
 您可以顯示或隱藏標題在任何時間。 為索引標籤式視窗或窗格浮動迷你框架中，將會加入為一個索引標籤的窗格時，framework 就會隱藏標題。  
  
##  <a name="getahrestoredrect"></a>  CDockablePane::GetAHRestoredRect  
 指定在自動隱藏模式中窗格的位置。  
  
```  
CRect GetAHRestoredRect() const;  
```  
  
### <a name="return-value"></a>傳回值  
 A`CRect`包含窗格的位置，在 自動隱藏模式時的物件。  
  
### <a name="remarks"></a>備註  
  
##  <a name="getahslidemode"></a>  CDockablePane::GetAHSlideMode  
 擷取窗格的 自動隱藏投影片模式。  
  
```  
virtual UINT GetAHSlideMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 單位，指定  窗格的 自動隱藏投影片模式。 傳回值可以是 AFX_AHSM_MOVE 或 AFX_AHSM_STRETCH，但實作只會使用 AFX_AHSM_MOVE。  
  
### <a name="remarks"></a>備註  
  
##  <a name="getcaptionheight"></a>  CDockablePane::GetCaptionHeight  
 傳回高度，單位為像素的目前的標題。  
  
```  
virtual int GetCaptionHeight() const;  
```  
  
### <a name="return-value"></a>傳回值  
 標題，單位為像素的高度。  
  
### <a name="remarks"></a>備註  
 標題高度為 0，如果已隱藏標題[CDockablePane::EnableGripper](#enablegripper)方法，或如果窗格沒有標題。  
  
##  <a name="getdefaultpanedivider"></a>  CDockablePane::GetDefaultPaneDivider  
 傳回預設值 窗格分割線，窗格的容器。  
  
```  
CPaneDivider* GetDefaultPaneDivider() const;  
```  
  
### <a name="return-value"></a>傳回值  
 有效[CPaneDivider](../../mfc/reference/cpanedivider-class.md)物件，如果可停駐窗格停駐於主框架視窗中，或`NULL`如果可停駐窗格未停駐或浮動。  
  
### <a name="remarks"></a>備註  
 如需詳細資訊窗格分割線的詳細資訊，請參閱[CPaneDivider 類別](../../mfc/reference/cpanedivider-class.md)。  
  
##  <a name="getdockingstatus"></a>  CDockablePane::GetDockingStatus  
 判斷提供的指標位置為基礎的停駐窗格的能力。  
  
```  
virtual AFX_CS_STATUS GetDockingStatus(
    CPoint pt,  
    int nSensitivity);
```  
  
### <a name="parameters"></a>參數  
 [in]*pt*  
 螢幕座標中指標的位置。  
  
 [in]*nSensitivity*  
 距離，單位為像素矩形的邊緣與指標必須在啟用停駐。  
  
### <a name="return-value"></a>傳回值  
 其中一個下列的狀態值：  
  
|AFX_CS_STATUS 值|意義|  
|---------------------------|-------------|  
|CS_NOTHING|指標不是透過與停駐位置。 此架構不會不停駐窗格。|  
|CS_DOCK_IMMEDIATELY|滑鼠指標位於移轉停駐網站 （[] 窗格中會使用 DT_IMMEDIATE 停駐模式） 的即時模式中。 此架構會立即固定窗格。|  
|CS_DELAY_DOCK|指標是透過與另一個停駐窗格或主要畫面格的一個邊緣的停駐位置。 此架構會在延遲之後固定窗格。 請參閱 < 備註 > 一節，如需有關此延遲。|  
|CS_DELAY_DOCK_TO_TAB|滑鼠指標位於移轉時，要在索引標籤式視窗停駐窗格會停駐網站。 會發生這種情況是當滑鼠指標位於，透過標題的停駐的另一個窗格或索引標籤式窗格的索引標籤區域。|  
  
### <a name="remarks"></a>備註  
 架構會呼叫此方法以處理停駐浮動窗格。  
  
 浮動工具列或固定使用 DT_IMMEDIATE 停駐模式的窗格，架構會延遲停駐命令，以讓使用者將視窗移出父框架工作區，停駐發生之前。 延遲的時間長度以毫秒為單位，並且受到[CDockingManager::m_nTimeOutBeforeToolBarDock](../../mfc/reference/cdockingmanager-class.md#m_ntimeoutbeforetoolbardock)資料成員... 預設值[CDockingManager::m_nTimeOutBeforeToolBarDock](../../mfc/reference/cdockingmanager-class.md#m_ntimeoutbeforetoolbardock)為 200。 此行為是模擬的停駐行為[!INCLUDE[ofprword](../../mfc/reference/includes/ofprword_md.md)]2007年。  
  
 延遲停駐狀態 （CS_DELAY_DOCK 和 CS_DELAY_DOCK_TO_TAB），此架構不會執行停駐，直到使用者放開滑鼠按鈕。 如果窗格使用 DT_STANDARD 固定模式，架構會顯示在預計的停駐位置的矩形。 如果窗格使用 DT_SMART 固定模式，架構，則會顯示智慧停駐標記與半透明矩形在預計的停駐位置。 若要指定您窗格停駐模式，請呼叫[CBasePane::SetDockingMode](../../mfc/reference/cbasepane-class.md#setdockingmode)方法。 如需智慧停駐的詳細資訊，請參閱[CDockingManager::GetSmartDockingParams](../../mfc/reference/cdockingmanager-class.md#getsmartdockingparams)。  
  
##  <a name="getdragsensitivity"></a>  CDockablePane::GetDragSensitivity  
 傳回停駐窗格拖曳機密性。  
  
```  
static const CSize& GetDragSensitivity();
```  
  
### <a name="return-value"></a>傳回值  
 A [CSize](../../atl-mfc-shared/reference/csize-class.md)物件，其中包含的寬度和高度，單位為像素矩形拖曳點上置中。 不會開始拖曳作業，直到滑鼠指標移動此矩形的外面。  
  
##  <a name="getlastpercentinpanecontainer"></a>  CDockablePane::GetLastPercentInPaneContainer  
 擷取在其容器中的窗格中所佔的空間百分比 ( [CPaneContainer 類別](../../mfc/reference/cpanecontainer-class.md))。  
  
```  
int GetLastPercentInPaneContainer() const;  
```  
  
### <a name="return-value"></a>傳回值  
 *Int* ，指定在其容器中的窗格中所佔的空間百分比。  
  
### <a name="remarks"></a>備註  
 容器調整其版面配置時，會使用這個方法。  
  
##  <a name="gettabarea"></a>  CDockablePane::GetTabArea  
 擷取窗格 索引標籤區域。  
  
```  
virtual void GetTabArea(
    CRect& rectTabAreaTop,  
    CRect& rectTabAreaBottom) const;  
```  
  
### <a name="parameters"></a>參數  
 [in]*rectTabAreaTop*  
 `GetTabArea` 如果索引標籤位於頂端的窗格，請使用索引標籤區域填入此變數。 如果索引標籤底端的窗格中，此變數會填入空的矩形中。  
  
 [in]*rectTabAreaBottom*  
 `GetTabArea` 如果索引標籤會位於底部窗格，請使用索引標籤區域填入此變數。 如果索引標籤頂端的窗格中，此變數會填入空的矩形中。  
  
### <a name="remarks"></a>備註  
 這個方法只適用於類別衍生自`CDockablePane`和有索引標籤。 如需詳細資訊，請參閱 < [CTabbedPane::GetTabArea](../../mfc/reference/ctabbedpane-class.md#gettabarea)並[CMFCOutlookBar::GetTabArea](../../mfc/reference/cmfcoutlookbar-class.md#gettabarea)。  
  
##  <a name="gettabbedpanertc"></a>  CDockablePane::GetTabbedPaneRTC  
 傳回目前的窗格停駐於另一個窗格時，會建立索引標籤式視窗的執行階段類別資訊。  
  
```  
CRuntimeClass* GetTabbedPaneRTC() const;  
```  
  
### <a name="return-value"></a>傳回值  
 可停駐窗格執行階段類別資訊。  
  
### <a name="remarks"></a>備註  
 呼叫這個方法來擷取索引標籤式窗格，以動態方式建立的執行階段類別資訊。 這可能是當使用者將一個窗格拖曳至標題的另一個窗格中，或如果您呼叫[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法用來以程式設計方式建立索引標籤式的窗格，從兩個可停駐窗格。  
  
 您可以設定執行階段類別資訊，藉由呼叫[cdockablepane:: Settabbedpanertc](#settabbedpanertc)方法。  
  
##  <a name="hasautohidemode"></a>  CDockablePane::HasAutoHideMode  
 指定是否可以停駐窗格切換為自動隱藏模式。  
  
```  
virtual BOOL HasAutoHideMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果可停駐窗格可以切換為 自動隱藏模式，則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 若要停用特定的可停駐窗格的 自動隱藏模式在衍生類別中，這個方法會覆寫。  
  
##  <a name="hittest"></a>  CDockablePane::HitTest  
 在使用者按一下滑鼠的位置 窗格中指定的位置。  
  
```  
virtual int HitTest(
    CPoint point,  
    BOOL bDetectCaption = FALSE);
```  
  
### <a name="parameters"></a>參數  
 [in]*點*  
 指定要測試的點。  
  
 [in]*bDetectCaption*  
 如果應傳回 HTCAPTION 點位在窗格的標題，則為 TRUE否則為 FALSE。  
  
### <a name="return-value"></a>傳回值  
 下列其中一個值：  
  
- HTNOWHERE 如果*點*不在可停駐窗格。  
  
- HTCLIENT 如果*點*可停駐窗格的工作區中。  
  
- HTCAPTION 如果*點*可停駐窗格的標題區域中。  
  
- AFX_HTCLOSE 如果*點*位於 [關閉] 按鈕。  
  
- HTMAXBUTTON 如果*點*釘選按鈕上。  
  
##  <a name="isautohideallenabled"></a>  CDockablePane::IsAutohideAllEnabled  
 指出是否停駐窗格和容器中的所有其他窗格可以切換為自動隱藏模式。  
  
```  
virtual BOOL IsAutohideAllEnabled() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果可停駐窗格中，並在容器中，所有其他窗格可以切換為 自動隱藏模式，則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 使用者會啟用自動隱藏模式時保存停駐的 [釘選] 按鈕，即可**Ctrl**金鑰  
  
 若要啟用或停用此行為，請呼叫[CDockablePane::EnableAutohideAll](#enableautohideall)方法。  
  
##  <a name="isautohidemode"></a>  CDockablePane::IsAutoHideMode  
 判斷一個窗格是否處於自動隱藏模式。  
  
```  
virtual BOOL IsAutoHideMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 自動隱藏模式，可停駐窗格時，則為 TRUE。否則為 FALSE。  
  
##  <a name="isdocked"></a>  CDockablePane::IsDocked  
 判斷目前的窗格是否停駐。  
  
```  
virtual BOOL IsDocked() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果可停駐窗格不屬於迷你框架，或是浮動迷你框架與另一個窗格中，則為 TRUE。 如果窗格迷你視窗的子系，而且沒有任何屬於迷你框架的其他窗格中，則為 FALSE。  
  
### <a name="remarks"></a>備註  
 若要判斷是否停駐於主框架視窗的窗格，請呼叫[CDockablePane::GetDefaultPaneDivider](#getdefaultpanedivider)。 如果此方法會傳回非 NULL 指標，會窗格停駐於主框架視窗。  
  
##  <a name="ishideinautohidemode"></a>  CDockablePane::IsHideInAutoHideMode  
 決定的窗格是自動隱藏模式中，如果它是顯示 （或隱藏） 藉由呼叫行為[CDockablePane::ShowPane](#showpane)。  
  
```  
virtual BOOL IsHideInAutoHideMode() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果應該隱藏可停駐窗格，在 自動隱藏模式，則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 在 自動隱藏模式中可停駐窗格時，它的行為方式當您呼叫`ShowPane`隱藏或顯示的窗格。 此行為受到靜態成員[CDockablePane::m_bHideInAutoHideMode](#m_bhideinautohidemode)。 如果這個成員是 TRUE，可停駐窗格和其相關的自動隱藏工具列，或自動隱藏 按鈕會隱藏或顯示當您呼叫`ShowPane`。 否則，可停駐窗格啟用或停用，而且其相關的自動隱藏工具列或 [自動隱藏] 按鈕一律會顯示。  
  
 若要變更個別窗格的預設行為的衍生類別中，這個方法會覆寫。  
  
 預設值為`m_bHideInAutoHideMode`為 FALSE。  
  
##  <a name="isinfloatingmultipaneframewnd"></a>  CDockablePane::IsInFloatingMultiPaneFrameWnd  
 指定是否在多窗格框架視窗窗格 ( [CMultiPaneFrameWnd 類別](../../mfc/reference/cmultipaneframewnd-class.md))。  
  
```  
virtual BOOL IsInFloatingMultiPaneFrameWnd() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果窗格為多窗格框架視窗; 中，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
  
##  <a name="isresizable"></a>  CDockablePane::IsResizable  
 指定是否可調整大小的窗格。  
  
```  
virtual BOOL IsResizable() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果窗格為可調整大小;，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 根據預設，可停駐窗格是可調整大小。 若要避免重新調整大小，在衍生類別中置換此方法，並傳回 FALSE。 請注意，則為 FALSE 的值會導致容錯**ASSERT**中[CPane::DockPane](../../mfc/reference/cpane-class.md#dockpane)。 使用[CDockingManager::AddPane](../../mfc/reference/cdockingmanager-class.md#addpane)改為停駐在父範圍內的窗格。  
  
 無法調整大小的窗格可以兩者皆非浮動，也不進入自動隱藏模式，並會一律位於父框架的外部邊緣。  
  
##  <a name="istablocationbottom"></a>  CDockablePane::IsTabLocationBottom  
 指定是否位在頂端或底部窗格的索引標籤。  
  
```  
virtual BOOL IsTabLocationBottom() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果索引標籤會位於底部窗格中，則為 TRUE如果索引標籤位於頂端的窗格中，則為 FALSE。  
  
### <a name="remarks"></a>備註  
 如需詳細資訊，請參閱 < [CTabbedPane::IsTabLocationBottom](../../mfc/reference/ctabbedpane-class.md#istablocationbottom)。  
  
##  <a name="istracked"></a>  CDockablePane::IsTracked  
 指定使用者是否正在移動的窗格。  
  
```  
BOOL IsTracked() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果正在移動窗格;，則為 TRUE。否則為 FALSE。  
  
##  <a name="isvisible"></a>  CDockablePane::IsVisible  
 判斷目前的窗格是否可見。  
  
```  
virtual BOOL IsVisible() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果可停駐窗格是可見的則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 呼叫此方法，以判斷可停駐窗格是否可見。 您可以使用這個方法，而不是呼叫[CWnd::IsWindowVisible](../../mfc/reference/cwnd-class.md#iswindowvisible)或 WS_VISIBLE 樣式測試。 傳回的可見性狀態取決於是否啟用或停用自動隱藏模式和值[CDockablePane::IsHideInAutoHideMode](#ishideinautohidemode)屬性。  
  
 如果可停駐窗格處於自動隱藏模式和`IsHideInAutoHideMode`傳回 FALSE 的可見性狀態永遠是 FALSE。  
  
 如果可停駐窗格處於自動隱藏模式和`IsHideInAutoHideMode`傳回 TRUE 的可見性狀態取決於最相關的自動隱藏工具列的可見性狀態。  
  
 如果可停駐窗格不是處於自動隱藏模式中，有的可見性狀態會由[CBasePane::IsVisible](../../mfc/reference/cbasepane-class.md#isvisible)方法。  
  
##  <a name="m_bdisableanimation"></a>  CDockablePane::m_bDisableAnimation  
 指定是否要停用自動隱藏可停駐窗格的動畫。  
  
```  
AFX_IMPORT_DATA static BOOL m_bDisableAnimation;  
```  
  
##  <a name="m_bhideinautohidemode"></a>  CDockablePane::m_bHideInAutoHideMode  
 [] 窗格處於自動隱藏模式時，請決定窗格的行為。  
  
```  
AFX_IMPORT_DATA static BOOL m_bHideInAutoHideMode;  
```  
  
### <a name="remarks"></a>備註  
 這個值會影響應用程式中的所有停駐窗格。  
  
 如果您將這個成員設定為 TRUE，可停駐窗格為隱藏或顯示其相關的自動隱藏工具列和按鈕，當您呼叫[CDockablePane::ShowPane](#showpane)。  
  
 如果您將這個成員設定為 FALSE，可停駐窗格會啟用或停用當您呼叫[CDockablePane::ShowPane](#showpane)。  
  
##  <a name="m_nslidesteps"></a>  CDockablePane::m_nSlideSteps  
 在 自動隱藏模式中時，請指定動畫速度的窗格。  
  
```  
AFX_IMPORT_DATA static int m_nSlideSteps;  
```  
  
### <a name="remarks"></a>備註  
 如需更快的動畫效果，請降低此值。 如需較慢的動畫效果，增加此值。  
  
##  <a name="onafterchangeparent"></a>  CDockablePane::OnAfterChangeParent  
 [!INCLUDE[cpp_fp_under_construction](../../mfc/reference/includes/cpp_fp_under_construction_md.md)]  
  
```  
virtual void OnAfterChangeParent(CWnd* pWndOldParent);
```  
  
### <a name="parameters"></a>參數  
 [in]*pWndOldParent*  
  
### <a name="remarks"></a>備註  
  
##  <a name="onafterdockfromminiframe"></a>  CDockablePane::OnAfterDockFromMiniFrame  
 在框架視窗停駐浮動的停駐列時，由架構呼叫。  
  
```  
virtual void OnAfterDockFromMiniFrame();
```  
  
### <a name="remarks"></a>備註  
 根據預設，這個方法沒有任何作用。  
  
##  <a name="onbeforechangeparent"></a>  CDockablePane::OnBeforeChangeParent  
 架構會呼叫這個方法，然後才會變更窗格的父代。  
  
```  
virtual void OnBeforeChangeParent(
    CWnd* pWndNewParent,  
    BOOL bDelay = FALSE);
```  
  
### <a name="parameters"></a>參數  
 [in]*pWndNewParent*  
 新的父視窗的指標。  
  
 [in]*bDelay*  
 布林，指定是否要延遲的停駐的配置重新計算，如果未停駐窗格。 如需詳細資訊，請參閱 < [CDockablePane::UndockPane](#undockpane)。  
  
### <a name="remarks"></a>備註  
 如果停駐窗格的新父系不允許停駐，這個方法可以卸除的窗格。  
  
 如果窗格正在轉換為索引標籤式文件時，這個方法會儲存其最近停駐位置。 架構會使用最新的停駐位置時則會轉換回停駐狀態還原窗格的位置。  
  
##  <a name="onbeforefloat"></a>  CDockablePane::OnBeforeFloat  
 Framework 之前呼叫這個方法窗格轉換為浮點狀態。  
  
```  
virtual BOOL OnBeforeFloat(
    CRect& rectFloat,  
    AFX_DOCK_METHOD dockMethod);
```  
  
### <a name="parameters"></a>參數  
 [in]*rectFloat*  
 處於浮動狀態時，指定的位置和大小的窗格。  
  
 [in]*dockMethod*  
 指定的停駐的方法。 請參閱[CPane::DockPane](../../mfc/reference/cpane-class.md#dockpane)取得一份可能的值。  
  
### <a name="return-value"></a>傳回值  
 如果可以浮動窗格;，則為 TRUE。否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 窗格即將浮點數時，這個方法是由架構呼叫。 如果您想要執行任何處理，才能窗格浮動，您可以覆寫這個方法在衍生類別中。  
  
##  <a name="onpressbuttons"></a>  CDockablePane::OnPressButtons  
 當使用者按下標題按鈕而非 AFX_HTCLOSE 和 AFX_HTMAXBUTTON 按鈕時呼叫。  
  
```  
virtual void OnPressButtons(UINT nHit);
```  
  
### <a name="parameters"></a>參數  
 [in]*nHit*  
 不使用這個參數。  
  
### <a name="remarks"></a>備註  
 如果您的自訂按鈕加入可停駐窗格的標題，請覆寫這個方法，以接收通知，當使用者按下按鈕時。  
  
##  <a name="onslide"></a>  CDockablePane::OnSlide  
 由架構呼叫以動畫顯示的窗格中，以自動隱藏模式時。  
  
```  
virtual void OnSlide(BOOL bSlideOut);
```  
  
### <a name="parameters"></a>參數  
 [in]*bSlideOut*  
 True 表示要顯示的窗格中;如果為 false，則隱藏窗格。  
  
### <a name="remarks"></a>備註  
 覆寫此方法在衍生類別來實作自訂的自動隱藏效果。  
  
##  <a name="removefromdefaultpanedividier"></a>  為 Cdockablepane  
 當窗格能卸除時，架構會呼叫這個方法。  
  
```  
void RemoveFromDefaultPaneDividier();
```  
  
### <a name="remarks"></a>備註  
 這個方法會設定為 NULL 的預設值 窗格分割線，並從其容器中移除窗格。  
  
##  <a name="replacepane"></a>  CDockablePane::ReplacePane  
 取代指定的窗格中的窗格。  
  
```  
BOOL ReplacePane(
    CDockablePane* pBarToReplaceWith,  
    AFX_DOCK_METHOD dockMethod,  
    BOOL bRegisterWithFrame = FALSE);
```  
  
### <a name="parameters"></a>參數  
 [in]*pBarToReplaceWith*  
 指標，可停駐窗格。  
  
 [in]*dockMethod*  
 未使用。  
  
 [in]*bRegisterWithFrame*  
 如果為 TRUE，新的窗格會向父代的舊窗格停駐的管理員。 舊的窗格，窗格停駐的管理員所維護的清單中的索引處插入新的窗格。  
  
### <a name="return-value"></a>傳回值  
 如果取代成功，則為 TRUE否則為 FALSE。  
  
##  <a name="restoredefaultpanedivider"></a>  CDockablePane::RestoreDefaultPaneDivider  
 當還原序列化的窗格時，架構會呼叫這個方法，以還原預設的窗格分割線。  
  
```  
void RestoreDefaultPaneDivider();
```  
  
### <a name="remarks"></a>備註  
 還原的預設的窗格分割線會取代目前的預設值 窗格分割線，若有的話。  
  
##  <a name="setautohidemode"></a>  CDockablePane::SetAutoHideMode  
 切換之間顯示停駐窗格和 自動隱藏模式。  
  
```  
virtual CMFCAutoHideBar* SetAutoHideMode(
    BOOL bMode,  
    DWORD dwAlignment,  
    CMFCAutoHideBar* pCurrAutoHideBar = NULL,  
    BOOL bUseTimer = TRUE);
```  
  
### <a name="parameters"></a>參數  
 [in]*bMode*  
 TRUE 表示啟用自動隱藏模式;若要啟用一般停駐的模式，則為 FALSE。  
  
 [in]*dwAlignment*  
 指定要建立的 [自動隱藏] 窗格的對齊方式。  
  
 [in][out]*pCurrAutoHideBar*  
 在目前的自動隱藏工具列的指標。 可以是 NULL。  
  
 [in]*bUseTimer*  
 指定要使用的自動隱藏 」 效果，當使用者將窗格切換為自動隱藏模式還是要立即隱藏窗格。  
  
### <a name="return-value"></a>傳回值  
 自動隱藏工具列切換到 自動隱藏模式中，則為 NULL 的結果所建立。  
  
### <a name="remarks"></a>備註  
 當使用者按一下釘選按鈕，切換為自動隱藏模式或一般停駐模式的可停駐窗格時，架構會呼叫這個方法。  
  
 呼叫這個方法來以程式設計方式將可停駐窗格切換為自動隱藏模式。 必須停駐窗格中，於主框架視窗 ( [CDockablePane::GetDefaultPaneDivider](#getdefaultpanedivider)必須傳回的有效指標[CPaneDivider](../../mfc/reference/cpanedivider-class.md))。  
  
##  <a name="setautohideparents"></a>  CDockablePane::SetAutoHideParents  
 設定自動隱藏按鈕和 [] 窗格中的自動隱藏工具列。  
  
```  
void SetAutoHideParents(
    CMFCAutoHideBar* pToolBar,  
    CMFCAutoHideButton* pBtn);
```  
  
### <a name="parameters"></a>參數  
 [in]*pToolBar*  
 自動隱藏工具列的指標。  
  
 [in]*pBtn*  
 自動隱藏按鈕的指標。  
  
##  <a name="setlastpercentinpanecontainer"></a>  CDockablePane::SetLastPercentInPaneContainer  
 設定 窗格，則在其容器中所佔的空間百分比。  
  
```  
void SetLastPercentInPaneContainer(int n);
```  
  
### <a name="parameters"></a>參數  
 [in]*n*  
 **Int** ，指定在其容器中的窗格中所佔的空間百分比。  
  
### <a name="remarks"></a>備註  
 架構會調整版面配置時，使用新值 窗格。  
  
##  <a name="setrestoreddefaultpanedivider"></a>  CDockablePane::SetRestoredDefaultPaneDivider  
 設定還原的預設的窗格分割線。  
  
```  
void SetRestoredDefaultPaneDivider(HWND hRestoredSlider);
```  
  
### <a name="parameters"></a>參數  
 [in]*hRestoredSlider*  
 窗格分割線 （滑桿） 控制代碼。  
  
### <a name="remarks"></a>備註  
 還原序列化的窗格時，會取得還原的預設的窗格分割線。 如需詳細資訊，請參閱 < [CDockablePane::RestoreDefaultPaneDivider](#restoredefaultpanedivider)。  
  
##  <a name="settabbedpanertc"></a>  Cdockablepane:: Settabbedpanertc  
 設定兩個窗格停駐在一起時，會建立索引標籤式視窗的執行階段類別資訊。  
  
```  
void SetTabbedPaneRTC(CRuntimeClass* pRTC);
```  
  
### <a name="parameters"></a>參數  
 [in]*pRTC*  
 索引標籤式窗格執行階段類別資訊。  
  
### <a name="remarks"></a>備註  
 呼叫這個方法來設定索引標籤式窗格，以動態方式建立的執行階段類別資訊。 這可能是當使用者將一個窗格拖曳至標題的另一個窗格中，或如果您呼叫[cdockablepane:: Attachtotabwnd](#attachtotabwnd)方法用來以程式設計方式建立索引標籤式的窗格，從兩個可停駐窗格。  
  
 根據設定的預設執行階段類別*dwTabbedStyle*的參數[CDockablePane::Create](#create)並[cdockablepane:: Createex](#createex)。 若要自訂新的索引標籤式的窗格，請從其中一個下列類別衍生您的類別：  
  
- [CBaseTabbedPane 類別](../../mfc/reference/cbasetabbedpane-class.md)  
  
- [CTabbedPane 類別](../../mfc/reference/ctabbedpane-class.md)  
  
- [CMFCOutlookBar 類別](../../mfc/reference/cmfcoutlookbar-class.md)。  
  
 然後，呼叫這個方法時對其執行階段類別資訊指標。  
  
##  <a name="showpane"></a>  CDockablePane::ShowPane  
 顯示或隱藏窗格。  
  
```  
virtual void ShowPane(
    BOOL bShow,  
    BOOL bDelay,  
    BOOL bActivate);
```  
  
### <a name="parameters"></a>參數  
 [in]*bShow*  
 True 表示要顯示的窗格中;如果為 false，則隱藏窗格。  
  
 [in]*bDelay*  
 True 會延遲調整停駐的版面配置。立即調整停駐的配置，則為 FALSE。  
  
 [in]*bActivate*  
 若要啟用的窗格顯示; 時，則為 TRUE否則為 FALSE。  
  
### <a name="remarks"></a>備註  
 呼叫此方法，而非[CWnd::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)顯示或隱藏可停駐窗格時。  
  
##  <a name="slide"></a>  CDockablePane::Slide  
 以動畫顯示自動隱藏模式中的窗格。  
  
```  
virtual void Slide(
    BOOL bSlideOut,  
    BOOL bUseTimer = TRUE);
```  
  
### <a name="parameters"></a>參數  
 [in]*bSlideOut*  
 True 表示要顯示的窗格中;如果為 false，則隱藏窗格。  
  
 [in]*bUseTimer*  
 若要顯示或隱藏窗格中的，使用 [自動隱藏] 效果;，則為 TRUE若要顯示或隱藏窗格立即，則為 FALSE。  
  
### <a name="remarks"></a>備註  
 架構會呼叫這個方法，以動畫顯示自動隱藏模式中的窗格。  
  
 這個方法會使用`CDockablePane::m_nSlideDefaultTimeOut`值，以判斷的投影片效果逾時。 逾時的預設值為 1。 如果您自訂的自動隱藏 」 演算法，修改這個成員，才能變更逾時。  
  
##  <a name="toggleautohide"></a>  CDockablePane::ToggleAutoHide  
 切換 顯示的 之間一律窗格 和 自動隱藏模式。  
  
```  
virtual void ToggleAutoHide();
```  
  
### <a name="remarks"></a>備註  
 這個方法會切換窗格的 自動隱藏模式藉由呼叫[CDockablePane::SetAutoHideMode](#setautohidemode)。  
  
##  <a name="undockpane"></a>  CDockablePane::UndockPane  
 從主框架視窗或迷你視窗容器窗格可以卸除。  
  
```  
virtual void UndockPane(BOOL bDelay = FALSE);
```  
  
### <a name="parameters"></a>參數  
 [in]*bDelay*  
 True 會延遲計算停駐的版面配置。若要立即重新計算停駐的配置，則為 FALSE。  
  
### <a name="remarks"></a>備註  
 呼叫這個方法來取消停駐窗格的主框架視窗或從多個迷你視窗容器 （在單一迷你視窗，內含其他窗格浮動窗格）。  
  
 您必須取消停駐窗格執行不由執行的任何外部作業之前，先[CDockingManager](../../mfc/reference/cdockingmanager-class.md)。 例如，您必須卸除它以程式設計方式從一個位置移到另一個窗格。  
  
 架構會自動取消停駐這些窗格之前終結。  
  
## <a name="see-also"></a>另請參閱  
 [階層架構圖表](../../mfc/hierarchy-chart.md)   
 [類別](../../mfc/reference/mfc-classes.md)   
 [CPane 類別](../../mfc/reference/cpane-class.md)
