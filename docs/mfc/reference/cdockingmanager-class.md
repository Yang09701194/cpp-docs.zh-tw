---
title: CDockingManager 類別
ms.date: 11/04/2016
f1_keywords:
- CDockingManager
- AFXDOCKINGMANAGER/CDockingManager
- AFXDOCKINGMANAGER/CDockingManager::AddDockSite
- AFXDOCKINGMANAGER/CDockingManager::AddHiddenMDITabbedBar
- AFXDOCKINGMANAGER/CDockingManager::AddMiniFrame
- AFXDOCKINGMANAGER/CDockingManager::AddPane
- AFXDOCKINGMANAGER/CDockingManager::AdjustDockingLayout
- AFXDOCKINGMANAGER/CDockingManager::AdjustPaneFrames
- AFXDOCKINGMANAGER/CDockingManager::AdjustRectToClientArea
- AFXDOCKINGMANAGER/CDockingManager::AlignAutoHidePane
- AFXDOCKINGMANAGER/CDockingManager::AutoHidePane
- AFXDOCKINGMANAGER/CDockingManager::BringBarsToTop
- AFXDOCKINGMANAGER/CDockingManager::BuildPanesMenu
- AFXDOCKINGMANAGER/CDockingManager::CalcExpectedDockedRect
- AFXDOCKINGMANAGER/CDockingManager::Create
- AFXDOCKINGMANAGER/CDockingManager::DeterminePaneAndStatus
- AFXDOCKINGMANAGER/CDockingManager::DisableRestoreDockState
- AFXDOCKINGMANAGER/CDockingManager::DockPane
- AFXDOCKINGMANAGER/CDockingManager::DockPaneLeftOf
- AFXDOCKINGMANAGER/CDockingManager::EnableAutoHidePanes
- AFXDOCKINGMANAGER/CDockingManager::EnableDocking
- AFXDOCKINGMANAGER/CDockingManager::EnableDockSiteMenu
- AFXDOCKINGMANAGER/CDockingManager::EnablePaneContextMenu
- AFXDOCKINGMANAGER/CDockingManager::FindDockSite
- AFXDOCKINGMANAGER/CDockingManager::FindDockSiteByPane
- AFXDOCKINGMANAGER/CDockingManager::FindPaneByID
- AFXDOCKINGMANAGER/CDockingManager::FixupVirtualRects
- AFXDOCKINGMANAGER/CDockingManager::FrameFromPoint
- AFXDOCKINGMANAGER/CDockingManager::GetClientAreaBounds
- AFXDOCKINGMANAGER/CDockingManager::GetDockingMode
- AFXDOCKINGMANAGER/CDockingManager::GetDockSiteFrameWnd
- AFXDOCKINGMANAGER/CDockingManager::GetEnabledAutoHideAlignment
- AFXDOCKINGMANAGER/CDockingManager::GetMiniFrames
- AFXDOCKINGMANAGER/CDockingManager::GetOuterEdgeBounds
- AFXDOCKINGMANAGER/CDockingManager::GetPaneList
- AFXDOCKINGMANAGER/CDockingManager::GetSmartDockingManager
- AFXDOCKINGMANAGER/CDockingManager::GetSmartDockingManagerPermanent
- AFXDOCKINGMANAGER/CDockingManager::GetSmartDockingParams
- AFXDOCKINGMANAGER/CDockingManager::GetSmartDockingTheme
- AFXDOCKINGMANAGER/CDockingManager::HideAutoHidePanes
- AFXDOCKINGMANAGER/CDockingManager::InsertDockSite
- AFXDOCKINGMANAGER/CDockingManager::InsertPane
- AFXDOCKINGMANAGER/CDockingManager::IsDockSiteMenu
- AFXDOCKINGMANAGER/CDockingManager::IsInAdjustLayout
- AFXDOCKINGMANAGER/CDockingManager::IsOLEContainerMode
- AFXDOCKINGMANAGER/CDockingManager::IsPointNearDockSite
- AFXDOCKINGMANAGER/CDockingManager::IsPrintPreviewValid
- AFXDOCKINGMANAGER/CDockingManager::LoadState
- AFXDOCKINGMANAGER/CDockingManager::LockUpdate
- AFXDOCKINGMANAGER/CDockingManager::OnActivateFrame
- AFXDOCKINGMANAGER/CDockingManager::OnClosePopupMenu
- AFXDOCKINGMANAGER/CDockingManager::OnMoveMiniFrame
- AFXDOCKINGMANAGER/CDockingManager::OnPaneContextMenu
- AFXDOCKINGMANAGER/CDockingManager::PaneFromPoint
- AFXDOCKINGMANAGER/CDockingManager::ProcessPaneContextMenuCommand
- AFXDOCKINGMANAGER/CDockingManager::RecalcLayout
- AFXDOCKINGMANAGER/CDockingManager::ReleaseEmptyPaneContainers
- AFXDOCKINGMANAGER/CDockingManager::RemoveHiddenMDITabbedBar
- AFXDOCKINGMANAGER/CDockingManager::RemoveMiniFrame
- AFXDOCKINGMANAGER/CDockingManager::RemovePaneFromDockManager
- AFXDOCKINGMANAGER/CDockingManager::ReplacePane
- AFXDOCKINGMANAGER/CDockingManager::ResortMiniFramesForZOrder
- AFXDOCKINGMANAGER/CDockingManager::SaveState
- AFXDOCKINGMANAGER/CDockingManager::SendMessageToMiniFrames
- AFXDOCKINGMANAGER/CDockingManager::Serialize
- AFXDOCKINGMANAGER/CDockingManager::SetAutohideZOrder
- AFXDOCKINGMANAGER/CDockingManager::SetDockingMode
- AFXDOCKINGMANAGER/CDockingManager::SetDockState
- AFXDOCKINGMANAGER/CDockingManager::SetPrintPreviewMode
- AFXDOCKINGMANAGER/CDockingManager::SetSmartDockingParams
- AFXDOCKINGMANAGER/CDockingManager::ShowDelayShowMiniFrames
- AFXDOCKINGMANAGER/CDockingManager::ShowPanes
- AFXDOCKINGMANAGER/CDockingManager::StartSDocking
- AFXDOCKINGMANAGER/CDockingManager::StopSDocking
- AFXDOCKINGMANAGER/CDockingManager::m_bHideDockingBarsInContainerMode
- AFXDOCKINGMANAGER/CDockingManager::m_dockModeGlobal
- AFXDOCKINGMANAGER/CDockingManager::m_nDockSensitivity
- AFXDOCKINGMANAGER/CDockingManager::m_nTimeOutBeforeDockingBarDock
- AFXDOCKINGMANAGER/CDockingManager::m_nTimeOutBeforeToolBarDock
helpviewer_keywords:
- CDockingManager [MFC], AddDockSite
- CDockingManager [MFC], AddHiddenMDITabbedBar
- CDockingManager [MFC], AddMiniFrame
- CDockingManager [MFC], AddPane
- CDockingManager [MFC], AdjustDockingLayout
- CDockingManager [MFC], AdjustPaneFrames
- CDockingManager [MFC], AdjustRectToClientArea
- CDockingManager [MFC], AlignAutoHidePane
- CDockingManager [MFC], AutoHidePane
- CDockingManager [MFC], BringBarsToTop
- CDockingManager [MFC], BuildPanesMenu
- CDockingManager [MFC], CalcExpectedDockedRect
- CDockingManager [MFC], Create
- CDockingManager [MFC], DeterminePaneAndStatus
- CDockingManager [MFC], DisableRestoreDockState
- CDockingManager [MFC], DockPane
- CDockingManager [MFC], DockPaneLeftOf
- CDockingManager [MFC], EnableAutoHidePanes
- CDockingManager [MFC], EnableDocking
- CDockingManager [MFC], EnableDockSiteMenu
- CDockingManager [MFC], EnablePaneContextMenu
- CDockingManager [MFC], FindDockSite
- CDockingManager [MFC], FindDockSiteByPane
- CDockingManager [MFC], FindPaneByID
- CDockingManager [MFC], FixupVirtualRects
- CDockingManager [MFC], FrameFromPoint
- CDockingManager [MFC], GetClientAreaBounds
- CDockingManager [MFC], GetDockingMode
- CDockingManager [MFC], GetDockSiteFrameWnd
- CDockingManager [MFC], GetEnabledAutoHideAlignment
- CDockingManager [MFC], GetMiniFrames
- CDockingManager [MFC], GetOuterEdgeBounds
- CDockingManager [MFC], GetPaneList
- CDockingManager [MFC], GetSmartDockingManager
- CDockingManager [MFC], GetSmartDockingManagerPermanent
- CDockingManager [MFC], GetSmartDockingParams
- CDockingManager [MFC], GetSmartDockingTheme
- CDockingManager [MFC], HideAutoHidePanes
- CDockingManager [MFC], InsertDockSite
- CDockingManager [MFC], InsertPane
- CDockingManager [MFC], IsDockSiteMenu
- CDockingManager [MFC], IsInAdjustLayout
- CDockingManager [MFC], IsOLEContainerMode
- CDockingManager [MFC], IsPointNearDockSite
- CDockingManager [MFC], IsPrintPreviewValid
- CDockingManager [MFC], LoadState
- CDockingManager [MFC], LockUpdate
- CDockingManager [MFC], OnActivateFrame
- CDockingManager [MFC], OnClosePopupMenu
- CDockingManager [MFC], OnMoveMiniFrame
- CDockingManager [MFC], OnPaneContextMenu
- CDockingManager [MFC], PaneFromPoint
- CDockingManager [MFC], ProcessPaneContextMenuCommand
- CDockingManager [MFC], RecalcLayout
- CDockingManager [MFC], ReleaseEmptyPaneContainers
- CDockingManager [MFC], RemoveHiddenMDITabbedBar
- CDockingManager [MFC], RemoveMiniFrame
- CDockingManager [MFC], RemovePaneFromDockManager
- CDockingManager [MFC], ReplacePane
- CDockingManager [MFC], ResortMiniFramesForZOrder
- CDockingManager [MFC], SaveState
- CDockingManager [MFC], SendMessageToMiniFrames
- CDockingManager [MFC], Serialize
- CDockingManager [MFC], SetAutohideZOrder
- CDockingManager [MFC], SetDockingMode
- CDockingManager [MFC], SetDockState
- CDockingManager [MFC], SetPrintPreviewMode
- CDockingManager [MFC], SetSmartDockingParams
- CDockingManager [MFC], ShowDelayShowMiniFrames
- CDockingManager [MFC], ShowPanes
- CDockingManager [MFC], StartSDocking
- CDockingManager [MFC], StopSDocking
- CDockingManager [MFC], m_bHideDockingBarsInContainerMode
- CDockingManager [MFC], m_dockModeGlobal
- CDockingManager [MFC], m_nDockSensitivity
- CDockingManager [MFC], m_nTimeOutBeforeDockingBarDock
- CDockingManager [MFC], m_nTimeOutBeforeToolBarDock
ms.assetid: 98e69c43-55d8-4f43-b861-4fda80ec1e32
ms.openlocfilehash: 6d3bbafa15ada97f53710f0faf6a18ea8e892f6c
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2019
ms.locfileid: "62391214"
---
# <a name="cdockingmanager-class"></a>CDockingManager 類別

實作控制配置停駐於主框架視窗中的核心功能。

## <a name="syntax"></a>語法

```
class CDockingManager : public CObject
```

## <a name="members"></a>成員

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CDockingManager::AddDockSite](#adddocksite)|建立停駐窗格，並將它新增至控制列清單。|
|[CDockingManager::AddHiddenMDITabbedBar](#addhiddenmditabbedbar)|將控制代碼加入至列窗格，即可隱藏 MDI 索引標籤式窗格列的清單。|
|[CDockingManager::AddMiniFrame](#addminiframe)|您可以將框架加入迷你框架的清單。|
|[CDockingManager::AddPane](#addpane)|向停駐的管理員窗格。|
|[CDockingManager::AdjustDockingLayout](#adjustdockinglayout)|重新計算，並調整框架視窗中的所有窗格的配置。|
|[CDockingManager::AdjustPaneFrames](#adjustpaneframes)|會導致 WM_NCCALCSIZE 訊息傳送至所有窗格和`CPaneFrameWnd`windows。|
|[CDockingManager::AdjustRectToClientArea](#adjustrecttoclientarea)|調整對齊的矩形。|
|[CDockingManager::AlignAutoHidePane](#alignautohidepane)|調整大小，以自動隱藏模式中的停駐窗格所需的整個寬度或高度括住的畫面格的工作區的停駐的站台。|
|[CDockingManager::AutoHidePane](#autohidepane)|建立自動隱藏工具列。|
|[CDockingManager::BringBarsToTop](#bringbarstotop)|將具有指定的對齊上方的停駐的列。|
|[CDockingManager::BuildPanesMenu](#buildpanesmenu)|將功能表中的停駐窗格和工具列的名稱。|
|[CDockingManager::CalcExpectedDockedRect](#calcexpecteddockedrect)|計算預期的固定視窗矩形。|
|[CDockingManager::Create](#create)|建立停駐的管理員。|
|[CDockingManager::DeterminePaneAndStatus](#determinepaneandstatus)|決定包含指定的點，以及其停駐狀態的窗格。|
|[CDockingManager::DisableRestoreDockState](#disablerestoredockstate)|啟用或停用停駐的配置，從登錄載入。|
|[CDockingManager::DockPane](#dockpane)|另一個窗格或框架視窗停駐窗格。|
|[CDockingManager::DockPaneLeftOf](#dockpaneleftof)|將窗格停駐於另一個窗格的左邊。|
|[CDockingManager::EnableAutoHidePanes](#enableautohidepanes)|可讓回主框架窗格的停駐、 建立停駐窗格中，並將它新增至控制列清單。|
|[CDockingManager::EnableDocking](#enabledocking)|建立停駐窗格並啟用回主框架窗格的停駐。|
|[CDockingManager::EnableDockSiteMenu](#enabledocksitemenu)|顯示其他按鈕開啟快顯功能表上的所有停駐窗格的標題。|
|[CDockingManager::EnablePaneContextMenu](#enablepanecontextmenu)|會告訴程式庫來顯示特殊的操作功能表，使用者按下滑鼠右按鈕和程式庫會處理 WM_CONTEXTMENU 訊息時，有一份應用程式工具列和停駐窗格。|
|[CDockingManager::FindDockSite](#finddocksite)|擷取列窗格中，位在指定的位置，且具有指定的對齊方式。|
|[CDockingManager::FindDockSiteByPane](#finddocksitebypane)|傳回列 id 為目標狀態列窗格的窗格。|
|[CDockingManager::FindPaneByID](#findpanebyid)|尋找窗格中所指定的控制項 id。|
|[CDockingManager::FixupVirtualRects](#fixupvirtualrects)|認可虛擬矩形目前所有工具列位置。|
|[CDockingManager::FrameFromPoint](#framefrompoint)|傳回包含指定的點的框架。|
|[CDockingManager::GetClientAreaBounds](#getclientareabounds)|取得包含用戶端區域的界限的矩形。|
|[CDockingManager::GetDockingMode](#getdockingmode)|傳回目前停駐的模式。|
|[CDockingManager::GetDockSiteFrameWnd](#getdocksiteframewnd)|取得父視窗框架指標。|
|[CDockingManager::GetEnabledAutoHideAlignment](#getenabledautohidealignment)|傳回已啟用的對齊方式的窗格。|
|[CDockingManager::GetMiniFrames](#getminiframes)|取得主機的清單。|
|[CDockingManager::GetOuterEdgeBounds](#getouteredgebounds)|取得包含框架外部邊緣的矩形。|
|[CDockingManager::GetPaneList](#getpanelist)|傳回一份窗格隸屬於停駐的管理員。 這包括所有浮動窗格。|
|[CDockingManager::GetSmartDockingManager](#getsmartdockingmanager)|擷取智慧停駐的管理員的指標。|
|[CDockingManager::GetSmartDockingManagerPermanent](#getsmartdockingmanagerpermanent)|擷取智慧停駐的管理員的指標。|
|[CDockingManager::GetSmartDockingParams](#getsmartdockingparams)|智慧停駐的參數傳回停駐的管理員。|
|[CDockingManager::GetSmartDockingTheme](#getsmartdockingtheme)|傳回用來顯示智慧停駐標記佈景主題的靜態方法。|
|[CDockingManager::HideAutoHidePanes](#hideautohidepanes)|隱藏自動隱藏模式中的窗格。|
|[CDockingManager::InsertDockSite](#insertdocksite)|建立停駐窗格，並將它插入控制列清單。|
|[CDockingManager::InsertPane](#insertpane)|控制項窗格插入控制列清單。|
|[CDockingManager::IsDockSiteMenu](#isdocksitemenu)|指定的所有窗格的標題是否顯示快顯功能表。|
|[CDockingManager::IsInAdjustLayout](#isinadjustlayout)|決定所有窗格的配置會進行調整。|
|[CDockingManager::IsOLEContainerMode](#isolecontainermode)|指定是否停駐的管理員為 OLE 容器模式。|
|[CDockingManager::IsPointNearDockSite](#ispointneardocksite)|判斷指定的點是否停駐位置附近。|
|[CDockingManager::IsPrintPreviewValid](#isprintpreviewvalid)|判斷是否設定預覽列印模式。|
|[CDockingManager::LoadState](#loadstate)|從登錄載入停駐的管理員狀態。|
|[CDockingManager::LockUpdate](#lockupdate)|鎖定指定的視窗。|
|[CDockingManager::OnActivateFrame](#onactivateframe)|框架視窗變成使用中或已停用時由架構呼叫。|
|[CDockingManager::OnClosePopupMenu](#onclosepopupmenu)|架構在作用中的快顯功能表處理 WM_DESTROY 訊息時所呼叫。|
|[CDockingManager::OnMoveMiniFrame](#onmoveminiframe)|由架構呼叫以移動迷你框架視窗。|
|[CDockingManager::OnPaneContextMenu](#onpanecontextmenu)|建置一個功能表，並有一份窗格時，由架構呼叫。|
|[CDockingManager::PaneFromPoint](#panefrompoint)|傳回包含指定的點的窗格。|
|[CDockingManager::ProcessPaneContextMenuCommand](#processpanecontextmenucommand)|由架構呼叫來選取或清除核取方塊，針對指定的命令，並重新計算顯示窗格的配置。|
|[CDockingManager::RecalcLayout](#recalclayout)|重新計算中的控制項清單控制項的內部配置。|
|[CDockingManager::ReleaseEmptyPaneContainers](#releaseemptypanecontainers)|釋出的空窗格中的容器。|
|[CDockingManager::RemoveHiddenMDITabbedBar](#removehiddenmditabbedbar)|移除指定的列窗格隱藏項目。|
|[CDockingManager::RemoveMiniFrame](#removeminiframe)|從迷你框架的清單中移除指定的範圍。|
|[CDockingManager::RemovePaneFromDockManager](#removepanefromdockmanager)|取消註冊窗格，並從停駐的管理員在清單中移除。|
|[CDockingManager::ReplacePane](#replacepane)|以一個窗格取代另一個。|
|[CDockingManager::ResortMiniFramesForZOrder](#resortminiframesforzorder)|訴諸迷你框架的清單中的框架。|
|[CDockingManager::SaveState](#savestate)|將停駐的管理員狀態儲存至登錄中。|
|[CDockingManager::SendMessageToMiniFrames](#sendmessagetominiframes)|將指定的訊息傳送至所有的迷你框架中。|
|[CDockingManager::Serialize](#serialize)|寫入封存中的停駐的管理員。 (覆寫 [CObject::Serialize](../../mfc/reference/cobject-class.md#serialize)。)|
|[CDockingManager::SetAutohideZOrder](#setautohidezorder)|設定大小、 寬度和高度的控制列和指定的窗格。|
|[CDockingManager::SetDockingMode](#setdockingmode)|設定固定的模式。|
|[CDockingManager::SetDockState](#setdockstate)|設定停駐控制列、 迷你框架，以及自動隱藏列的狀態。|
|[CDockingManager::SetPrintPreviewMode](#setprintpreviewmode)|設定的預覽列印模式會在預覽列印中顯示的橫條。|
|[CDockingManager::SetSmartDockingParams](#setsmartdockingparams)|設定可定義智慧停駐行為的參數。|
|[CDockingManager::ShowDelayShowMiniFrames](#showdelayshowminiframes)|顯示或隱藏的迷你框架視窗。|
|[CDockingManager::ShowPanes](#showpanes)|顯示或隱藏控制項，並自動隱藏列的窗格。|
|[CDockingManager::StartSDocking](#startsdocking)|啟動指定的視窗，根據智慧停駐的管理員的對齊方式智慧停駐。|
|[CDockingManager::StopSDocking](#stopsdocking)|停駐點智慧停駐。|

### <a name="data-members"></a>資料成員

|名稱|描述|
|----------|-----------------|
|[CDockingManager::m_bHideDockingBarsInContainerMode](#m_bhidedockingbarsincontainermode)|指定是否停駐的管理員，將會隱藏 OLE 容器模式下的窗格。|
|[CDockingManager::m_dockModeGlobal](#m_dockmodeglobal)|指定的全域停駐的模式。|
|[CDockingManager::m_nDockSensitivity](#m_ndocksensitivity)|指定停駐的敏感度。|
|[CDockingManager::m_nTimeOutBeforeDockingBarDock](#m_ntimeoutbeforedockingbardock)|之前的停駐窗格停駐在停駐的即時模式中，指定時間，以毫秒為單位。|
|[CDockingManager::m_nTimeOutBeforeToolBarDock](#m_ntimeoutbeforetoolbardock)|工具列停駐於主框架視窗之前，請指定時間，以毫秒為單位。|

## <a name="remarks"></a>備註

主框架視窗建立，並會自動初始化此類別。

停駐的管理員物件保留一份所有窗格中的停駐的配置，以及一份所有[CPaneFrameWnd](../../mfc/reference/cpaneframewnd-class.md)屬於主框架視窗的視窗。

`CDockingManager`類別會實作某些服務可供您尋找窗格或`CPaneFrameWnd`視窗。 您通常不這些服務會直接呼叫因為它們會包裝在主框架視窗物件。 如需詳細資訊，請參閱 < [CPaneFrameWnd 類別](../../mfc/reference/cpaneframewnd-class.md)。

## <a name="customization-tips"></a>自訂秘訣

下列秘訣適用於`CDockingManager`物件：

- [CDockingManager 類別](../../mfc/reference/cdockingmanager-class.md)支援這些停駐的模式：

  - `AFX_DOCK_TYPE::DT_IMMEDIATE`

  - `AFX_DOCK_TYPE::DT_STANDARD`

  - `AFX_DOCK_TYPE::DT_SMART`

  這些停駐的模式由[CDockingManager::m_dockModeGlobal](#m_dockmodeglobal)並且由呼叫設定[CDockingManager::SetDockingMode](#setdockingmode)。

- 如果您想要建立非浮動、 不可調整大小的窗格中，呼叫[CDockingManager::AddPane](#addpane)方法。 這個方法會向停駐的管理員會負責配置的窗格中的窗格。

## <a name="example"></a>範例

下列範例示範如何使用中的各種方法`CDockingManager`類別，以設定`CDockingManager`物件。 此範例示範如何顯示額外的按鈕會開啟快顯功能表上的所有停駐窗格的標題，以及如何設定物件的固定模式。 此程式碼片段是一部分[Visual Studio 示範範例](../../overview/visual-cpp-samples.md)。

[!code-cpp[NVC_MFC_VisualStudioDemo#24](../../mfc/codesnippet/cpp/cdockingmanager-class_1.cpp)]

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](../../mfc/reference/cobject-class.md)

[CDockingManager](../../mfc/reference/cdockingmanager-class.md)

## <a name="requirements"></a>需求

**標頭：** afxDockingManager.h

##  <a name="adddocksite"></a>  CDockingManager::AddDockSite

建立停駐窗格，並將它新增至控制列清單。

```
BOOL AddDockSite(
    const AFX_DOCKSITE_INFO& info,
    CDockSite** ppDockBar = NULL);
```

### <a name="parameters"></a>參數

*info*<br/>
[in]包含的資訊結構的參考停駐窗格的對齊方式。

*ppDockBar*<br/>
[out]指向新的停駐窗格的指標。

### <a name="return-value"></a>傳回值

如果停駐窗格建立成功;，則為 TRUE。FALSE 否則。

##  <a name="addhiddenmditabbedbar"></a>  CDockingManager::AddHiddenMDITabbedBar

將控制代碼加入至列窗格，即可隱藏 MDI 索引標籤式窗格列的清單。

```
void AddHiddenMDITabbedBar(CDockablePane* pBar);
```

### <a name="parameters"></a>參數

*pBar*<br/>
[in]指標為橫條窗格

##  <a name="addpane"></a>  CDockingManager::AddPane

向停駐的管理員窗格。

```
BOOL AddPane(
    CBasePane* pWnd,
    BOOL bTail = TRUE,
    BOOL bAutoHide = FALSE,
    BOOL bInsertForOuterEdge = FALSE);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
[in、 out]指定將新增至停駐的管理員窗格。

*bTail*<br/>
[in]TRUE 表示停駐的管理員; 中的窗格清單的結尾加入窗格否則為 FALSE。

*bAutoHide*<br/>
[in]僅供內部使用。 一律使用預設值為 FALSE。

*bInsertForOuterEdge*<br/>
[in]僅供內部使用。 一律使用預設值為 FALSE。

### <a name="return-value"></a>傳回值

如果窗格已成功向停駐的管理員，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

呼叫這個方法來向停駐的管理員註冊非浮動、 不可調整大小的窗格。 如果您沒有註冊的窗格中，將無法正確顯示時停駐的管理員已配置版面。

##  <a name="adjustdockinglayout"></a>  CDockingManager::AdjustDockingLayout

重新計算，並調整框架視窗中的所有窗格的配置。

```
virtual void AdjustDockingLayout(HDWP hdwp = NULL);
```

### <a name="parameters"></a>參數

*hdwp*<br/>
[in]指定延遲的視窗位置結構。 如需詳細資訊，請參閱 [Windows 資料類型](/windows/desktop/WinProg/windows-data-types)。

### <a name="remarks"></a>備註

##  <a name="addminiframe"></a>  CDockingManager::AddMiniFrame

您可以將框架加入迷你框架的清單。

```
virtual BOOL AddMiniFrame(CPaneFrameWnd* pWnd);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
[in]框架指標。

### <a name="return-value"></a>傳回值

如果框架不在迷你框架的清單，且已順利新增，則為 TRUE。FALSE 否則。

##  <a name="adjustpaneframes"></a>  CDockingManager::AdjustPaneFrames

會導致 WM_NCCALCSIZE 訊息傳送至所有窗格和`CPaneFrameWnd`windows。

```
virtual void AdjustPaneFrames();
```

### <a name="remarks"></a>備註

##  <a name="adjustrecttoclientarea"></a>  CDockingManager::AdjustRectToClientArea

調整對齊的矩形。

```
virtual BOOL AdjustRectToClientArea(
    CRect& rectResult,
    DWORD dwAlignment);
```

### <a name="parameters"></a>參數

*rectResult*<br/>
[in]參考`CRect`物件

*dwAlignment*<br/>
[in]對齊方式`CRect`物件

### <a name="return-value"></a>傳回值

則為 TRUE 的對齊方式`CRect`調整物件;FALSE 否則。

### <a name="remarks"></a>備註

*DwAlignment*參數可以具有下列值之一：

- CBRS_ALIGN_TOP

- CBRS_ALIGN_BOTTOM

- CBRS_ALIGN_LEFT

- CBRS_ALIGN_RIGHT

##  <a name="alignautohidepane"></a>  CDockingManager::AlignAutoHidePane

調整大小，以自動隱藏模式中的停駐窗格所需的整個寬度或高度括住的畫面格的工作區的停駐的站台。

```
void AlignAutoHidePane(
    CPaneDivider* pDefaultSlider,
    BOOL bIsVisible = TRUE);
```

### <a name="parameters"></a>參數

*pDefaultSlider*<br/>
[in][停駐的滑桿] 窗格中。

*bIsVisible*<br/>
[in]如果停駐窗格為可見;，則為 TRUE。FALSE 否則。

##  <a name="autohidepane"></a>  CDockingManager::AutoHidePane

建立自動隱藏工具列。

```
CMFCAutoHideToolBar* AutoHidePane(
    CDockablePane* pBar,
    CMFCAutoHideToolBar* pCurrAutoHideToolBar = NULL);
```

### <a name="parameters"></a>參數

*pBar*<br/>
[in]列指標窗格。

*pCurrAutoHideToolBar*<br/>
[in]指標，自動隱藏工具列。

### <a name="return-value"></a>傳回值

如果不是自動隱藏工具列，則為 NULL否則為新的工具列的指標。

##  <a name="bringbarstotop"></a>  CDockingManager::BringBarsToTop

將具有指定的對齊上方的停駐的列。

```
void BringBarsToTop(
    DWORD dwAlignment = 0,
    BOOL bExcludeDockedBars = TRUE);
```

### <a name="parameters"></a>參數

*dwAlignment*<br/>
[in]就可以享受頂端的其他視窗停駐列對齊方式。

*bExcludeDockedBars*<br/>
[in]若要排除的停駐的列在最上層顯示;，則為 TRUE否則為 FALSE。

##  <a name="buildpanesmenu"></a>  CDockingManager::BuildPanesMenu

將功能表中的停駐窗格和工具列的名稱。

```
void BuildPanesMenu(
    CMenu& menu,
    BOOL bToolbarsOnly);
```

### <a name="parameters"></a>參數

*menu*<br/>
[in]若要新增的停駐窗格和工具列名稱功能表。

*bToolbarsOnly*<br/>
[in]TRUE 表示將唯一的工具列名稱新增至功能表FALSE 否則。

##  <a name="calcexpecteddockedrect"></a>  CDockingManager::CalcExpectedDockedRect

計算預期的固定視窗矩形。

```
void CalcExpectedDockedRect(
    CWnd* pWnd,
    CPoint ptMouse,
    CRect& rectResult,
    BOOL& bDrawTab,
    CDockablePane** ppTargetBar);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
[in]若要停駐視窗的指標。

*ptMouse*<br/>
[in]滑鼠位置。

*rectResult*<br/>
[out]導出的矩形。

*bDrawTab*<br/>
[in]True 會繪製一個索引標籤;否則為 FALSE。

*ppTargetBar*<br/>
[out]指向 [目標] 窗格的指標。

### <a name="remarks"></a>備註

這個方法會計算如果使用者拖曳到所指定的點的視窗，視窗會佔據的矩形*ptMouse*而那里將它停駐。

##  <a name="create"></a>  CDockingManager::Create

建立停駐的管理員。

```
BOOL Create(CFrameWnd* pParentWnd);
```

### <a name="parameters"></a>參數

*pParentWnd*<br/>
[in]停駐的管理員的父框架指標。 此值必須不是 NULL。

### <a name="return-value"></a>傳回值

永遠為 TRUE。

##  <a name="determinepaneandstatus"></a>  CDockingManager::DeterminePaneAndStatus

決定包含指定的點，以及其停駐狀態的窗格。

```
virtual AFX_CS_STATUS DeterminePaneAndStatus(
    CPoint pt,
    int nSensitivity,
    DWORD dwEnabledAlignment,
    CBasePane** ppTargetBar,
    const CBasePane* pBarToIgnore,
    const CBasePane* pBarToDock);
```

### <a name="parameters"></a>參數

*pt*<br/>
[in]若要檢查窗格的位置。

*nSensitivity*<br/>
[in]值，以延長已檢查的每個窗格的視窗矩形。 窗格在這個增加的區域中指定的點是否符合搜尋準則。

*dwEnabledAlignment*<br/>
[in]停駐窗格的對齊方式。

*ppTargetBar*<br/>
[out]指向 [目標] 窗格的指標。

*pBarToIgnore*<br/>
[in]這個方法會忽略 [] 窗格。

*pBarToDock*<br/>
[in]停駐窗格。

### <a name="return-value"></a>傳回值

停駐的狀態。

### <a name="remarks"></a>備註

停駐狀態可以是下列值之一：

|AFX_CS_STATUS 值|意義|
|---------------------------|-------------|
|CS_NOTHING|指標不是透過與停駐位置。 因此，讓窗格浮動。|
|CS_DOCK_IMMEDIATELY|指標位在 dock 中的站台即時模式 （DT_IMMEDIATE 樣式已啟用），所以必須立即停駐窗格。|
|CS_DELAY_DOCK|指標是透過與另一個停駐窗格或主要畫面格的一個邊緣的停駐位置。|
|CS_DELAY_DOCK_TO_TAB|指標是透過與會導致要在索引標籤式視窗停駐窗格的停駐位置。 會發生這種情況是透過另一個停駐窗格的標題或索引標籤式窗格的索引標籤區域滑鼠時。|

##  <a name="disablerestoredockstate"></a>  CDockingManager::DisableRestoreDockState

啟用或停用停駐的配置，從登錄載入。

```
void DisableRestoreDockState(BOOL bDisable = TRUE);
```

### <a name="parameters"></a>參數

*bDisable*<br/>
[in]True 會從登錄; 停駐配置的停用載入否則為 FALSE。

### <a name="remarks"></a>備註

當載入應用程式的狀態時，您必須保留目前的停駐窗格和工具列版面配置時，請呼叫這個方法。

##  <a name="dockpane"></a>  CDockingManager::DockPane

另一個窗格或框架視窗停駐窗格。

```
void DockPane(
    CBasePane* pBar,
    UINT nDockBarID = 0,
    LPCRECT lpRect = NULL);
```

### <a name="parameters"></a>參數

*pBar*<br/>
[in]為橫條指標停駐窗格。

*nDockBarID*<br/>
[in]若要停駐列的識別碼。

*lpRect*<br/>
[in]目的矩形。

##  <a name="dockpaneleftof"></a>  CDockingManager::DockPaneLeftOf

將窗格停駐於另一個窗格的左邊。

```
BOOL DockPaneLeftOf(
    CPane* pBarToDock,
    CPane* pTargetBar);
```

### <a name="parameters"></a>參數

*pBarToDock*<br/>
[in]左邊的停駐窗格的指標*pTargetBar*。

*pTargetBar*<br/>
[in]對 [目標] 窗格的指標。

### <a name="return-value"></a>傳回值

如果已順利停駐窗格，則為 TRUE。否則為 FALSE。

##  <a name="enableautohidepanes"></a>  CDockingManager::EnableAutoHidePanes

可讓回主框架窗格的停駐、 建立停駐窗格中，並將它新增至控制列清單。

```
BOOL EnableAutoHidePanes(DWORD dwStyle);
```

### <a name="parameters"></a>參數

*dwStyle*<br/>
[in]停駐的對齊方式。

### <a name="return-value"></a>傳回值

如果停駐窗格建立成功;，則為 TRUE。FALSE 否則。

##  <a name="enabledocking"></a>  CDockingManager::EnableDocking

建立停駐窗格並啟用回主框架窗格的停駐。

```
BOOL EnableDocking(DWORD dwStyle);
```

### <a name="parameters"></a>參數

*dwStyle*<br/>
[in]停駐的對齊方式。

### <a name="return-value"></a>傳回值

如果停駐窗格建立成功;，則為 TRUE。FALSE 否則。

##  <a name="enabledocksitemenu"></a>  CDockingManager::EnableDockSiteMenu

顯示其他按鈕開啟快顯功能表上的所有停駐窗格的標題。

```
static void EnableDockSiteMenu(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
[in]TRUE 表示啟用停駐 [網站] 功能表中;否則為 FALSE。

### <a name="remarks"></a>備註

停駐的 [網站] 功能表會顯示下列選項，以變更窗格的停駐狀態：

- `Floating` -讓窗格浮動

- `Docking` -停駐窗格中，在主要畫面格的窗格上次停駐位置的位置

- `AutoHide` -窗格切換到 自動隱藏模式

- `Hide` -隱藏窗格

根據預設，不會顯示此功能表。

##  <a name="enablepanecontextmenu"></a>  CDockingManager::EnablePaneContextMenu

會告訴程式庫來顯示特殊的操作功能表，使用者按下滑鼠右按鈕和程式庫會處理 WM_CONTEXTMENU 訊息時，有一份應用程式工具列和停駐窗格。

```
void EnablePaneContextMenu(
    BOOL bEnable,
    UINT uiCustomizeCmd,
    const CString& strCustomizeText,
    BOOL bToolbarsOnly = FALSE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
[in]如果為 TRUE，程式庫會開啟自動內容功能表的支援如果為 FALSE 的程式庫就會關閉自動快顯功能表的支援。

*uiCustomizeCmd*<br/>
[in]命令 id**自訂**功能表中的項目。

*strCustomizeText*<br/>
[in]文字**自訂**項目。

*bToolbarsOnly*<br/>
[in]如果為 TRUE，功能表會顯示一份應用程式工具列;如果為 FALSE，程式庫會將這份清單的應用程式停駐窗格。

##  <a name="finddocksite"></a>  CDockingManager::FindDockSite

擷取列窗格中，位在指定的位置，且具有指定的對齊方式。

```
virtual CDockSite* FindDockSite(
    DWORD dwAlignment,
    BOOL bOuter);
```

### <a name="parameters"></a>參數

*dwAlignment*<br/>
[in]列的對齊方式窗格。

*bOuter*<br/>
[in]如果為 TRUE，擷取在控制列前端的位置清單中的列。 否則，擷取在清單中的控制列的結尾位置中的列。

### <a name="return-value"></a>傳回值

具有指定的對齊; 停駐窗格否則為 NULL。

##  <a name="findpanebyid"></a>  CDockingManager::FindPaneByID

尋找窗格中所指定的控制項 id。

```
virtual CBasePane* FindPaneByID(
    UINT uBarID,
    BOOL bSearchMiniFrames = FALSE);
```

### <a name="parameters"></a>參數

*uBarID*<br/>
[in]指定要尋找窗格的控制項 ID。

*bSearchMiniFrames*<br/>
[in]在搜尋中包含所有在浮動窗格，則為 TRUE。 如果為 false，則包含僅停駐的窗格。

### <a name="return-value"></a>傳回值

[CBasePane](../../mfc/reference/cbasepane-class.md)物件具有指定的控制項識別碼，則為 NULL，如果找不到指定的窗格。

### <a name="remarks"></a>備註

##  <a name="finddocksitebypane"></a>  CDockingManager::FindDockSiteByPane

傳回列 id 為目標狀態列窗格的窗格。

```
virtual CDockSite* FindDockSiteByPane(CPane* pTargetBar);
```

### <a name="parameters"></a>參數

*pTargetBar*<br/>
[in]指向的目標狀態列窗格。

### <a name="return-value"></a>傳回值

列識別碼為 目標列 窗格中的窗格如果沒有滿足下列條件 窗格列存在，則為 NULL。

##  <a name="fixupvirtualrects"></a>  CDockingManager::FixupVirtualRects

認可虛擬矩形目前所有工具列位置。

```
virtual void FixupVirtualRects();
```

### <a name="remarks"></a>備註

當使用者開始拖曳工具列時，應用程式會記住在其原始位置*虛擬矩形*。 當使用者將其停駐的站台之間的工具列時，工具列就可能會變更其他工具列。 其他工具列的原始位置會儲存在對應的虛擬矩形。

##  <a name="framefrompoint"></a>  CDockingManager::FrameFromPoint

傳回包含指定的點的框架。

```
virtual CPaneFrameWnd* FrameFromPoint(
    CPoint pt,
    CPaneFrameWnd* pFrameToExclude,
    BOOL bFloatMultiOnly) const;
```

### <a name="parameters"></a>參數

*pt*<br/>
[in]指定的點，若要檢查的螢幕座標。

*pFrameToExclude*<br/>
[in]若要排除的框架指標。

*bFloatMultiOnly*<br/>
[in]排除的畫面格的執行個體的 True `CMultiPaneFrameWnd`;FALSE 否則。

### <a name="return-value"></a>傳回值

框架，其中包含指定的點;否則為 NULL。

##  <a name="getclientareabounds"></a>  CDockingManager::GetClientAreaBounds

取得包含用戶端區域的界限的矩形。

```
CRect GetClientAreaBounds() const;

void GetClientAreaBounds(CRect& rcClient);
```

### <a name="parameters"></a>參數

*rcClient*<br/>
[out]包含用戶端區域的界限的矩形的參考。

### <a name="return-value"></a>傳回值

包含用戶端區域的界限的矩形。

##  <a name="getdockingmode"></a>  CDockingManager::GetDockingMode

傳回目前停駐的模式。

```
static AFX_DOCK_TYPE GetDockingMode();
```

### <a name="return-value"></a>傳回值

列舉程式值，代表目前停駐的模式。 它可以是下列值之一：

- DT_STANDARD

- DT_IMMEDIATE

- DT_SMART

### <a name="remarks"></a>備註

若要設定停駐的模式，請呼叫[CDockingManager::SetDockingMode](#setdockingmode)。

##  <a name="getdocksiteframewnd"></a>  CDockingManager::GetDockSiteFrameWnd

取得父視窗框架指標。

```
CFrameWnd* GetDockSiteFrameWnd() const;
```

### <a name="return-value"></a>傳回值

父視窗框架指標。

##  <a name="getenabledautohidealignment"></a>  CDockingManager::GetEnabledAutoHideAlignment

傳回已啟用的對齊方式的窗格。

```
DWORD GetEnabledAutoHideAlignment() const;
```

### <a name="return-value"></a>傳回值

CBRS_ALIGN_ 旗標或 0，如果未啟用自動隱藏窗格的位元組合。 如需詳細資訊，請參閱 < [CFrameWnd::EnableDocking](../../mfc/reference/cframewnd-class.md#enabledocking)。

### <a name="remarks"></a>備註

方法會傳回自動隱藏控制列的已啟用對齊方式。 若要啟用自動隱藏列，請呼叫[CFrameWndEx::EnableAutoHidePanes](../../mfc/reference/cframewndex-class.md#enableautohidepanes)。

##  <a name="getminiframes"></a>  CDockingManager::GetMiniFrames

取得主機的清單。

```
const CObList& GetMiniFrames() const;
```

### <a name="return-value"></a>傳回值

包含屬於停駐的管理員控制列的主機清單。

##  <a name="getouteredgebounds"></a>  CDockingManager::GetOuterEdgeBounds

取得包含框架外部邊緣的矩形。

```
CRect GetOuterEdgeBounds() const;
```

### <a name="return-value"></a>傳回值

包含外部框架邊緣的矩形。

##  <a name="getpanelist"></a>  CDockingManager::GetPaneList

傳回一份窗格隸屬於停駐的管理員。 這包括所有浮動窗格。

```
void GetPaneList(
    CObList& lstBars,
    BOOL bIncludeAutohide = FALSE,
    CRuntimeClass* pRTCFilter = NULL,
    BOOL bIncludeTabs = FALSE);
```

### <a name="parameters"></a>參數

*lstBars*<br/>
[in、 out]包含目前停駐的管理員的所有窗格。

*bIncludeAutohide*<br/>
[in]True 表示要包含 [自動隱藏模式;] 窗格否則為 FALSE。

*pRTCFilter*<br/>
[in]如果不是 NULL，傳回的清單會包含只有指定的執行階段類別的窗格。

*bIncludeTabs*<br/>
[in]True 表示要包含的索引標籤;否則為 FALSE。

### <a name="remarks"></a>備註

如果停駐的管理員中有任何索引標籤式的窗格，方法會傳回指標[CBaseTabbedPane 類別](../../mfc/reference/cbasetabbedpane-class.md)物件，您必須 索引標籤列舉明確。

使用*pRTCFilter*來取得特定類別的窗格。 比方說，您可以適當地設定此值來取得只有工具列。

##  <a name="getsmartdockingmanager"></a>  CDockingManager::GetSmartDockingManager

擷取智慧停駐的管理員的指標。

```
CSmartDockingManager* GetSmartDockingManager();
```

### <a name="return-value"></a>傳回值

智慧停駐的管理員指標。

##  <a name="getsmartdockingmanagerpermanent"></a>  CDockingManager::GetSmartDockingManagerPermanent

擷取智慧停駐的管理員的指標。

```
CSmartDockingManager* GetSmartDockingManagerPermanent() const;
```

### <a name="return-value"></a>傳回值

智慧停駐的管理員指標。

##  <a name="getsmartdockingparams"></a>  CDockingManager::GetSmartDockingParams

智慧停駐的參數傳回停駐的管理員。

```
static CSmartDockingInfo& GetSmartDockingParams();
```

### <a name="return-value"></a>傳回值

包含目前停駐的管理員智慧停駐參數類別。 如需詳細資訊，請參閱 < [CSmartDockingInfo 類別](../../mfc/reference/csmartdockinginfo-class.md)。

### <a name="remarks"></a>備註

##  <a name="hideautohidepanes"></a>  CDockingManager::HideAutoHidePanes

隱藏自動隱藏模式中的窗格。

```
void HideAutoHidePanes(
    CDockablePane* pBarToExclude = NULL,
    BOOL bImmediately = FALSE);
```

### <a name="parameters"></a>參數

*pBarToExclude*<br/>
[in]若要排除隱藏列的指標。

*bImmediately*<br/>
[in]若要立即; 隱藏窗格，則為 TRUE若要隱藏窗格中的，使用 [自動隱藏] 效果，則為 FALSE。

##  <a name="insertdocksite"></a>  CDockingManager::InsertDockSite

建立停駐窗格，並將它插入控制列清單。

```
BOOL InsertDockSite(
    const AFX_DOCKSITE_INFO& info,
    DWORD dwAlignToInsertAfter,
    CDockSite** ppDockBar = NULL);
```

### <a name="parameters"></a>參數

*info*<br/>
[in]結構，其中包含 [dock] 窗格中的對齊方式資訊。

*dwAlignToInsertAfter*<br/>
[in]停駐窗格的對齊方式。

*ppDockBar*<br/>
[out]將停駐窗格的指標的指標。

### <a name="return-value"></a>傳回值

如果停駐窗格建立成功;，則為 TRUE。FALSE 否則。

##  <a name="insertpane"></a>  CDockingManager::InsertPane

控制項窗格插入控制列清單。

```
BOOL InsertPane(
    CBasePane* pControlBar,
    CBasePane* pTarget,
    BOOL bAfter = TRUE);
```

### <a name="parameters"></a>參數

*pControlBar*<br/>
[in]指向控制項窗格的指標。

*pTarget*<br/>
[in]指向的目標窗格。

*bAfter*<br/>
[in]插入窗格的 [目標] 窗格中; 位置之後，則為 TRUEFALSE 否則。

### <a name="return-value"></a>傳回值

如果控制項窗格已成功新增至控制列; 的清單，則為 TRUE。FALSE 否則。

### <a name="remarks"></a>備註

如果 [控制項] 窗格已經在清單中的控制列，或控制列清單中沒有 [目標] 窗格中，則這個方法會傳回 false。

##  <a name="isdocksitemenu"></a>  CDockingManager::IsDockSiteMenu

指定的所有窗格的標題是否顯示快顯功能表。

```
static BOOL IsDockSiteMenu();
```

### <a name="return-value"></a>傳回值

如果停駐網站的功能表會顯示所有的停駐窗格; 的原文字幕，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

您可以藉由呼叫停駐的 [網站] 功能表[CDockingManager::EnableDockSiteMenu](#enabledocksitemenu)。

##  <a name="isinadjustlayout"></a>  CDockingManager::IsInAdjustLayout

決定所有窗格的配置會進行調整。

```
BOOL IsInAdjustLayout() const;
```

### <a name="return-value"></a>傳回值

如果所有窗格的配置會進行調整;，則為 TRUE。FALSE 否則。

##  <a name="isolecontainermode"></a>  CDockingManager::IsOLEContainerMode

指定是否停駐的管理員為 OLE 容器模式。

```
BOOL IsOLEContainerMode() const;
```

### <a name="return-value"></a>傳回值

如果停駐的管理員為 OLE 容器模式，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

在 OLE 容器模式中，會隱藏所有停駐窗格和應用程式工具列。 如果您已將窗格也會在此模式中隱藏[CDockingManager::m_bHideDockingBarsInContainerMode](#m_bhidedockingbarsincontainermode)設為 TRUE。

##  <a name="ispointneardocksite"></a>  CDockingManager::IsPointNearDockSite

判斷指定的點是否停駐位置附近。

```
BOOL IsPointNearDockSite(
    CPoint point,
    DWORD& dwBarAlignment,
    BOOL& bOuterEdge) const;
```

### <a name="parameters"></a>參數

*point*<br/>
[in]指定的點。

*dwBarAlignment*<br/>
[out]指定的點是附近的邊緣。 可能的值為 CBRS_ALIGN_LEFT、 CBRS_ALIGN_RIGHT、 CBRS_ALIGN_TOP 和 CBRS_ALIGN_BOTTOM。

*bOuterEdge*<br/>
[out]如果 point 為附近的停駐站台，其外部框線，則為 TRUE。FALSE 否則。

### <a name="return-value"></a>傳回值

如果 point 為附近的停駐網站;，則為 TRUE。否則為 FALSE。

##  <a name="isprintpreviewvalid"></a>  CDockingManager::IsPrintPreviewValid

判斷是否設定預覽列印模式。

```
BOOL IsPrintPreviewValid() const;
```

### <a name="return-value"></a>傳回值

如果已設定 預覽列印模式，則為 TRUEFALSE 否則。

##  <a name="loadstate"></a>  CDockingManager::LoadState

從登錄載入停駐的管理員狀態。

```
virtual BOOL LoadState(
    LPCTSTR lpszProfileName = NULL,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>參數

*lpszProfileName*<br/>
[in]設定檔名稱。

*uiID*<br/>
[in]停駐的管理員識別碼。

### <a name="return-value"></a>傳回值

如果停駐的管理員狀態載入成功，則為 TRUE否則為 FALSE。

##  <a name="lockupdate"></a>  CDockingManager::LockUpdate

鎖定指定的視窗。

```
void LockUpdate(BOOL bLock);
```

### <a name="parameters"></a>參數

*bLock*<br/>
[in]如果視窗已鎖定，則為 TRUEFALSE 否則。

### <a name="remarks"></a>備註

當鎖定視窗時，無法移動，而且無法重新繪製。

##  <a name="m_bhidedockingbarsincontainermode"></a>  CDockingManager::m_bHideDockingBarsInContainerMode

指定是否停駐的管理員，將會隱藏 OLE 容器模式下的窗格。

```
AFX_IMPORT_DATA static BOOL m_bHideDockingBarsInContainerMode;
```

### <a name="remarks"></a>備註

如果您想要保留所有 OLE 容器模式中的應用程式時，停駐於主框架顯示的窗格，請將此值設定為 FALSE。 根據預設，這個值會是 TRUE。

##  <a name="m_dockmodeglobal"></a>  CDockingManager::m_dockModeGlobal

指定的全域停駐的模式。

```
AFX_IMPORT_DATA static AFX_DOCK_TYPE m_dockModeGlobal;
```

### <a name="remarks"></a>備註

根據預設，每個停駐窗格會使用此停駐的模式。 如需有關這個欄位可以設定為值的詳細資訊，請參閱[cbasepane:: Getdockingmode](../../mfc/reference/cbasepane-class.md#getdockingmode)。

##  <a name="m_ndocksensitivity"></a>  CDockingManager::m_nDockSensitivity

指定停駐的敏感度。

```
AFX_IMPORT_DATA static int m_nDockSensitivity;
```

### <a name="remarks"></a>備註

停駐的敏感度定義如何關閉浮動窗格可以方法的停駐窗格、 停駐的站台或另一個窗格，然後才架構變更其狀態，以停駐。

##  <a name="m_ntimeoutbeforedockingbardock"></a>  CDockingManager::m_nTimeOutBeforeDockingBarDock

之前的停駐窗格停駐在停駐的即時模式中，指定時間，以毫秒為單位。

```
static UINT m_nTimeOutBeforeDockingBarDock;
```

### <a name="remarks"></a>備註

停駐窗格時，架構會等候指定的時間長度。 這可防止不小心停駐的位置而使用者仍拖曳窗格。

##  <a name="m_ntimeoutbeforetoolbardock"></a>  CDockingManager::m_nTimeOutBeforeToolBarDock

工具列停駐於主框架視窗之前，請指定時間，以毫秒為單位。

```
static UINT m_nTimeOutBeforeToolBarDock;
```

### <a name="remarks"></a>備註

工具列停駐之前，此架構會等候指定的時間長度。 這可防止不小心停駐的位置而使用者仍拖曳工具列。

##  <a name="onactivateframe"></a>  CDockingManager::OnActivateFrame

框架視窗變成使用中或已停用時由架構呼叫。

```
virtual void OnActivateFrame(BOOL bActivate);
```

### <a name="parameters"></a>參數

*bActivate*<br/>
[in]如果為 TRUE，框架視窗會變成作用;如果為 FALSE，框架視窗會停用。

##  <a name="onclosepopupmenu"></a>  CDockingManager::OnClosePopupMenu

架構在作用中的快顯功能表處理 WM_DESTROY 訊息時所呼叫。

```
void OnClosePopupMenu();
```

### <a name="remarks"></a>備註

要關閉目前的主視窗時，架構就會傳送 WM_DESTROY 訊息。 覆寫此方法以處理來自通知`CMFCPopupMenu`屬於框架視窗物件時`CMFCPopupMenu`物件處理 WM_DESTROY 訊息。

##  <a name="onmoveminiframe"></a>  CDockingManager::OnMoveMiniFrame

由架構呼叫以移動迷你框架視窗。

```
virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
```

### <a name="parameters"></a>參數

*pFrame*<br/>
[in]迷你框架視窗的指標。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE。否則為 FALSE。

##  <a name="onpanecontextmenu"></a>  CDockingManager::OnPaneContextMenu

建置一個功能表，並有一份窗格時，由架構呼叫。

```
void OnPaneContextMenu(CPoint point);
```

### <a name="parameters"></a>參數

*point*<br/>
[in]指定功能表的位置。

##  <a name="panefrompoint"></a>  CDockingManager::PaneFromPoint

傳回包含指定的點的窗格。

```
virtual CBasePane* PaneFromPoint(
    CPoint point,
    int nSensitivity,
    bool bExactBar = false,
    CRuntimeClass* pRTCBarType = NULL,
    BOOL bCheckVisibility = FALSE,
    const CBasePane* pBarToIgnore = NULL) const;

virtual CBasePane* PaneFromPoint(
    CPoint point,
    int nSensitivity,
    DWORD& dwAlignment,
    CRuntimeClass* pRTCBarType = NULL,
    const CBasePane* pBarToIgnore = NULL) const;
```

### <a name="parameters"></a>參數

*point*<br/>
[in]指定的點，若要檢查的螢幕座標。

*nSensitivity*<br/>
[in]要擴充的每個已檢查的窗格視窗矩形的值。 如果給的定點位於此擴大的區域中，窗格會符合搜尋準則。

*bExactBar*<br/>
[in]TRUE 表示忽略*nSensitivity*參數; 否則為 FALSE。

*pRTCBarType*<br/>
[in]如果不是 NULL，則該方法會搜尋指定之型別的窗格。

*bCheckVisibility*<br/>
[in]若要檢查可見窗格; TRUE否則為 FALSE。

*dwAlignment*<br/>
[out]如果指定點上找到一個窗格，則此參數會包含已最接近指定點窗格。 如需詳細資訊，請參閱＜備註＞一節。

*pBarToIgnore*<br/>
[in]如果不是 NULL，則這個方法會忽略此參數所指定的窗格。

### <a name="return-value"></a>傳回值

[CBasePane](../../mfc/reference/cbasepane-class.md)-衍生的物件，其中包含指定的點，則為 NULL，如果找不到任何窗格。

### <a name="remarks"></a>備註

此函數會傳回，而且找不到的窗格中，當*dwAlignment*包含指定點的對齊方式。 比方說，如果點是最頂端的窗格中，接近*dwAlignment*設 CBRS_ALIGN_TOP。

##  <a name="processpanecontextmenucommand"></a>  CDockingManager::ProcessPaneContextMenuCommand

由架構呼叫來選取或清除核取方塊，針對指定的命令，並重新計算顯示窗格的配置。

```
BOOL ProcessPaneContextMenuCommand(
    UINT nID,
    int nCode,
    void* pExtra,
    AFX_CMDHANDLERINFO* pHandlerInfo);
```

### <a name="parameters"></a>參數

*nID*<br/>
[in]在功能表中的控制列識別碼。

*nCode*<br/>
[in]命令通知程式碼。

*pExtra*<br/>
[in]Void 的指標會轉換成指標`CCmdUI`如果*則 nCode*是 CN_UPDATE_COMMAND_UI。

*pHandlerInfo*<br/>
[in]資訊結構的指標。 不使用這個參數。

### <a name="return-value"></a>傳回值

則為 TRUE *pEXtra*不是 NULL 並*則 nCode*等於 CN_UPDATE_COMMAND_UI，或者如果沒有具有指定的控制列*nID*。

##  <a name="recalclayout"></a>  CDockingManager::RecalcLayout

重新計算中的控制項清單控制項的內部配置。

```
virtual void RecalcLayout(BOOL bNotify = TRUE);
```

### <a name="parameters"></a>參數

*bNotify*<br/>
[in]未使用此參數。

##  <a name="releaseemptypanecontainers"></a>  CDockingManager::ReleaseEmptyPaneContainers

釋出的空窗格中的容器。

```
void ReleaseEmptyPaneContainers();
```

##  <a name="removehiddenmditabbedbar"></a>  CDockingManager::RemoveHiddenMDITabbedBar

移除指定的列窗格隱藏項目。

```
void RemoveHiddenMDITabbedBar(CDockablePane* pBar);
```

### <a name="parameters"></a>參數

*pBar*<br/>
[in]指標為橫條窗格，即可移除。

##  <a name="removeminiframe"></a>  CDockingManager::RemoveMiniFrame

從迷你框架的清單中移除指定的範圍。

```
virtual BOOL RemoveMiniFrame(CPaneFrameWnd* pWnd);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
[in]若要移除的畫面格指標。

### <a name="return-value"></a>傳回值

如果已移除指定的範圍;，則為 TRUE。FALSE 否則。

##  <a name="removepanefromdockmanager"></a>  CDockingManager::RemovePaneFromDockManager

取消註冊窗格，並從停駐的管理員在清單中移除。

```
void RemovePaneFromDockManager(
    CBasePane* pWnd,
    BOOL bDestroy,
    BOOL bAdjustLayout,
    BOOL bAutoHide = FALSE,
    CBasePane* pBarReplacement = NULL);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
[in]指標，要移除的窗格。

*bDestroy*<br/>
[in]如果為 TRUE，就會終結移除的窗格。

*bAdjustLayout*<br/>
[in]如果為 TRUE，請立即調整停駐的配置。

*bAutoHide*<br/>
[in]如果為 TRUE，窗格會從自動隱藏列清單中移除。 如果為 FALSE，窗格會移除從清單中的 [一般] 窗格中。

*pBarReplacement*<br/>
[in]指標，會取代 [移除] 窗格的窗格。

##  <a name="replacepane"></a>  CDockingManager::ReplacePane

以一個窗格取代另一個。

```
BOOL ReplacePane(
    CDockablePane* pOriginalBar,
    CDockablePane* pNewBar);
```

### <a name="parameters"></a>參數

*pOriginalBar*<br/>
[in]到 [原始] 窗格的指標。

*pNewBar*<br/>
[in]指標，會取代原始的窗格的窗格。

### <a name="return-value"></a>傳回值

如果成功取代窗格;，則為 TRUE。FALSE 否則。

##  <a name="resortminiframesforzorder"></a>  CDockingManager::ResortMiniFramesForZOrder

訴諸迷你框架的清單中的框架。

```
void ResortMiniFramesForZOrder();
```

##  <a name="savestate"></a>  CDockingManager::SaveState

將停駐的管理員狀態儲存至登錄中。

```
virtual BOOL SaveState(
    LPCTSTR lpszProfileName = NULL,
    UINT uiID = (UINT) -1);
```

### <a name="parameters"></a>參數

*lpszProfileName*<br/>
[in]登錄機碼路徑。

*uiID*<br/>
[in]停駐的管理員識別碼。

### <a name="return-value"></a>傳回值

如果已成功; 儲存狀態，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

儲存至登錄的停駐的管理員狀態包括儲存控制列的狀態、 自動隱藏列的狀態和狀態的停駐的管理員中的迷你框架。

##  <a name="sendmessagetominiframes"></a>  CDockingManager::SendMessageToMiniFrames

將指定的訊息傳送至所有的迷你框架中。

```
BOOL SendMessageToMiniFrames(
    UINT uMessage,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*uMessage*<br/>
[in]要傳送的訊息。

*wParam*<br/>
[in]額外的訊息相關的資訊。

*lParam*<br/>
[in]額外的訊息相關的資訊。

### <a name="return-value"></a>傳回值

永遠為 TRUE。

##  <a name="serialize"></a>  CDockingManager::Serialize

寫入封存中的停駐的管理員。

```
void Serialize(CArchive& ar);
```

### <a name="parameters"></a>參數

*ar*<br/>
[in]封存物件的參考。

### <a name="remarks"></a>備註

停駐的管理員寫入封存，牽涉到決定停駐控制列和滑桿，和寫入封存中的控制列、 迷你框架、 自動隱藏列和 MDI 索引標籤式列的數目。

##  <a name="setautohidezorder"></a>  CDockingManager::SetAutohideZOrder

設定大小、 寬度和高度的控制列和指定的窗格。

```
void SetAutohideZOrder(CDockablePane* pAHDockingBar);
```

### <a name="parameters"></a>參數

*pAHDockingBar*<br/>
[in]指標，可停駐窗格。

##  <a name="setdockingmode"></a>  CDockingManager::SetDockingMode

設定固定的模式。

```
static void SetDockingMode(
    AFX_DOCK_TYPE dockMode,
    AFX_SMARTDOCK_THEME theme = AFX_SDT_DEFAULT);
```

### <a name="parameters"></a>參數

*dockMode*<br/>
指定新的停駐模式。 如需詳細資訊，請參閱＜備註＞一節。

*theme*<br/>
指定要用於智慧停駐標記的佈景主題。 它可以是下列的列舉值之一：AFX_SDT_DEFAULT, AFX_SDT_VS2005, AFX_SDT_VS2008.

### <a name="remarks"></a>備註

呼叫此靜態方法，以設定固定的模式。

*dockMode*可以是下列值之一：

- DT_STANDARD-標準停駐的模式，是在 Visual Studio.NET 2003年中實作。 拖曳窗格沒有拖曳的內容。

- DT_IMMEDIATE-即時停駐的模式，為 Microsoft Visio 中實作。 拖曳窗格拖曳內容，但會顯示任何標記。

- DT_SMART-智慧停駐的模式，是在 Visual Studio 2005 中實作。 拖曳窗格拖曳內容，並顯示智慧標記會顯示可以停駐窗格的位置。

##  <a name="setdockstate"></a>  CDockingManager::SetDockState

設定停駐控制列、 迷你框架，以及自動隱藏列的狀態。

```
virtual void SetDockState();
```

##  <a name="setprintpreviewmode"></a>  CDockingManager::SetPrintPreviewMode

設定的預覽列印模式會在預覽列印中顯示的橫條。

```
void SetPrintPreviewMode(
    BOOL bPreview,
    CPrintPreviewState* pState);
```

### <a name="parameters"></a>參數

*bPreview*<br/>
[in]如果已設定預覽列印模式，則為 TRUEFALSE 否則。

*pState*<br/>
[in]預覽狀態的指標。 不使用這個參數。

##  <a name="setsmartdockingparams"></a>  CDockingManager::SetSmartDockingParams

設定可定義智慧停駐行為的參數。

```
static void SetSmartDockingParams(CSmartDockingInfo& params);
```

### <a name="parameters"></a>參數

*params*<br/>
[in、 out]定義智慧停駐的參數。

### <a name="remarks"></a>備註

如果您想要自訂外觀、 色彩或智慧停駐標記的形狀，請呼叫這個方法。

若要使用智慧停駐標記的預設外觀，傳遞初始化的執行個體的[CSmartDockingInfo 類別](../../mfc/reference/csmartdockinginfo-class.md)要*params*。

##  <a name="showdelayshowminiframes"></a>  CDockingManager::ShowDelayShowMiniFrames

顯示或隱藏的迷你框架視窗。

```
void ShowDelayShowMiniFrames(BOOL bshow);
```

### <a name="parameters"></a>參數

*bShow*<br/>
[in]若要啟用顯示框架的視窗;，則為 TRUE若要隱藏的框架視窗，則為 FALSE。

##  <a name="showpanes"></a>  CDockingManager::ShowPanes

顯示或隱藏控制項，並自動隱藏列的窗格。

```
virtual BOOL ShowPanes(BOOL bShow);
```

### <a name="parameters"></a>參數

*bShow*<br/>
[in]若要顯示的窗格中，則為 TRUE如果為 false，則隱藏窗格。

### <a name="return-value"></a>傳回值

永遠為 FALSE。

##  <a name="startsdocking"></a>  CDockingManager::StartSDocking

啟動指定的視窗，根據智慧停駐的管理員的對齊方式智慧停駐。

```
void StartSDocking(CWnd* pDockingWnd);
```

### <a name="parameters"></a>參數

*pDockingWnd*<br/>
[in]若要停駐視窗的指標。

##  <a name="stopsdocking"></a>  CDockingManager::StopSDocking

停駐點智慧停駐。

```
void StopSDocking();
```

##  <a name="getsmartdockingtheme"></a>  CDockingManager::GetSmartDockingTheme

傳回用來顯示智慧停駐標記佈景主題的靜態方法。

```
static AFX_SMARTDOCK_THEME __stdcall GetSmartDockingTheme();
```

### <a name="return-value"></a>傳回值

會傳回下列的列舉值之一：AFX_SDT_DEFAULT, AFX_SDT_VS2005, AFX_SDT_VS2008.

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[類別](../../mfc/reference/mfc-classes.md)<br/>
[CObject 類別](../../mfc/reference/cobject-class.md)<br/>
[CFrameWndEx 類別](../../mfc/reference/cframewndex-class.md)<br/>
[CDockablePane 類別](../../mfc/reference/cdockablepane-class.md)<br/>
[CPaneFrameWnd 類別](../../mfc/reference/cpaneframewnd-class.md)
