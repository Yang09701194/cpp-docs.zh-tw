---
title: COleClientItem 類別
ms.date: 07/02/2019
f1_keywords:
- COleClientItem
- AFXOLE/COleClientItem
- AFXOLE/COleClientItem::COleClientItem
- AFXOLE/COleClientItem::Activate
- AFXOLE/COleClientItem::ActivateAs
- AFXOLE/COleClientItem::AttachDataObject
- AFXOLE/COleClientItem::CanCreateFromData
- AFXOLE/COleClientItem::CanCreateLinkFromData
- AFXOLE/COleClientItem::CanPaste
- AFXOLE/COleClientItem::CanPasteLink
- AFXOLE/COleClientItem::Close
- AFXOLE/COleClientItem::ConvertTo
- AFXOLE/COleClientItem::CopyToClipboard
- AFXOLE/COleClientItem::CreateCloneFrom
- AFXOLE/COleClientItem::CreateFromClipboard
- AFXOLE/COleClientItem::CreateFromData
- AFXOLE/COleClientItem::CreateFromFile
- AFXOLE/COleClientItem::CreateLinkFromClipboard
- AFXOLE/COleClientItem::CreateLinkFromData
- AFXOLE/COleClientItem::CreateLinkFromFile
- AFXOLE/COleClientItem::CreateNewItem
- AFXOLE/COleClientItem::CreateStaticFromClipboard
- AFXOLE/COleClientItem::CreateStaticFromData
- AFXOLE/COleClientItem::Deactivate
- AFXOLE/COleClientItem::DeactivateUI
- AFXOLE/COleClientItem::Delete
- AFXOLE/COleClientItem::DoDragDrop
- AFXOLE/COleClientItem::DoVerb
- AFXOLE/COleClientItem::Draw
- AFXOLE/COleClientItem::GetActiveView
- AFXOLE/COleClientItem::GetCachedExtent
- AFXOLE/COleClientItem::GetClassID
- AFXOLE/COleClientItem::GetClipboardData
- AFXOLE/COleClientItem::GetDocument
- AFXOLE/COleClientItem::GetDrawAspect
- AFXOLE/COleClientItem::GetExtent
- AFXOLE/COleClientItem::GetIconFromRegistry
- AFXOLE/COleClientItem::GetIconicMetafile
- AFXOLE/COleClientItem::GetInPlaceWindow
- AFXOLE/COleClientItem::GetItemState
- AFXOLE/COleClientItem::GetLastStatus
- AFXOLE/COleClientItem::GetLinkUpdateOptions
- AFXOLE/COleClientItem::GetType
- AFXOLE/COleClientItem::GetUserType
- AFXOLE/COleClientItem::IsInPlaceActive
- AFXOLE/COleClientItem::IsLinkUpToDate
- AFXOLE/COleClientItem::IsModified
- AFXOLE/COleClientItem::IsOpen
- AFXOLE/COleClientItem::IsRunning
- AFXOLE/COleClientItem::OnActivate
- AFXOLE/COleClientItem::OnActivateUI
- AFXOLE/COleClientItem::OnChange
- AFXOLE/COleClientItem::OnDeactivate
- AFXOLE/COleClientItem::OnDeactivateUI
- AFXOLE/COleClientItem::OnGetClipboardData
- AFXOLE/COleClientItem::OnInsertMenus
- AFXOLE/COleClientItem::OnRemoveMenus
- AFXOLE/COleClientItem::OnSetMenu
- AFXOLE/COleClientItem::OnShowControlBars
- AFXOLE/COleClientItem::OnUpdateFrameTitle
- AFXOLE/COleClientItem::ReactivateAndUndo
- AFXOLE/COleClientItem::Release
- AFXOLE/COleClientItem::Reload
- AFXOLE/COleClientItem::Run
- AFXOLE/COleClientItem::SetDrawAspect
- AFXOLE/COleClientItem::SetExtent
- AFXOLE/COleClientItem::SetHostNames
- AFXOLE/COleClientItem::SetIconicMetafile
- AFXOLE/COleClientItem::SetItemRects
- AFXOLE/COleClientItem::SetLinkUpdateOptions
- AFXOLE/COleClientItem::SetPrintDevice
- AFXOLE/COleClientItem::UpdateLink
- AFXOLE/COleClientItem::CanActivate
- AFXOLE/COleClientItem::OnChangeItemPosition
- AFXOLE/COleClientItem::OnDeactivateAndUndo
- AFXOLE/COleClientItem::OnDiscardUndoState
- AFXOLE/COleClientItem::OnGetClipRect
- AFXOLE/COleClientItem::OnGetItemPosition
- AFXOLE/COleClientItem::OnGetWindowContext
- AFXOLE/COleClientItem::OnScrollBy
- AFXOLE/COleClientItem::OnShowItem
helpviewer_keywords:
- COleClientItem [MFC], COleClientItem
- COleClientItem [MFC], Activate
- COleClientItem [MFC], ActivateAs
- COleClientItem [MFC], AttachDataObject
- COleClientItem [MFC], CanCreateFromData
- COleClientItem [MFC], CanCreateLinkFromData
- COleClientItem [MFC], CanPaste
- COleClientItem [MFC], CanPasteLink
- COleClientItem [MFC], Close
- COleClientItem [MFC], ConvertTo
- COleClientItem [MFC], CopyToClipboard
- COleClientItem [MFC], CreateCloneFrom
- COleClientItem [MFC], CreateFromClipboard
- COleClientItem [MFC], CreateFromData
- COleClientItem [MFC], CreateFromFile
- COleClientItem [MFC], CreateLinkFromClipboard
- COleClientItem [MFC], CreateLinkFromData
- COleClientItem [MFC], CreateLinkFromFile
- COleClientItem [MFC], CreateNewItem
- COleClientItem [MFC], CreateStaticFromClipboard
- COleClientItem [MFC], CreateStaticFromData
- COleClientItem [MFC], Deactivate
- COleClientItem [MFC], DeactivateUI
- COleClientItem [MFC], Delete
- COleClientItem [MFC], DoDragDrop
- COleClientItem [MFC], DoVerb
- COleClientItem [MFC], Draw
- COleClientItem [MFC], GetActiveView
- COleClientItem [MFC], GetCachedExtent
- COleClientItem [MFC], GetClassID
- COleClientItem [MFC], GetClipboardData
- COleClientItem [MFC], GetDocument
- COleClientItem [MFC], GetDrawAspect
- COleClientItem [MFC], GetExtent
- COleClientItem [MFC], GetIconFromRegistry
- COleClientItem [MFC], GetIconicMetafile
- COleClientItem [MFC], GetInPlaceWindow
- COleClientItem [MFC], GetItemState
- COleClientItem [MFC], GetLastStatus
- COleClientItem [MFC], GetLinkUpdateOptions
- COleClientItem [MFC], GetType
- COleClientItem [MFC], GetUserType
- COleClientItem [MFC], IsInPlaceActive
- COleClientItem [MFC], IsLinkUpToDate
- COleClientItem [MFC], IsModified
- COleClientItem [MFC], IsOpen
- COleClientItem [MFC], IsRunning
- COleClientItem [MFC], OnActivate
- COleClientItem [MFC], OnActivateUI
- COleClientItem [MFC], OnChange
- COleClientItem [MFC], OnDeactivate
- COleClientItem [MFC], OnDeactivateUI
- COleClientItem [MFC], OnGetClipboardData
- COleClientItem [MFC], OnInsertMenus
- COleClientItem [MFC], OnRemoveMenus
- COleClientItem [MFC], OnSetMenu
- COleClientItem [MFC], OnShowControlBars
- COleClientItem [MFC], OnUpdateFrameTitle
- COleClientItem [MFC], ReactivateAndUndo
- COleClientItem [MFC], Release
- COleClientItem [MFC], Reload
- COleClientItem [MFC], Run
- COleClientItem [MFC], SetDrawAspect
- COleClientItem [MFC], SetExtent
- COleClientItem [MFC], SetHostNames
- COleClientItem [MFC], SetIconicMetafile
- COleClientItem [MFC], SetItemRects
- COleClientItem [MFC], SetLinkUpdateOptions
- COleClientItem [MFC], SetPrintDevice
- COleClientItem [MFC], UpdateLink
- COleClientItem [MFC], CanActivate
- COleClientItem [MFC], OnChangeItemPosition
- COleClientItem [MFC], OnDeactivateAndUndo
- COleClientItem [MFC], OnDiscardUndoState
- COleClientItem [MFC], OnGetClipRect
- COleClientItem [MFC], OnGetItemPosition
- COleClientItem [MFC], OnGetWindowContext
- COleClientItem [MFC], OnScrollBy
- COleClientItem [MFC], OnShowItem
ms.assetid: 7f571b7c-2758-4839-847a-0cf1ef643128
ms.openlocfilehash: ce321c9709b752602a664142f283884f4d17b50b
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/22/2020
ms.locfileid: "81753969"
---
# <a name="coleclientitem-class"></a>COleClientItem 類別

定義 OLE 項目的容器介面。

## <a name="syntax"></a>語法

```
class COleClientItem : public CDocItem
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[COleClientItem：： COleClientItem](#coleclientitem)|建構 `COleClientItem` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[COleClientItem：： Activate](#activate)|開啟作業的 OLE 專案，然後執行指定的動詞。|
|[COleClientItem：： ActivateAs](#activateas)|以另一種類型的形式啟動專案。|
|[COleClientItem：： AttachDataObject](#attachdataobject)|存取 OLE 物件中的資料。|
|[COleClientItem：： CanCreateFromData](#cancreatefromdata)|指出容器應用程式是否可以建立内嵌物件。|
|[COleClientItem：： CanCreateLinkFromData](#cancreatelinkfromdata)|指出容器應用程式是否可以建立連結化物件。|
|[COleClientItem：： CanPaste](#canpaste)|指出剪貼簿是否包含可嵌入或靜態的 OLE 專案。|
|[COleClientItem：： CanPasteLink](#canpastelink)|指出剪貼簿是否包含可連結的 OLE 專案。|
|[COleClientItem：： Close](#close)|關閉伺服器的連結，但不會摧毀 OLE 專案。|
|[COleClientItem：： Convertto-html](#convertto)|將專案轉換成另一個類型。|
|[COleClientItem：： CopyToClipboard](#copytoclipboard)|將 OLE 專案複製到剪貼簿。|
|[COleClientItem：： CreateCloneFrom](#createclonefrom)|建立現有專案的複本。|
|[COleClientItem：： CreateFromClipboard](#createfromclipboard)|從剪貼簿建立內嵌專案。|
|[COleClientItem：： CreateFromData](#createfromdata)|從資料物件建立內嵌專案。|
|[COleClientItem：： CreateFromFile](#createfromfile)|從檔案建立內嵌專案。|
|[COleClientItem：： CreateLinkFromClipboard](#createlinkfromclipboard)|從剪貼簿建立連結專案。|
|[COleClientItem：： CreateLinkFromData](#createlinkfromdata)|從資料物件建立連結專案。|
|[COleClientItem：： CreateLinkFromFile](#createlinkfromfile)|從檔案建立連結專案。|
|[COleClientItem：： CreateNewItem](#createnewitem)|藉由啟動伺服器應用程式，建立新的內嵌專案。|
|[COleClientItem：： CreateStaticFromClipboard](#createstaticfromclipboard)|從剪貼簿建立靜態專案。|
|[COleClientItem：： CreateStaticFromData](#createstaticfromdata)|從資料物件建立靜態專案。|
|[COleClientItem：:D eactivate](#deactivate)|停用專案。|
|[COleClientItem：:D eactivateUI](#deactivateui)|將容器應用程式的使用者介面還原成其原始狀態。|
|[COleClientItem：:D 刪除](#delete)|刪除或關閉 OLE 專案（如果它是連結專案的話）。|
|[COleClientItem：:D oDragDrop](#dodragdrop)|執行拖放作業。|
|[COleClientItem：:D oVerb](#doverb)|執行指定的動詞。|
|[COleClientItem：:D raw](#draw)|繪製 OLE 專案。|
|[COleClientItem：： GetActiveView](#getactiveview)|取得專案已就地啟動的視圖。|
|[COleClientItem：： GetCachedExtent](#getcachedextent)|傳回 OLE 專案矩形的界限。|
|[COleClientItem：： GetClassID](#getclassid)|取得目前專案的類別識別碼。|
|[COleClientItem：： GetClipboardData](#getclipboarddata)|藉由呼叫`CopyToClipboard`成員函式，取得要放在剪貼簿上的資料。|
|[COleClientItem：： GetDocument](#getdocument)|傳回包含`COleDocument`目前專案的物件。|
|[COleClientItem：： GetDrawAspect](#getdrawaspect)|取得專案目前的呈現視圖。|
|[COleClientItem：： GetExtent](#getextent)|傳回 OLE 專案矩形的界限。|
|[COleClientItem：： GetIconFromRegistry](#geticonfromregistry)|抓取與特定 CLSID 伺服器相關聯之圖示的控制碼。|
|[COleClientItem：： GetIconicMetafile](#geticonicmetafile)|取得用來繪製專案圖示的中繼檔。|
|[COleClientItem：： GetInPlaceWindow](#getinplacewindow)|傳回專案之就地編輯視窗的指標。|
|[COleClientItem：： GetItemState](#getitemstate)|取得專案的目前狀態。|
|[COleClientItem：： GetLastStatus](#getlaststatus)|傳回上一個 OLE 作業的狀態。|
|[COleClientItem：： GetLinkUpdateOptions](#getlinkupdateoptions)|傳回連結專案的更新模式（「高級功能」）。|
|[COleClientItem：： GetType](#gettype)|傳回 OLE 專案的類型（內嵌、連結或靜態）。|
|[COleClientItem：： GetUserType](#getusertype)|取得描述專案類型的字串。|
|[COleClientItem：： IsInPlaceActive](#isinplaceactive)|如果專案為就地啟用，則傳回 TRUE。|
|[COleClientItem：： IsLinkUpToDate](#islinkuptodate)|如果連結的專案與來源文件保持在最新的狀態，則傳回 TRUE。|
|[COleClientItem：： IsModified](#ismodified)|如果專案自上次儲存後已經過修改，則傳回 TRUE。|
|[COleClientItem：： IsOpen](#isopen)|如果專案目前在伺服器應用程式中開啟，則傳回 TRUE。|
|[COleClientItem：： IsRunning](#isrunning)|如果專案的伺服器應用程式正在執行，則傳回 TRUE。|
|[COleClientItem：： OnActivate](#onactivate)|由架構呼叫以通知專案已啟用它。|
|[COleClientItem：： OnActivateUI](#onactivateui)|由架構呼叫，以通知專案其已啟動，應該顯示其使用者介面。|
|[COleClientItem：： OnChange](#onchange)|當伺服器變更 OLE 專案時呼叫。 需要執行。|
|[COleClientItem：： OnDeactivate](#ondeactivate)|當專案停用時由架構呼叫。|
|[COleClientItem：： OnDeactivateUI](#ondeactivateui)|當伺服器已移除其就地使用者介面時，由架構呼叫。|
|[COleClientItem：： OnGetClipboardData](#ongetclipboarddata)|由架構呼叫，以取得要複製到剪貼簿的資料。|
|[COleClientItem：： OnInsertMenus](#oninsertmenus)|由架構呼叫以建立複合功能表。|
|[COleClientItem：： OnRemoveMenus](#onremovemenus)|由架構呼叫，以從複合功能表中移除容器的功能表。|
|[COleClientItem：： OnSetMenu](#onsetmenu)|由架構呼叫以安裝和移除複合功能表。|
|[COleClientItem：： OnShowControlBars](#onshowcontrolbars)|由架構呼叫以顯示和隱藏控制列。|
|[COleClientItem：： OnUpdateFrameTitle](#onupdateframetitle)|由架構呼叫以更新框架視窗的標題列。|
|[COleClientItem：： ReactivateAndUndo](#reactivateandundo)|重新啟動專案，並復原最後一個就地編輯作業。|
|[COleClientItem：： Release](#release)|釋放與 OLE 連結專案的連接，並在開啟時將它關閉。 不會損毀用戶端專案。|
|[COleClientItem：： Reload](#reload)|在呼叫之後重載專案`ActivateAs`。|
|[COleClientItem：： Run](#run)|執行與專案相關聯的應用程式。|
|[COleClientItem：： SetDrawAspect](#setdrawaspect)|設定專案目前的呈現視圖。|
|[COleClientItem：： SetExtent](#setextent)|設定 OLE 專案的周框。|
|[COleClientItem：： SetHostNames](#sethostnames)|設定當編輯 OLE 專案時，伺服器所顯示的名稱。|
|[COleClientItem：： SetIconicMetafile](#seticonicmetafile)|快取用來繪製專案圖示的中繼檔。|
|[COleClientItem：： SetItemRects](#setitemrects)|設定專案的周框。|
|[COleClientItem：： SetLinkUpdateOptions](#setlinkupdateoptions)|設定連結專案的更新模式（[advanced] 功能）。|
|[COleClientItem：： SetPrintDevice](#setprintdevice)|設定此用戶端專案的列印目標裝置。|
|[COleClientItem：： UpdateLink](#updatelink)|更新專案的呈現快取。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[COleClientItem：： CanActivate](#canactivate)|由架構呼叫以判斷是否允許就地啟用。|
|[COleClientItem：： OnChangeItemPosition](#onchangeitemposition)|當專案的位置變更時由架構呼叫。|
|[COleClientItem：： OnDeactivateAndUndo](#ondeactivateandundo)|由架構呼叫以在啟用後復原。|
|[COleClientItem：： OnDiscardUndoState](#ondiscardundostate)|由架構呼叫以捨棄專案的復原狀態資訊。|
|[COleClientItem：： OnGetClipRect](#ongetcliprect)|由架構呼叫以取得專案的裁剪矩形座標。|
|[COleClientItem：： OnGetItemPosition](#ongetitemposition)|由架構呼叫，以取得相對於視圖的專案位置。|
|[COleClientItem：： OnGetWindowCoNtext](#ongetwindowcontext)|當專案就地啟動時由架構呼叫。|
|[COleClientItem：： OnScrollBy](#onscrollby)|由架構呼叫以將專案滾動到 view。|
|[COleClientItem：： OnShowItem](#onshowitem)|由架構呼叫以顯示 OLE 專案。|

## <a name="remarks"></a>備註

OLE 專案代表由伺服器應用程式所建立和維護的資料，可以「順暢地」合併到檔中，讓使用者看起來像是單一檔。 結果是由 OLE 專案和包含檔組成的「複合檔案」。

OLE 專案可以是內嵌或連結的。 如果內嵌，其資料會儲存為複合檔案的一部分。 如果已連結，其資料會儲存為伺服器應用程式所建立之個別檔案的一部分，而且只有該檔案的連結會儲存在複合檔案中。 所有 OLE 專案都包含指定應呼叫來編輯服務器應用程式的資訊。

`COleClientItem`定義數個可覆寫的函式，這些函式會針對回應伺服器應用程式的要求而呼叫。這些 overridables 通常會作為通知。 這可讓伺服器應用程式在編輯 OLE 專案時，將使用者所做的變更通知容器，或在編輯期間取得所需的資訊。

`COleClientItem`可以與[COleDocument](../../mfc/reference/coledocument-class.md)、 [COleLinkingDoc](../../mfc/reference/colelinkingdoc-class.md)或[COleServerDoc](../../mfc/reference/coleserverdoc-class.md)類別搭配使用。 若要`COleClientItem`使用，請從它衍生類別並執行[OnChange](#onchange)成員函式，以定義容器如何回應對專案所做的變更。 若要支援就地啟用，請覆寫[OnGetItemPosition](#ongetitemposition)成員函式。 此函式會提供 OLE 專案顯示位置的相關資訊。

如需使用容器介面的詳細資訊，請參閱[容器：執行容器](../../mfc/containers-implementing-a-container.md)[和啟動](../../mfc/activation-cpp.md)文章。

> [!NOTE]
> Windows SDK 將內嵌和連結專案稱為「物件」，並將專案類型稱為「類別」。 此參考會使用「item」一詞來區分 OLE 實體與對應的 c + + 物件，以及「類型」一詞，以區別來自 c + + 類別的 OLE 類別目錄。

## <a name="inheritance-hierarchy"></a>繼承階層架構

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CDocItem](../../mfc/reference/cdocitem-class.md)

`COleClientItem`

## <a name="requirements"></a>需求

**標頭：** afxole。h

## <a name="coleclientitemactivate"></a><a name="activate"></a>COleClientItem：： Activate

呼叫此函式可執行指定的動詞，而不是[DoVerb](#doverb) ，讓您可以在擲回例外狀況時執行自己的處理。

```cpp
void Activate(
    LONG nVerb,
    CView* pView,
    LPMSG lpMsg = NULL);
```

### <a name="parameters"></a>參數

*nVerb*<br/>
指定要執行的指令動詞。 可以是下列其中一項：

|值|意義|符號|
|-----------|-------------|------------|
|-0|主動詞命令|OLEIVERB_PRIMARY|
|- 1|次要動詞|(無)|
|- 1|顯示要編輯的專案|OLEIVERB_SHOW|
|-2|在個別視窗中編輯專案|OLEIVERB_OPEN|
|-3|隱藏專案|OLEIVERB_HIDE|

-1 值通常是另一個動詞的別名。 如果不支援開啟編輯，-2 的效果會與-1 相同。 如需其他值，請參閱 Windows SDK 中的[IOleObject：:D overb](/windows/win32/api/oleidl/nf-oleidl-ioleobject-doverb) 。

*pView*<br/>
包含 OLE 專案之容器 view 視窗的指標。伺服器應用程式會使用這項功能來進行就地啟用。 如果容器不支援就地啟用，這個參數應該是 Null。

*lpMsg*<br/>
導致啟用專案之訊息的指標。

### <a name="remarks"></a>備註

如果伺服器應用程式是使用 MFC 程式庫撰寫的，此函式會[OnDoVerb](../../mfc/reference/coleserveritem-class.md#ondoverb)導致執行對應`COleServerItem`物件的 OnDoVerb 成員函式。

如果主要動詞命令是 Edit，而且在*nVerb*參數中指定了零，就會啟動伺服器應用程式，以允許編輯 OLE 專案。 如果容器應用程式支援就地啟用，則可以就地完成編輯。 如果容器不支援就地啟用（或指定了開啟的動詞），伺服器就會在另一個視窗中啟動，並可在該處完成編輯。 一般而言，當容器應用程式的使用者按兩下 OLE 專案時， *nVerb*參數中主要動詞命令的值會決定使用者可以採取的動作。 不過，如果伺服器只支援一個動作，不論在*nVerb*參數中指定哪一個值，它都會採取該動作。

如需詳細資訊，請參閱 Windows SDK 中的[IOleObject：:D overb](/windows/win32/api/oleidl/nf-oleidl-ioleobject-doverb) 。

## <a name="coleclientitemactivateas"></a><a name="activateas"></a>COleClientItem：： ActivateAs

會使用 OLE 的物件轉換功能來啟動專案，就像它是*clsidNew*所指定之類型的專案一樣。

```
virtual BOOL ActivateAs(
    LPCTSTR lpszUserType,
    REFCLSID clsidOld,
    REFCLSID clsidNew);
```

### <a name="parameters"></a>參數

*lpszUserType*<br/>
代表目標使用者類型之字串的指標，例如「Word 檔」。

*clsidOld*<br/>
專案目前類別識別碼的參考。 類別識別碼應代表實際物件的類型（如已儲存），除非它是連結。 在此情況下，它應該是連結所參考之專案的 CLSID。 [COleConvertDialog](../../mfc/reference/coleconvertdialog-class.md)會自動為專案提供正確的類別 ID。

*clsidNew*<br/>
目標類別識別碼的參考。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

這是由[COleConvertDialog：:D oconvert](../../mfc/reference/coleconvertdialog-class.md#doconvert)自動呼叫。 通常不會直接呼叫它。

## <a name="coleclientitemattachdataobject"></a><a name="attachdataobject"></a>COleClientItem：： AttachDataObject

呼叫此函式可初始化[COleDataObject](../../mfc/reference/coledataobject-class.md) ，以便存取 OLE 專案中的資料。

```cpp
void AttachDataObject(COleDataObject& rDataObject) const;
```

### <a name="parameters"></a>參數

*rDataObject*<br/>
`COleDataObject`物件的參考，將會初始化以允許存取 OLE 專案中的資料。

## <a name="coleclientitemcanactivate"></a><a name="canactivate"></a>COleClientItem：： CanActivate

當使用者要求就地啟用 OLE 專案時由架構呼叫;此函式的傳回值會決定是否允許就地啟用。

```
virtual BOOL CanActivate();
```

### <a name="return-value"></a>傳回值

如果允許就地啟用，則為非零值;否則為0。

### <a name="remarks"></a>備註

如果容器具有有效的視窗，則預設的執行允許就地啟用。 覆寫此函式，以執行接受或拒絕啟用要求的特殊邏輯。 例如，如果 OLE 專案太小或目前看不到，則會拒絕啟用要求。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceSite：： CanInPlaceActivate](/windows/win32/api/oleidl/nf-oleidl-ioleinplacesite-caninplaceactivate) 。

## <a name="coleclientitemcancreatefromdata"></a><a name="cancreatefromdata"></a>COleClientItem：： CanCreateFromData

檢查容器應用程式是否可以從指定`COleDataObject`的物件建立内嵌物件。

```
static BOOL PASCAL CanCreateFromData(const COleDataObject* pDataObject);
```

### <a name="parameters"></a>參數

*pDataObject*<br/>
要從中建立 OLE 專案之[COleDataObject](../../mfc/reference/coledataobject-class.md)物件的指標。

### <a name="return-value"></a>傳回值

如果容器可以從`COleDataObject`物件建立内嵌物件，則為非零。否則為0。

### <a name="remarks"></a>備註

在`COleDataObject`資料傳輸中，會使用類別，透過拖放或從內嵌的 OLE 專案，從剪貼簿抓取各種格式的資料。

容器可以使用此函式來決定要啟用或停用其 [編輯貼上] 和 [編輯貼上特殊] 命令。

如需詳細資訊，請參閱[資料物件和資料來源（OLE）](../../mfc/data-objects-and-data-sources-ole.md)一文。

## <a name="coleclientitemcancreatelinkfromdata"></a><a name="cancreatelinkfromdata"></a>COleClientItem：： CanCreateLinkFromData

檢查容器應用程式是否可以從指定`COleDataObject`的物件建立連結化物件。

```
static BOOL PASCAL CanCreateLinkFromData(const COleDataObject* pDataObject);
```

### <a name="parameters"></a>參數

*pDataObject*<br/>
要從中建立 OLE 專案之[COleDataObject](../../mfc/reference/coledataobject-class.md)物件的指標。

### <a name="return-value"></a>傳回值

如果容器可以從`COleDataObject`物件建立連結化物件，則為非零。

### <a name="remarks"></a>備註

在`COleDataObject`資料傳輸中，會使用類別，透過拖放或從內嵌的 OLE 專案，從剪貼簿抓取各種格式的資料。

容器可以使用此函式來決定要啟用或停用其 [編輯] [貼上特殊] 和 [編輯貼上] 連結命令。

如需詳細資訊，請參閱[資料物件和資料來源（OLE）](../../mfc/data-objects-and-data-sources-ole.md)一文。

## <a name="coleclientitemcanpaste"></a><a name="canpaste"></a>COleClientItem：： CanPaste

呼叫此函式，以查看是否可以從剪貼簿貼上內嵌的 OLE 專案。

```
static BOOL PASCAL CanPaste();
```

### <a name="return-value"></a>傳回值

如果內嵌的 OLE 專案可以從剪貼簿貼上，則為非零值。否則為0。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 Windows SDK 中的[OleGetClipboard](/windows/win32/api/ole2/nf-ole2-olegetclipboard)和[OleQueryCreateFromData](/windows/win32/api/ole2/nf-ole2-olequerycreatefromdata) 。

## <a name="coleclientitemcanpastelink"></a><a name="canpastelink"></a>COleClientItem：： CanPasteLink

呼叫此函式，以查看是否可以從剪貼簿貼上連結的 OLE 專案。

```
static BOOL PASCAL CanPasteLink();
```

### <a name="return-value"></a>傳回值

如果連結的 OLE 專案可以從剪貼簿貼入，則為非零。否則為0。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 Windows SDK 中的[OleGetClipboard](/windows/win32/api/ole2/nf-ole2-olegetclipboard)和[OleQueryLinkFromData](/windows/win32/api/ole2/nf-ole2-olequerylinkfromdata) 。

## <a name="coleclientitemclose"></a><a name="close"></a>COleClientItem：： Close

呼叫此函式可將 OLE 專案的狀態從「執行中」狀態變更為「已載入」狀態，也就是在記憶體中載入其處理常式，但伺服器未執行。

```cpp
void Close(OLECLOSE dwCloseOption = OLECLOSE_SAVEIFDIRTY);
```

### <a name="parameters"></a>參數

*dwCloseOption*<br/>
旗標，指定在何種情況下，當 OLE 專案回到載入狀態時，就會儲存該檔案。 其值可以是下列其中一個值：

- OLECLOSE_SAVEIFDIRTY 儲存 OLE 專案。

- OLECLOSE_NOSAVE 不要儲存 OLE 專案。

- OLECLOSE_PROMPTSAVE 提示使用者是否要儲存 OLE 專案。

### <a name="remarks"></a>備註

當 OLE 專案未執行時，此函式不會有任何作用。

如需詳細資訊，請參閱 Windows SDK 中的[IOleObject：： Close](/windows/win32/api/oleidl/nf-oleidl-ioleobject-close) 。

## <a name="coleclientitemcoleclientitem"></a><a name="coleclientitem"></a>COleClientItem：： COleClientItem

會建立`COleClientItem`物件，並將它加入至容器檔案的檔專案集合，這只會建立 c + + 物件，而不會執行任何 OLE 初始化。

```
COleClientItem(COleDocument* pContainerDoc = NULL);
```

### <a name="parameters"></a>參數

*pContainerDoc*<br/>
將包含此專案之容器檔案的指標。 這可以是任何[COleDocument](../../mfc/reference/coledocument-class.md)的衍生。

### <a name="remarks"></a>備註

如果您傳遞 Null 指標，則不會對容器檔案進行任何加法。 您必須明確地呼叫[COleDocument：： AddItem](../../mfc/reference/coledocument-class.md#additem)。

您必須先呼叫下列其中一個建立成員函式，才可以使用 OLE 專案：

- [CreateFromClipboard](#createfromclipboard)

- [CreateFromData](#createfromdata)

- [CreateFromFile](#createfromfile)

- [CreateStaticFromClipboard](#createstaticfromclipboard)

- [CreateStaticFromData](#createstaticfromdata)

- [CreateLinkFromClipboard](#createlinkfromclipboard)

- [CreateLinkFromData](#createlinkfromdata)

- [CreateLinkFromFile](#createlinkfromfile)

- [CreateNewItem](#createnewitem)

- [CreateCloneFrom](#createclonefrom)

## <a name="coleclientitemconvertto"></a><a name="convertto"></a>COleClientItem：： Convertto-html

呼叫這個成員函式，將專案轉換為*clsidNew*所指定的類型。

```
virtual BOOL ConvertTo(REFCLSID clsidNew);
```

### <a name="parameters"></a>參數

*clsidNew*<br/>
目標型別的類別識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

這會由[COleConvertDialog](../../mfc/reference/coleconvertdialog-class.md)自動呼叫。 不需要直接呼叫它。

## <a name="coleclientitemcopytoclipboard"></a><a name="copytoclipboard"></a>COleClientItem：： CopyToClipboard

呼叫此函式可將 OLE 專案複製到剪貼簿。

```cpp
void CopyToClipboard(BOOL bIncludeLink = FALSE);
```

### <a name="parameters"></a>參數

*bIncludeLink*<br/>
如果連結資訊應該複製到剪貼簿，允許貼上連結的專案，則為 TRUE;否則為 FALSE。

### <a name="remarks"></a>備註

一般來說，您會在針對 [編輯] 功能表中的 [複製] 或 [剪下] 命令撰寫訊息處理常式時呼叫此函式。 如果您想要執行 [複製] 或 [剪下] 命令，您必須在容器應用程式中執行專案選擇。

如需詳細資訊，請參閱 Windows SDK 中的[OleSetClipboard](/windows/win32/api/ole2/nf-ole2-olesetclipboard) 。

## <a name="coleclientitemcreateclonefrom"></a><a name="createclonefrom"></a>COleClientItem：： CreateCloneFrom

呼叫此函式可建立指定之 OLE 專案的複本。

```
BOOL CreateCloneFrom(const COleClientItem* pSrcItem);
```

### <a name="parameters"></a>參數

*pSrcItem*<br/>
要複製之 OLE 專案的指標。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

此複本與來源專案相同。 您可以使用此函數來支援復原作業。

## <a name="coleclientitemcreatefromclipboard"></a><a name="createfromclipboard"></a>COleClientItem：： CreateFromClipboard

呼叫此函式可從剪貼簿的內容建立內嵌專案。

```
BOOL CreateFromClipboard(
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

您通常會從 [編輯] 功能表上的 [貼上] 命令的訊息處理常式中呼叫此函數。 （如果[CanPaste](#canpaste)成員函式傳回非零值，則架構會啟用 [貼上] 命令）。

如需詳細資訊，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatefromdata"></a><a name="createfromdata"></a>COleClientItem：： CreateFromData

呼叫此函式可從`COleDataObject`物件建立內嵌專案。

```
BOOL CreateFromData(
    COleDataObject* pDataObject,
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*pDataObject*<br/>
要從中建立 OLE 專案之[COleDataObject](../../mfc/reference/coledataobject-class.md)物件的指標。

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

資料傳輸作業（例如從剪貼簿或拖放作業貼入）會提供`COleDataObject`物件，其中包含伺服器應用程式所提供的資訊。 它通常用於您的[CView：： system.windows.uielement.ondrop](../../mfc/reference/cview-class.md#ondrop)的覆寫。

如需詳細資訊，請參閱 Windows SDK 中的[OleCreateFromData](/windows/win32/api/ole2/nf-ole2-olecreatefromdata)、 [OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatefromfile"></a><a name="createfromfile"></a>COleClientItem：： CreateFromFile

呼叫此函式可從檔案建立內嵌的 OLE 專案。

```
BOOL CreateFromFile(
    LPCTSTR lpszFileName,
    REFCLSID clsid = CLSID_NULL,
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*lpszFileName*<br/>
要從中建立 OLE 專案之檔案名稱的指標。

*clsid*<br/>
保留供未來使用。

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

當選取 [從檔案建立] 按鈕時，如果使用者從 [插入物件] 對話方塊中選擇 [確定]，則架構會從[COleInsertDialog：： CreateItem](../../mfc/reference/coleinsertdialog-class.md#createitem)呼叫這個函式。

如需詳細資訊，請參閱 Windows SDK 中的[OleCreateFromFile](/windows/win32/api/ole/nf-ole-olecreatefromfile)、 [OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatelinkfromclipboard"></a><a name="createlinkfromclipboard"></a>COleClientItem：： CreateLinkFromClipboard

呼叫此函式可從剪貼簿的內容建立連結專案。

```
BOOL CreateLinkFromClipboard(
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

您通常會從 [編輯] 功能表上的 [貼上連結] 命令的訊息處理常式中呼叫此函式。 （如果剪貼簿包含可連結的 OLE 專案，則會在[COleDocument](../../mfc/reference/coledocument-class.md)的預設執行中啟用 [貼上連結] 命令）。

如需詳細資訊，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatelinkfromdata"></a><a name="createlinkfromdata"></a>COleClientItem：： CreateLinkFromData

呼叫此函式可從`COleDataObject`物件建立連結專案。

```
BOOL CreateLinkFromData(
    COleDataObject* pDataObject,
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*pDataObject*<br/>
要從中建立 OLE 專案之[COleDataObject](../../mfc/reference/coledataobject-class.md)物件的指標。

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

當使用者指出應該建立連結時，請在 drop 作業期間呼叫此作業。 它也可以用來處理 [編輯貼入] 命令。 當已選取連結選項時`COleClientItem::CreateLinkFromClipboard` ，和[COlePasteSpecialDialog：： CreateItem](../../mfc/reference/colepastespecialdialog-class.md#createitem)中的架構會呼叫它。

如需詳細資訊，請參閱 Windows SDK 中的[OleCreateLinkFromData](/windows/win32/api/ole2/nf-ole2-olecreatelinkfromdata)、 [OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatelinkfromfile"></a><a name="createlinkfromfile"></a>COleClientItem：： CreateLinkFromFile

呼叫此函式可從檔案建立連結的 OLE 專案。

```
BOOL CreateLinkFromFile(
    LPCTSTR lpszFileName,
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*lpszFileName*<br/>
要從中建立 OLE 專案之檔案名稱的指標。

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

當選取 [從檔案建立] 按鈕並核取 [連結] 核取方塊時，如果使用者從 [插入物件] 對話方塊中選擇 [確定]，則架構會呼叫這個函式。 它是從[COleInsertDialog：： CreateItem](../../mfc/reference/coleinsertdialog-class.md#createitem)呼叫。

如需詳細資訊，請參閱 Windows SDK 中的[OleCreateLinkToFile](/windows/win32/api/ole2/nf-ole2-olecreatelinktofile)、 [OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatenewitem"></a><a name="createnewitem"></a>COleClientItem：： CreateNewItem

呼叫此函式以建立內嵌專案;此函式會啟動伺服器應用程式，讓使用者能夠建立 OLE 專案。

```
BOOL CreateNewItem(
    REFCLSID clsid,
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*clsid*<br/>
唯一識別要建立之 OLE 專案類型的識別碼。

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

如果選取 [建立新的] 按鈕時，當使用者從 [插入物件] 對話方塊中選擇 [確定] 時，架構會呼叫這個函式。

如需詳細資訊，請參閱 Windows SDK 中的[OleCreate](/windows/win32/api/ole/nf-ole-olecreate)、 [OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatestaticfromclipboard"></a><a name="createstaticfromclipboard"></a>COleClientItem：： CreateStaticFromClipboard

呼叫此函式可從剪貼簿的內容建立靜態專案。

```
BOOL CreateStaticFromClipboard(
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

靜態專案包含呈現資料，而不是原生資料。因此無法編輯。 如果[CreateFromClipboard](#createfromclipboard)成員函式失敗，通常會呼叫這個函式。

如需詳細資訊，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemcreatestaticfromdata"></a><a name="createstaticfromdata"></a>COleClientItem：： CreateStaticFromData

呼叫此函式可從`COleDataObject`物件建立靜態專案。

```
BOOL CreateStaticFromData(
    COleDataObject* pDataObject,
    OLERENDER render = OLERENDER_DRAW,
    CLIPFORMAT cfFormat = 0,
    LPFORMATETC lpFormatEtc = NULL);
```

### <a name="parameters"></a>參數

*pDataObject*<br/>
要從中建立 OLE 專案之[COleDataObject](../../mfc/reference/coledataobject-class.md)物件的指標。

*使得*<br/>
指定伺服器如何呈現 OLE 專案的旗標。 如需可能的值，請參閱 Windows SDK 中的[OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender) 。

*cfFormat*<br/>
指定在建立 OLE 專案時要快取的剪貼簿資料格式。

*lpFormatEtc*<br/>
當*render* OLERENDER_FORMAT 或 OLERENDER_DRAW 時，所使用之[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc)結構的指標。 只有當您想要指定超出*cfFormat*所指定剪貼簿格式的其他格式資訊時，才提供此參數的值。 如果您省略此參數，則會將預設值用於`FORMATETC`結構中的其他欄位。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

靜態專案包含呈現資料，而不是原生資料。因此，它無法編輯。 這基本上與[CreateStaticFromClipboard](#createstaticfromclipboard)相同，不同之處在于可以從任意`COleDataObject`處，而不只是從剪貼簿建立靜態專案。

當選取 [靜態] 時，用於[COlePasteSpecialDialog：： CreateItem](../../mfc/reference/colepastespecialdialog-class.md#createitem) 。

如需詳細資訊，請參閱 Windows SDK 中的[OleCreateStaticFromData](/windows/win32/api/ole2/nf-ole2-olecreatestaticfromdata)、 [OLERENDER](/windows/win32/api/oleidl/ne-oleidl-olerender)和[FORMATETC](/windows/win32/api/objidl/ns-objidl-formatetc) 。

## <a name="coleclientitemdeactivate"></a><a name="deactivate"></a>COleClientItem：:D eactivate

呼叫此函式可停用 OLE 專案，並釋放任何相關聯的資源。

```cpp
void Deactivate();
```

### <a name="remarks"></a>備註

當使用者在專案範圍外的工作區上按一下滑鼠時，通常會停用就地作用中的 OLE 專案。 請注意，停用 OLE 專案會捨棄其復原狀態，因此無法呼叫[ReactivateAndUndo](#reactivateandundo)成員函式。

如果您的應用程式支援復原，請`Deactivate`不要呼叫;相反地，請呼叫[DeactivateUI](#deactivateui)。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceObject：： InPlaceDeactivate](/windows/win32/api/oleidl/nf-oleidl-ioleinplaceobject-inplacedeactivate) 。

## <a name="coleclientitemdeactivateui"></a><a name="deactivateui"></a>COleClientItem：:D eactivateUI

當使用者停用就地啟用的專案時，呼叫此函式。

```cpp
void DeactivateUI();
```

### <a name="remarks"></a>備註

此函式會將容器應用程式的使用者介面還原成其原始狀態，並隱藏任何針對就地啟用而建立的功能表和其他控制項。

此函式不會清除專案的復原狀態資訊。 系統會保留該資訊，以便稍後在停用專案之後，立即選擇容器的 [復原] 命令時， [ReactivateAndUndo](#reactivateandundo)可以在伺服器應用程式中用來執行 [復原] 命令。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceObject：： InPlaceDeactivate](/windows/win32/api/oleidl/nf-oleidl-ioleinplaceobject-inplacedeactivate) 。

## <a name="coleclientitemdelete"></a><a name="delete"></a>COleClientItem：:D 刪除

呼叫此函式可從容器檔案中刪除 OLE 專案。

```cpp
void Delete(BOOL bAutoDelete = TRUE);
```

### <a name="parameters"></a>參數

*bAutoDelete*<br/>
指定是否要從檔中移除專案。

### <a name="remarks"></a>備註

此函式會呼叫[Release](#release)成員函式，而該函式會接著刪除專案的 c + + 物件，並從檔中永久移除 OLE 專案。 如果 OLE 專案是內嵌的，則會刪除專案的原生資料。 它一律會關閉正在執行的伺服器;因此，如果專案是開啟的連結，則此函式會將它關閉。

## <a name="coleclientitemdodragdrop"></a><a name="dodragdrop"></a>COleClientItem：:D oDragDrop

呼叫`DoDragDrop`成員函式以執行拖放作業。

```
DROPEFFECT DoDragDrop(
    LPCRECT lpItemRect,
    CPoint ptOffset,
    BOOL bIncludeLink = FALSE,
    DWORD dwEffects = DROPEFFECT_COPY | DROPEFFECT_MOVE,
    LPCRECT lpRectStartDrag = NULL);
```

### <a name="parameters"></a>參數

*lpItemRect*<br/>
在畫面上以用戶端座標（圖元）表示的專案矩形。

*ptOffset*<br/>
*LpItemRect*的位移，其中滑鼠位置位於拖曳時。

*bIncludeLink*<br/>
如果應該將連結資料複製到剪貼簿，請將此值設定為 TRUE。 如果您的伺服器應用程式不支援連結，請將它設定為 FALSE。

*dwEffects*<br/>
決定拖曳作業在拖曳作業中允許的效果。

*lpRectStartDrag*<br/>
定義拖曳實際開始位置之矩形的指標。 如需詳細資訊，請參閱接下來的＜備註＞一節。

### <a name="return-value"></a>傳回值

DROPEFFECT 值。 如果 DROPEFFECT_MOVE，則應該移除原始資料。

### <a name="remarks"></a>備註

拖放作業不會立即啟動。 它會等到滑鼠游標離開*lpRectStartDrag*所指定的矩形，或直到經過指定的毫秒數為止。 如果*lpRectStartDrag*為 Null，則矩形的大小為一個圖元。

延遲時間是由登錄機碼設定所指定。 您可以藉由呼叫[CWinApp：： WriteProfileString](../../mfc/reference/cwinapp-class.md#writeprofilestring)或[CWinApp：： WriteProfileInt](../../mfc/reference/cwinapp-class.md#writeprofileint)來變更延遲時間。 如果您未指定延遲時間，則會使用預設值200毫秒。 拖曳延遲時間的儲存方式如下：

- Windows NT 拖曳延遲時間儲存在 HKEY_LOCAL_MACHINE \SOFTWARE\Microsoft\Windows\NT\CurrentVersion\IniFileMapping\win.ini\Windows\DragDelay。

- Windows 3.x 拖曳延遲時間會儲存在 WIN 中。INI 檔案，位於 [Windows}] 區段底下。

- Windows 95/98 拖曳延遲時間會儲存在 WIN 的快取版本中。.INI.

如需如何將拖曳延遲資訊儲存在登錄或中的詳細資訊。INI 檔，請參閱 Windows SDK 中的[WriteProfileString](/windows/win32/api/winbase/nf-winbase-writeprofilestringw) 。

## <a name="coleclientitemdoverb"></a><a name="doverb"></a>COleClientItem：:D oVerb

呼叫`DoVerb`以執行指定的動詞。

```
virtual BOOL DoVerb(
    LONG nVerb,
    CView* pView,
    LPMSG lpMsg = NULL);
```

### <a name="parameters"></a>參數

*nVerb*<br/>
指定要執行的指令動詞。 它可以包含下列其中一項：

|值|意義|符號|
|-----------|-------------|------------|
|-0|主動詞命令|OLEIVERB_PRIMARY|
|- 1|次要動詞|(無)|
|- 1|顯示要編輯的專案|OLEIVERB_SHOW|
|-2|在個別視窗中編輯專案|OLEIVERB_OPEN|
|-3|隱藏專案|OLEIVERB_HIDE|

-1 值通常是另一個動詞的別名。 如果不支援開啟編輯，-2 的效果會與-1 相同。 如需其他值，請參閱 Windows SDK 中的[IOleObject：:D overb](/windows/win32/api/oleidl/nf-oleidl-ioleobject-doverb) 。

*pView*<br/>
View 視窗的指標;伺服器會使用這項功能進行就地啟用。 如果容器應用程式不允許就地啟用，這個參數應該是 Null。

*lpMsg*<br/>
導致啟用專案之訊息的指標。

### <a name="return-value"></a>傳回值

如果成功執行動詞命令，則為非零;否則為0。

### <a name="remarks"></a>備註

此函式會呼叫[Activate](#activate)成員函式來執行動詞。 它也會攔截例外狀況，並向使用者顯示訊息方塊（如果有擲回的話）。

如果主要動詞命令是 Edit，而且在*nVerb*參數中指定了零，就會啟動伺服器應用程式，以允許編輯 OLE 專案。 如果容器應用程式支援就地啟用，則可以就地完成編輯。 如果容器不支援就地啟用（或指定了開啟的動詞），伺服器就會在另一個視窗中啟動，並可在該處完成編輯。 一般而言，當容器應用程式的使用者按兩下 OLE 專案時， *nVerb*參數中主要動詞命令的值會決定使用者可以採取的動作。 不過，如果伺服器只支援一個動作，不論在*nVerb*參數中指定哪一個值，它都會採取該動作。

## <a name="coleclientitemdraw"></a><a name="draw"></a>COleClientItem：:D raw

呼叫此函式，使用指定的裝置內容，將 OLE 專案繪製到指定的周框。

```
BOOL Draw(
    CDC* pDC,
    LPCRECT lpBounds,
    DVASPECT nDrawAspect = (DVASPECT)-1);
```

### <a name="parameters"></a>參數

*pDC*<br/>
用於繪製 OLE 專案之[CDC](../../mfc/reference/cdc-class.md)物件的指標。

*lpBounds*<br/>
[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或`RECT`結構的指標，定義要在其中繪製 OLE 專案的周框（以裝置內容所決定的邏輯單元）。

*nDrawAspect*<br/>
指定 OLE 專案的外觀，也就是它的顯示方式。 如果*nDrawAspect*為-1，則會使用使用[SetDrawAspect](#setdrawaspect)設定的最後一個層面。 如需此旗標可能值的詳細資訊，請參閱[SetDrawAspect](#setdrawaspect)。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

函式可能會使用由的[OnDraw](../../mfc/reference/coleserveritem-class.md#ondraw)成員函式所建立之 OLE 專案的元`COleServerItem`檔標記法。

通常您會`Draw`使用進行螢幕顯示，以*pDC*的形式傳遞螢幕裝置內容。 在此情況下，您只需要指定前兩個參數。

*LpBounds*參數會識別目標裝置內容中的矩形（相對於其目前的對應模式）。 轉譯可能牽涉到調整圖片的大小，容器應用程式可以使用它來強加在顯示的視圖和最終列印影像之間調整的外觀。

如需詳細資訊，請參閱 Windows SDK 中的[IViewObject：:D raw](/windows/win32/api/oleidl/nf-oleidl-iviewobject-draw) 。

## <a name="coleclientitemgetactiveview"></a><a name="getactiveview"></a>COleClientItem：： GetActiveView

傳回已啟用專案的視圖。

```
CView* GetActiveView() const;
```

### <a name="return-value"></a>傳回值

視圖的指標;如果專案不是就地啟用，則為 Null。

## <a name="coleclientitemgetcachedextent"></a><a name="getcachedextent"></a>COleClientItem：： GetCachedExtent

呼叫此函式可取得 OLE 專案的大小。

```
BOOL GetCachedExtent(
    LPSIZE lpSize,
    DVASPECT nDrawAspect = (DVASPECT)-1);
```

### <a name="parameters"></a>參數

*lpSize*<br/>
`SIZE`結構的指標，或將接收大小資訊的[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

*nDrawAspect*<br/>
指定要抓取其界限的 OLE 專案的層面。 如需可能的值，請參閱[SetDrawAspect](#setdrawaspect)。

### <a name="return-value"></a>傳回值

如果成功，則為非零;如果 OLE 專案為空白，則為0。

### <a name="remarks"></a>備註

此函式會提供與[GetExtent](#getextent)相同的資訊。 不過，您可以呼叫`GetCachedExtent`來取得處理其他 OLE 處理常式（例如[OnChange](#onchange)）期間的範圍資訊。 這些維度是 MM_HIMETRIC 單位。

這是可能的`GetCachedExtent` ，因為會使用[IViewObject2](/windows/win32/api/oleidl/nn-oleidl-iviewobject2)介面，而不是使用[IOleObject](/windows/win32/api/oleidl/nn-oleidl-ioleobject)介面來取得此專案的範圍。 `IViewObject2` COM 物件會快取先前呼叫 IViewObject 所使用的範圍資訊[：:D raw](/windows/win32/api/oleidl/nf-oleidl-iviewobject-draw)。

如需詳細資訊，請參閱 Windows SDK 中的[IViewObject2：： GetExtent](/windows/win32/api/oleidl/nf-oleidl-iviewobject2-getextent) 。

## <a name="coleclientitemgetclassid"></a><a name="getclassid"></a>COleClientItem：： GetClassID

將專案的類別 ID 傳回給*pClassID*所指向的記憶體。

```cpp
void GetClassID(CLSID* pClassID) const;
```

### <a name="parameters"></a>參數

*pClassID*<br/>
[CLSID](/windows/win32/com/clsid-key-hklm)類型識別碼的指標，用來抓取類別 ID。 如需 CLSID 的詳細資訊，請參閱 Windows SDK。

### <a name="remarks"></a>備註

類別識別碼是128位的數位，可唯一識別編輯專案的應用程式。

如需詳細資訊，請參閱 Windows SDK 中的[IPersist：： GetClassID](/windows/win32/api/objidl/nf-objidl-ipersist-getclassid) 。

## <a name="coleclientitemgetclipboarddata"></a><a name="getclipboarddata"></a>COleClientItem：： GetClipboardData

呼叫此函式可取得`COleDataSource`物件，其中包含[CopyToClipboard](#copytoclipboard)成員函式的呼叫，將放在剪貼簿上的所有資料。

```cpp
void GetClipboardData(
    COleDataSource* pDataSource,
    BOOL bIncludeLink = FALSE,
    LPPOINT lpOffset = NULL,
    LPSIZE lpSize = NULL);
```

### <a name="parameters"></a>參數

*pDataSource*<br/>
[COleDataSource](../../mfc/reference/coledatasource-class.md)物件的指標，它會接收包含在 OLE 專案中的資料。

*bIncludeLink*<br/>
如果應該包含連結資料，則為 TRUE;否則為 FALSE。

*lpOffset*<br/>
滑鼠游標從物件原點開始的位移（以圖元為單位）。

*lpSize*<br/>
物件的大小（以圖元為單位）。

### <a name="remarks"></a>備註

`GetClipboardData`會呼叫做為[OnGetClipboardData](#ongetclipboarddata)的預設執行。 只有`OnGetClipboardData`在您除了提供的`CopyToClipboard`資料格式之外，才需要覆寫。 `COleDataSource`在呼叫`CopyToClipboard`之前或之後將這些格式放在物件中，然後將`COleDataSource`物件傳遞至[COleDataSource：： SetClipboard](../../mfc/reference/coledatasource-class.md#setclipboard)函數。 例如，如果您想要在其容器檔案中將 OLE 專案的位置伴隨在剪貼簿上，您可以定義自己的格式來傳遞該資訊，並將它放`COleDataSource`在中`CopyToClipboard`，然後再呼叫。

## <a name="coleclientitemgetdocument"></a><a name="getdocument"></a>COleClientItem：： GetDocument

呼叫此函式可取得包含 OLE 專案之檔的指標。

```
COleDocument* GetDocument() const;
```

### <a name="return-value"></a>傳回值

包含 OLE 專案之檔的指標。 如果專案不是檔的一部分，則為 Null。

### <a name="remarks"></a>備註

此指標允許存取您當做`COleDocument`引數傳遞至`COleClientItem`函式的物件。

## <a name="coleclientitemgetdrawaspect"></a><a name="getdrawaspect"></a>COleClientItem：： GetDrawAspect

呼叫`GetDrawAspect`成員函式，以判斷專案的目前「外觀」或「視圖」。

```
DVASPECT GetDrawAspect() const;
```

### <a name="return-value"></a>傳回值

來自 DVASPECT 列舉的值，其值會列在[SetDrawAspect](#setdrawaspect)的參考中。

### <a name="remarks"></a>備註

此外觀會指定要如何呈現專案。

## <a name="coleclientitemgetextent"></a><a name="getextent"></a>COleClientItem：： GetExtent

呼叫此函式可取得 OLE 專案的大小。

```
BOOL GetExtent(
    LPSIZE lpSize,
    DVASPECT nDrawAspect = (DVASPECT)- 1);
```

### <a name="parameters"></a>參數

*lpSize*<br/>
`SIZE`結構的指標，或將`CSize`接收大小資訊的物件。

*nDrawAspect*<br/>
指定要抓取其界限的 OLE 專案的層面。 如需可能的值，請參閱[SetDrawAspect](#setdrawaspect)。

### <a name="return-value"></a>傳回值

如果成功，則為非零;如果 OLE 專案為空白，則為0。

### <a name="remarks"></a>備註

如果伺服器應用程式是使用 MFC 程式庫撰寫的，此函式會[OnGetExtent](../../mfc/reference/coleserveritem-class.md#ongetextent)導致呼叫對應`COleServerItem`物件的 OnGetExtent 成員函式。 請注意，所抓取的大小可能與[SetExtent](#setextent)成員函式最後所設定的大小不同。所指定的大小`SetExtent`會被視為建議。 這些維度是 MM_HIMETRIC 單位。

> [!NOTE]
> 請勿在處理`GetExtent` OLE 處理常式期間呼叫，例如[OnChange](#onchange)。 請改為呼叫[GetCachedExtent](#getcachedextent) 。

如需詳細資訊，請參閱 Windows SDK 中的[IOleObject：： GetExtent](/windows/win32/api/oleidl/nf-oleidl-ioleobject-getextent) 。

## <a name="coleclientitemgeticonfromregistry"></a><a name="geticonfromregistry"></a>COleClientItem：： GetIconFromRegistry

呼叫這個成員函式可抓取與特定 CLSID 伺服器相關聯之圖示資源的控制碼。

```
HICON GetIconFromRegistry() const;

static HICON GetIconFromRegistry(CLSID& clsid);
```

### <a name="parameters"></a>參數

*clsid*<br/>
與圖示相關聯之伺服器的 CLSID 參考。

### <a name="return-value"></a>傳回值

圖示資源的有效控制碼，如果找不到伺服器的圖示或預設圖示，則為 Null。

### <a name="remarks"></a>備註

即使伺服器已經在執行中，這個成員函式也不會啟動伺服器或動態取得圖示。 相反地，此成員函式會開啟伺服器的可執行映射，並抓取與已註冊之伺服器相關聯的靜態圖示。

## <a name="coleclientitemgeticonicmetafile"></a><a name="geticonicmetafile"></a>COleClientItem：： GetIconicMetafile

抓取用來繪製專案圖示的中繼檔。

```
HGLOBAL GetIconicMetafile();
```

### <a name="return-value"></a>傳回值

如果成功，則為中繼檔的控制碼;否則為 Null。

### <a name="remarks"></a>備註

如果沒有目前的圖示，則會傳回預設圖示。 這是由 MFC/OLE 對話方塊自動呼叫，通常不會直接呼叫。

此函式也會呼叫[SetIconicMetafile](#seticonicmetafile)來快取中繼檔以供稍後使用。

## <a name="coleclientitemgetinplacewindow"></a><a name="getinplacewindow"></a>COleClientItem：： GetInPlaceWindow

呼叫`GetInPlaceWindow`成員函式，取得已開啟專案以進行就地編輯之視窗的指標。

```
CWnd* GetInPlaceWindow();
```

### <a name="return-value"></a>傳回值

專案之就地編輯視窗的指標;如果專案不在作用中或其伺服器無法使用，則為 Null。

### <a name="remarks"></a>備註

只有就地作用中的專案才能呼叫此函式。

## <a name="coleclientitemgetitemstate"></a><a name="getitemstate"></a>COleClientItem：： GetItemState

呼叫此函式可取得 OLE 專案的目前狀態。

```
UINT GetItemState() const;
```

### <a name="return-value"></a>傳回值

`COleClientItem::ItemState`列舉值，可以是下列其中一`emptyState`項：、 `loadedState`、 `openState`、 `activeState`、。 `activeUIState` 如需這些狀態的相關資訊，請參閱[容器：用戶端專案狀態](../../mfc/containers-client-item-states.md)一文。

### <a name="remarks"></a>備註

若要在 OLE 專案的狀態變更時收到通知，請使用[OnChange](#onchange)成員函式。

如需詳細資訊，請參閱[容器：用戶端專案狀態](../../mfc/containers-client-item-states.md)一文。

## <a name="coleclientitemgetlaststatus"></a><a name="getlaststatus"></a>COleClientItem：： GetLastStatus

傳回上一個 OLE 運算的狀態碼。

```
SCODE GetLastStatus() const;
```

### <a name="return-value"></a>傳回值

SCODE 值。

### <a name="remarks"></a>備註

對於傳回 BOOL 值 FALSE 的成員函式，或傳回 Null 的其他成員函式， `GetLastStatus`會傳回更詳細的失敗資訊。 請注意，大部分的 OLE 成員函式會針對更嚴重的錯誤擲回例外狀況。 SCODE 解釋的特定資訊，取決於上次傳回 SCODE 值的基礎 OLE 呼叫。

如需有關 SCODE 的詳細資訊，請參閱 Windows SDK 檔中[的 COM 錯誤碼的結構](/windows/win32/com/structure-of-com-error-codes)。

## <a name="coleclientitemgetlinkupdateoptions"></a><a name="getlinkupdateoptions"></a>COleClientItem：： GetLinkUpdateOptions

呼叫此函式可取得 OLE 專案之連結-更新選項的目前值。

```
OLEUPDATE GetLinkUpdateOptions();
```

### <a name="return-value"></a>傳回值

下列其中一個值：

- OLEUPDATE_ALWAYS 盡可能更新連結的專案。 此選項支援 [連結] 對話方塊中的 [自動連結更新] 選項按鈕。

- OLEUPDATE_ONCALL 只在容器應用程式的要求上更新連結的專案（呼叫[UpdateLink](#updatelink)成員函式時）。 此選項支援 [連結] 對話方塊中的 [手動連結-更新] 選項按鈕。

### <a name="remarks"></a>備註

這是一個先進的作業。

此函式會由[COleLinksDialog](../../mfc/reference/colelinksdialog-class.md)類別自動呼叫。

如需詳細資訊，請參閱 Windows SDK 中的[IOleLink：： GetUpdateOptions](/windows/win32/api/oleidl/nf-oleidl-iolelink-getupdateoptions) 。

## <a name="coleclientitemgettype"></a><a name="gettype"></a>COleClientItem：： GetType

呼叫此函式可判斷 OLE 專案是內嵌或連結，還是靜態。

```
OLE_OBJTYPE GetType() const;
```

### <a name="return-value"></a>傳回值

具有下列其中一個值的不帶正負號的整數：

- OT_LINK OLE 專案是一個連結。

- OT_EMBEDDED OLE 專案是內嵌的。

- OT_STATIC OLE 專案是靜態的，也就是說，它只包含簡報資料，而非原生資料，因此無法編輯。

## <a name="coleclientitemgetusertype"></a><a name="getusertype"></a>COleClientItem：： GetUserType

呼叫此函式可取得描述 OLE 專案類型的使用者可見字串，例如「Word 檔」。

```cpp
void GetUserType(
    USERCLASSTYPE nUserClassType,
    CString& rString);
```

### <a name="parameters"></a>參數

*nUserClassType*<br/>
值，表示描述 OLE 專案類型的字串所需的 variant。 這可以有下列其中一個值：

- USERCLASSTYPE_FULL 向使用者顯示的完整類型名稱。

- USERCLASSTYPE_SHORT 快捷方式名稱（最多15個字元）以用於快顯功能表和 [編輯連結] 對話方塊。

- 服務類別的應用程式 USERCLASSTYPE_APPNAME 名稱。

*rString*<br/>
[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件的參考，描述 OLE 專案類型的字串將會傳回。

### <a name="remarks"></a>備註

這通常是系統註冊資料庫中的專案。

如果要求的是完整型別名稱，但無法使用，則會改為使用簡短名稱。 如果在註冊資料庫中找不到 OLE 專案類型的專案，或者如果沒有針對 OLE 專案類型註冊的使用者類型，則會使用目前儲存在 OLE 專案中的使用者類型。 如果該使用者類型名稱是空字串，則會使用「未知物件」。

如需詳細資訊，請參閱 Windows SDK 中的[IOleObject：： GetUserType](/windows/win32/api/oleidl/nf-oleidl-ioleobject-getusertype) 。

## <a name="coleclientitemisinplaceactive"></a><a name="isinplaceactive"></a>COleClientItem：： IsInPlaceActive

呼叫此函式，以查看 OLE 專案是否為就地作用中。

```
BOOL IsInPlaceActive() const;
```

### <a name="return-value"></a>傳回值

如果 OLE 專案為就地啟用，則為非零值;否則為0。

### <a name="remarks"></a>備註

視是否就地編輯專案而定，執行不同的邏輯是很常見的。 函式會檢查目前的專案狀態是否等於`activeState`或。 `activeUIState`

## <a name="coleclientitemislinkuptodate"></a><a name="islinkuptodate"></a>COleClientItem：： IsLinkUpToDate

呼叫此函式，以查看 OLE 專案是否為最新狀態。

```
BOOL IsLinkUpToDate() const;
```

### <a name="return-value"></a>傳回值

如果 OLE 專案是最新的，則為非零值;否則為0。

### <a name="remarks"></a>備註

如果連結專案的來源文件已更新，可能會過期。 在其中包含連結的內嵌專案可能會變成過期。 函式會對 OLE 專案進行遞迴檢查。 請注意，判斷 OLE 專案是否已過期，會比實際執行更新的成本高。

這會由[COleLinksDialog](../../mfc/reference/colelinksdialog-class.md)的執行自動呼叫。

如需詳細資訊，請參閱 Windows SDK 中的[IOleObject：： IsUpToDate](/windows/win32/api/oleidl/nf-oleidl-ioleobject-isuptodate) 。

## <a name="coleclientitemismodified"></a><a name="ismodified"></a>COleClientItem：： IsModified

呼叫此函式可查看 OLE 專案是否已變更（自上次儲存後修改過）。

```
BOOL IsModified() const;
```

### <a name="return-value"></a>傳回值

如果 OLE 專案已變更，則為非零值;否則為0。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 Windows SDK 中的[IPersistStorage：： IsDirty](/windows/win32/api/objidl/nf-objidl-ipersiststorage-isdirty) 。

## <a name="coleclientitemisopen"></a><a name="isopen"></a>COleClientItem：： IsOpen

呼叫此函式可查看 OLE 專案是否為開啟狀態;也就是在另一個視窗中執行的伺服器應用程式實例中開啟。

```
BOOL IsOpen() const;
```

### <a name="return-value"></a>傳回值

如果 OLE 專案已開啟，則為非零。否則為0。

### <a name="remarks"></a>備註

它是用來決定何時使用影線圖樣繪製物件。 開啟的物件應該要有一個在物件上繪製的影線圖樣。 您可以使用[CRectTracker](../../mfc/reference/crecttracker-class.md)物件來完成此動作。

## <a name="coleclientitemisrunning"></a><a name="isrunning"></a>COleClientItem：： IsRunning

呼叫此函式以查看 OLE 專案是否正在執行;也就是，是否在伺服器應用程式中載入並執行專案。

```
BOOL IsRunning() const;
```

### <a name="return-value"></a>傳回值

如果 OLE 專案正在執行，則為非零。否則為0。

### <a name="remarks"></a>備註

如需詳細資訊，請參閱 Windows SDK 中的[OleIsRunning](/windows/win32/api/ole2/nf-ole2-oleisrunning) 。

## <a name="coleclientitemonactivate"></a><a name="onactivate"></a>COleClientItem：： OnActivate

由架構呼叫，以通知專案它剛開始的位置。

```
virtual void OnActivate();
```

### <a name="remarks"></a>備註

請注意，此函式會呼叫以指出伺服器正在執行，而不表示其使用者介面已安裝在容器應用程式中。 此時，物件沒有作用中的使用者介面（不是`activeUIState`）。 尚未安裝其功能表或工具列。 當發生這種情況時，會呼叫[OnActivateUI](#onactivateui)成員函式。

預設的實作為呼叫[OnChange](#onchange)成員函式，並以 OLE_CHANGEDSTATE 做為參數。 覆寫此函式，以在專案變成就地作用中時執行自訂處理。

## <a name="coleclientitemonactivateui"></a><a name="onactivateui"></a>COleClientItem：： OnActivateUI

當物件已`OnActivateUI`進入作用中 UI 狀態時，架構會呼叫。

```
virtual void OnActivateUI();
```

### <a name="remarks"></a>備註

物件現在已安裝其工具列和功能表。

預設的執行會記住伺服器的 HWND，以`GetServerWindow`供稍後呼叫。

## <a name="coleclientitemonchange"></a><a name="onchange"></a>COleClientItem：： OnChange

當使用者修改、儲存或關閉 OLE 專案時，由架構呼叫。

```
virtual void OnChange(
    OLE_NOTIFICATION nCode,
    DWORD dwParam);
```

### <a name="parameters"></a>參數

*nCode*<br/>
伺服器變更此專案的原因。 其值可以是下列其中一個值：

- OLE_CHANGED OLE 專案的外觀已經變更。

- 已儲存 OLE 專案 OLE_SAVED。

- OLE_CLOSED OLE 專案已關閉。

- OLE_CHANGED_STATE OLE 專案已從某個狀態變更為另一個。

*dwParam*<br/>
如果*nCode*為 OLE_SAVED 或 OLE_CLOSED，則不會使用這個參數。 如果*nCode*為 OLE_CHANGED，此參數會指定已變更之 OLE 專案的層面。 如需可能的值，請參閱[COleClientItem：:D raw](#draw)的*dwParam*參數。 如果*nCode*為 OLE_CHANGED_STATE，此參數會是`COleClientItem::ItemState`列舉值，並描述所輸入的狀態。 它可以有下列其中一個`emptyState`值：、 `loadedState`、 `openState`、 `activeState`或。 `activeUIState`

### <a name="remarks"></a>備註

（如果伺服器應用程式是使用 MFC 程式庫撰寫的，則會呼叫此函式以回應`Notify` `COleServerDoc`或`COleServerItem`的成員函式）。如果*nCode* OLE_CHANGED 或 OLE_SAVED，預設的執行會將容器檔案標示為已修改。

針對 OLE_CHANGED_STATE，從[GetItemState](#getitemstate)傳回的目前狀態仍會是舊狀態，表示在此狀態變更之前的目前狀態。

覆寫這個函式，以回應 OLE 專案狀態的變更。 通常您會藉由使專案顯示的區域失效，來更新專案的外觀。 在覆寫的開頭呼叫基類實。

## <a name="coleclientitemonchangeitemposition"></a><a name="onchangeitemposition"></a>COleClientItem：： OnChangeItemPosition

由架構呼叫，以通知容器 OLE 專案的範圍在就地啟用期間已變更。

```
virtual BOOL OnChangeItemPosition(const CRect& rectPos);
```

### <a name="parameters"></a>參數

*rectPos*<br/>
表示專案相對於容器應用程式之工作區的位置。

### <a name="return-value"></a>傳回值

如果成功變更專案的位置，則為非零。否則為0。

### <a name="remarks"></a>備註

預設的實值會決定 OLE 專案的新可見矩形，並使用新的值來呼叫[SetItemRects](#setitemrects) 。 預設的執行會計算專案的可見矩形，並將該資訊傳遞至伺服器。

覆寫此函式，以將特殊規則套用至調整大小/移動作業。 如果應用程式是以 MFC 撰寫，這會呼叫，因為伺服器稱為[COleServerDoc：： RequestPositionChange](../../mfc/reference/coleserverdoc-class.md#requestpositionchange)。

## <a name="coleclientitemondeactivate"></a><a name="ondeactivate"></a>COleClientItem：： OnDeactivate

當 OLE 專案從就地作用中狀態（ `activeState`）轉換為載入狀態時，由架構呼叫，這表示它會在就地啟用之後停用。

```
virtual void OnDeactivate();
```

### <a name="remarks"></a>備註

請注意，此函式會呼叫以指出 OLE 專案已關閉，而不是已從容器應用程式中移除其使用者介面。 發生這種情況時，會呼叫[OnDeactivateUI](#ondeactivateui)成員函式。

預設的實作為呼叫[OnChange](#onchange)成員函式，並以 OLE_CHANGEDSTATE 做為參數。 當就地作用中的專案停用時，覆寫此函式以執行自訂處理。 例如，如果您支援容器應用程式中的 [復原] 命令，您可以覆寫此函式以捨棄復原狀態，這表示在停用專案之後，無法復原在 OLE 專案上執行的最後一個作業。

## <a name="coleclientitemondeactivateandundo"></a><a name="ondeactivateandundo"></a>COleClientItem：： OnDeactivateAndUndo

當使用者在就地啟用 OLE 專案之後叫用 [復原] 命令時，由架構呼叫。

```
virtual void OnDeactivateAndUndo();
```

### <a name="remarks"></a>備註

預設的執行會呼叫[DeactivateUI](#deactivateui)來停用伺服器的使用者介面。 如果您要在您的容器應用程式中執行復原命令，請覆寫此函式。 在您的覆寫中，呼叫函式的基類版本，然後復原在應用程式中執行的最後一個命令。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceSite：:D eactivateandundo](/windows/win32/api/oleidl/nf-oleidl-ioleinplacesite-deactivateandundo) 。

## <a name="coleclientitemondeactivateui"></a><a name="ondeactivateui"></a>COleClientItem：： OnDeactivateUI

當使用者停用就地啟用的專案時呼叫。

```
virtual void OnDeactivateUI(BOOL bUndoable);
```

### <a name="parameters"></a>參數

*bUndoable*<br/>
指定編輯變更是否為可撤銷。

### <a name="remarks"></a>備註

此函式會將容器應用程式的使用者介面還原成其原始狀態，並隱藏任何針對就地啟用而建立的功能表和其他控制項。

如果*bUndoable*為 FALSE，則容器應該停用復原命令，因為它表示伺服器所執行的最後一個作業無法復原，所以會捨棄容器的恢復狀態。

## <a name="coleclientitemondiscardundostate"></a><a name="ondiscardundostate"></a>COleClientItem：： OnDiscardUndoState

當使用者執行的動作在編輯 OLE 專案時捨棄復原狀態時，由架構呼叫。

```
virtual void OnDiscardUndoState();
```

### <a name="remarks"></a>備註

預設實作不做任何動作。 如果您要在您的容器應用程式中執行復原命令，請覆寫此函式。 在您的覆寫中，捨棄容器應用程式的復原狀態。

如果伺服器是以 MFC 程式庫撰寫，則伺服器可能會呼叫[COleServerDoc：:D iscardundostate](../../mfc/reference/coleserverdoc-class.md#discardundostate)來呼叫此函式。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceSite：:D iscardundostate](/windows/win32/api/oleidl/nf-oleidl-ioleinplacesite-discardundostate) 。

## <a name="coleclientitemongetclipboarddata"></a><a name="ongetclipboarddata"></a>COleClientItem：： OnGetClipboardData

由架構呼叫以取得`COleDataSource`物件，其中包含的所有資料都將會藉由呼叫[CopyToClipboard](#copytoclipboard)或[DoDragDrop](#dodragdrop)成員函式放在剪貼簿上。

```
virtual COleDataSource* OnGetClipboardData(
    BOOL bIncludeLink,
    LPPOINT lpOffset,
    LPSIZE lpSize);
```

### <a name="parameters"></a>參數

*bIncludeLink*<br/>
如果應該將連結資料複製到剪貼簿，請將此設為 TRUE。 如果您的伺服器應用程式不支援連結，請將此設定為 FALSE。

*lpOffset*<br/>
從物件原點到滑鼠游標位移的指標（以圖元為單位）。

*lpSize*<br/>
物件大小的指標，以圖元為單位。

### <a name="return-value"></a>傳回值

包含剪貼簿資料之[COleDataSource](../../mfc/reference/coledatasource-class.md)物件的指標。

### <a name="remarks"></a>備註

此函式的預設實作用會呼叫[GetClipboardData](#getclipboarddata)。

## <a name="coleclientitemongetcliprect"></a><a name="ongetcliprect"></a>COleClientItem：： OnGetClipRect

架構會呼叫`OnGetClipRect`成員函式，以取得就地編輯之專案的裁剪矩形座標。

```
virtual void OnGetClipRect(CRect& rClipRect);
```

### <a name="parameters"></a>參數

*rClipRect*<br/>
[CRect](../../atl-mfc-shared/reference/crect-class.md)類別之物件的指標，其會保存專案的裁剪矩形座標。

### <a name="remarks"></a>備註

座標是以圖元為單位，相對於容器應用程式視窗的工作區。

預設的執行方式只會傳回此專案就地作用中之視圖的用戶端矩形。

## <a name="coleclientitemongetitemposition"></a><a name="ongetitemposition"></a>COleClientItem：： OnGetItemPosition

架構會呼叫`OnGetItemPosition`成員函式，以取得就地編輯之專案的座標。

```
virtual void OnGetItemPosition(CRect& rPosition);
```

### <a name="parameters"></a>參數

*rPosition*<br/>
[CRect](../../atl-mfc-shared/reference/crect-class.md)物件的參考，其中將包含專案的位置座標。

### <a name="remarks"></a>備註

座標是以圖元為單位，相對於容器應用程式視窗的工作區。

此函式的預設實作不做任何動作。 支援就地編輯的應用程式需要它的執行。

## <a name="coleclientitemongetwindowcontext"></a><a name="ongetwindowcontext"></a>COleClientItem：： OnGetWindowCoNtext

當專案就地啟動時由架構呼叫。

```
virtual BOOL OnGetWindowContext(
    CFrameWnd** ppMainFrame,
    CFrameWnd** ppDocFrame,
    LPOLEINPLACEFRAMEINFO lpFrameInfo);
```

### <a name="parameters"></a>參數

*ppMainFrame*<br/>
主框架視窗指標的指標。

*ppDocFrame*<br/>
指向檔框架視窗之指標的指標。

*lpFrameInfo*<br/>
[OLEINPLACEFRAMEINFO](/windows/win32/api/oleidl/ns-oleidl-oleinplaceframeinfo)結構的指標，將會接收框架視窗資訊。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

此函式是用來抓取 OLE 專案的父視窗的相關資訊。

如果容器是 MDI 應用程式，則預設的執行會傳回*ppMainFrame*中[CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)物件的指標，以及*ppDocFrame*中使用中[CMDIChildWnd](../../mfc/reference/cmdichildwnd-class.md)物件的指標。 如果容器是 SDI 應用程式，則預設的執行會將指標傳回至*ppMainFrame*中的[CFrameWnd](../../mfc/reference/cframewnd-class.md)物件，並在*ppDocFrame*中傳回 Null。 預設的執行也會填入*lpFrameInfo*的成員。

只有當預設的執行不符合您的應用程式時，才覆寫此函式;例如，如果您的應用程式具有不同于 SDI 或 MDI 的使用者介面範例。 這是一個先進的可覆寫。

如需詳細資訊，請參閱[IOleInPlaceSite：： GetWindowCoNtext](/windows/win32/api/oleidl/nf-oleidl-ioleinplacesite-getwindowcontext)和 Windows SDK 中的[OLEINPLACEFRAMEINFO](/windows/win32/api/oleidl/ns-oleidl-oleinplaceframeinfo)結構。

## <a name="coleclientitemoninsertmenus"></a><a name="oninsertmenus"></a>COleClientItem：： OnInsertMenus

在就地啟用期間由架構呼叫，以將容器應用程式的功能表插入空的功能表中。

```
virtual void OnInsertMenus(
    CMenu* pMenuShared,
    LPOLEMENUGROUPWIDTHS lpMenuWidths);
```

### <a name="parameters"></a>參數

*pMenuShared*<br/>
指向空的功能表。

*lpMenuWidths*<br/>
指向六個長數值的陣列，指出下列每個功能表群組中有多少個功能表： [檔案]、[編輯]、[容器]、[物件]、[視窗]、[說明]。 容器應用程式會負責 [檔案]、[容器] 和 [視窗] 功能表群組（對應于此陣列的元素0、2和4）。

### <a name="remarks"></a>備註

此功能表接著會傳遞至伺服器，這會插入自己的功能表，並建立複合功能表。 您可以重複呼叫此函式來建立數個複合功能表。

預設的執行會將就地的容器功能表插入*pMenuShared*中;也就是 [檔案]、[容器] 和 [視窗] 功能表群組。 [CDocTemplate：： SetContainerInfo](../../mfc/reference/cdoctemplate-class.md#setcontainerinfo)是用來設定此功能表資源。 預設的執行也會將適當的值指派給*lpMenuWidths*中的元素0、2和4，視功能表資源而定。 如果預設的執行不適合您的應用程式，請覆寫此函式;例如，如果您的應用程式未使用檔範本來將資源與檔案類型產生關聯。 如果您覆寫此函式，您也應該覆寫[OnSetMenu](#onsetmenu)和[OnRemoveMenus](#onremovemenus)。 這是一個先進的可覆寫。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceFrame：： InsertMenus](/windows/win32/api/oleidl/nf-oleidl-ioleinplaceframe-insertmenus) 。

## <a name="coleclientitemonremovemenus"></a><a name="onremovemenus"></a>COleClientItem：： OnRemoveMenus

由架構呼叫，以在就地啟用結束時，從指定的複合功能表中移除容器的功能表。

```
virtual void OnRemoveMenus(CMenu* pMenuShared);
```

### <a name="parameters"></a>參數

*pMenuShared*<br/>
指向[OnInsertMenus](#oninsertmenus)成員函式的呼叫所結構的複合功能表。

### <a name="remarks"></a>備註

預設的實*pMenuShared*會從就地的容器功能表（也就是 [檔案]、[容器] 和 [視窗] 功能表群組）中移除。 如果預設的執行不適合您的應用程式，請覆寫此函式;例如，如果您的應用程式未使用檔範本來將資源與檔案類型產生關聯。 如果您覆寫此函式，您可能也會覆寫[OnInsertMenus](#oninsertmenus)和[OnSetMenu](#onsetmenu) 。 這是一個先進的可覆寫。

如果伺服器重複*pMenuShared*呼叫`OnInsertMenus`，pMenuShared 上的子功能表可能會由一個以上的複合功能表共用。 因此，您不應該刪除覆寫中的`OnRemoveMenus`任何子功能表;您應該只將它們卸離。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceFrame：： RemoveMenus](/windows/win32/api/oleidl/nf-oleidl-ioleinplaceframe-removemenus) 。

## <a name="coleclientitemonscrollby"></a><a name="onscrollby"></a>COleClientItem：： OnScrollBy

由架構呼叫，以回應來自伺服器的要求來滾動 OLE 專案。

```
virtual BOOL OnScrollBy(CSize sizeExtent);
```

### <a name="parameters"></a>參數

*sizeExtent*<br/>
以圖元為單位，指定要在 x 和 y 方向上滾動的距離。

### <a name="return-value"></a>傳回值

如果專案已滾動，則為非零值;如果無法滾動專案，則為0。

### <a name="remarks"></a>備註

例如，如果 OLE 專案是部分可見的，而且使用者在執行就地編輯時移到可見區域外，則會呼叫這個函式，讓游標保持可見。 預設實作不做任何動作。 覆寫此函式，依指定的數量滾動專案。 請注意，由於滾動的結果，OLE 專案的可見部分可能會變更。 呼叫[SetItemRects](#setitemrects)以更新專案的可見矩形。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceSite：： Scroll](/windows/win32/api/oleidl/nf-oleidl-ioleinplacesite-scroll) 。

## <a name="coleclientitemonsetmenu"></a><a name="onsetmenu"></a>COleClientItem：： OnSetMenu

當就地啟用開始和結束時，由架構呼叫兩次;第一次安裝複合功能表和第二次（ *holemenu*等於 Null）時，會將它移除。

```
virtual void OnSetMenu(
    CMenu* pMenuShared,
    HOLEMENU holemenu,
    HWND hwndActiveObject);
```

### <a name="parameters"></a>參數

*pMenuShared*<br/>
由呼叫[OnInsertMenus](#oninsertmenus)成員函式和`InsertMenu`函式所建立之複合功能表的指標。

*holemenu*<br/>
函式所傳回`OleCreateMenuDescriptor`之功能表描述項的控制碼，如果要移除分派程式碼，則為 Null。

*hwndActiveObject*<br/>
OLE 專案之編輯視窗的控制碼。 這是將從 OLE 接收編輯命令的視窗。

### <a name="remarks"></a>備註

預設的執行會安裝或移除複合功能表，然後呼叫[OleSetMenuDescriptor](/windows/win32/api/ole2/nf-ole2-olesetmenudescriptor)函式來安裝或移除分派程式碼。 如果預設的執行不適合您的應用程式，請覆寫此函式。 如果您覆寫此函式，您可能也會覆寫[OnInsertMenus](#oninsertmenus)和[OnRemoveMenus](#onremovemenus) 。 這是一個先進的可覆寫。

如需詳細資訊，請參閱 Windows SDK 中的[OleCreateMenuDescriptor](/windows/win32/api/ole2/nf-ole2-olecreatemenudescriptor)、 [OleSetMenuDescriptor](/windows/win32/api/ole2/nf-ole2-olesetmenudescriptor)和[IOleInPlaceFrame：： SetMenu](/windows/win32/api/oleidl/nf-oleidl-ioleinplaceframe-setmenu) 。

## <a name="coleclientitemonshowcontrolbars"></a><a name="onshowcontrolbars"></a>COleClientItem：： OnShowControlBars

由架構呼叫以顯示和隱藏容器應用程式的控制列。

```
virtual BOOL OnShowControlBars(
    CFrameWnd* pFrameWnd,
    BOOL bShow);
```

### <a name="parameters"></a>參數

*pFrameWnd*<br/>
容器應用程式框架視窗的指標。 這可以是主框架視窗或 MDI 子視窗。

*bShow*<br/>
指定是否要顯示或隱藏控制列。

### <a name="return-value"></a>傳回值

如果函式呼叫造成控制列狀態的變更，則為非零。如果呼叫不會造成任何變更，或*pFrameWnd*未指向容器的框架視窗，則為0。

### <a name="remarks"></a>備註

如果控制列已在 BShow 所指定的狀態中，則此函式會傳回 0 *。* 例如，如果控制列已隱藏且*bShow*為 FALSE，就會發生這種情況。

預設的實值會從最上層框架視窗中移除工具列。

## <a name="coleclientitemonshowitem"></a><a name="onshowitem"></a>COleClientItem：： OnShowItem

由架構呼叫以顯示 OLE 專案，讓它在編輯期間完全可見。

```
virtual void OnShowItem();
```

### <a name="remarks"></a>備註

當您的容器應用程式支援內嵌專案的連結時（也就是，如果您已從[COleLinkingDoc](../../mfc/reference/colelinkingdoc-class.md)衍生您的檔類別），就會使用它。 此函式會在就地啟用期間呼叫，或當 OLE 專案為連結來源，且使用者想要編輯它時呼叫。 預設的執行會啟用容器檔案的第一個視圖。 覆寫此函式以滾動檔，以便顯示 OLE 專案。

## <a name="coleclientitemonupdateframetitle"></a><a name="onupdateframetitle"></a>COleClientItem：： OnUpdateFrameTitle

在就地啟用期間由架構呼叫，以更新框架視窗的標題列。

```
virtual BOOL OnUpdateFrameTitle();
```

### <a name="return-value"></a>傳回值

如果此函數成功更新框架標題，則為非零，否則為零。

### <a name="remarks"></a>備註

預設的執行並不會變更框架視窗的標題。 如果您想要讓應用程式使用不同的框架標題，例如「 *docname*中的*伺服器應用程式* - *專案*」（例如，「Microsoft Excel-報表中的試算表」），請覆寫此函式。DOC "）。 這是一個先進的可覆寫。

## <a name="coleclientitemreactivateandundo"></a><a name="reactivateandundo"></a>COleClientItem：： ReactivateAndUndo

呼叫此函式可重新開機 OLE 專案，並復原使用者在就地編輯期間所執行的最後一個作業。

```
BOOL ReactivateAndUndo();
```

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

如果您的容器應用程式支援 [復原] 命令，則在停用 OLE 專案之後，如果使用者立即選擇 [復原] 命令，請呼叫此函式。

如果伺服器應用程式是以 Microsoft Foundation 類別庫撰寫的，此函式會導致伺服器呼叫[COleServerDoc：： OnReactivateAndUndo](../../mfc/reference/coleserverdoc-class.md#onreactivateandundo)。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceObject：： ReactivateAndUndo](/windows/win32/api/oleidl/nf-oleidl-ioleinplaceobject-reactivateandundo) 。

## <a name="coleclientitemrelease"></a><a name="release"></a>COleClientItem：： Release

呼叫此函式可清除 OLE 專案所使用的資源。

```
virtual void Release(OLECLOSE dwCloseOption = OLECLOSE_NOSAVE);
```

### <a name="parameters"></a>參數

*dwCloseOption*<br/>
旗標，指定在何種情況下，當 OLE 專案回到載入狀態時，就會儲存該檔案。 如需可能值的清單，請參閱[COleClientItem：： Close](#close)。

### <a name="remarks"></a>備註

`Release`由「 `COleClientItem`析構函式」呼叫。

如需詳細資訊，請參閱 Windows SDK 中的[IUnknown：： Release](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) 。

## <a name="coleclientitemreload"></a><a name="reload"></a>COleClientItem：： Reload

關閉並重載專案。

```
BOOL Reload();
```

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`Reload`藉由呼叫[ActivateAs](#activateas)，在將專案啟用為另一個類型的專案之後，呼叫函式。

## <a name="coleclientitemrun"></a><a name="run"></a>COleClientItem：： Run

執行與此專案相關聯的應用程式。

```cpp
void Run();
```

### <a name="remarks"></a>備註

呼叫`Run`成員函式以啟動伺服器應用程式，然後再啟用專案。 這會由[Activate](#activate)和[DoVerb](#doverb)自動完成，因此通常不需要呼叫此函式。 如果必須執行伺服器才能在執行[DoVerb](#doverb)之前設定專案屬性（例如[SetExtent](#setextent)），請呼叫此函式。

## <a name="coleclientitemsetdrawaspect"></a><a name="setdrawaspect"></a>COleClientItem：： SetDrawAspect

呼叫`SetDrawAspect`成員函式，以設定專案的「外觀」或「視圖」。

```
virtual void SetDrawAspect(DVASPECT nDrawAspect);
```

### <a name="parameters"></a>參數

*nDrawAspect*<br/>
來自 DVASPECT 列舉的值。 這個參數的值可以是下列其中一個：

- DVASPECT_CONTENT 專案的表示方式，可以在其容器內顯示為内嵌物件。

- DVASPECT_THUMBNAIL 專案會以「縮圖」標記法呈現，使其可以在流覽工具中顯示。

- DVASPECT_ICON 專案是以圖示表示。

- DVASPECT_DOCPRINT 專案的表示方式，就如同使用 [檔案] 功能表中的 [列印] 命令來列印一樣。

### <a name="remarks"></a>備註

當使用該函式的*nDrawAspect*引數的預設值時，此外觀會指定如何藉由[繪製](#draw)來轉譯專案。

此函式會由變更圖示（以及直接呼叫 [變更圖示] 對話方塊的其他對話方塊）自動呼叫，以在使用者要求時啟用 iconic 顯示外觀。

## <a name="coleclientitemsetextent"></a><a name="setextent"></a>COleClientItem：： SetExtent

呼叫此函式可指定 OLE 專案有多少可用空間。

```cpp
void SetExtent(
    const CSize& size,
    DVASPECT nDrawAspect = DVASPECT_CONTENT);
```

### <a name="parameters"></a>參數

*size*<br/>
包含大小資訊的[CSize](../../atl-mfc-shared/reference/csize-class.md)物件。

*nDrawAspect*<br/>
指定要設定其界限的 OLE 專案的層面。 如需可能的值，請參閱[SetDrawAspect](#setdrawaspect)。

### <a name="remarks"></a>備註

如果伺服器應用程式是使用 MFC 程式庫所撰寫，這會呼叫[OnSetExtent](../../mfc/reference/coleserveritem-class.md#onsetextent)對應`COleServerItem`物件的 OnSetExtent 成員函式。 然後，OLE 專案可以據以調整其顯示。 維度必須是 MM_HIMETRIC 單位。 當使用者調整 OLE 專案的大小時，或如果您支援某種形式的版面配置協商，請呼叫此函式。

如需詳細資訊，請參閱 Windows SDK 中的[IOleObject：： SetExtent](/windows/win32/api/oleidl/nf-oleidl-ioleobject-setextent) 。

## <a name="coleclientitemsethostnames"></a><a name="sethostnames"></a>COleClientItem：： SetHostNames

呼叫此函式可指定容器應用程式的名稱，以及內嵌 OLE 專案的容器名稱。

```cpp
void SetHostNames(
    LPCTSTR lpszHost,
    LPCTSTR lpszHostObj);
```

### <a name="parameters"></a>參數

*lpszHost*<br/>
容器應用程式使用者可見名稱的指標。

*lpszHostObj*<br/>
包含 OLE 專案之容器的識別字串指標。

### <a name="remarks"></a>備註

如果伺服器應用程式是使用 MFC 程式庫撰寫的，此函式會[OnSetHostNames](../../mfc/reference/coleserverdoc-class.md#onsethostnames)呼叫包含 OLE 專案之`COleServerDoc`檔的 OnSetHostNames 成員函式。 當編輯 OLE 專案時，會在視窗標題中使用這項資訊。 每次載入容器檔案時，架構都會針對檔中的所有 OLE 專案呼叫這個函式。 `SetHostNames`僅適用于內嵌專案。 每次啟用內嵌 OLE 專案進行編輯時，都不需要呼叫這個函式。

當載入物件時，或以不同的名稱儲存檔案時，也會自動以應用程式名稱和檔案名稱來呼叫。 因此，通常不需要直接呼叫此函式。

如需詳細資訊，請參閱 Windows SDK 中的[IOleObject：： SetHostNames](/windows/win32/api/oleidl/nf-oleidl-ioleobject-sethostnames) 。

## <a name="coleclientitemseticonicmetafile"></a><a name="seticonicmetafile"></a>COleClientItem：： SetIconicMetafile

快取用來繪製專案圖示的中繼檔。

```
BOOL SetIconicMetafile(HGLOBAL hMetaPict);
```

### <a name="parameters"></a>參數

*hMetaPict*<br/>
用來繪製專案圖示之中繼檔的控制碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

使用[GetIconicMetafile](#geticonicmetafile)來取出中繼檔。

*HMetaPict*參數會複製到專案中;因此，呼叫端必須釋放*hMetaPict* 。

## <a name="coleclientitemsetitemrects"></a><a name="setitemrects"></a>COleClientItem：： SetItemRects

呼叫此函式可設定周框或 OLE 專案的可見矩形。

```
BOOL SetItemRects(
    LPCRECT lpPosRect = NULL,
    LPCRECT lpClipRect = NULL);
```

### <a name="parameters"></a>參數

*lprcPosRect*<br/>
矩形的指標，其中包含相對於其父視窗的 OLE 專案界限（以工作區座標表示）。

*lprcClipRect*<br/>
矩形的指標，其中包含 OLE 專案相對於其父視窗的可見部分範圍（以工作區座標表示）。

### <a name="return-value"></a>傳回值

如果成功，則為非零;否則為0。

### <a name="remarks"></a>備註

[OnChangeItemPosition](#onchangeitemposition)成員函式的預設實值會呼叫這個函式。 當 OLE 專案的位置或可見部分變更時，您應該呼叫這個函式。 通常這表示您會從 view 的[OnSize](../../mfc/reference/cwnd-class.md#onsize)和[OnScrollBy](../../mfc/reference/cview-class.md#onscrollby)成員函式呼叫它。

如需詳細資訊，請參閱 Windows SDK 中的[IOleInPlaceObject：： SetObjectRects](/windows/win32/api/oleidl/nf-oleidl-ioleinplaceobject-setobjectrects) 。

## <a name="coleclientitemsetlinkupdateoptions"></a><a name="setlinkupdateoptions"></a>COleClientItem：： SetLinkUpdateOptions

呼叫此函式可設定指定連結專案之呈現的連結-更新選項。

```cpp
void SetLinkUpdateOptions(OLEUPDATE dwUpdateOpt);
```

### <a name="parameters"></a>參數

*dwUpdateOpt*<br/>
此專案的連結-更新選項值。 此值必須是下列其中一項：

- OLEUPDATE_ALWAYS 盡可能更新連結的專案。 此選項支援 [連結] 對話方塊中的 [自動連結更新] 選項按鈕。

- OLEUPDATE_ONCALL 只在容器應用程式的要求上更新連結的專案（呼叫[UpdateLink](#updatelink)成員函式時）。 此選項支援 [連結] 對話方塊中的 [手動連結-更新] 選項按鈕。

### <a name="remarks"></a>備註

一般來說，您不應該在 [連結] 對話方塊中變更使用者所選擇的更新選項。

如需詳細資訊，請參閱 Windows SDK 中的[IOleLink：： SetUpdateOptions](/windows/win32/api/oleidl/nf-oleidl-iolelink-setupdateoptions) 。

## <a name="coleclientitemsetprintdevice"></a><a name="setprintdevice"></a>COleClientItem：： SetPrintDevice

呼叫此函式可變更此專案的列印目標裝置。

```
BOOL SetPrintDevice(const DVTARGETDEVICE* ptd);
BOOL SetPrintDevice(const PRINTDLG* ppd);
```

### <a name="parameters"></a>參數

*ptd*<br/>
[DVTARGETDEVICE](/windows/win32/api/objidl/ns-objidl-dvtargetdevice)資料結構的指標，其中包含新列印目標裝置的相關資訊。 可以是 NULL。

*ppd*<br/>
[PRINTDLG](/windows/win32/api/commdlg/ns-commdlg-printdlga)資料結構的指標，其中包含新列印目標裝置的相關資訊。 可以是 NULL。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零;否則為0。

### <a name="remarks"></a>備註

此函式會更新專案的列印目標裝置，但不會重新整理簡報快取。 若要更新專案的呈現快取，請呼叫[UpdateLink](#updatelink)。

此函式的引數包含 OLE 系統用來識別目標裝置的資訊。 `PRINTDLG`結構包含 Windows 用來初始化一般 [列印] 對話方塊的資訊。 在使用者關閉對話方塊之後，Windows 會傳回此結構中使用者選取專案的相關資訊。 CPrintDialog `m_pd`物件的成員[CPrintDialog](../../mfc/reference/cprintdialog-class.md)是一個`PRINTDLG`結構。

如需此結構的詳細資訊，請參閱 Windows SDK 中的[PRINTDLG](/windows/win32/api/commdlg/ns-commdlg-printdlga) 。

如需詳細資訊，請參閱 Windows SDK 中的[DVTARGETDEVICE](/windows/win32/api/objidl/ns-objidl-dvtargetdevice) 。

## <a name="coleclientitemupdatelink"></a><a name="updatelink"></a>COleClientItem：： UpdateLink

呼叫此函式以立即更新 OLE 專案的呈現資料。

```
BOOL UpdateLink();
```

### <a name="return-value"></a>傳回值

非零成功，否則為 0。

### <a name="remarks"></a>備註

針對連結的專案，函式會尋找連結來源，以取得 OLE 專案的新簡報。 此程式可能牽涉到執行一或多個伺服器應用程式，這可能非常耗時。 針對內嵌專案，函式會以遞迴方式運作，檢查內嵌專案是否包含可能已過期的連結並加以更新。 使用者也可以使用 [連結] 對話方塊，手動更新個別的連結。

如需詳細資訊，請參閱 Windows SDK 中的[IOleLink：： Update](/windows/win32/api/oleidl/nf-oleidl-iolelink-update) 。

## <a name="see-also"></a>另請參閱

[MFC 範例 MFCBIND](../../overview/visual-cpp-samples.md)<br/>
[MFC 範例 OCLIENT](../../overview/visual-cpp-samples.md)<br/>
[CDocItem 類別](../../mfc/reference/cdocitem-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[COleServerItem 類別](../../mfc/reference/coleserveritem-class.md)
