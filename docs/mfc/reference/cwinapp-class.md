---
title: CWinApp 類別
ms.date: 07/15/2019
f1_keywords:
- CWinApp
- AFXWIN/CWinApp
- AFXWIN/CWinApp::CWinApp
- AFXWIN/CWinApp::AddDocTemplate
- AFXWIN/CWinApp::AddToRecentFileList
- AFXWIN/CWinApp::ApplicationRecoveryCallback
- AFXWIN/CWinApp::CloseAllDocuments
- AFXWIN/CWinApp::CreatePrinterDC
- AFXWIN/CWinApp::DelRegTree
- AFXWIN/CWinApp::DoMessageBox
- AFXWIN/CWinApp::DoWaitCursor
- AFXWIN/CWinApp::EnableD2DSupport
- AFXWIN/CWinApp::EnableHtmlHelp
- AFXWIN/CWinApp::EnableTaskbarInteraction
- AFXWIN/CWinApp::ExitInstance
- AFXWIN/CWinApp::GetApplicationRecoveryParameter
- AFXWIN/CWinApp::GetApplicationRecoveryPingInterval
- AFXWIN/CWinApp::GetApplicationRestartFlags
- AFXWIN/CWinApp::GetAppRegistryKey
- AFXWIN/CWinApp::GetDataRecoveryHandler
- AFXWIN/CWinApp::GetFirstDocTemplatePosition
- AFXWIN/CWinApp::GetHelpMode
- AFXWIN/CWinApp::GetNextDocTemplate
- AFXWIN/CWinApp::GetPrinterDeviceDefaults
- AFXWIN/CWinApp::GetProfileBinary
- AFXWIN/CWinApp::GetProfileInt
- AFXWIN/CWinApp::GetProfileString
- AFXWIN/CWinApp::GetSectionKey
- AFXWIN/CWinApp::HideApplication
- AFXWIN/CWinApp::HtmlHelp
- AFXWIN/CWinApp::InitInstance
- AFXWIN/CWinApp::IsTaskbarInteractionEnabled
- AFXWIN/CWinApp::LoadCursor
- AFXWIN/CWinApp::LoadIcon
- AFXWIN/CWinApp::LoadOEMCursor
- AFXWIN/CWinApp::LoadOEMIcon
- AFXWIN/CWinApp::LoadStandardCursor
- AFXWIN/CWinApp::LoadStandardIcon
- AFXWIN/CWinApp::OnDDECommand
- AFXWIN/CWinApp::OnIdle
- AFXWIN/CWinApp::OpenDocumentFile
- AFXWIN/CWinApp::ParseCommandLine
- AFXWIN/CWinApp::PreTranslateMessage
- AFXWIN/CWinApp::ProcessMessageFilter
- AFXWIN/CWinApp::ProcessShellCommand
- AFXWIN/CWinApp::ProcessWndProcException
- AFXWIN/CWinApp::Register
- AFXWIN/CWinApp::RegisterWithRestartManager
- AFXWIN/CWinApp::ReopenPreviousFilesAtRestart
- AFXWIN/CWinApp::RestartInstance
- AFXWIN/CWinApp::RestoreAutosavedFilesAtRestart
- AFXWIN/CWinApp::Run
- AFXWIN/CWinApp::RunAutomated
- AFXWIN/CWinApp::RunEmbedded
- AFXWIN/CWinApp::SaveAllModified
- AFXWIN/CWinApp::SelectPrinter
- AFXWIN/CWinApp::SetHelpMode
- AFXWIN/CWinApp::SupportsApplicationRecovery
- AFXWIN/CWinApp::SupportsAutosaveAtInterval
- AFXWIN/CWinApp::SupportsAutosaveAtRestart
- AFXWIN/CWinApp::SupportsRestartManager
- AFXWIN/CWinApp::Unregister
- AFXWIN/CWinApp::WinHelp
- AFXWIN/CWinApp::WriteProfileBinary
- AFXWIN/CWinApp::WriteProfileInt
- AFXWIN/CWinApp::WriteProfileString
- AFXWIN/CWinApp::EnableShellOpen
- AFXWIN/CWinApp::LoadStdProfileSettings
- AFXWIN/CWinApp::OnContextHelp
- AFXWIN/CWinApp::OnFileNew
- AFXWIN/CWinApp::OnFileOpen
- AFXWIN/CWinApp::OnFilePrintSetup
- AFXWIN/CWinApp::OnHelp
- AFXWIN/CWinApp::OnHelpFinder
- AFXWIN/CWinApp::OnHelpIndex
- AFXWIN/CWinApp::OnHelpUsing
- AFXWIN/CWinApp::RegisterShellFileTypes
- AFXWIN/CWinApp::SetAppID
- AFXWIN/CWinApp::SetRegistryKey
- AFXWIN/CWinApp::UnregisterShellFileTypes
- AFXWIN/CWinApp::m_bHelpMode
- AFXWIN/CWinApp::m_eHelpType
- AFXWIN/CWinApp::m_hInstance
- AFXWIN/CWinApp::m_lpCmdLine
- AFXWIN/CWinApp::m_nCmdShow
- AFXWIN/CWinApp::m_pActiveWnd
- AFXWIN/CWinApp::m_pszAppID
- AFXWIN/CWinApp::m_pszAppName
- AFXWIN/CWinApp::m_pszExeName
- AFXWIN/CWinApp::m_pszHelpFilePath
- AFXWIN/CWinApp::m_pszProfileName
- AFXWIN/CWinApp::m_pszRegistryKey
- AFXWIN/CWinApp::m_dwRestartManagerSupportFlags
- AFXWIN/CWinApp::m_nAutosaveInterval
- AFXWIN/CWinApp::m_pDataRecoveryHandler
helpviewer_keywords:
- CWinApp [MFC], CWinApp
- CWinApp [MFC], AddDocTemplate
- CWinApp [MFC], AddToRecentFileList
- CWinApp [MFC], ApplicationRecoveryCallback
- CWinApp [MFC], CloseAllDocuments
- CWinApp [MFC], CreatePrinterDC
- CWinApp [MFC], DelRegTree
- CWinApp [MFC], DoMessageBox
- CWinApp [MFC], DoWaitCursor
- CWinApp [MFC], EnableD2DSupport
- CWinApp [MFC], EnableHtmlHelp
- CWinApp [MFC], EnableTaskbarInteraction
- CWinApp [MFC], ExitInstance
- CWinApp [MFC], GetApplicationRecoveryParameter
- CWinApp [MFC], GetApplicationRecoveryPingInterval
- CWinApp [MFC], GetApplicationRestartFlags
- CWinApp [MFC], GetAppRegistryKey
- CWinApp [MFC], GetDataRecoveryHandler
- CWinApp [MFC], GetFirstDocTemplatePosition
- CWinApp [MFC], GetHelpMode
- CWinApp [MFC], GetNextDocTemplate
- CWinApp [MFC], GetPrinterDeviceDefaults
- CWinApp [MFC], GetProfileBinary
- CWinApp [MFC], GetProfileInt
- CWinApp [MFC], GetProfileString
- CWinApp [MFC], GetSectionKey
- CWinApp [MFC], HideApplication
- CWinApp [MFC], HtmlHelp
- CWinApp [MFC], InitInstance
- CWinApp [MFC], IsTaskbarInteractionEnabled
- CWinApp [MFC], LoadCursor
- CWinApp [MFC], LoadIcon
- CWinApp [MFC], LoadOEMCursor
- CWinApp [MFC], LoadOEMIcon
- CWinApp [MFC], LoadStandardCursor
- CWinApp [MFC], LoadStandardIcon
- CWinApp [MFC], OnDDECommand
- CWinApp [MFC], OnIdle
- CWinApp [MFC], OpenDocumentFile
- CWinApp [MFC], ParseCommandLine
- CWinApp [MFC], PreTranslateMessage
- CWinApp [MFC], ProcessMessageFilter
- CWinApp [MFC], ProcessShellCommand
- CWinApp [MFC], ProcessWndProcException
- CWinApp [MFC], Register
- CWinApp [MFC], RegisterWithRestartManager
- CWinApp [MFC], ReopenPreviousFilesAtRestart
- CWinApp [MFC], RestartInstance
- CWinApp [MFC], RestoreAutosavedFilesAtRestart
- CWinApp [MFC], Run
- CWinApp [MFC], RunAutomated
- CWinApp [MFC], RunEmbedded
- CWinApp [MFC], SaveAllModified
- CWinApp [MFC], SelectPrinter
- CWinApp [MFC], SetHelpMode
- CWinApp [MFC], SupportsApplicationRecovery
- CWinApp [MFC], SupportsAutosaveAtInterval
- CWinApp [MFC], SupportsAutosaveAtRestart
- CWinApp [MFC], SupportsRestartManager
- CWinApp [MFC], Unregister
- CWinApp [MFC], WinHelp
- CWinApp [MFC], WriteProfileBinary
- CWinApp [MFC], WriteProfileInt
- CWinApp [MFC], WriteProfileString
- CWinApp [MFC], EnableShellOpen
- CWinApp [MFC], LoadStdProfileSettings
- CWinApp [MFC], OnContextHelp
- CWinApp [MFC], OnFileNew
- CWinApp [MFC], OnFileOpen
- CWinApp [MFC], OnFilePrintSetup
- CWinApp [MFC], OnHelp
- CWinApp [MFC], OnHelpFinder
- CWinApp [MFC], OnHelpIndex
- CWinApp [MFC], OnHelpUsing
- CWinApp [MFC], RegisterShellFileTypes
- CWinApp [MFC], SetAppID
- CWinApp [MFC], SetRegistryKey
- CWinApp [MFC], UnregisterShellFileTypes
- CWinApp [MFC], m_bHelpMode
- CWinApp [MFC], m_eHelpType
- CWinApp [MFC], m_hInstance
- CWinApp [MFC], m_lpCmdLine
- CWinApp [MFC], m_nCmdShow
- CWinApp [MFC], m_pActiveWnd
- CWinApp [MFC], m_pszAppID
- CWinApp [MFC], m_pszAppName
- CWinApp [MFC], m_pszExeName
- CWinApp [MFC], m_pszHelpFilePath
- CWinApp [MFC], m_pszProfileName
- CWinApp [MFC], m_pszRegistryKey
- CWinApp [MFC], m_dwRestartManagerSupportFlags
- CWinApp [MFC], m_nAutosaveInterval
- CWinApp [MFC], m_pDataRecoveryHandler
ms.assetid: e426a3cd-0d15-40d6-bd55-beaa5feb2343
ms.openlocfilehash: 4bb1ade4182424cbdcbf0d7ba69af88bbb88abe6
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/22/2020
ms.locfileid: "81750680"
---
# <a name="cwinapp-class"></a>CWinApp 類別

Windows 應用程式物件所衍生自的基底類別。

## <a name="syntax"></a>語法

```
class CWinApp : public CWinThread
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CWinApp:CWinApp](#cwinapp)|建構 `CWinApp` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CWinApp::添加DocTemplate](#adddoctemplate)|將文件範本添加到應用程式的可用文件範本清單中。|
|[CWinApp::添加到最新檔案清單](#addtorecentfilelist)|將檔案名添加到最近使用的 (MRU) 檔案清單中。|
|[CWinApp::應用程式恢復回電](#applicationrecoverycallback)|當應用程式意外退出時,由框架調用。|
|[CWinApp:關閉所有文件](#closealldocuments)|關閉所有打開的文檔。|
|[CWinApp::建立印表機DC](#createprinterdc)|創建印表機設備上下文。|
|[CWinApp::DelRegTree](#delregtree)|刪除指定的金鑰及其所有子鍵。|
|[CWinApp::DoMessageBox](#domessagebox)|為應用程序實現[AfxMessageBox。](cstring-formatting-and-message-box-display.md#afxmessagebox)|
|[CWinApp::Do等待游標](#dowaitcursor)|打開和關閉等待游標。|
|[CWinApp:啟用D2D支援](#enabled2dsupport)|支援應用程式 D2D 支援。 初始化主視窗之前先呼叫這個方法。|
|[CWinApp::啟用Html説明](#enablehtmlhelp)|實現應用程式的 HTML 説明,而不是 WinHelp。|
|[CWinApp::啟用任務列交互](#enabletaskbarinteraction)|啟用任務列交互。|
|[CWinApp:退出實例](#exitinstance)|覆蓋以在應用程式終止時清理。|
|[CWinApp:抓取應用程式復原參數](#getapplicationrecoveryparameter)|檢索應用程式恢復方法的輸入參數。|
|[CWinApp:取得應用程式恢復間隔](#getapplicationrecoverypinginterval)|返回重新啟動管理器等待恢復回調函數返回的時間長度。|
|[CWinApp::取得應用程式重啟標誌](#getapplicationrestartflags)|返回重新啟動管理員的標誌。|
|[CWinApp::獲取應用註冊金鑰](#getappregistrykey)|返回HKEY_CURRENT_USER"\\軟體"的金鑰\註冊表項\配置檔名稱。|
|[CWinApp:抓取資料復原處理程式](#getdatarecoveryhandler)|獲取應用程式此實例的數據恢復處理程式。|
|[CWinApp:取得第一文件樣本位置](#getfirstdoctemplateposition)|檢索第一個文檔範本的位置。|
|[CWinApp:取得説明模式](#gethelpmode)|檢索應用程式使用的幫助類型。|
|[CWinApp::獲取NextDocTemplate](#getnextdoctemplate)|檢索文件範本的位置。 可遞歸使用。|
|[CWinApp::取得印表機設備預設值](#getprinterdevicedefaults)|檢索印表機設備預設值。|
|[CWinApp:取得設定檔二進位](#getprofilebinary)|從應用程式中的條目檢索二進位數據。INI 檔。|
|[CWinApp:取得設定檔](#getprofileint)|從應用程式中的條目中檢索整數。INI 檔。|
|[CWinApp:取得設定檔案字串](#getprofilestring)|從應用程式中的項目中檢索字串。INI 檔。|
|[CWinApp:取得節鍵](#getsectionkey)|返回HKEY_CURRENT_USER"\\軟體"的鍵\註冊表項\AppName_lpszSection。|
|[CWinApp:隱藏應用程式](#hideapplication)|在關閉所有文檔之前隱藏應用程式。|
|[CWinApp:html説明](#htmlhelp)|調用`HTMLHelp`Windows 函數。|
|[CWinApp:ininininininininininininininininininininInin](#initinstance)|覆蓋以執行 Windows 實例初始化,例如創建視窗物件。|
|[CWinApp:是任務列互動啟用](#istaskbarinteractionenabled)|告訴是否啟用了 Windows 7 任務列交互。|
|[CWinApp::載入游標](#loadcursor)|載入游標資源。|
|[CWinApp::載入圖示](#loadicon)|載入圖示資源。|
|[CWinApp::載入OEM游標](#loadoemcursor)|載入**OCR_** 常量在 WINDOWS 中指定的 Windows OEM 預先定義游標。H。|
|[CWinApp::載入OEMIcon](#loadoemicon)|載入**OIC_** 常量在 WINDOWS 中指定的 Windows OEM 預先定義圖示。H。|
|[CWinApp::載入標準游標](#loadstandardcursor)|載入**IDC_** 常量在 WINDOWS 中指定的 Windows 預定義游標。H。|
|[CWinApp::載入標準圖示](#loadstandardicon)|載入**IDI_** 常量在 WINDOWS 中指定的 Windows 預先定義圖示。H。|
|[CWinApp:OnDDE命令](#onddecommand)|框架調用以回應動態資料交換 (DDE) 執行命令。|
|[CWinApp::上](#onidle)|覆蓋以執行特定於應用程式的空閑時間處理。|
|[CWinApp::開啟檔案檔案](#opendocumentfile)|由框架呼叫以從文件打開文件。|
|[CWinApp::P](#parsecommandline)|分析命令列中的單個參數和標誌。|
|[CWinApp::P重新翻譯訊息](#pretranslatemessage)|在郵件發送到 Windows 函數[「翻譯訊息](/windows/win32/api/winuser/nf-winuser-translatemessage)」和[「調度訊息](/windows/win32/api/winuser/nf-winuser-dispatchmessage)」之前對其進行篩選。|
|[CWinApp::Process消息篩檢程式](#processmessagefilter)|在某些消息到達應用程式之前攔截它們。|
|[CWinApp::P羅塞斯舍爾命令](#processshellcommand)|處理命令列參數和標誌。|
|[CWinApp::P羅塞斯·溫德普羅奇例外](#processwndprocexception)|攔截應用程式的消息和命令處理程序引發的所有未處理異常。|
|[CWinApp:註冊](#register)|執行自定義註冊。|
|[CWinApp::註冊與重新啟動管理器](#registerwithrestartmanager)|向重新啟動管理器註冊應用程式。|
|[CWinApp::重新打開以前的檔在重新啟動](#reopenpreviousfilesatrestart)|確定重新啟動管理員是否重新打開應用程式意外退出時打開的檔案。|
|[CWinApp:重新啟動實體](#restartinstance)|處理重新啟動管理器啟動的應用程式重新啟動。|
|[CWinApp::回復自動儲存的檔案在重新啟動](#restoreautosavedfilesatrestart)|確定重新啟動管理員在重新啟動應用程式時是否還原自動儲存的檔。|
|[CWinApp::運行](#run)|運行預設消息迴圈。 重寫以自定義消息迴圈。|
|[CWinApp::執行自動](#runautomated)|測試應用程式的命令行為 **/自動化**選項。 已過時。 而是在調用[ParseCommandLine](#parsecommandline)後,使用[CCommandLineInfo::m_bRunAutomated](../../mfc/reference/ccommandlineinfo-class.md#m_brunautomated)中的值。|
|[CWinApp::運行嵌入式](#runembedded)|測試應用程式的命令列/**嵌入**選項。 已過時。 而是在調用[ParseCommandLine](#parsecommandline)後,使用[CCommandLineInfo::m_bRunEmbedded](../../mfc/reference/ccommandlineinfo-class.md#m_brunembedded)中的值。|
|[CWinApp::保存所有修改](#saveallmodified)|提示使用者保存所有修改的文檔。|
|[CWinApp::選擇印表機](#selectprinter)|通過列印對話框選擇以前由使用者指示的印表機。|
|[CWinApp::設定説明模式](#sethelpmode)|設置和初始化應用程式使用的幫助類型。|
|[CWinApp::支援應用程式恢復](#supportsapplicationrecovery)|確定重新啟動管理員是否恢復意外退出的應用程式。|
|[CWinApp::支援自動儲存At間隔](#supportsautosaveatinterval)|確定重新啟動管理員是否以常規間隔自動儲存打開的文檔。|
|[CWinApp::支援自動儲存Atrestart](#supportsautosaveatrestart)|確定重新啟動管理員在應用程式重新啟動時是否自動儲存任何打開的文件。|
|[CWinApp::支援重新啟動管理員](#supportsrestartmanager)|確定應用程式是否支援重新啟動管理員。|
|[CWinApp::取消註冊](#unregister)|取消註冊`CWinApp`物件註冊的所有內容。|
|[CWinApp::贏説明](#winhelp)|調用`WinHelp`Windows 函數。|
|[CWinApp::寫配置檔二進位](#writeprofilebinary)|將二進位資料寫入應用程式的條目。INI 檔。|
|[CWinApp::寫配置檔](#writeprofileint)|將整數寫入應用程式的條目。INI 檔。|
|[CWinApp::寫配置檔字串](#writeprofilestring)|將字串寫入應用程式中的項目。INI 檔。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[CWinApp::啟用ShellOpen](#enableshellopen)|允許使用者從 Windows 檔案管理器打開數據檔。|
|[CWinApp::載入Std設定檔設定](#loadstdprofilesettings)|負載標準 。INI 檔案設定並啟用 MRU 檔案清單功能。|
|[CWinApp:在上下文説明](#oncontexthelp)|在應用程式中處理 SHIFT_F1説明。|
|[CWinApp:在檔新](#onfilenew)|實現ID_FILE_NEW命令。|
|[CWinApp:在檔案開啟](#onfileopen)|實現ID_FILE_OPEN命令。|
|[CWinApp::在檔案列印設定](#onfileprintsetup)|實現ID_FILE_PRINT_SETUP命令。|
|[CWinApp::上説明](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|
|[CWinApp::在説明查找器上](#onhelpfinder)|處理ID_HELP_FINDER和ID_DEFAULT_HELP命令。|
|[CWinApp::在説明索引](#onhelpindex)|處理ID_HELP_INDEX命令並提供默認幫助主題。|
|[CWinApp::在説明使用](#onhelpusing)|處理ID_HELP_USING命令。|
|[CWinApp::註冊外殼文件類型](#registershellfiletypes)|向 Windows 檔案管理員註冊應用程式的所有文件類型。|
|[CWinApp::SetAppID](#setappid)|顯式設置應用程式的應用程式使用者模型 ID。 在向使用者顯示任何使用者介面之前,應調用此方法(最佳位置是應用程式構造函數)。|
|[CWinApp::設定註冊金鑰](#setregistrykey)|導致應用程式設定儲存在註冊表中而不是 。INI 檔。|
|[CWinApp::取消註冊ShellFile類型](#unregistershellfiletypes)|向 Windows 檔案管理員取消註冊應用程式的所有文件類型。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CWinApp:m_bHelpMode](#m_bhelpmode)|指示使用者是否處於説明上下文模式(通常使用SHIFT_F1調用)。|
|[CWinApp:m_eHelpType](#m_ehelptype)|指定應用程式使用的幫助類型。|
|[CWinApp:m_hInstance](#m_hinstance)|標識應用程式的當前實例。|
|[CWinApp:m_lpCmdLine](#m_lpcmdline)|指定應用程式的指令列的 null 連接字串。|
|[CWinApp:m_nCmdShow](#m_ncmdshow)|指定最初顯示視窗的方式。|
|[CWinApp:m_pActiveWnd](#m_pactivewnd)|當 OLE 伺服器就地處於活動狀態時,指向容器應用程式的主視窗。|
|[CWinApp:m_pszAppID](#m_pszappid)|應用程式使用者型號 ID。|
|[CWinApp:m_pszAppName](#m_pszappname)|指定應用程式的名稱。|
|[CWinApp:m_pszExeName](#m_pszexename)|應用程式的模組名稱。|
|[CWinApp:m_pszHelpFilePath](#m_pszhelpfilepath)|應用程式的幫助文件的路徑。|
|[CWinApp:m_pszProfileName](#m_pszprofilename)|應用程式的 。INI 檔名。|
|[CWinApp:m_pszRegistryKey](#m_pszregistrykey)|用於確定用於存儲應用程式配置檔設置的完整註冊表項。|

### <a name="protected-data-members"></a>受保護的資料成員

|名稱|描述|
|----------|-----------------|
|[CWinApp:m_dwRestartManagerSupportFlags](#m_dwrestartmanagersupportflags)|確定重新啟動管理器如何執行的標誌。|
|[CWinApp:m_nAutosaveInterval](#m_nautosaveinterval)|自動保存之間的時間長度(以毫秒為單位)。|
|[CWinApp:m_pDataRecoveryHandler](#m_pdatarecoveryhandler)|指向應用程式的數據恢復處理程序的指標。|

## <a name="remarks"></a>備註

應用程式物件提供成員函數,用於初始化應用程式(及其每個實例)和運行應用程式。

使用 Microsoft 基礎類的每個應用程式只能包含派生`CWinApp`自 的一個物件。 此物件是在構造其他C++全域物件時構造的,並且在Windows調用由`WinMain`Microsoft基礎類庫提供的函數時已經可用。 在全域級別`CWinApp`聲明派生物件。

從 派生應用程式類`CWinApp`時 ,將重寫[InitInstance](#initinstance)成員函數以創建應用程式的主視窗物件。

除了`CWinApp`成員函數之外,Microsoft 基礎類庫還提供以下全域函數來存取`CWinApp`物件 和其他全域資訊:

- [AfxGetApp](application-information-and-management.md#afxgetapp)獲取指向對象`CWinApp`的指標。

- [AfxGetinstanceHandle](application-information-and-management.md#afxgetinstancehandle)獲取當前應用程式實例的句柄。

- [AfxGet資源手柄](application-information-and-management.md#afxgetresourcehandle)獲取應用程式的資源的句柄。

- [AfxGetApp名稱](application-information-and-management.md#afxgetappname)獲取指向包含應用程式名稱的字串的指標。 或者,如果您有指向物件的指標,`CWinApp`請使用`m_pszExeName`來獲取應用程式的名稱。

有關`CWinApp`該類的詳細資訊,請參閱[CWinApp:應用程式類](../../mfc/cwinapp-the-application-class.md),包括以下概述:

- `CWinApp`-由應用程式精靈編寫的派生代碼。

- `CWinApp`在應用程式的執行序列中的角色。

- `CWinApp`的預設成員函數實現。

- `CWinApp`關鍵超易。

數據`m_hPrevInstance`成員不再存在。 要確定應用程式的另一個實例是否正在運行,請使用命名的互斥體。 如果打開互斥體失敗,則應用程式沒有其他實例運行。

## <a name="inheritance-hierarchy"></a>繼承階層架構

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

[CWinThread](../../mfc/reference/cwinthread-class.md)

`CWinApp`

## <a name="requirements"></a>需求

**標題:** afxwin.h

## <a name="cwinappadddoctemplate"></a><a name="adddoctemplate"></a>CWinApp::添加DocTemplate

呼叫此成員函數將文件範本添加到應用程式維護的可用文件範本清單中。

```cpp
void AddDocTemplate(CDocTemplate* pTemplate);
```

### <a name="parameters"></a>參數

*pTemplate*<br/>
要添加的`CDocTemplate`指標。

### <a name="remarks"></a>備註

在調用[註冊ShellFileType](#registershellfiletypes)之前,應將所有文檔範本添加到應用程式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#35](../../mfc/reference/codesnippet/cpp/cwinapp-class_1.cpp)]

## <a name="cwinappaddtorecentfilelist"></a><a name="addtorecentfilelist"></a>CWinApp::添加到最新檔案清單

呼叫此成員函數將*lpszPathName*添加到 MRU 檔案清單中。

```
virtual void AddToRecentFileList(LPCTSTR lpszPathName);
```

### <a name="parameters"></a>參數

*lpszPath名稱*<br/>
檔案的路徑。

### <a name="remarks"></a>備註

在使用此成員函數之前,應呼叫[LoadStdProfile 設定](#loadstdprofilesettings)成員函數來載入目前的 MRU 檔案清單。

當框架打開檔或執行「儲存為」命令以儲存具有新名稱的檔時,將呼叫此成員函數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#36](../../mfc/reference/codesnippet/cpp/cwinapp-class_2.cpp)]

## <a name="cwinappapplicationrecoverycallback"></a><a name="applicationrecoverycallback"></a>CWinApp::應用程式恢復回電

當應用程式意外退出時,由框架調用。

```
virtual DWORD ApplicationRecoveryCallback(LPVOID lpvParam);
```

### <a name="parameters"></a>參數

*lpvParam*<br/>
[在]保留以供將來使用。

### <a name="return-value"></a>傳回值

如果此方法成功,為 0;如果發生錯誤,則非零。

### <a name="remarks"></a>備註

如果應用程式支援重新啟動管理器,則當應用程式意外退出時,框架將調用此函數。

的`ApplicationRecoveryCallback`預設實現`CDataRecoveryHandler`使用 將當前打開的文件的清單保存到註冊表。 此方法不自動保存任何檔。

要自定義行為,請在派生[的 CWinApp 類別](../../mfc/reference/cwinapp-class.md)中重寫此函數,或將您自己的應用程式恢復方法作為參數傳遞給[CWinApp::註冊與 RestartManager](#registerwithrestartmanager)。

## <a name="cwinappclosealldocuments"></a><a name="closealldocuments"></a>CWinApp:關閉所有文件

在退出之前調用此成員函數關閉所有打開的文檔。

```cpp
void CloseAllDocuments(BOOL bEndSession);
```

### <a name="parameters"></a>參數

*bEndSession*<br/>
指定是否終止 Windows 工作階段。 如果會話正在結束,則為 TRUE;如果會話已結束,則為 TRUE。否則 FALSE。

### <a name="remarks"></a>備註

在呼叫`CloseAllDocuments`之前呼叫[隱藏應用程式](#hideapplication)。

## <a name="cwinappcreateprinterdc"></a><a name="createprinterdc"></a>CWinApp::建立印表機DC

調用此成員函數從所選印表機創建印表機設備上下文 (DC)。

```
BOOL CreatePrinterDC(CDC& dc);
```

### <a name="parameters"></a>參數

*直流*<br/>
對印表機裝置上下文的引用。

### <a name="return-value"></a>傳回值

如果成功創建印表機設備上下文,則非零;否則 0。

### <a name="remarks"></a>備註

`CreatePrinterDC`初始化透過引用傳遞的裝置上下文,以便可以使用它進行列印。

如果函數成功,則在完成列印後,必須銷毀設備上下文。 您可以讓[CDC](../../mfc/reference/cdc-class.md)物件的析構函數執行此操作,也可以通過調用[CDC::DeleteDC](../../mfc/reference/cdc-class.md#deletedc)來顯式執行此操作。

## <a name="cwinappcwinapp"></a><a name="cwinapp"></a>CWinApp:CWinApp

建構`CWinApp`物件並傳遞*lpszAppName*以儲存為應用程式名稱。

```
CWinApp(LPCTSTR lpszAppName = NULL);
```

### <a name="parameters"></a>參數

*lpszApp 名稱*<br/>
包含 Windows 使用的應用程式名稱的 null 終止字串。 如果未提供此參數或為 NULL,`CWinApp`則使用資源字串AFX_IDS_APP_TITLE或可執行檔的檔案名。

### <a name="remarks"></a>備註

應構造`CWinApp`派生類的一個全域物件。 應用程式中只能有一個`CWinApp`物件。 建構函式儲存指向物件的指標,`CWinApp``WinMain`以便呼叫物件的成員函數來初始化和運行應用程式。

## <a name="cwinappdelregtree"></a><a name="delregtree"></a>CWinApp::DelRegTree

刪除特定的註冊表項及其所有子密鑰。

```
LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName);

LONG DelRegTree(
    HKEY hParentKey,
    const CString& strKeyName,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*h父鍵*<br/>
句柄到註冊表項。

*斯特基名稱*<br/>
要刪除的註冊表項的名稱。

*pTM*<br/>
指向 CAtl 事務管理器物件的指標。

### <a name="return-value"></a>傳回值

如果函數成功,則返回值ERROR_SUCCESS。 如果函數失敗,返回值是在 Winerror.h 中定義的非零錯誤代碼。

### <a name="remarks"></a>備註

呼叫此函數以刪除指定的密鑰及其子鍵。

## <a name="cwinappdomessagebox"></a><a name="domessagebox"></a>CWinApp::DoMessageBox

該框架調用此成員函數來實現全域函數[AfxMessageBox](cstring-formatting-and-message-box-display.md#afxmessagebox)的消息框。

```
virtual int DoMessageBox(
    LPCTSTR lpszPrompt,
    UINT nType,
    UINT nIDPrompt);
```

### <a name="parameters"></a>參數

*lpszPrompt*<br/>
消息框中的文本位址。

*nType*<br/>
訊息盒[樣式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)。

*NID提示*<br/>
説明上下文字串的索引。

### <a name="return-value"></a>傳回值

返回與`AfxMessageBox`的值相同的值。

### <a name="remarks"></a>備註

不要調用此成員函數打開消息框;改`AfxMessageBox`用。

重寫此成員函數以自定義應用程式範圍的`AfxMessageBox`話務處理。

## <a name="cwinappdowaitcursor"></a><a name="dowaitcursor"></a>CWinApp::Do等待游標

此成員函數由框架調用,以實現[CWaitCursor、CCmdTarget::開始等待游標](../../mfc/reference/ccmdtarget-class.md#beginwaitcursor)[、CCmdTarget::結束等待游標](../../mfc/reference/ccmdtarget-class.md#endwaitcursor)和[CmdTarget::還原等待游標](../../mfc/reference/ccmdtarget-class.md#restorewaitcursor)。 [CWaitCursor](../../mfc/reference/cwaitcursor-class.md)

```
virtual void DoWaitCursor(int nCode);
```

### <a name="parameters"></a>參數

*n代碼*<br/>
如果此參數為 1,則將顯示等待游標。 如果為 0,則無需增加引用計數即可還原等待游標。 如果 -1,則等待游標結束。

### <a name="remarks"></a>備註

默認值實現沙漏游標。 `DoWaitCursor`維護引用計數。 為正時,將顯示沙漏游標。

雖然通常不會直接調用`DoWaitCursor`,但可以重寫此成員函數以更改等待游標或在顯示等待游標時執行其他處理。

要取得更簡單、更簡化的方法來實現等待游標,請使用`CWaitCursor`。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#37](../../mfc/reference/codesnippet/cpp/cwinapp-class_3.cpp)]

## <a name="cwinappenabled2dsupport"></a><a name="enabled2dsupport"></a>CWinApp:啟用D2D支援

必須有 Visual Studio 2010 SP1。

支援應用程式 D2D 支援。 初始化主視窗之前先呼叫這個方法。

```
BOOL EnableD2DSupport(
    D2D1_FACTORY_TYPE d2dFactoryType = D2D1_FACTORY_TYPE_SINGLE_THREADED,
    DWRITE_FACTORY_TYPE writeFactoryType = DWRITE_FACTORY_TYPE_SHARED);
```

### <a name="parameters"></a>參數

*d2d 工廠類型*<br/>
D2D 工廠的線程模型及其創建的資源。

*寫入工廠類型*<br/>
指定寫入工廠物件是分享還是隔離的值

### <a name="return-value"></a>傳回值

開啟 D2D 支援,則傳回 TRUE,否則

## <a name="cwinappenablehtmlhelp"></a><a name="enablehtmlhelp"></a>CWinApp::啟用Html説明

從`CWinApp`派生類的建構函數中呼叫此成員函數,以便使用 HTMLHelp 來幫助應用程式。

```cpp
void EnableHtmlHelp();
```

### <a name="remarks"></a>備註

## <a name="cwinappenableshellopen"></a><a name="enableshellopen"></a>CWinApp::啟用ShellOpen

呼叫此函數(通常從`InitInstance`重寫)以使應用程式的使用者在從 Windows 檔管理器中雙擊檔時打開數據檔。

```cpp
void EnableShellOpen();
```

### <a name="remarks"></a>備註

將`RegisterShellFileTypes`成員函數與此函數結合使用,或提供 。註冊檔與您的應用程式手動註冊文件類型。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#38](../../mfc/reference/codesnippet/cpp/cwinapp-class_4.cpp)]

## <a name="cwinappenabletaskbarinteraction"></a><a name="enabletaskbarinteraction"></a>CWinApp::啟用任務列交互

啟用任務列交互。

```
BOOL EnableTaskbarInteraction(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*b 啟用*<br/>
指定是啟用與 Windows 7 工作列的互動(TRUE),還是禁用 (FALSE)。

### <a name="return-value"></a>傳回值

如果可以啟用或禁用任務列交互,則返回 TRUE。

### <a name="remarks"></a>備註

在創建主視窗之前,必須調用此方法,否則它斷言並返回 FALSE。

## <a name="cwinappexitinstance"></a><a name="exitinstance"></a>CWinApp:退出實例

由框架從`Run`成員函數中調用以退出應用程式的此實例。

```
virtual int ExitInstance();
```

### <a name="return-value"></a>傳回值

應用程式的退出代碼;0 表示沒有錯誤,大於 0 的值表示錯誤。 此值用作`WinMain`中的返回值。

### <a name="remarks"></a>備註

不要從任何位置調用此成員函數,`Run`但不得在成員函數內調用。

此函數的預設實現將框架選項寫入應用程式的 。INI 檔。 重寫此函數以在應用程式終止時清理。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#39](../../mfc/reference/codesnippet/cpp/cwinapp-class_5.cpp)]

## <a name="cwinappgetapplicationrecoveryparameter"></a><a name="getapplicationrecoveryparameter"></a>CWinApp:抓取應用程式復原參數

檢索應用程式恢復方法的輸入參數。

```
virtual LPVOID GetApplicationRecoveryParameter();
```

### <a name="return-value"></a>傳回值

應用程式恢復方法的預設輸入參數。

### <a name="remarks"></a>備註

此函數的預設行為返回 NULL。

有關詳細資訊,請參閱[CWinApp:應用程式恢復回電](#applicationrecoverycallback)。

## <a name="cwinappgetapplicationrecoverypinginterval"></a><a name="getapplicationrecoverypinginterval"></a>CWinApp:取得應用程式恢復間隔

返回重新啟動管理器等待恢復回調函數返回的時間長度。

```
virtual DWORD GetApplicationRecoveryPingInterval();
```

### <a name="return-value"></a>傳回值

時間長度(以毫秒為單位)。

### <a name="remarks"></a>備註

當註冊為重新啟動管理器的應用程式意外退出時,應用程式將嘗試保存打開的文檔並調用恢復回檔功能。 預設回復回檔函數是[CWinApp::應用程式恢復回檔](#applicationrecoverycallback)。

框架等待恢復回調函數返回的時間長度是 ping 間隔。 您可以透過重`CWinApp::GetApplicationRecoveryPingInterval`寫 或提供自訂值來自訂 ping`RegisterWithRestartManager`間隔 。

## <a name="cwinappgetapplicationrestartflags"></a><a name="getapplicationrestartflags"></a>CWinApp::取得應用程式重啟標誌

返回重新啟動管理員的標誌。

```
virtual DWORD GetApplicationRestartFlags();
```

### <a name="return-value"></a>傳回值

重新啟動管理員的標誌。 預設實現返回 0。

### <a name="remarks"></a>備註

重新啟動管理器的標誌對預設實現不起作用。 它們供將來使用。

使用[CWinApp::註冊與RestartManager](#registerwithrestartmanager)註冊應用程式時,您可以設置標誌。

重新啟動管理員旗標的可能值如下所示:

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

## <a name="cwinappgetappregistrykey"></a><a name="getappregistrykey"></a>CWinApp::獲取應用註冊金鑰

返回HKEY_CURRENT_USER"\\軟體"

```
HKEY GetAppRegistryKey(CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*pTM*<br/>
指向 `CAtlTransactionManager` 物件的指標。

### <a name="return-value"></a>傳回值

如果函數成功,則應用程式密鑰;否則 NULL。

### <a name="remarks"></a>備註

## <a name="cwinappgetdatarecoveryhandler"></a><a name="getdatarecoveryhandler"></a>CWinApp:抓取資料復原處理程式

獲取應用程式此實例的數據恢復處理程式。

```
virtual CDataRecoveryHandler *GetDataRecoveryHandler();
```

### <a name="return-value"></a>傳回值

應用程式此實例的數據恢復處理程式。

### <a name="remarks"></a>備註

使用重新啟動管理器的每個應用程式必須具有[CDataRecoveryHandler 類](../../mfc/reference/cdatarecoveryhandler-class.md)的一個實例。 此類負責監視打開的文檔和自動儲存檔。 的行為`CDataRecoveryHandler`取決於重新啟動管理員的配置。 有關詳細資訊,請參閱[CData 修復處理程式類別](../../mfc/reference/cdatarecoveryhandler-class.md)。

此方法在作業系統上返回 NULL 早於 Windows Vista。 重新啟動管理器在操作系統上不受 Windows Vista 的支援。

如果應用程式當前沒有數據恢復處理程式,此方法將創建一個並返回指向它的指標。

## <a name="cwinappgetfirstdoctemplateposition"></a><a name="getfirstdoctemplateposition"></a>CWinApp:取得第一文件樣本位置

獲取應用程式中第一個文檔範本的位置。

```
POSITION GetFirstDocTemplatePosition() const;
```

### <a name="return-value"></a>傳回值

可用於反覆運算或對象指標檢索的定位值;如果清單為空,則為 NULL。

### <a name="remarks"></a>備註

使用調用[GetNextDocTemplate](#getnextdoctemplate)中返回的"位置"值獲取第一個[CDocTemplate](../../mfc/reference/cdoctemplate-class.md)物件。

## <a name="cwinappgethelpmode"></a><a name="gethelpmode"></a>CWinApp:取得説明模式

檢索應用程式使用的幫助類型。

```
AFX_HELP_TYPE GetHelpMode();
```

### <a name="return-value"></a>傳回值

應用程式使用的幫助類型。 有關詳細資訊,請參閱[CWinApp::m_eHelpType。](#m_ehelptype)

## <a name="cwinappgetnextdoctemplate"></a><a name="getnextdoctemplate"></a>CWinApp::獲取NextDocTemplate

取得*pos*識別的文件樣本,然後將*位置*設定到"位置"

```
CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
```

### <a name="parameters"></a>參數

*Pos*<br/>
對前一個調用`GetNextDocTemplate`或[GetFirstDocTemplate 位置](#getfirstdoctemplateposition)傳回的定位值的引用。 此調用將該值更新為下一個位置。

### <a name="return-value"></a>傳回值

指向[CDocTemplate](../../mfc/reference/cdoctemplate-class.md)物件的指標。

### <a name="remarks"></a>備註

如果使用`GetNextDocTemplate`調`GetFirstDocTemplatePosition`用 建立初始位置,則可以在轉發反覆運算迴圈中使用。

您必須確保您的「位置」 值有效。 如果無效,則Microsoft基礎類庫的調試版本斷言。

如果檢索到的文件範本是最後可用,則*pos*的新值將設置為 NULL。

## <a name="cwinappgetprinterdevicedefaults"></a><a name="getprinterdevicedefaults"></a>CWinApp::取得印表機設備預設值

調用此成員函數以準備用於列印的印表機設備上下文。

```
BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
```

### <a name="parameters"></a>參數

*pPrintDlg*<br/>
指向[PRINTDLG](/windows/win32/api/commdlg/ns-commdlg-printdlga)結構的指標。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

從 Windows 檢索當前印表機預設值。根據需要提交 INI 檔,或使用使用者在「列印設置」中設置的最後一個印表機配置。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#40](../../mfc/reference/codesnippet/cpp/cwinapp-class_6.cpp)]

## <a name="cwinappgetprofilebinary"></a><a name="getprofilebinary"></a>CWinApp:取得設定檔二進位

調用此成員函數從應用程式註冊表或 的指定部分中的條目中檢索二進位數據。INI 檔。

```
BOOL GetProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE* ppData,
    UINT* pBytes);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要擷取其值的項目。

*ppData*<br/>
指向將接收數據位址的指標。

*p 位元組*<br/>
指向將接收數據大小的 UINT(以位元組為單位)。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

此成員函數不區分大小寫,因此*lpszSection*和*lpszEntry*參數中的字串可能因情況而異。

> [!NOTE]
> `GetProfileBinary`分配緩衝區並在\**ppData*中傳回其位址。 呼叫者負責使用**delete *** 釋放緩衝區。

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#41](../../mfc/reference/codesnippet/cpp/cwinapp-class_7.cpp)]

有關其他範例,請參閱[CWinApp::寫入設定檔二進制](#writeprofilebinary)。

## <a name="cwinappgetprofileint"></a><a name="getprofileint"></a>CWinApp:取得設定檔

呼叫此成員函式，從應用程式登錄檔或 .INI 檔中指定的區段內的項目擷取整數的值。

```
UINT GetProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nDefault);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
指向以 null 終止的字串，其中包含要擷取其值的項目。

*n預設*<br/>
指定架構找不到項目時要傳回的預設值。

### <a name="return-value"></a>傳回值

如果函式成功，在指定項目後面之字串的整數值。 如果函數找不到條目,則返回值是*nDefault*參數的值。 如果對應到指定項目的值不是整數，則傳回值為 0。

此成員函式支援 .INI 檔中值的十六進位標記法。 檢索已簽署整數時,應將該值轉換為**int**。

### <a name="remarks"></a>備註

此成員函數不區分大小寫,因此*lpszSection*和*lpszEntry*參數中的字串可能因情況而異。

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#42](../../mfc/reference/codesnippet/cpp/cwinapp-class_8.cpp)]

有關其他示例,請參閱[CWinApp::WriteProfileint](#writeprofileint)。

## <a name="cwinappgetprofilestring"></a><a name="getprofilestring"></a>CWinApp:取得設定檔案字串

呼叫此成員函數以檢索與應用程式註冊表或 中的指定節中的條目關聯的字串。INI 檔。

```
CString GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault = NULL);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。

*lpszEntry*<br/>
包含要檢索其字串的項目目的 null 的字串。 此值不能為 NULL。

*lpszDefault*<br/>
如果在初始化檔中找不到該條目,則指向給定條目的預設字串值。

### <a name="return-value"></a>傳回值

傳回值是應用程式的字串。如果找不到字串,則 INI 檔或*lpszDefault。* 框架支援的最大字串長度為_MAX_PATH。 如果*lpszDefault*為 NULL,則傳回值為空字串。

### <a name="remarks"></a>備註

> [!IMPORTANT]
> 這個函式傳回的資料不一定是以 NULL 終止，因此，呼叫端必須執行驗證。 如需詳細資訊，請參閱 [Avoiding Buffer Overruns (避免緩衝區滿溢)](/windows/win32/SecBP/avoiding-buffer-overruns)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

對於另一個示例,請參閱[CWinApp 的範例::獲取配置檔。](#getprofileint)

## <a name="cwinappgetsectionkey"></a><a name="getsectionkey"></a>CWinApp:取得節鍵

返回HKEY_CURRENT_USER"\\軟體"的金鑰\註冊表項\AppName_lpszSection。

```
HKEY GetSectionKey(
    LPCTSTR lpszSection,
    CAtlTransactionManager* pTM = NULL);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
要獲取的鍵的名稱。

*pTM*<br/>
指向 `CAtlTransactionManager` 物件的指標。

### <a name="return-value"></a>傳回值

如果函數成功,則節鍵;否則 NULL。

### <a name="remarks"></a>備註

## <a name="cwinapphideapplication"></a><a name="hideapplication"></a>CWinApp:隱藏應用程式

在關閉打開的文檔之前調用此成員函數以隱藏應用程式。

```cpp
void HideApplication();
```

## <a name="cwinapphtmlhelp"></a><a name="htmlhelp"></a>CWinApp:html説明

呼叫此成員函數以呼叫 HTMLHelp 應用程式。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他數據。 使用的值取決於*nCmd*參數的值。 預設值`0x000F`,表示[HH_HELP_CONTEXT](/previous-versions/windows/desktop/htmlhelp/hh-help-context-command)。

*nCmd*<br/>
指定要求的說明類型。 有關可能值及其如何影響*dwData*參數的清單,請參閱 Windows SDK 中的[HtmlHelpW](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpw)或[HtmlHelpA](/windows/win32/api/htmlhelp/nf-htmlhelp-htmlhelpa) API 函數中描述的*uCommand*參數。

### <a name="remarks"></a>備註

框架還會調用此函數以調用 HTMLHelp 應用程式。

當應用程式終止時,框架將自動關閉 HTMLHelp 應用程式。

## <a name="cwinappinitinstance"></a><a name="initinstance"></a>CWinApp:ininininininininininininininininininininInin

Windows 允許同時運行同一程式的多個副本。

```
virtual BOOL InitInstance();
```

### <a name="return-value"></a>傳回值

初始化成功時非零;否則 0。

### <a name="remarks"></a>備註

應用程式初始化在概念上分為兩個部分:一次性應用程式初始化,在程式首次運行時完成,以及每次運行程式副本(包括第一次)時運行的實例初始化。 框架的實現`WinMain`調用此函數。

覆蓋`InitInstance`以初始化在 Windows 下運行的應用程式的每個新實例。 通常,您可以重寫`InitInstance`以建構主視窗物件`CWinThread::m_pMainWnd`, 並將資料成員設置為指向該視窗。 有關重寫此成員函數的詳細資訊,請參閱[CWinApp:應用程式類](../../mfc/cwinapp-the-application-class.md)。

> [!NOTE]
> MFC 應用程式必須初始化為單線程單元 (STA)。 如果在`InitInstance`重寫中調用[Co 初始化 Ex,](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex)請指定COINIT_APARTMENTTHREADED(而不是COINIT_MULTITHREADED)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCListView#9](../../atl/reference/codesnippet/cpp/cwinapp-class_10.cpp)]

## <a name="cwinappistaskbarinteractionenabled"></a><a name="istaskbarinteractionenabled"></a>CWinApp:是任務列互動啟用

告訴是否啟用了 Windows 7 任務列交互。

```
virtual BOOL IsTaskbarInteractionEnabled();
```

### <a name="return-value"></a>傳回值

如果`EnableTaskbarInteraction`已調用,並且操作系統為 Windows 7 或更高版本,則返回 TRUE。

### <a name="remarks"></a>備註

任務列交互意味著 MDI 應用程式在單獨的選項卡式縮略圖中顯示 MDI 子項的內容,當滑鼠指標位於應用程式任務列按鈕上時,這些縮略圖會顯示。

## <a name="cwinapploadcursor"></a><a name="loadcursor"></a>CWinApp::載入游標

從目前可執行檔載入*由 lpszResourceName*命名或*nIDResource*指定的游標資源。

```
HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;  HCURSOR LoadCursor(UINT nIDResource) const;
```

### <a name="parameters"></a>參數

*lpsz 資源名稱*<br/>
指向包含游標資源名稱的 null 連接端的字串。 可以選擇此參數`CString`。

*nID資源*<br/>
游標資源的 ID。 有關資源清單,請參閱 Windows SDK 中的[LoadCursor。](/windows/win32/api/winuser/nf-winuser-loadcursorw)

### <a name="return-value"></a>傳回值

游標的句柄(如果成功);如果成功,則否則 NULL。

### <a name="remarks"></a>備註

`LoadCursor`僅當游標以前未載入時,才將游標載入到記憶體中;否則,它將檢索現有資源的句柄。

使用[LoadStandardCursor](#loadstandardcursor)或[LoadOEMCursor](#loadoemcursor)成員函數存取預定義的 Windows 游標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#44](../../mfc/reference/codesnippet/cpp/cwinapp-class_11.cpp)]

## <a name="cwinapploadicon"></a><a name="loadicon"></a>CWinApp::載入圖示

從執行檔載入*由 lpszResourceName*命名或*nIDResource*指定的圖示資源。

```
HICON LoadIcon(LPCTSTR lpszResourceName) const;  HICON LoadIcon(UINT nIDResource) const;
```

### <a name="parameters"></a>參數

*lpsz 資源名稱*<br/>
包含圖示資源名稱的 null 連接端的字串。 也可以選擇此參數`CString`。

*nID資源*<br/>
圖示資源的 ID 號。

### <a name="return-value"></a>傳回值

圖示的句柄(如果成功);圖示的句柄否則 NULL。

### <a name="remarks"></a>備註

`LoadIcon`僅當之前未載入該圖示時,才載入該圖示;否則,它將檢索現有資源的句柄。

您可以使用[LoadStandardIcon](#loadstandardicon)或[LoadOEMIcon](#loadoemicon)成員功能存取預定義的 Windows 圖示。

> [!NOTE]
> 此成員函數調用 Win32 API 函數[LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw),它只能載入其大小符合SM_CXICON和SM_CYICON系統指標值的圖示。

## <a name="cwinapploadoemcursor"></a><a name="loadoemcursor"></a>CWinApp::載入OEM游標

載入*nIDCursor*指定的 Windows 預先定義的游標資源。

```
HCURSOR LoadOEMCursor(UINT nIDCursor) const;
```

### <a name="parameters"></a>參數

*nIDCursor*<br/>
指定預先定義的 Windows 游標的**OCR_** 清單常量識別碼。 您必須具有`#define OEMRESOURCE``#include \<afxwin.h>`以前才能訪問 WINDOWS 中**OCR_** 常量。H。

### <a name="return-value"></a>傳回值

游標的句柄(如果成功);如果成功,則否則 NULL。

### <a name="remarks"></a>備註

使用`LoadOEMCursor`或[LoadStandardCursor](#loadstandardcursor)成員函數存取預定義的 Windows 游標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#45](../../mfc/reference/codesnippet/cpp/cwinapp-class_12.h)]

[!code-cpp[NVC_MFCWindowing#46](../../mfc/reference/codesnippet/cpp/cwinapp-class_13.cpp)]

## <a name="cwinapploadoemicon"></a><a name="loadoemicon"></a>CWinApp::載入OEMIcon

載入*nIDIcon*指定的 Windows 預先定義圖示資源。

```
HICON LoadOEMIcon(UINT nIDIcon) const;
```

### <a name="parameters"></a>參數

*nIDIcon*<br/>
指定預先定義的 Windows 圖示**的OIC_** 清單常量識別碼。 您必須具有`#define OEMRESOURCE``#include \<afxwin.h>`以前 才能存取 WINDOWS 中的**OIC_** 常量。H。

### <a name="return-value"></a>傳回值

圖示的句柄(如果成功);圖示的句柄否則 NULL。

### <a name="remarks"></a>備註

使用`LoadOEMIcon`或[LoadStandardIcon](#loadstandardicon)成員函數存取預定義的 Windows 圖示。

## <a name="cwinapploadstandardcursor"></a><a name="loadstandardcursor"></a>CWinApp::載入標準游標

載入*lpszCursorName*指定的 Windows 預先定義的游標資源。

```
HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const;
```

### <a name="parameters"></a>參數

*lpszCursor名稱*<br/>
指定預先定義的 Windows 游標的**IDC_** 清單常量識別碼。 這些標識碼在 WINDOWS 中定義。H。 下面的清單顯示*lpszCursorName*的可能預定義值和含義 :

- IDC_ARROW標準箭號游標

- IDC_IBEAM標準文字插入游標

- IDC_WAIT Windows 執行耗時任務時使用的沙漏游標

- IDC_CROSS十字游標供選擇

- IDC_UPARROW直向上指向的箭頭

- IDC_SIZE過時且不受支援;使用IDC_SIZEALL

- IDC_SIZEALL四角箭頭。 調整視窗大小的游標。

- IDC_ICON已過時且不受支援。 使用IDC_ARROW。

- IDC_SIZENWSE雙頭箭頭,末端在左上角和右下角

- IDC_SIZENESW雙頭箭頭,末端在右上方和左下角

- IDC_SIZEWE水平雙頭箭頭

- IDC_SIZENS垂直雙頭箭頭

### <a name="return-value"></a>傳回值

游標的句柄(如果成功);如果成功,則否則 NULL。

### <a name="remarks"></a>備註

使用`LoadStandardCursor`或[LoadOEMCursor](#loadoemcursor)成員函數存取預定義的 Windows 游標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#47](../../mfc/reference/codesnippet/cpp/cwinapp-class_14.cpp)]

## <a name="cwinapploadstandardicon"></a><a name="loadstandardicon"></a>CWinApp::載入標準圖示

載入*lpszIconName*指定的 Windows 預先定義圖示資源。

```
HICON LoadStandardIcon(LPCTSTR lpszIconName) const;
```

### <a name="parameters"></a>參數

*lpszIcon 名稱*<br/>
指定預先定義的 Windows 圖示的清單常量識別碼。 這些標識碼在 WINDOWS 中定義。H。 有關可能預定義值及其說明的清單,請參閱 Windows SDK 中的[LoadIcon](/windows/win32/api/winuser/nf-winuser-loadiconw)中的*lpIconName*參數。

### <a name="return-value"></a>傳回值

圖示的句柄(如果成功);圖示的句柄否則 NULL。

### <a name="remarks"></a>備註

使用`LoadStandardIcon`或[LoadOEMIcon](#loadoemicon)成員函數存取預定義的 Windows 圖示。

## <a name="cwinapploadstdprofilesettings"></a><a name="loadstdprofilesettings"></a>CWinApp::載入Std設定檔設定

從[InitA 成員](#initinstance)函數中呼叫此成員函數,以啟用和載入最近使用 (MRU) 檔和上次預覽狀態的清單。

```cpp
void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT);
```

### <a name="parameters"></a>參數

*nMaxMRU*<br/>
要追蹤的最近使用的檔案數。

### <a name="remarks"></a>備註

如果*nMaxMRU*為 0,則不會保留 MRU 清單。

## <a name="cwinappm_bhelpmode"></a><a name="m_bhelpmode"></a>CWinApp:m_bHelpMode

如果應用程式處於説明上下文模式(通常使用 SHIFT + F1 調用),則為 TRUE;否則 FALSE。

```
BOOL m_bHelpMode;
```

### <a name="remarks"></a>備註

在説明上下文模式下,游標將成為問號,用戶可以在螢幕上移動它。 如果要在説明模式下實現特殊處理,請檢查此標誌。 `m_bHelpMode`是 BOOL 類型的公共變數。

## <a name="cwinappm_dwrestartmanagersupportflags"></a><a name="m_dwrestartmanagersupportflags"></a>CWinApp:m_dwRestartManagerSupportFlags

確定重新啟動管理器如何執行的標誌。

```
DWORD m_dwRestartManagerSupportFlags;
```

### <a name="remarks"></a>備註

要啟用重新啟動管理員,請設置為`m_dwRestartManagerSupportFlags`所需的行為。 下表顯示了可用的標誌。

|||
|-|-|
|旗標|描述|
|AFX_RESTART_MANAGER_SUPPORT_RESTART|該應用程式使用[CWinApp 註冊::註冊與重新啟動管理員](#registerwithrestartmanager)。 重新啟動管理員負責重新啟動應用程式,如果它意外退出。|
|- AFX_RESTART_MANAGER_SUPPORT_RECOVERY|應用程式註冊到重新啟動管理器,重新啟動管理器在重新啟動應用程式時調用恢復回調功能。 預設回復回檔函數是[CWinApp::應用程式恢復回檔](#applicationrecoverycallback)。|
|- AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART|啟用自動儲存,重新啟動管理器在應用程式重新啟動時自動儲存任何打開的文檔。|
|- AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL|啟用自動儲存,重新啟動管理器會定期自動儲存任何打開的文檔。 間隔由[CWinApp::m_nAutosaveInterval](#m_nautosaveinterval)定義。|
|- AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES|重新啟動管理員在從意外退出中重新啟動應用程式後打開以前打開的文檔。 [CDataRecoveryHandler 類](../../mfc/reference/cdatarecoveryhandler-class.md)處理存儲打開的文檔清單並還原它們。|
|- AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES|重新啟動管理員提示使用者在重新啟動應用程式後還原自動儲存的檔。 類`CDataRecoveryHandler`查詢使用者。|
|- AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE|AFX_RESTART_MANAGER_SUPPORT_RESTART、AFX_RESTART_MANAGER_SUPPORT_RECOVER和AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES的結合。|
|- AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS|AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE、AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART、AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL和AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES的結合。|
|- AFX_RESTART_MANAGER_SUPPORT_RESTART_ASPECTS|AFX_RESTART_MANAGER_SUPPORT_RESTART、AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART、AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES和AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES的結合。|
|- AFX_RESTART_MANAGER_SUPPORT_RECOVERY_ASPECTS|工會ofAFX_RESTART_MANAGER_SUPPORT_RECOVERY、AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL、AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES和AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES。|

## <a name="cwinappm_ehelptype"></a><a name="m_ehelptype"></a>CWinApp:m_eHelpType

此數據成員的類型是枚舉類型AFX_HELP_TYPE,在類中`CWinApp`定義。

```
AFX_HELP_TYPE m_eHelpType;
```

### <a name="remarks"></a>備註

AFX_HELP_TYPE枚舉的定義如下:

```
enum AFX_HELP_TYPE {
    afxWinHelp = 0,
    afxHTMLHelp = 1
    };
```

- 要將應用程式的協助設定為 HTML 說明,請呼叫[SetHelpMode](#sethelpmode)`afxHTMLHelp`並指定 。

- 要將應用程式的協助設定為 WinHelp,請呼`SetHelpMode`叫`afxWinHelp`並指定 。

## <a name="cwinappm_hinstance"></a><a name="m_hinstance"></a>CWinApp:m_hInstance

對應於 Windows`WinMain`傳遞給*的 hInstance*參數。

```
HINSTANCE m_hInstance;
```

### <a name="remarks"></a>備註

數據`m_hInstance`成員是 Windows 下運行的應用程式當前實例的句柄。 這由全域函數[AfxGetInstance Handle](application-information-and-management.md#afxgetinstancehandle)返回。 `m_hInstance`是 HINSTANCE 類型的公共變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#55](../../mfc/reference/codesnippet/cpp/cwinapp-class_15.cpp)]

## <a name="cwinappm_lpcmdline"></a><a name="m_lpcmdline"></a>CWinApp:m_lpCmdLine

對應於 Windows`WinMain`傳遞給的*lpCmdLine*參數。

```
LPTSTR m_lpCmdLine;
```

### <a name="remarks"></a>備註

指定應用程式的指令列的 null 連接字串。 用於`m_lpCmdLine`存取使用者在啟動應用程式時輸入的任何命令列參數。 `m_lpCmdLine`是 LPTSTR 類型的公共變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

## <a name="cwinappm_nautosaveinterval"></a><a name="m_nautosaveinterval"></a>CWinApp:m_nAutosaveInterval

自動保存之間的時間長度(以毫秒為單位)。

```
int m_nAutosaveInterval;
```

### <a name="remarks"></a>備註

您可以將重新啟動管理器配置為按設定的時間間隔自動儲存打開的文檔。 如果應用程式不自動保存檔,則此參數不起作用。

## <a name="cwinappm_ncmdshow"></a><a name="m_ncmdshow"></a>CWinApp:m_nCmdShow

對應於 Windows 傳遞到的*nCmdShow*參數`WinMain`。

```
int m_nCmdShow;
```

### <a name="remarks"></a>備註

當您為應用程式`m_nCmdShow`的主視窗調用[CWnd:::ShowWindow](../../mfc/reference/cwnd-class.md#showwindow)時,應作為參數傳遞。 `m_nCmdShow`是**int**類型的公共變數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#56](../../mfc/reference/codesnippet/cpp/cwinapp-class_17.cpp)]

## <a name="cwinappm_pactivewnd"></a><a name="m_pactivewnd"></a>CWinApp:m_pActiveWnd

使用此資料成員可以儲存指向 OLE 容器應用程式主視窗的指標,該視窗已啟動 OLE 伺服器應用程式就地。

### <a name="remarks"></a>備註

如果此資料成員為 NULL,則應用程式未就地處於活動狀態。

當框架視窗由 OLE 容器應用程式啟動時,框架將設置此成員變數。

## <a name="cwinappm_pdatarecoveryhandler"></a><a name="m_pdatarecoveryhandler"></a>CWinApp:m_pDataRecoveryHandler

指向應用程式的數據恢復處理程序的指標。

```
CDataRecoveryHandler* m_pDataRecoveryHandler;
```

### <a name="remarks"></a>備註

應用程式的數據恢復處理程式監視打開的文檔並自動儲存它們。 當應用程式意外退出後重新啟動時,框架使用數據恢復處理程式還原自動儲存的檔。 有關詳細資訊,請參閱[CData 修復處理程式類別](../../mfc/reference/cdatarecoveryhandler-class.md)。

## <a name="cwinappm_pszappname"></a><a name="m_pszappname"></a>CWinApp:m_pszAppName

指定應用程式的名稱。

```
LPCTSTR m_pszAppName;
```

### <a name="remarks"></a>備註

應用程式名稱可以來自傳遞給[CWinApp](#cwinapp)建構函數的參數,或者(如果未指定)到 ID 為 AFX_IDS_APP_TITLE 的資源字串。 如果在資源中找不到應用程式名稱,則它來自程式的 。EXE 檔名。

傳回全域函數[AfxGetAppName](application-information-and-management.md#afxgetappname)。 `m_pszAppName`是類型**const char**<strong>\*</strong>的公共變數。

> [!NOTE]
> 如果將值分配給`m_pszAppName`,則必須在堆上動態分配該值。 析`CWinApp`構函數使用此指標調用**自由**( )。 您許多人希望使用`_tcsdup`( ) 執行時庫函數來執行分配。 此外,在分配新值之前,釋放與當前指標關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#57](../../mfc/reference/codesnippet/cpp/cwinapp-class_18.cpp)]

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#65](../../mfc/reference/codesnippet/cpp/cwinapp-class_19.cpp)]

## <a name="cwinappm_pszexename"></a><a name="m_pszexename"></a>CWinApp:m_pszExeName

包含應用程式可執行檔的名稱,沒有副檔名。

```
LPCTSTR m_pszExeName;
```

### <a name="remarks"></a>備註

與[m_pszAppName](#m_pszappname)不同,此名稱不能包含空白。 `m_pszExeName`是類型**const char**<strong>\*</strong>的公共變數。

> [!NOTE]
> 如果將值分配給`m_pszExeName`,則必須在堆上動態分配該值。 析`CWinApp`構函數使用此指標調用**自由**( )。 您許多人希望使用`_tcsdup`( ) 執行時庫函數來執行分配。 此外,在分配新值之前,釋放與當前指標關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#58](../../mfc/reference/codesnippet/cpp/cwinapp-class_20.cpp)]

## <a name="cwinappm_pszhelpfilepath"></a><a name="m_pszhelpfilepath"></a>CWinApp:m_pszHelpFilePath

包含應用程式的幫助檔的路徑。

```
LPCTSTR m_pszHelpFilePath;
```

### <a name="remarks"></a>備註

預設情況下,框架用"初始化`m_pszHelpFilePath`到應用程式的名稱。附加 HLP"。 要更改說明檔案的名稱,將`m_pszHelpFilePath`設定為指向包含所需説明檔的完整名稱的字串。 在應用程式的[InitInstance](#initinstance)函數中方便了執行此操作。 `m_pszHelpFilePath`是類型**const char**<strong>\*</strong>的公共變數。

> [!NOTE]
> 如果將值分配給`m_pszHelpFilePath`,則必須在堆上動態分配該值。 析`CWinApp`構函數使用此指標調用**自由**( )。 您許多人希望使用`_tcsdup`( ) 執行時庫函數來執行分配。 此外,在分配新值之前,釋放與當前指標關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#59](../../mfc/reference/codesnippet/cpp/cwinapp-class_21.cpp)]

## <a name="cwinappm_pszprofilename"></a><a name="m_pszprofilename"></a>CWinApp:m_pszProfileName

包含應用程式的 名稱。INI 檔。

```
LPCTSTR m_pszProfileName;
```

### <a name="remarks"></a>備註

`m_pszProfileName`是類型**const char**<strong>\*</strong>的公共變數。

> [!NOTE]
> 如果將值分配給`m_pszProfileName`,則必須在堆上動態分配該值。 析`CWinApp`構函數使用此指標調用**自由**( )。 您許多人希望使用`_tcsdup`( ) 執行時庫函數來執行分配。 此外,在分配新值之前,釋放與當前指標關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#60](../../mfc/reference/codesnippet/cpp/cwinapp-class_22.cpp)]

## <a name="cwinappm_pszregistrykey"></a><a name="m_pszregistrykey"></a>CWinApp:m_pszRegistryKey

用於確定在註冊表或 INI 檔中儲存應用程式設定檔設定的位置。

```
LPCTSTR m_pszRegistryKey;
```

### <a name="remarks"></a>備註

通常,此數據成員被視為唯讀。

- 該值存儲到註冊表項。 應用程式設定檔設置的名稱將追加到以下註冊表項:HKEY_CURRENT_USER/軟體/本地應用嚮導生成/。

如果將值分配給`m_pszRegistryKey`,則必須在堆上動態分配該值。 析`CWinApp`構函數使用此指標調用**自由**( )。 您許多人希望使用`_tcsdup`( ) 執行時庫函數來執行分配。 此外,在分配新值之前,釋放與當前指標關聯的記憶體。 例如：

[!code-cpp[NVC_MFCWindowing#61](../../mfc/reference/codesnippet/cpp/cwinapp-class_23.cpp)]

## <a name="cwinappm_pszappid"></a><a name="m_pszappid"></a>CWinApp:m_pszAppID

應用程式使用者型號 ID。

```
LPCTSTR m_pszAppID;
```

### <a name="remarks"></a>備註

## <a name="cwinapponcontexthelp"></a><a name="oncontexthelp"></a>CWinApp:在上下文説明

在應用程式中處理 SHIFT_F1説明。

```
afx_msg void OnContextHelp();
```

### <a name="remarks"></a>備註

您必須向`CWinApp`類`ON_COMMAND( ID_CONTEXT_HELP, OnContextHelp )`消息 映射添加語句,並添加快速鍵表條目(通常為 SHIFT_F1)才能啟用此成員函數。

`OnContextHelp`將應用程式置於説明模式。 游標將變為箭頭和問號,然後使用者可以移動滑鼠指標並按滑鼠左鍵選擇對話框、視窗、功能表或命令按鈕。 此成員函數檢索游標下物件的説明上下文,並調用 Windows 函數 WinHelp 與該説明上下文。

## <a name="cwinapponddecommand"></a><a name="onddecommand"></a>CWinApp:OnDDE命令

當主框架視窗收到 DDE 執行消息時,由框架調用。

```
virtual BOOL OnDDECommand(LPTSTR lpszCommand);
```

### <a name="parameters"></a>參數

*lpszCommand*<br/>
指向應用程式收到的 DDE 命令字串。

### <a name="return-value"></a>傳回值

處理命令時非零;否則 0。

### <a name="remarks"></a>備註

預設實現檢查該命令是否是打開文件的請求,如果是,則打開指定的文檔。 當使用者雙擊數據檔時,Windows 檔案管理員通常會發送此類 DDE 命令字串。 重寫此函數以處理其他 DDE 執行命令,如要列印的命令。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#48](../../mfc/reference/codesnippet/cpp/cwinapp-class_24.cpp)]

## <a name="cwinapponfilenew"></a><a name="onfilenew"></a>CWinApp:在檔新

實現ID_FILE_NEW命令。

```
afx_msg void OnFileNew();
```

### <a name="remarks"></a>備註

您必須向`CWinApp`類`ON_COMMAND( ID_FILE_NEW, OnFileNew )`消息 映射添加語句才能啟用此成員函數。 如果啟用,此函數將處理「檔新」命令的執行。

有關默認行為的資訊以及如何重寫此成員函數,請參閱[技術說明 22。](../../mfc/tn022-standard-commands-implementation.md)

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponfileopen"></a><a name="onfileopen"></a>CWinApp:在檔案開啟

實現ID_FILE_OPEN命令。

```
afx_msg void OnFileOpen();
```

### <a name="remarks"></a>備註

您必須向`CWinApp`類`ON_COMMAND( ID_FILE_OPEN, OnFileOpen )`消息 映射添加語句才能啟用此成員函數。 如果啟用,此函數將處理檔打開命令的執行。

有關預設行為的資訊以及如何重寫此成員函數的指導,請參閱[技術說明 22](../../mfc/tn022-standard-commands-implementation.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponfileprintsetup"></a><a name="onfileprintsetup"></a>CWinApp::在檔案列印設定

實現ID_FILE_PRINT_SETUP命令。

```
afx_msg void OnFilePrintSetup();
```

### <a name="remarks"></a>備註

您必須向`CWinApp`類`ON_COMMAND( ID_FILE_PRINT_SETUP, OnFilePrintSetup )`消息 映射添加語句才能啟用此成員函數。 如果啟用,此函數將處理檔列印命令的執行。

有關預設行為的資訊以及如何重寫此成員函數的指導,請參閱[技術說明 22](../../mfc/tn022-standard-commands-implementation.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#49](../../mfc/reference/codesnippet/cpp/cwinapp-class_25.cpp)]

[!code-cpp[NVC_MFCWindowing#50](../../mfc/reference/codesnippet/cpp/cwinapp-class_26.cpp)]

## <a name="cwinapponhelp"></a><a name="onhelp"></a>CWinApp::上説明

在應用程式 (使用目前的內容) 中處理 F1 說明。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>備註

通常,您還會為 F1 鍵添加加速器鍵項目。 啟用 F1 密鑰只是慣例,而不是要求。

您必須向`CWinApp`類`ON_COMMAND( ID_HELP, OnHelp )`消息 映射添加語句才能啟用此成員函數。 如果啟用,則當使用者按下 F1 鍵時由框架調用。

此消息處理程式函數的預設實現確定與當前視窗、對話框或功能表項對應的説明上下文,然後調用 WINHELP。Exe。 如果當前沒有可用的上下文,則函數使用預設上下文。

重寫此成員函數,將"説明"上下文設置為當前具有焦點的視窗、對話框、功能表項或工具列按鈕以外的內容。 使用`WinHelp`所需的説明上下文 ID 調用。

## <a name="cwinapponhelpfinder"></a><a name="onhelpfinder"></a>CWinApp::在説明查找器上

處理ID_HELP_FINDER和ID_DEFAULT_HELP命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>備註

您必須向`CWinApp`類`ON_COMMAND( ID_HELP_FINDER, OnHelpFinder )`消息 映射添加語句才能啟用此成員函數。 如果啟用,則當應用程式的使用者選擇幫助查找器命令以使用標準`WinHelp`**HELP_FINDER**主題呼叫時,框架將調用此訊息處理程式函數。

## <a name="cwinapponhelpindex"></a><a name="onhelpindex"></a>CWinApp::在説明索引

處理ID_HELP_INDEX命令並提供默認幫助主題。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>備註

您必須向`CWinApp`類`ON_COMMAND( ID_HELP_INDEX, OnHelpIndex )`消息 映射添加語句才能啟用此成員函數。 如果啟用,則當應用程式的用戶選擇説明索引命令以使用標準`WinHelp`**HELP_INDEX**主題調用時,框架將調用此消息處理程式函數。

## <a name="cwinapponhelpusing"></a><a name="onhelpusing"></a>CWinApp::在説明使用

處理ID_HELP_USING命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>備註

您必須向`CWinApp`類`ON_COMMAND( ID_HELP_USING, OnHelpUsing )`消息 映射添加語句才能啟用此成員函數。 當應用程式的用戶選擇「説明使用」命令以使用標準`WinHelp`**HELP_HELPONHELP**主題調用應用程式時,框架將調用此消息處理程式函數。

## <a name="cwinapponidle"></a><a name="onidle"></a>CWinApp::上

重寫此成員函數以執行空閒時間處理。

```
virtual BOOL OnIdle(LONG lCount);
```

### <a name="parameters"></a>參數

*l. Count*<br/>
當應用程式的消息隊列為空`OnIdle`時,每次調用一個計數器。 每次處理新消息時,此計數都會重置為 0。 可以使用*lCount*參數來確定應用程式空閒的相對時間長度,而無需處理消息。

### <a name="return-value"></a>傳回值

非零接收更多的空閒處理時間;如果不再需要空閒時間,則為 0。

### <a name="remarks"></a>備註

`OnIdle`當應用程式的消息隊列為空時,在預設消息迴圈中調用。 使用重寫呼叫您自己的後台空閒處理程式任務。

`OnIdle`應返回 0 以指示不需要空閒處理時間。 每次`OnIdle`調用消息隊列為空時,每次調用*lCount*參數都會增加,並且每次處理新消息時都重置為 0。 您可以基於此計數調用不同的空閒例程。

下面總結了空閒迴圈處理:

1. 如果 Microsoft 基礎類庫中的消息迴圈檢查消息佇列,但找不到掛起的消息,它將`OnIdle`調用 應用程式物件並將 0 作為*lCount*參數提供。

2. `OnIdle`執行一些處理並返回非零值,以指示應再次調用該值以執行進一步處理。

3. 消息迴圈再次檢查消息佇列。 如果沒有掛起的消息,它將再次調用`OnIdle`,從而增加*lCount*參數。

4. 最終,`OnIdle`完成處理其所有空閒任務並返回 0。 這告訴消息迴圈停止調用`OnIdle`,直到從消息佇列收到下一條消息,此時空閒迴圈將重新啟動,參數設置為 0。

在此期間`OnIdle`不要執行冗長的任務,因為應用程式在返回`OnIdle`之前 無法處理使用者輸入。

> [!NOTE]
> 更新的`OnIdle`默認實現命令使用者介面物件(如功能表項和工具列按鈕),並執行內部數據結構清理。 因此,如果重寫`OnIdle`,則必須使用重`CWinApp::OnIdle`寫`lCount`版本中 的調用。 首先調用所有基類空閒處理(即,直到基類`OnIdle`返回 0)。 如果需要在基類處理完成之前執行工作,請查看基類實現以選擇正確的*lCount*以在其中完成工作。

如果不想`OnIdle`從消息佇列中檢索消息時被調用,則可以重寫[CWinThreadIsIdleMessage](../../mfc/reference/cwinthread-class.md#isidlemessage)。 如果應用程式設置了非常短的計時器,或者如果系統正在發送WM_SYSTIMER消息,則`OnIdle`將重複調用該消息並降低性能。

### <a name="example"></a>範例

以下兩個範例展示如何使用`OnIdle`。 第一個範例使用*lCount*參數處理兩個空閒任務,以確定任務的優先順序。 第一個任務是高優先順序的,您應該盡可能執行。 第二個任務不太重要,只有在使用者輸入長時間暫停時才應執行。 請注意對的基類版本的`OnIdle`調用。 第二個範例管理一組具有不同優先順序的空閒任務。

[!code-cpp[NVC_MFCWindowing#51](../../mfc/reference/codesnippet/cpp/cwinapp-class_27.cpp)]

## <a name="cwinappopendocumentfile"></a><a name="opendocumentfile"></a>CWinApp::開啟檔案檔案

框架呼叫此方法來打開應用程式的命名[CDocument](../../mfc/reference/cdocument-class.md)檔案。

```
virtual CDocument* OpenDocumentFile(
    LPCTSTR lpszFileName
    BOOL bAddToMRU = TRUE);
```

### <a name="parameters"></a>參數

*lpszFile 名稱*<br/>
[在]要打開的文件的名稱。

*bAddtoMRU*<br/>
[在]TRUE 表示文檔是最新的檔之一;FALSE 表示文檔不是最新的檔之一。

### <a name="return-value"></a>傳回值

指向`CDocument`的指標(如果成功);如果成功,則指向否則 NULL。

### <a name="remarks"></a>備註

如果具有該名稱的文檔已打開,則包含該文檔的第一個框架視窗將獲取焦點。 如果應用程式支援多個文檔範本,則框架使用檔名擴展名來查找適當的文檔範本,以嘗試載入文檔。 如果成功,文檔範本將創建一個框架視窗並為文檔創建檢視。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#52](../../mfc/reference/codesnippet/cpp/cwinapp-class_16.cpp)]

## <a name="cwinappparsecommandline"></a><a name="parsecommandline"></a>CWinApp::P

呼叫此成員函數來分析命令列,並將參數(一次一個)傳送到[CCommandLineInfo::ParseParam](../../mfc/reference/ccommandlineinfo-class.md#parseparam)。

```cpp
void ParseCommandLine(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>參數

*rCmdInfo*<br/>
對[CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md)物件的引用。

### <a name="remarks"></a>備註

使用應用程式精靈啟動新的 MFC 專案時,應用程式精靈將`CCommandLineInfo`建立的本地實例,然後在[InitA](#initinstance)`ParseCommandLine`成員函式中`ProcessShellCommand`呼叫 。 命令列遵循下面描述的路由:

1. 在中`InitInstance`建立後,`CCommandLineInfo`物件會傳遞`ParseCommandLine`給 。

2. `ParseCommandLine`然後重複`CCommandLineInfo::ParseParam`調用,每個參數重複調用一次。

3. `ParseParam`填滿`CCommandLineInfo`物件,然後傳遞給[行程ShellCommand](#processshellcommand)。

4. `ProcessShellCommand`處理命令列參數和標誌。

請注意,您可以根據需要直接`ParseCommandLine`呼叫。

有關命令列標誌的說明,請參閱[CCommandLineInfo::m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand)。

## <a name="cwinapppretranslatemessage"></a><a name="pretranslatemessage"></a>CWinApp::P重新翻譯訊息

重寫此函數以篩選視窗訊息,然後再將其發送到 Windows 函數[TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage)和[DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage)預設實現執行快捷鍵`CWinApp::PreTranslateMessage`轉換,因此您必須在重寫版本中調用成員函數。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
指向包含要處理的消息的[MSG](/windows/win32/api/winuser/ns-winuser-msg)結構的指標。

### <a name="return-value"></a>傳回值

如果消息已完全處理,`PreTranslateMessage`則非零,不應進一步處理。 如果消息應以正常方式處理,則為零。

## <a name="cwinappprocessmessagefilter"></a><a name="processmessagefilter"></a>CWinApp::Process消息篩檢程式

框架的 hook 函數呼叫此成員函數來篩選和回應某些 Windows 訊息。

```
virtual BOOL ProcessMessageFilter(
    int code,
    LPMSG lpMsg);
```

### <a name="parameters"></a>參數

*code*<br/>
指定挂鉤代碼。 此成員函數使用代碼來確定如何處理*lpMsg。*

*lpMsg*<br/>
指向 Windows [MSG](/windows/win32/api/winuser/ns-winuser-msg)truc 的指標。

### <a name="return-value"></a>傳回值

處理消息時非零;否則 0。

### <a name="remarks"></a>備註

hook 函數在事件發送到應用程式的正常消息處理之前處理事件。

如果重寫此高級功能,請確保調用基類版本以維護框架的挂鉤處理。

## <a name="cwinappprocessshellcommand"></a><a name="processshellcommand"></a>CWinApp::P羅塞斯舍爾命令

[InitInstance](#initinstance)調用此成員函數以接受從*rCmdInfo*`CCommandLineInfo`標識的物件傳遞的參數,並執行指示的操作。

```
BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);
```

### <a name="parameters"></a>參數

*rCmdInfo*<br/>
對[CCommandLineInfo](../../mfc/reference/ccommandlineinfo-class.md)物件的引用。

### <a name="return-value"></a>傳回值

如果外殼命令成功處理,則非零。 如果為 0,則從[Initinstance](#initinstance)傳回 FALSE 。

### <a name="remarks"></a>備註

使用應用程式精靈啟動新的 MFC 專案時,應用程式精靈`CCommandLineInfo`將建立的本地實例,然後在`ProcessShellCommand``InitInstance`成員函數中調用和[ParseCommandLine。](#parsecommandline) 命令列遵循下面描述的路由:

1. 在中`InitInstance`建立後,`CCommandLineInfo`物件會傳遞`ParseCommandLine`給 。

2. `ParseCommandLine`然後重複調用[CCommandLineInfo::ParseParam,](../../mfc/reference/ccommandlineinfo-class.md#parseparam)每個參數一次。

3. `ParseParam`填滿`CCommandLineInfo`物件,然後傳遞`ProcessShellCommand`給 。

4. `ProcessShellCommand`處理命令列參數和標誌。

[CCommandLineInfo::m_nShellCommand](../../mfc/reference/ccommandlineinfo-class.md#m_nshellcommand)標識的`CCommandLineInfo``CCommandLineInfo`物件 的數據成員屬於以下枚舉類型,在類中定義。

```
enum {
    FileNew,
    FileOpen,
    FilePrint,
    FilePrintTo,
    FileDDE
    };
```

有關每個值的簡要說明,請參閱`CCommandLineInfo::m_nShellCommand`。

## <a name="cwinappprocesswndprocexception"></a><a name="processwndprocexception"></a>CWinApp::P羅塞斯·溫德普羅奇例外

每當處理程式未捕獲應用程式的消息或命令處理程序中引發異常時,框架將調用此成員函數。

```
virtual LRESULT ProcessWndProcException(
    CException* e,
    const MSG* pMsg);
```

### <a name="parameters"></a>參數

*e*<br/>
指向未捕獲異常的指標。

*pMsg*<br/>
包含導致框架引發異常的視窗訊息的資訊的[MSG](/windows/win32/api/winuser/ns-winuser-msg)策略。

### <a name="return-value"></a>傳回值

應返回到 Windows 的值。 通常,這是 0L 視窗訊息, 1L ( TRUE) 的命令訊息.

### <a name="remarks"></a>備註

不要直接調用此成員函數。

此成員函數的預設實現將創建一個消息框。 如果未捕獲的異常源自功能表、工具列或加速器命令失敗,則消息框將顯示"命令失敗"消息;如果未捕獲的異常源自功能表、工具列或加速器命令失敗。"否則,它會顯示"內部應用程式錯誤"消息。

重寫此成員函數,以提供異常的全域處理。 僅當希望顯示消息框時,才調用基本功能。

## <a name="cwinappregister"></a><a name="register"></a>CWinApp:註冊

執行未由`RegisterShellFileTypes`處理的任何註冊任務。

```
virtual BOOL Register();
```

### <a name="return-value"></a>傳回值

非零成功，否則為 0。

### <a name="remarks"></a>備註

預設實現僅返回 TRUE。 重寫此函數以提供任何自定義的註冊步驟。

## <a name="cwinappregistershellfiletypes"></a><a name="registershellfiletypes"></a>CWinApp::註冊外殼文件類型

呼叫此成員函數向 Windows 檔案管理員註冊應用程式的所有文件類型。

```cpp
void RegisterShellFileTypes(BOOL bCompat = FALSE);
```

### <a name="parameters"></a>參數

*b 康波特*<br/>
[在]TRUE 添加 shell 命令"列印"和"列印到"的註冊條目,允許使用者直接從 shell 列印檔,或者將檔案拖動到印表機物件。 它還添加了默認圖示密鑰。 默認情況下,此參數為 FALSE,用於向後相容性。

### <a name="remarks"></a>備註

這允許用戶通過從檔管理器中按兩下應用程式創建的數據檔來打開該檔。 在`RegisterShellFileTypes`調用應用程式中的每個文檔範本後致電[AddDocTemplate。](#adddoctemplate) 呼叫`RegisterShellFileTypes`時還會調用[啟用ShellOpen](#enableshellopen)成員函數。

`RegisterShellFileTypes`通過應用程式維護的[CDocTemplate](../../mfc/reference/cdoctemplate-class.md)物件清單進行重新訪問,並且為每個文檔範本將條目添加到 Windows 為檔關聯維護的註冊資料庫。 檔案管理員使用這些條目在使用者按兩下資料檔時打開資料檔。 這消除了發貨的需要。註冊檔與您的應用程式。

> [!NOTE]
> `RegisterShellFileTypes`僅當使用者使用管理員許可權運行程式時才有效。 如果程式沒有管理員許可權,則無法更改註冊表項。

如果註冊資料庫已經將給定的檔名副檔名與另一種文件類型關聯,則不會創建新關聯。 有關註冊`CDocTemplate`此資訊所需的字串格式,請參閱類。

## <a name="cwinappregisterwithrestartmanager"></a><a name="registerwithrestartmanager"></a>CWinApp::註冊與重新啟動管理器

向重新啟動管理器註冊應用程式。

```
virtual HRESULT RegisterWithRestartManager(
    BOOL bRegisterRecoveryCallback,
    const CString& strRestartIdentifier);

virtual HRESULT RegisterWithRestartManager(
    LPCWSTR pwzCommandLineArgs,
    DWORD dwRestartFlags,
    APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    LPVOID lpvParam,
    DWORD dwPingInterval,
    DWORD dwCallbackFlags);
```

### <a name="parameters"></a>參數

|||
|-|-|
|參數|描述|
|*b 註冊復原回電*|[在]TRUE 指示應用程式的此實例使用恢復回調函數;FALSE 表示它不。 當應用程式意外退出時,框架調用恢復回調函數。 有關詳細資訊,請參閱[CWinApp:應用程式恢復回電](#applicationrecoverycallback)。|
|*strRestart識別碼*|[在]識別重新啟動管理員此實例的唯一字串。 重新啟動管理員標識碼對於應用程式的每個實體是唯一的。|
|*pwzCommandLineArgs*|[在]包含命令列中任何額外參數的字串。|
|*dwRestartFlags*|[在]重新啟動管理員的可選標誌。 如需詳細資訊，請參閱＜備註＞一節。|
|*p 復原回電*|[在]恢復回調功能。 此函數必須採用 LPVOID 參數作為輸入並返回 DWORD。 預設回復回檔函數`CWinApp::ApplicationRecoveryCallback`為 。|
|*lpvParam*|[在]恢復回調函數的輸入參數。 有關詳細資訊,請參閱[CWinApp:應用程式恢復回電](#applicationrecoverycallback)。|
|*dwping 間隔*|[在]重新啟動管理器等待恢復回調功能返回的時間長度。 此參數以毫秒為單位。|
|*dwCallbackFlags*|[在]傳遞給恢復回調功能的標誌。 保留供未來使用。|

### <a name="return-value"></a>傳回值

如果方法成功,S_OK;否則是錯誤代碼。

### <a name="remarks"></a>備註

如果應用程式使用預設 MFC 實現進行自動儲存檔,則`RegisterWithRestartManager`應使用的簡單版本。 如果要自訂應用程式的自動儲存`RegisterWithRestartManager`行為,請使用

如果使用*strRestart 標識字*串呼叫此方法,請`RegisterWithRestartManager`為重新啟動管理器的此實例創建唯一識別字串。

當應用程式意外退出時,重新啟動管理器將從命令列重新啟動應用程式,並提供唯一的重新啟動標識符作為可選參數。 在這種情況下,框架調用`RegisterWithRestartManager`兩次。 第一個調用來自[CWinApp::InitInstance](#initinstance)具有字串標識元的空字串。 然後,方法[CWinApp::Process ShellCommand](#processshellcommand)`RegisterWithRestartManager`調用具有唯一的重新啟動標識符。

向重新啟動管理器註冊應用程式後,重新啟動管理器將監視應用程式。 如果應用程式意外退出,重新啟動管理器將在關閉過程中調用恢復回調功能。 重新啟動管理員等待*dwPingInterval,* 等待來自回復回檔函數的回應。 如果恢復回調函數在此時間內未回應,則應用程式將退出而不執行恢復回調功能。

默認情況下,dwRestartFlags 不受支援,但可供將來使用。 *dwRestartFlags*的可能值如下所示:

- RESTART_NO_CRASH

- RESTART_NO_HANG

- RESTART_NO_PATCH

- RESTART_NO_REBOOT

## <a name="cwinappreopenpreviousfilesatrestart"></a><a name="reopenpreviousfilesatrestart"></a>CWinApp::重新打開以前的檔在重新啟動

確定重新啟動管理員是否重新打開應用程式意外退出時打開的檔案。

```
virtual BOOL ReopenPreviousFilesAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新啟動管理器將重新打開以前打開的檔;如果重新啟動,則表示重新啟動管理器將重新打開以前打開的檔。FALSE 表示重新啟動管理器沒有。

## <a name="cwinapprestartinstance"></a><a name="restartinstance"></a>CWinApp:重新啟動實體

處理重新啟動管理器啟動的應用程式重新啟動。

```
virtual BOOL CWinApp::RestartInstance();
```

### <a name="return-value"></a>傳回值

如果數據恢復處理程序打開以前打開的文檔,則為 TRUE;如果數據恢復處理程序出現錯誤或以前沒有打開的文檔,則 FALSE。

### <a name="remarks"></a>備註

重新啟動管理器重新啟動應用程式時,框架將調用此方法。 此方法檢索數據恢復處理程式並還原自動儲存的檔。 此方法調用[CDataRecoveryHandler::還原自動儲存的文檔](../../mfc/reference/cdatarecoveryhandler-class.md#restoreautosaveddocuments),以確定使用者是否希望還原自動保存的檔。

如果[CDataRecoveryHandler](../../mfc/reference/cdatarecoveryhandler-class.md)確定沒有打開的文檔,則此方法將返回 FALSE。 如果沒有打開的文檔,應用程式通常會啟動。

## <a name="cwinapprestoreautosavedfilesatrestart"></a><a name="restoreautosavedfilesatrestart"></a>CWinApp::回復自動儲存的檔案在重新啟動

確定重新啟動管理員在重新啟動應用程式時是否還原自動儲存的檔。

```
virtual BOOL RestoreAutosavedFilesAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新啟動管理員還原自動儲存的檔;FALSE 表示重新啟動管理器沒有。

## <a name="cwinapprun"></a><a name="run"></a>CWinApp::運行

提供預設消息迴圈。

```
virtual int Run();
```

### <a name="return-value"></a>傳回值

由`WinMain`返回**的int**值。

### <a name="remarks"></a>備註

`Run`獲取和調度 Windows 消息,直到應用程式收到WM_QUIT消息。 如果應用程式的消息佇列當前不包含任何消息,請`Run`調用[OnIdle](#onidle)以執行空閒時間處理。 傳入訊息轉到[PreTranslateMessage](#pretranslatemessage)成員函數進行特殊處理,然後轉到`TranslateMessage`Windows 函數進行標準鍵盤轉換;最後,`DispatchMessage`調用 Windows 函數。

`Run`很少重寫,但您可以重寫它以提供特殊行為。

## <a name="cwinapprunautomated"></a><a name="runautomated"></a>CWinApp::執行自動

呼叫此函數以確定是否存在 **"/自動化**'或 **"-自動化**'選項,該選項指示伺服器應用程式是否由用戶端應用程式啟動。

```
BOOL RunAutomated();
```

### <a name="return-value"></a>傳回值

如果找到選項,則非零;否則 0。

### <a name="remarks"></a>備註

如果存在,則從命令行中刪除該選項。 有關 OLE 自動化的詳細資訊,請參閱文章["自動化伺服器](../../mfc/automation-servers.md)"。

## <a name="cwinapprunembedded"></a><a name="runembedded"></a>CWinApp::運行嵌入式

呼叫此函數以確定是否存在 **「/嵌入**」或 **「-嵌入**」選項,該選項指示伺服器應用程式是否由用戶端應用程式啟動。

```
BOOL RunEmbedded();
```

### <a name="return-value"></a>傳回值

如果找到選項,則非零;否則 0。

### <a name="remarks"></a>備註

如果存在,則從命令行中刪除該選項。 有關嵌入的詳細資訊,請參閱文章[「伺服器:實現伺服器](../../mfc/servers-implementing-a-server.md)」。

## <a name="cwinappsaveallmodified"></a><a name="saveallmodified"></a>CWinApp::保存所有修改

由框架呼叫以在關閉應用程式的主框架視窗或透過WM_QUERYENDSESSION訊息保存所有文件。

```
virtual BOOL SaveAllModified();
```

### <a name="return-value"></a>傳回值

非零,如果安全終止應用程式;0 如果不安全,則終止應用程式。

### <a name="remarks"></a>備註

此成員函數的預設實現調用[CDocument::保存修改](../../mfc/reference/cdocument-class.md#savemodified)的成員函數,依次用於應用程式中的所有修改文檔。

## <a name="cwinappselectprinter"></a><a name="selectprinter"></a>CWinApp::選擇印表機

調用此成員功能以選擇特定印表機,並釋放以前在「列印對話框」中選擇的印表機。

```cpp
void SelectPrinter(
    HANDLE hDevNames,
    HANDLE hDevMode,
    BOOL bFreeOld = TRUE);
```

### <a name="parameters"></a>參數

*hDevNames*<br/>
識別特定印表機的驅動程式、設備和輸出埠名稱的[DEVNAMES](/windows/win32/api/commdlg/ns-commdlg-devnames)分道的句柄。

*hDevMode*<br/>
指定有關印表機裝置初始化和環境的資訊的[DEVMODE](/windows/win32/api/wingdi/ns-wingdi-devmodea)結構的句柄。

*bFreeOld*<br/>
釋放以前選擇的印表機。

### <a name="remarks"></a>備註

如果*hDevMode*和*hDevNames*`SelectPrinter`均為 NULL,則使用目前的預設印表機。

## <a name="cwinappsethelpmode"></a><a name="sethelpmode"></a>CWinApp::設定説明模式

設置應用程式的幫助類型。

```cpp
void SetHelpMode(AFX_HELP_TYPE eHelpType);
```

### <a name="parameters"></a>參數

*eHelpType*<br/>
指定要使用的幫助類型。 有關詳細資訊,請參閱[CWinApp::m_eHelpType。](#m_ehelptype)

### <a name="remarks"></a>備註

設置應用程式的幫助類型。

要將應用程式的「幫助」 型態為 HTML 說明,可以呼叫[啟用 HTML 說明](#enablehtmlhelp)。 呼叫`EnableHTMLHelp`後,應用程式必須使用 HTMLHelp 作為其幫助應用程式。 如果要更改使用 WinHelp,可以呼`SetHelpMode`叫 eHelpType 並將*eHelpType*設定為`afxWinHelp`。

## <a name="cwinappsetregistrykey"></a><a name="setregistrykey"></a>CWinApp::設定註冊金鑰

導致應用程式設定存儲在註冊表中,而不是 INI 檔中。

```cpp
void SetRegistryKey(LPCTSTR lpszRegistryKey);
void SetRegistryKey(UINT nIDRegistryKey);
```

### <a name="parameters"></a>參數

*lpsz註冊金鑰*<br/>
指向包含鍵名稱的字串的指標。

*nID註冊鍵*<br/>
包含註冊表項名稱的字串資源的 ID。

### <a name="remarks"></a>備註

此函數集*m_pszRegistryKey* `GetProfileInt`,然後由`GetProfileString``WriteProfileInt`的`WriteProfileString`, 與的成員`CWinApp`函數使用 。 如果已調用此函數,則最近使用 (MRU) 檔案的清單也會存儲在註冊表中。 註冊表項通常是公司的名稱。 它存儲在以下形式的鍵:HKEY_CURRENT_USER_\\軟體<公司\>\\名稱\>\\\>\\<应用程序名称\><节名称<值名称。

## <a name="cwinappsupportsapplicationrecovery"></a><a name="supportsapplicationrecovery"></a>CWinApp::支援應用程式恢復

確定重新啟動管理員是否恢復意外退出的應用程式。

```
virtual BOOL SupportsApplicationRecovery() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新啟動管理器正在恢復應用程式;FALSE 表示重新啟動管理器沒有。

## <a name="cwinappsupportsautosaveatinterval"></a><a name="supportsautosaveatinterval"></a>CWinApp::支援自動儲存At間隔

確定重新啟動管理員是否以常規間隔自動儲存打開的文檔。

```
virtual BOOL SupportsAutosaveAtInterval() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示重新啟動管理器自動儲存打開的文檔;FALSE 表示重新啟動管理器沒有。

## <a name="cwinappsupportsautosaveatrestart"></a><a name="supportsautosaveatrestart"></a>CWinApp::支援自動儲存Atrestart

確定重新啟動管理員在應用程式重新啟動時是否自動儲存任何打開的文件。

```
virtual BOOL SupportsAutosaveAtRestart() const;
```

### <a name="return-value"></a>傳回值

TRUE 指示重新啟動管理器在應用程式重新啟動時自動儲存打開的文檔;FALSE 表示重新啟動管理器沒有。

## <a name="cwinappsupportsrestartmanager"></a><a name="supportsrestartmanager"></a>CWinApp::支援重新啟動管理員

確定應用程式是否支援重新啟動管理員。

```
virtual BOOL SupportsRestartManager() const;
```

### <a name="return-value"></a>傳回值

TRUE 表示應用程式支援重新啟動管理員;FALSE 表示應用程式沒有。

## <a name="cwinappunregister"></a><a name="unregister"></a>CWinApp::取消註冊

取消註冊應用程式物件註冊的所有檔。

```
virtual BOOL Unregister();
```

### <a name="return-value"></a>傳回值

非零成功，否則為 0。

### <a name="remarks"></a>備註

該`Unregister`函數撤銷應用程式物件和[寄存器](#register)函數執行的註冊。 通常,MFC 隱式調用這兩個函數,因此不會顯示在代碼中。

重寫此函數以執行自定義取消註冊步驟。

## <a name="cwinappunregistershellfiletypes"></a><a name="unregistershellfiletypes"></a>CWinApp::取消註冊ShellFile類型

呼叫此成員函數,以在 Windows 檔管理員中取消註冊應用程式的所有文件類型。

```cpp
void UnregisterShellFileTypes();
```

## <a name="cwinappwinhelp"></a><a name="winhelp"></a>CWinApp::贏説明

調用此成員函數以調用 WinHelp 應用程式。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他數據。 使用的值取決於*nCmd*參數的值。

*nCmd*<br/>
指定要求的說明類型。 有關可能值的清單及其如何影響*dwData*參數,請參閱[WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) Windows 函數。

### <a name="remarks"></a>備註

框架還會調用此函數以調用 WinHelp 應用程式。

當您的應用程式終止時,框架將自動關閉 WinHelp 應用程式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#53](../../mfc/reference/codesnippet/cpp/cwinapp-class_28.cpp)]

## <a name="cwinappwriteprofilebinary"></a><a name="writeprofilebinary"></a>CWinApp::寫配置檔二進位

調用此成員函數將二進位數據寫入應用程式註冊表或的指定部分。INI 檔。

```
BOOL WriteProfileBinary(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPBYTE pData,
    UINT nBytes);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果節不存在,則創建該節。 節的名稱是案例獨立的;字串可以是大寫字母和小寫字母的任意組合。

*lpszEntry*<br/>
包含要寫入該值的項目目的 null 連接端的字串。 如果該項在指定的節中不存在,則創建該條目。

*pData*<br/>
指向要寫入的數據。

*n 位元組*<br/>
包含要寫入的位元組數。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

此範例用於`CWinApp* pApp = AfxGetApp();`存取 CWinApp`WriteProfileBinary``GetProfileBinary`類, 說明可以從 MFC 應用程式中的任何函數使用的方法。

[!code-cpp[NVC_MFCWindowing#54](../../mfc/reference/codesnippet/cpp/cwinapp-class_29.cpp)]

對於另一個範例,請參閱[CWinApp 的範例::取得設定檔 Binary](#getprofilebinary)。

## <a name="cwinappwriteprofileint"></a><a name="writeprofileint"></a>CWinApp::寫配置檔

呼叫此成員函數將指定值寫入應用程式註冊表或的指定部分。INI 檔。

```
BOOL WriteProfileInt(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    int nValue);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果節不存在,則創建該節。 節的名稱是案例獨立的;字串可以是大寫字母和小寫字母的任意組合。

*lpszEntry*<br/>
包含要寫入該值的項目目的 null 連接端的字串。 如果該項在指定的節中不存在,則創建該條目。

*n值*<br/>
包含要寫入的值。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

此範例`CWinApp* pApp = AfxGetApp();`用於在 CWinApp 類別`WriteProfileString`中說明一種`WriteProfileInt`方法,該`GetProfileString`方法可以從 MFC 應用程式中的任何`GetProfileInt`函數中使用 。

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

對於另一個示例,請參閱[CWinApp 的範例::獲取配置檔。](#getprofileint)

## <a name="cwinappwriteprofilestring"></a><a name="writeprofilestring"></a>CWinApp::寫配置檔字串

呼叫此成員函數將指定的字串寫入應用程式註冊表或的指定部分。INI 檔。

```
BOOL WriteProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszValue);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
指向以 null 終止的字串，這個字串指定包含項目的區段。 如果節不存在,則創建該節。 節的名稱是案例獨立的;字串可以是大寫字母和小寫字母的任意組合。

*lpszEntry*<br/>
包含要寫入該值的項目目的 null 連接端的字串。 如果該項在指定的節中不存在,則創建該條目。 如果此參數為 NULL,則刪除*lpszSection*指定的節。

*lpszValue*<br/>
指向要寫入的字串。 如果此參數為 NULL,則刪除*lpszEntry*參數指定的條目。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#43](../../mfc/reference/codesnippet/cpp/cwinapp-class_9.cpp)]

對於另一個示例,請參閱[CWinApp 的範例::獲取配置檔。](#getprofileint)

## <a name="cwinappsetappid"></a><a name="setappid"></a>CWinApp::SetAppID

顯式設置應用程式的應用程式使用者模型 ID。 在向使用者顯示任何使用者介面之前,應調用此方法(最佳位置是應用程式構造函數)。

```cpp
void SetAppID(LPCTSTR lpcszAppID);
```

### <a name="parameters"></a>參數

*lpcszAppID*<br/>
指定應用程式使用者型號 ID。

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[CWinThread 類別](../../mfc/reference/cwinthread-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[如何：新增重新啟動管理員支援](../../mfc/how-to-add-restart-manager-support.md)
