---
title: "CWnd 類別 |Microsoft 文件"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CWnd
- AFXWIN/CWnd
- AFXWIN/CWnd::CWnd
- AFXWIN/CWnd::accDoDefaultAction
- AFXWIN/CWnd::accHitTest
- AFXWIN/CWnd::accLocation
- AFXWIN/CWnd::accNavigate
- AFXWIN/CWnd::accSelect
- AFXWIN/CWnd::AnimateWindow
- AFXWIN/CWnd::ArrangeIconicWindows
- AFXWIN/CWnd::Attach
- AFXWIN/CWnd::BeginModalState
- AFXWIN/CWnd::BeginPaint
- AFXWIN/CWnd::BindDefaultProperty
- AFXWIN/CWnd::BindProperty
- AFXWIN/CWnd::BringWindowToTop
- AFXWIN/CWnd::CalcWindowRect
- AFXWIN/CWnd::CancelToolTips
- AFXWIN/CWnd::CenterWindow
- AFXWIN/CWnd::ChangeClipboardChain
- AFXWIN/CWnd::CheckDlgButton
- AFXWIN/CWnd::CheckRadioButton
- AFXWIN/CWnd::ChildWindowFromPoint
- AFXWIN/CWnd::ClientToScreen
- AFXWIN/CWnd::CloseWindow
- AFXWIN/CWnd::ContinueModal
- AFXWIN/CWnd::Create
- AFXWIN/CWnd::CreateAccessibleProxy
- AFXWIN/CWnd::CreateCaret
- AFXWIN/CWnd::CreateControl
- AFXWIN/CWnd::CreateEx
- AFXWIN/CWnd::CreateGrayCaret
- AFXWIN/CWnd::CreateSolidCaret
- AFXWIN/CWnd::DeleteTempMap
- AFXWIN/CWnd::DestroyWindow
- AFXWIN/CWnd::Detach
- AFXWIN/CWnd::DlgDirList
- AFXWIN/CWnd::DlgDirListComboBox
- AFXWIN/CWnd::DlgDirSelect
- AFXWIN/CWnd::DlgDirSelectComboBox
- AFXWIN/CWnd::DragAcceptFiles
- AFXWIN/CWnd::DragDetect
- AFXWIN/CWnd::DrawAnimatedRects
- AFXWIN/CWnd::DrawCaption
- AFXWIN/CWnd::DrawMenuBar
- AFXWIN/CWnd::EnableActiveAccessibility
- AFXWIN/CWnd::EnableDynamicLayout
- AFXWIN/CWnd::EnableD2DSupport
- AFXWIN/CWnd::EnableScrollBar
- AFXWIN/CWnd::EnableScrollBarCtrl
- AFXWIN/CWnd::EnableToolTips
- AFXWIN/CWnd::EnableTrackingToolTips
- AFXWIN/CWnd::EnableWindow
- AFXWIN/CWnd::EndModalLoop
- AFXWIN/CWnd::EndModalState
- AFXWIN/CWnd::EndPaint
- AFXWIN/CWnd::ExecuteDlgInit
- AFXWIN/CWnd::FilterToolTipMessage
- AFXWIN/CWnd::FindWindow
- AFXWIN/CWnd::FindWindowEx
- AFXWIN/CWnd::FlashWindow
- AFXWIN/CWnd::FlashWindowEx
- AFXWIN/CWnd::FromHandle
- AFXWIN/CWnd::FromHandlePermanent
- AFXWIN/CWnd::get_accChild
- AFXWIN/CWnd::get_accChildCount
- AFXWIN/CWnd::get_accDefaultAction
- AFXWIN/CWnd::get_accDescription
- AFXWIN/CWnd::get_accFocus
- AFXWIN/CWnd::get_accHelp
- AFXWIN/CWnd::get_accHelpTopic
- AFXWIN/CWnd::get_accKeyboardShortcut
- AFXWIN/CWnd::get_accName
- AFXWIN/CWnd::get_accParent
- AFXWIN/CWnd::get_accRole
- AFXWIN/CWnd::get_accSelection
- AFXWIN/CWnd::get_accState
- AFXWIN/CWnd::get_accValue
- AFXWIN/CWnd::GetActiveWindow
- AFXWIN/CWnd::GetAncestor
- AFXWIN/CWnd::GetCapture
- AFXWIN/CWnd::GetCaretPos
- AFXWIN/CWnd::GetCheckedRadioButton
- AFXWIN/CWnd::GetClientRect
- AFXWIN/CWnd::GetClipboardOwner
- AFXWIN/CWnd::GetClipboardViewer
- AFXWIN/CWnd::GetControlUnknown
- AFXWIN/CWnd::GetDC
- AFXWIN/CWnd::GetDCEx
- AFXWIN/CWnd::GetDCRenderTarget
- AFXWIN/CWnd::GetDescendantWindow
- AFXWIN/CWnd::GetDesktopWindow
- AFXWIN/CWnd::GetDlgCtrlID
- AFXWIN/CWnd::GetDlgItem
- AFXWIN/CWnd::GetDlgItemInt
- AFXWIN/CWnd::GetDlgItemText
- AFXWIN/CWnd::GetDSCCursor
- AFXWIN/CWnd::GetDynamicLayout
- AFXWIN/CWnd::GetExStyle
- AFXWIN/CWnd::GetFocus
- AFXWIN/CWnd::GetFont
- AFXWIN/CWnd::GetForegroundWindow
- AFXWIN/CWnd::GetIcon
- AFXWIN/CWnd::GetLastActivePopup
- AFXWIN/CWnd::GetLayeredWindowAttributes
- AFXWIN/CWnd::GetMenu
- AFXWIN/CWnd::GetNextDlgGroupItem
- AFXWIN/CWnd::GetNextDlgTabItem
- AFXWIN/CWnd::GetNextWindow
- AFXWIN/CWnd::GetOleControlSite
- AFXWIN/CWnd::GetOpenClipboardWindow
- AFXWIN/CWnd::GetOwner
- AFXWIN/CWnd::GetParent
- AFXWIN/CWnd::GetParentFrame
- AFXWIN/CWnd::GetParentOwner
- AFXWIN/CWnd::GetProperty
- AFXWIN/CWnd::GetRenderTarget
- AFXWIN/CWnd::GetSafeHwnd
- AFXWIN/CWnd::GetSafeOwner
- AFXWIN/CWnd::GetScrollBarCtrl
- AFXWIN/CWnd::GetScrollBarInfo
- AFXWIN/CWnd::GetScrollInfo
- AFXWIN/CWnd::GetScrollLimit
- AFXWIN/CWnd::GetScrollPos
- AFXWIN/CWnd::GetScrollRange
- AFXWIN/CWnd::GetStyle
- AFXWIN/CWnd::GetSystemMenu
- AFXWIN/CWnd::GetTitleBarInfo
- AFXWIN/CWnd::GetTopLevelFrame
- AFXWIN/CWnd::GetTopLevelOwner
- AFXWIN/CWnd::GetTopLevelParent
- AFXWIN/CWnd::GetTopWindow
- AFXWIN/CWnd::GetUpdateRect
- AFXWIN/CWnd::GetUpdateRgn
- AFXWIN/CWnd::GetWindow
- AFXWIN/CWnd::GetWindowContextHelpId
- AFXWIN/CWnd::GetWindowDC
- AFXWIN/CWnd::GetWindowedChildCount
- AFXWIN/CWnd::GetWindowInfo
- AFXWIN/CWnd::GetWindowlessChildCount
- AFXWIN/CWnd::GetWindowPlacement
- AFXWIN/CWnd::GetWindowRect
- AFXWIN/CWnd::GetWindowRgn
- AFXWIN/CWnd::GetWindowText
- AFXWIN/CWnd::GetWindowTextLength
- AFXWIN/CWnd::HideCaret
- AFXWIN/CWnd::HiliteMenuItem
- AFXWIN/CWnd::HtmlHelp
- AFXWIN/CWnd::Invalidate
- AFXWIN/CWnd::InvalidateRect
- AFXWIN/CWnd::InvalidateRgn
- AFXWIN/CWnd::InvokeHelper
- AFXWIN/CWnd::IsChild
- AFXWIN/CWnd::IsD2DSupportEnabled
- AFXWIN/CWnd::IsDialogMessage
- AFXWIN/CWnd::IsDlgButtonChecked
- AFXWIN/CWnd::IsDynamicLayoutEnabled
- AFXWIN/CWnd::IsIconic
- AFXWIN/CWnd::IsTouchWindow
- AFXWIN/CWnd::IsWindowEnabled
- AFXWIN/CWnd::IsWindowVisible
- AFXWIN/CWnd::IsZoomed
- AFXWIN/CWnd::KillTimer
- AFXWIN/CWnd::LockWindowUpdate
- AFXWIN/CWnd::MapWindowPoints
- AFXWIN/CWnd::MessageBox
- AFXWIN/CWnd::ModifyStyle
- AFXWIN/CWnd::ModifyStyleEx
- AFXWIN/CWnd::MoveWindow
- AFXWIN/CWnd::NotifyWinEvent
- AFXWIN/CWnd::OnAmbientProperty
- AFXWIN/CWnd::OnDrawIconicThumbnailOrLivePreview
- AFXWIN/CWnd::OnHelp
- AFXWIN/CWnd::OnHelpFinder
- AFXWIN/CWnd::OnHelpIndex
- AFXWIN/CWnd::OnHelpUsing
- AFXWIN/CWnd::OnToolHitTest
- AFXWIN/CWnd::OpenClipboard
- AFXWIN/CWnd::PaintWindowlessControls
- AFXWIN/CWnd::PostMessage
- AFXWIN/CWnd::PreCreateWindow
- AFXWIN/CWnd::PreSubclassWindow
- AFXWIN/CWnd::PreTranslateMessage
- AFXWIN/CWnd::Print
- AFXWIN/CWnd::PrintClient
- AFXWIN/CWnd::PrintWindow
- AFXWIN/CWnd::RedrawWindow
- AFXWIN/CWnd::RegisterTouchWindow
- AFXWIN/CWnd::ReleaseDC
- AFXWIN/CWnd::RepositionBars
- AFXWIN/CWnd::RunModalLoop
- AFXWIN/CWnd::ScreenToClient
- AFXWIN/CWnd::ScrollWindow
- AFXWIN/CWnd::ScrollWindowEx
- AFXWIN/CWnd::SendChildNotifyLastMsg
- AFXWIN/CWnd::SendDlgItemMessage
- AFXWIN/CWnd::SendMessage
- AFXWIN/CWnd::SendMessageToDescendants
- AFXWIN/CWnd::SendNotifyMessage
- AFXWIN/CWnd::SetActiveWindow
- AFXWIN/CWnd::SetCapture
- AFXWIN/CWnd::SetCaretPos
- AFXWIN/CWnd::SetClipboardViewer
- AFXWIN/CWnd::SetDlgCtrlID
- AFXWIN/CWnd::SetDlgItemInt
- AFXWIN/CWnd::SetDlgItemText
- AFXWIN/CWnd::SetFocus
- AFXWIN/CWnd::SetFont
- AFXWIN/CWnd::SetForegroundWindow
- AFXWIN/CWnd::SetIcon
- AFXWIN/CWnd::SetLayeredWindowAttributes
- AFXWIN/CWnd::SetMenu
- AFXWIN/CWnd::SetOwner
- AFXWIN/CWnd::SetParent
- AFXWIN/CWnd::SetProperty
- AFXWIN/CWnd::SetRedraw
- AFXWIN/CWnd::SetScrollInfo
- AFXWIN/CWnd::SetScrollPos
- AFXWIN/CWnd::SetScrollRange
- AFXWIN/CWnd::SetTimer
- AFXWIN/CWnd::SetWindowContextHelpId
- AFXWIN/CWnd::SetWindowPlacement
- AFXWIN/CWnd::SetWindowPos
- AFXWIN/CWnd::SetWindowRgn
- AFXWIN/CWnd::SetWindowText
- AFXWIN/CWnd::ShowCaret
- AFXWIN/CWnd::ShowOwnedPopups
- AFXWIN/CWnd::ShowScrollBar
- AFXWIN/CWnd::ShowWindow
- AFXWIN/CWnd::SubclassDlgItem
- AFXWIN/CWnd::SubclassWindow
- AFXWIN/CWnd::UnlockWindowUpdate
- AFXWIN/CWnd::UnsubclassWindow
- AFXWIN/CWnd::UpdateData
- AFXWIN/CWnd::UpdateDialogControls
- AFXWIN/CWnd::UpdateLayeredWindow
- AFXWIN/CWnd::UpdateWindow
- AFXWIN/CWnd::ValidateRect
- AFXWIN/CWnd::ValidateRgn
- AFXWIN/CWnd::WindowFromPoint
- AFXWIN/CWnd::WinHelp
- AFXWIN/CWnd::Default
- AFXWIN/CWnd::DefWindowProc
- AFXWIN/CWnd::DoDataExchange
- AFXWIN/CWnd::GetCurrentMessage
- AFXWIN/CWnd::InitDynamicLayout
- AFXWIN/CWnd::LoadDynamicLayoutResource
- AFXWIN/CWnd::OnActivate
- AFXWIN/CWnd::OnActivateApp
- AFXWIN/CWnd::OnAppCommand
- AFXWIN/CWnd::OnAskCbFormatName
- AFXWIN/CWnd::OnCancelMode
- AFXWIN/CWnd::OnCaptureChanged
- AFXWIN/CWnd::OnChangeCbChain
- AFXWIN/CWnd::OnChangeUIState
- AFXWIN/CWnd::OnChar
- AFXWIN/CWnd::OnCharToItem
- AFXWIN/CWnd::OnChildActivate
- AFXWIN/CWnd::OnChildNotify
- AFXWIN/CWnd::OnClipboardUpdate
- AFXWIN/CWnd::OnClose
- AFXWIN/CWnd::OnColorizationColorChanged
- AFXWIN/CWnd::OnCommand
- AFXWIN/CWnd::OnCompacting
- AFXWIN/CWnd::OnCompareItem
- AFXWIN/CWnd::OnCompositionChanged
- AFXWIN/CWnd::OnContextMenu
- AFXWIN/CWnd::OnCopyData
- AFXWIN/CWnd::OnCreate
- AFXWIN/CWnd::OnCtlColor
- AFXWIN/CWnd::OnDeadChar
- AFXWIN/CWnd::OnDeleteItem
- AFXWIN/CWnd::OnDestroy
- AFXWIN/CWnd::OnDestroyClipboard
- AFXWIN/CWnd::OnDeviceChange
- AFXWIN/CWnd::OnDevModeChange
- AFXWIN/CWnd::OnDrawClipboard
- AFXWIN/CWnd::OnDrawItem
- AFXWIN/CWnd::OnDropFiles
- AFXWIN/CWnd::OnEnable
- AFXWIN/CWnd::OnEndSession
- AFXWIN/CWnd::OnEnterIdle
- AFXWIN/CWnd::OnEnterMenuLoop
- AFXWIN/CWnd::OnEnterSizeMove
- AFXWIN/CWnd::OnEraseBkgnd
- AFXWIN/CWnd::OnExitMenuLoop
- AFXWIN/CWnd::OnExitSizeMove
- AFXWIN/CWnd::OnFontChange
- AFXWIN/CWnd::OnGetDlgCode
- AFXWIN/CWnd::OnGetMinMaxInfo
- AFXWIN/CWnd::OnHelpInfo
- AFXWIN/CWnd::OnHotKey
- AFXWIN/CWnd::OnHScroll
- AFXWIN/CWnd::OnHScrollClipboard
- AFXWIN/CWnd::OnIconEraseBkgnd
- AFXWIN/CWnd::OnInitMenu
- AFXWIN/CWnd::OnInitMenuPopup
- AFXWIN/CWnd::OnInputDeviceChange
- AFXWIN/CWnd::OnInputLangChange
- AFXWIN/CWnd::OnInputLangChangeRequest
- AFXWIN/CWnd::OnKeyDown
- AFXWIN/CWnd::OnKeyUp
- AFXWIN/CWnd::OnKillFocus
- AFXWIN/CWnd::OnLButtonDblClk
- AFXWIN/CWnd::OnLButtonDown
- AFXWIN/CWnd::OnLButtonUp
- AFXWIN/CWnd::OnMButtonDblClk
- AFXWIN/CWnd::OnMButtonDown
- AFXWIN/CWnd::OnMButtonUp
- AFXWIN/CWnd::OnMDIActivate
- AFXWIN/CWnd::OnMeasureItem
- AFXWIN/CWnd::OnMenuChar
- AFXWIN/CWnd::OnMenuDrag
- AFXWIN/CWnd::OnMenuGetObject
- AFXWIN/CWnd::OnMenuRButtonUp
- AFXWIN/CWnd::OnMenuSelect
- AFXWIN/CWnd::OnMouseActivate
- AFXWIN/CWnd::OnMouseHover
- AFXWIN/CWnd::OnMouseHWheel
- AFXWIN/CWnd::OnMouseLeave
- AFXWIN/CWnd::OnMouseMove
- AFXWIN/CWnd::OnMouseWheel
- AFXWIN/CWnd::OnMove
- AFXWIN/CWnd::OnMoving
- AFXWIN/CWnd::OnNcActivate
- AFXWIN/CWnd::OnNcCalcSize
- AFXWIN/CWnd::OnNcCreate
- AFXWIN/CWnd::OnNcDestroy
- AFXWIN/CWnd::OnNcHitTest
- AFXWIN/CWnd::OnNcLButtonDblClk
- AFXWIN/CWnd::OnNcLButtonDown
- AFXWIN/CWnd::OnNcLButtonUp
- AFXWIN/CWnd::OnNcMButtonDblClk
- AFXWIN/CWnd::OnNcMButtonDown
- AFXWIN/CWnd::OnNcMButtonUp
- AFXWIN/CWnd::OnNcMouseHover
- AFXWIN/CWnd::OnNcMouseLeave
- AFXWIN/CWnd::OnNcMouseMove
- AFXWIN/CWnd::OnNcPaint
- AFXWIN/CWnd::OnNcRButtonDblClk
- AFXWIN/CWnd::OnNcRButtonDown
- AFXWIN/CWnd::OnNcRButtonUp
- AFXWIN/CWnd::OnNcRenderingChanged
- AFXWIN/CWnd::OnNcXButtonDblClk
- AFXWIN/CWnd::OnNcXButtonDown
- AFXWIN/CWnd::OnNcXButtonUp
- AFXWIN/CWnd::OnNextMenu
- AFXWIN/CWnd::OnNotify
- AFXWIN/CWnd::OnNotifyFormat
- AFXWIN/CWnd::OnPaint
- AFXWIN/CWnd::OnPaintClipboard
- AFXWIN/CWnd::OnPaletteChanged
- AFXWIN/CWnd::OnPaletteIsChanging
- AFXWIN/CWnd::OnParentNotify
- AFXWIN/CWnd::OnPowerBroadcast
- AFXWIN/CWnd::OnQueryDragIcon
- AFXWIN/CWnd::OnQueryEndSession
- AFXWIN/CWnd::OnQueryNewPalette
- AFXWIN/CWnd::OnQueryOpen
- AFXWIN/CWnd::OnQueryUIState
- AFXWIN/CWnd::OnRawInput
- AFXWIN/CWnd::OnRButtonDblClk
- AFXWIN/CWnd::OnRButtonDown
- AFXWIN/CWnd::OnRButtonUp
- AFXWIN/CWnd::OnRenderAllFormats
- AFXWIN/CWnd::OnRenderFormat
- AFXWIN/CWnd::OnSessionChange
- AFXWIN/CWnd::OnSetCursor
- AFXWIN/CWnd::OnSetFocus
- AFXWIN/CWnd::OnSettingChange
- AFXWIN/CWnd::OnShowWindow
- AFXWIN/CWnd::OnSize
- AFXWIN/CWnd::OnSizeClipboard
- AFXWIN/CWnd::OnSizing
- AFXWIN/CWnd::OnSpoolerStatus
- AFXWIN/CWnd::OnStyleChanged
- AFXWIN/CWnd::OnStyleChanging
- AFXWIN/CWnd::OnSysChar
- AFXWIN/CWnd::OnSysColorChange
- AFXWIN/CWnd::OnSysCommand
- AFXWIN/CWnd::OnSysDeadChar
- AFXWIN/CWnd::OnSysKeyDown
- AFXWIN/CWnd::OnSysKeyUp
- AFXWIN/CWnd::OnTCard
- AFXWIN/CWnd::OnTimeChange
- AFXWIN/CWnd::OnTimer
- AFXWIN/CWnd::OnTouchInput
- AFXWIN/CWnd::OnTouchInputs
- AFXWIN/CWnd::OnUniChar
- AFXWIN/CWnd::OnUnInitMenuPopup
- AFXWIN/CWnd::OnUpdateUIState
- AFXWIN/CWnd::OnUserChanged
- AFXWIN/CWnd::OnVKeyToItem
- AFXWIN/CWnd::OnVScroll
- AFXWIN/CWnd::OnVScrollClipboard
- AFXWIN/CWnd::OnWindowPosChanged
- AFXWIN/CWnd::OnWindowPosChanging
- AFXWIN/CWnd::OnWinIniChange
- AFXWIN/CWnd::OnWndMsg
- AFXWIN/CWnd::OnXButtonDblClk
- AFXWIN/CWnd::OnXButtonDown
- AFXWIN/CWnd::OnXButtonUp
- AFXWIN/CWnd::PostNcDestroy
- AFXWIN/CWnd::ReflectChildNotify
- AFXWIN/CWnd::ReflectLastMsg
- AFXWIN/CWnd::ResizeDynamicLayout
- AFXWIN/CWnd::WindowProc
- AFXWIN/CWnd::m_hWnd
dev_langs:
- C++
helpviewer_keywords:
- windows [C++]
- window objects [C++]
- CWnd class
ms.assetid: 49a832ee-bc34-4126-88b3-bc1d9974f6c4
caps.latest.revision: 27
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: b790beb88de009e1c7161f3c9af6b3e21c22fd8e
ms.openlocfilehash: 77be7b572bd5fa6d90d52d14a40706f251176a2b
ms.lasthandoff: 03/29/2017

---
# <a name="cwnd-class"></a>CWnd 類別
提供 MFC 程式庫中所有視窗類別的基本功能。  
  
## <a name="syntax"></a>語法  
  
```  
class CWnd : public CCmdTarget  
```  
  
## <a name="members"></a>Members  
  
### <a name="public-constructors"></a>公用建構函式  
  
|名稱|說明|  
|----------|-----------------|  
|[CWnd::CWnd](#cwnd)|建構 `CWnd` 物件。|  
  
### <a name="public-methods"></a>公用方法  
  
|名稱|描述|  
|----------|-----------------|  
|[CWnd::accDoDefaultAction](#accdodefaultaction)|由架構呼叫以執行物件的預設動作。|  
|[CWnd::accHitTest](#acchittest)|由架構呼叫以擷取畫面中給定點的子項目或子物件。|  
|[CWnd::accLocation](#acclocation)|由架構呼叫以擷取指定物件目前畫面的位置。|  
|[CWnd::accNavigate](#accnavigate)|由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。|  
|[CWnd::accSelect](#accselect)|由架構呼叫以修改選取或移動指定物件的鍵盤焦點。|  
|[CWnd::AnimateWindow](#animatewindow)|建立相關聯的視窗物件的動畫。|  
|[CWnd::ArrangeIconicWindows](#arrangeiconicwindows)|排列所有最小化 (圖示) 子視窗。|  
|[CWnd::Attach](#attach)|將 Windows 控制代碼附加至 `CWnd` 物件。|  
|[CWnd::BeginModalState](#beginmodalstate)|呼叫此成員函式以製作框架視窗強制回應。|  
|[Cwnd:: Beginpaint](#beginpaint)|準備 `CWnd` 進行繪製。|  
|[CWnd::BindDefaultProperty](#binddefaultproperty)|將呼叫物件的預設簡單繫結屬性 (在類型程式庫中標示)，繫結至資料來源控制項相關聯的游標。|  
|[CWnd::BindProperty](#bindproperty)|將資料繫結控制項上的游標繫結屬性繫結至資料來源控制項，並註冊該關聯性與 MFC 繫結管理員。|  
|[CWnd::BringWindowToTop](#bringwindowtotop)|將 `CWnd` 帶到重疊視窗堆疊的最上層。|  
|[CWnd::CalcWindowRect](#calcwindowrect)|呼叫可從用戶端矩形計算視窗矩形。|  
|[CWnd::CancelToolTips](#canceltooltips)|停用工具提示控制項。|  
|[CWnd::CenterWindow](#centerwindow)|將相對於其父系的視窗置中。|  
|[CWnd::ChangeClipboardChain](#changeclipboardchain)|從剪貼簿檢視器的鏈結中移除 `CWnd`。|  
|[CWnd::CheckDlgButton](#checkdlgbutton)|在按鈕控制項旁放置核取記號，或從中移除核取記號。|  
|[CWnd::CheckRadioButton](#checkradiobutton)|檢查指定的選項按鈕，及移除指定的按鈕群組中所有其他選項按鈕的核取記號。|  
|[CWnd::ChildWindowFromPoint](#childwindowfrompoint)|判斷 (如果有的話) 是否有子視窗包含指定的點。|  
|[CWnd::ClientToScreen](#clienttoscreen)|將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。|  
|[CWnd::CloseWindow](#closewindow)|將視窗最小化。|  
|[CWnd::ContinueModal](#continuemodal)|繼續視窗的強制回應狀態。|  
|[Cwnd:: Create](#create)|建立並初始化 `CWnd` 物件相關聯的子視窗。|  
|[CWnd::CreateAccessibleProxy](#createaccessibleproxy)|建立指定物件的 Active Accessibility Proxy。|  
|[CWnd::CreateCaret](#createcaret)|建立系統游標的新形狀，並取得插入號的擁有權。|  
|[Cwnd:: Createcontrol](#createcontrol)|建立將由 `CWnd` 物件在 MFC 程式中表示的 ActiveX 控制項。|  
|[CWnd::CreateEx](#createex)|建立 Windows 重疊、快顯視窗或子視窗，並將其附加至 `CWnd` 物件。|  
|[CWnd::CreateGrayCaret](#creategraycaret)|建立系統游標的灰色區塊，並取得插入號的擁有權。|  
|[CWnd::CreateSolidCaret](#createsolidcaret)|建立系統游標的實心區塊，並取得插入號的擁有權。|  
|[CWnd::DeleteTempMap](#deletetempmap)|由 `CWinApp` 閒置時間處理常式自動呼叫，並刪除 `FromHandle` 建立的任何暫存 `CWnd` 物件。|  
|[Cwnd:: Destroywindow](#destroywindow)|終結附加的 Windowd 視窗。|  
|[CWnd::Detach](#detach)|從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。|  
|[CWnd::DlgDirList](#dlgdirlist)|使用檔案或目錄清單填入清單方塊。|  
|[CWnd::DlgDirListComboBox](#dlgdirlistcombobox)|使用檔案或目錄清單來填入下拉式方塊的清單方塊。|  
|[CWnd::DlgDirSelect](#dlgdirselect)|從清單方塊擷取目前的選取範圍。|  
|[CWnd::DlgDirSelectComboBox](#dlgdirselectcombobox)|從下拉式方塊的清單方塊中擷取目前的選取範圍。|  
|[CWnd::DragAcceptFiles](#dragacceptfiles)|指出視窗將接受拖曳的檔案。|  
|[CWnd::DragDetect](#dragdetect)|擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。|  
|[CWnd::DrawAnimatedRects](#drawanimatedrects)|繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。|  
|[CWnd::DrawCaption](#drawcaption)|繪製標題。|  
|[CWnd::DrawMenuBar](#drawmenubar)|重新繪製功能表列。|  
|[CWnd::EnableActiveAccessibility](#enableactiveaccessibility)|啟用使用者定義的 `Active Accessibility` 函式。|  
|[Cwnd:: Enabledynamiclayout](#enabledynamiclayout)|可在使用者調整視窗大小時，動態調整子視窗的位置與大小。|  
|[CWnd::EnableD2DSupport](#enabled2dsupport)|啟用或停用視窗 `D2D` 支援。 初始化主視窗之前先呼叫這個方法。|  
|[CWnd::EnableScrollBar](#enablescrollbar)|啟用或停用一個捲軸的一或兩個箭號。|  
|[CWnd::EnableScrollBarCtrl](#enablescrollbarctrl)|啟用或停用同層級捲軸控制項。|  
|[CWnd::EnableToolTips](#enabletooltips)|啟用工具提示控制項。|  
|[CWnd::EnableTrackingToolTips](#enabletrackingtooltips)|啟用追蹤模式中的工具提示控制項。|  
|[CWnd::EnableWindow](#enablewindow)|啟用或停用滑鼠和鍵盤輸入。|  
|[CWnd::EndModalLoop](#endmodalloop)|結束視窗的強制回應狀態。|  
|[CWnd::EndModalState](#endmodalstate)|呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。|  
|[CWnd::EndPaint](#endpaint)|標記繪製的結束。|  
|[CWnd::ExecuteDlgInit](#executedlginit)|初始化對話方塊資源。|  
|[CWnd::FilterToolTipMessage](#filtertooltipmessage)|擷取對話方塊中控制項相關聯的標題或文字。|  
|[CWnd::FindWindow](#findwindow)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|  
|[CWnd::FindWindowEx](#findwindowex)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|  
|[CWnd::FlashWindow](#flashwindow)|閃爍視窗一次。|  
|[CWnd::FlashWindowEx](#flashwindowex)|閃爍視窗與其他功能。|  
|[Cwnd:: Fromhandle](#fromhandle)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|  
|[CWnd::FromHandlePermanent](#fromhandlepermanent)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|  
|[CWnd::get_accChild](#get_accchild)|由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。|  
|[CWnd::get_accChildCount](#get_accchildcount)|由架構呼叫以擷取屬於此物件的子物件數目。|  
|[CWnd::get_accDefaultAction](#get_accdefaultaction)|由架構呼叫以擷取具有物件預設動作描述的字串。|  
|[CWnd::get_accDescription](#get_accdescription)|由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。|  
|[CWnd::get_accFocus](#get_accfocus)|由架構呼叫以擷取具有鍵盤焦點的物件。|  
|[CWnd::get_accHelp](#get_acchelp)|由架構呼叫以擷取物件的**協助**屬性字串。|  
|[CWnd::get_accHelpTopic](#get_acchelptopic)|由架構呼叫以擷取 `WinHelp` 檔 (與指定物件和該檔案中適切主題的識別項關聯) 的完整路徑。|  
|[CWnd::get_accKeyboardShortcut](#get_acckeyboardshortcut)|由架構呼叫以擷取指定物件的快速鍵或便捷鍵。|  
|[CWnd::get_accName](#get_accname)|由架構呼叫以擷取指定物件的名稱。|  
|[CWnd::get_accParent](#get_accparent)|由架構呼叫以擷取物件之父代的 `IDispatch` 介面。|  
|[CWnd::get_accRole](#get_accrole)|由架構呼叫以擷取含有指定物件的角色描述資訊。|  
|[CWnd::get_accSelection](#get_accselection)|由架構呼叫以擷取此物件的選取子物件。|  
|[CWnd::get_accState](#get_accstate)|由架構呼叫以擷取指定物件的目前狀態。|  
|[CWnd::get_accValue](#get_accvalue)|由架構呼叫以擷取指定物件的值。|  
|[CWnd::GetActiveWindow](#getactivewindow)|擷取使用中視窗。|  
|[CWnd::GetAncestor](#getancestor)|擷取指定視窗的上階視窗物件。|  
|[CWnd::GetCapture](#getcapture)|擷取具有滑鼠捕捉的 `CWnd`。|  
|[CWnd::GetCaretPos](#getcaretpos)|擷取插入號之目前位置的用戶端座標。|  
|[CWnd::GetCheckedRadioButton](#getcheckedradiobutton)|傳回按鈕群組中目前核取的選項按鈕的識別碼。|  
|[CWnd::GetClientRect](#getclientrect)|取得 `CWnd` 工作區的維度。|  
|[CWnd::GetClipboardOwner](#getclipboardowner)|擷取剪貼簿的目前擁有者的指標。|  
|[CWnd::GetClipboardViewer](#getclipboardviewer)|擷取剪貼簿檢視器鏈結中的第一個視窗的指標。|  
|[CWnd::GetControlUnknown](#getcontrolunknown)|擷取至未知 ActiveX 控制項的指標。|  
|[Cwnd:: Getdc](#getdc)|擷取工作區的顯示內容。|  
|[CWnd::GetDCEx](#getdcex)|擷取工作區的顯示內容，並在繪製時啟用裁剪。|  
|[CWnd::GetDCRenderTarget](#getdcrendertarget)|擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。|  
|[CWnd::GetDescendantWindow](#getdescendantwindow)|搜尋所有下階視窗，並傳回具有指定識別碼的視窗。|  
|[CWnd::GetDesktopWindow](#getdesktopwindow)|擷取 Windows 桌面視窗。|  
|[CWnd::GetDlgCtrlID](#getdlgctrlid)|如果 `CWnd` 是子視窗，呼叫這個函式會傳回它的識別碼值。|  
|[CWnd::GetDlgItem](#getdlgitem)|從指定的對話方塊中擷取具有指定識別碼的控制項。|  
|[CWnd::GetDlgItemInt](#getdlgitemint)|將指定對話方塊中的控制項文字轉譯成整數值。|  
|[CWnd::GetDlgItemText](#getdlgitemtext)|擷取與控制項相關聯的標題或文字。|  
|[CWnd::GetDSCCursor](#getdsccursor)|擷取料來源控制項的 DataSource、UserName、Password 和 SQL 屬性所定義之基礎游標的指標。|  
|[Cwnd:: Getdynamiclayout](#getdynamiclayout)|擷取動態配置管理員物件的指標。|  
|[CWnd::GetExStyle](#getexstyle)|傳回視窗的延伸樣式。|  
|[CWnd::GetFocus](#getfocus)|擷取目前具有輸入焦點的 `CWnd`。|  
|[CWnd::GetFont](#getfont)|擷取目前的字型。|  
|[CWnd::GetForegroundWindow](#getforegroundwindow)|讓指標回到前景視窗 (使用者目前使用的最上層視窗)。|  
|[CWnd::GetIcon](#geticon)|擷取圖示的控制代碼。|  
|[CWnd::GetLastActivePopup](#getlastactivepopup)|判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。|  
|[CWnd::GetLayeredWindowAttributes](#getlayeredwindowattributes)|擷取分層視窗的不透明和透明色鍵。|  
|[CWnd::GetMenu](#getmenu)|擷取指定功能表的指標。|  
|[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)|搜尋控制項群組內的下一個 (或上一個) 控制項。|  
|[CWnd::GetNextDlgTabItem](#getnextdlgtabitem)|擷取的第一個控制項與[WS_TABSTOP](window-styles.md) （或） 指定之控制項的樣式。|  
|[CWnd::GetNextWindow](#getnextwindow)|傳回視窗管理員清單中的下一個 (或上一個) 視窗。|  
|[CWnd::GetOleControlSite](#getolecontrolsite)|擷取指定的 ActiveX 控制項的自訂網站。|  
|[CWnd::GetOpenClipboardWindow](#getopenclipboardwindow)|擷取目前已開啟剪貼簿的視窗指標。|  
|[CWnd::GetOwner](#getowner)|擷取 `CWnd` 擁有者的指標。|  
|[CWnd::GetParent](#getparent)|擷取 `CWnd` 的父視窗 (如果有的話)。|  
|[CWnd::GetParentFrame](#getparentframe)|擷取 `CWnd` 物件的父框架視窗。|  
|[CWnd::GetParentOwner](#getparentowner)|傳回子視窗的父視窗指標。|  
|[CWnd::GetProperty](#getproperty)|擷取 ActiveX 控制項屬性。|  
|[CWnd::GetRenderTarget](#getrendertarget)|取得與此視窗相關聯的呈現目標。|  
|[CWnd::GetSafeHwnd](#getsafehwnd)|傳回 `m_hWnd`；或如果 `this` 指標為 `NULL` 則傳回 `NULL`。|  
|[CWnd::GetSafeOwner](#getsafeowner)|擷取給定視窗的安全擁有者。|  
|[Cwnd:: Getscrollbarctrl](#getscrollbarctrl)|傳回一個同層級捲軸控制項。|  
|[CWnd::GetScrollBarInfo](#getscrollbarinfo)|擷取所指定之捲軸的相關資訊。|  
|[CWnd::GetScrollInfo](#getscrollinfo)|擷取 `SCROLLINFO` 結構維護的捲軸相關資訊。|  
|[CWnd::GetScrollLimit](#getscrolllimit)|擷取捲軸的限制。|  
|[CWnd::GetScrollPos](#getscrollpos)|擷取捲動方塊的目前位置。|  
|[CWnd::GetScrollRange](#getscrollrange)|複製給定捲軸目前的最小和最大捲軸位置。|  
|[CWnd::GetStyle](#getstyle)|傳回目前的視窗樣式。|  
|[CWnd::GetSystemMenu](#getsystemmenu)|可讓應用程式存取控制功能表以進行複製和修改。|  
|[CWnd::GetTitleBarInfo](#gettitlebarinfo)|擷取指定之標題列的相關資訊。|  
|[CWnd::GetTopLevelFrame](#gettoplevelframe)|擷取視窗的最上層框架視窗。|  
|[CWnd::GetTopLevelOwner](#gettoplevelowner)|擷取最上層視窗。|  
|[CWnd::GetTopLevelParent](#gettoplevelparent)|擷取視窗的最上層父代。|  
|[CWnd::GetTopWindow](#gettopwindow)|傳回屬於 `CWnd` 的第一個子視窗。|  
|[CWnd::GetUpdateRect](#getupdaterect)|擷取完全圍住 `CWnd` 更新區域的最小矩形座標。|  
|[CWnd::GetUpdateRgn](#getupdatergn)|擷取 `CWnd` 更新區域。|  
|[CWnd::GetWindow](#getwindow)|傳回與此視窗具有指定關聯性的視窗。|  
|[CWnd::GetWindowContextHelpId](#getwindowcontexthelpid)|擷取說明內容識別碼。|  
|[Cwnd:: Getwindowdc](#getwindowdc)|擷取整個視窗的顯示內容，包括標題列、功能表和捲軸。|  
|[CWnd::GetWindowedChildCount](#getwindowedchildcount)|傳回相關聯子視窗的數目。|  
|[CWnd::GetWindowInfo](#getwindowinfo)|傳回視窗的相關資訊。|  
|[CWnd::GetWindowlessChildCount](#getwindowlesschildcount)|傳回相關聯的無視窗子視窗數目。|  
|[CWnd::GetWindowPlacement](#getwindowplacement)|擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|  
|[CWnd::GetWindowRect](#getwindowrect)|取得 `CWnd` 的螢幕座標。|  
|[CWnd::GetWindowRgn](#getwindowrgn)|擷取視窗的視窗區域複本。|  
|[CWnd::GetWindowText](#getwindowtext)|傳回視窗文字或標題 (如果有的話)。|  
|[CWnd::GetWindowTextLength](#getwindowtextlength)|傳回視窗的文字或標題的長度。|  
|[CWnd::HideCaret](#hidecaret)|藉由從顯示畫面移除插入號來隱藏該插入號。|  
|[CWnd::HiliteMenuItem](#hilitemenuitem)|反白顯示或從最上層 (功能表列) 的功能表項目中移除反白顯示。|  
|[CWnd::HtmlHelp](#htmlhelp)|呼叫以初始化 HTMLHelp 應用程式。|  
|[CWnd::Invalidate](#invalidate)|使整個工作區失效。|  
|[CWnd::InvalidateRect](#invalidaterect)|將矩形加入至目前的更新區域，使給定矩形內的工作區失效。|  
|[CWnd::InvalidateRgn](#invalidatergn)|將區域加入至目前的更新區域，使給定區域內的工作區失效。|  
|[CWnd::InvokeHelper](#invokehelper)|叫用 ActiveX 控制項方法或屬性。|  
|[CWnd::IsChild](#ischild)|指出 `CWnd` 是子視窗，還是指定視窗的其他直屬下階。|  
|[CWnd::IsD2DSupportEnabled](#isd2dsupportenabled)|決定是否啟用 `D2D` 支援。|  
|[CWnd::IsDialogMessage](#isdialogmessage)|判斷指定的訊息是否適用於非強制回應對話方塊，若是則處理它。|  
|[CWnd::IsDlgButtonChecked](#isdlgbuttonchecked)|決定是否核取按鈕控制項。|  
|[Cwnd:: Isdynamiclayoutenabled](#isdynamiclayoutenabled)|決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。|  
|[CWnd::IsIconic](#isiconic)|決定是否將 `CWnd` 降到最低 (圖示)。|  
|[CWnd::IsTouchWindow](#istouchwindow)|指定 `CWnd` 是否有觸控支援。|  
|[CWnd::IsWindowEnabled](#iswindowenabled)|決定是否為滑鼠和鍵盤輸入啟用視窗。|  
|[CWnd::IsWindowVisible](#iswindowvisible)|決定視窗是否可見。|  
|[CWnd::IsZoomed](#iszoomed)|決定是否將 `CWnd` 最大化。|  
|[CWnd::KillTimer](#killtimer)|刪除系統計時器。|  
|[CWnd::LockWindowUpdate](#lockwindowupdate)|停用或重新啟用在給定視窗中繪製。|  
|[CWnd::MapWindowPoints](#mapwindowpoints)|將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。|  
|[CWnd::MessageBox](#messagebox)|建立並顯示視窗，其中包含應用程式提供的訊息和標題。|  
|[CWnd::ModifyStyle](#modifystyle)|修改目前的視窗樣式。|  
|[CWnd::ModifyStyleEx](#modifystyleex)|修改視窗的延伸樣式。|  
|[CWnd::MoveWindow](#movewindow)|變更 `CWnd` 的位置和維度。|  
|[CWnd::NotifyWinEvent](#notifywinevent)|表示發生預先定義之事件的系統。|  
|[CWnd::OnAmbientProperty](#onambientproperty)|實作環境屬性值。|  
|[CWnd::OnDrawIconicThumbnailOrLivePreview](#ondrawiconicthumbnailorlivepreview)|需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。|  
|[CWnd::OnHelp](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|  
|[CWnd::OnHelpFinder](#onhelpfinder)|處理 `ID_HELP_FINDER` 和 `ID_DEFAULT_HELP` 命令。|  
|[CWnd::OnHelpIndex](#onhelpindex)|處理 `ID_HELP_INDEX` 命令並提供預設的說明主題。|  
|[CWnd::OnHelpUsing](#onhelpusing)|處理 `ID_HELP_USING` 命令。|  
|[CWnd::OnToolHitTest](#ontoolhittest)|決定一個點是否位於指定工具的週框中並擷取工具的相關資訊。|  
|[CWnd::OpenClipboard](#openclipboard)|開啟剪貼簿。 其他應用程式不能修改剪貼簿，直到 Windows [CloseClipboard](http://msdn.microsoft.com/library/windows/desktop/ms649035)呼叫函式。|  
|[CWnd::PaintWindowlessControls](#paintwindowlesscontrols)|在控制項容器上繪製無視窗控制項。|  
|[CWnd::PostMessage](#postmessage)|在應用程式佇列中放置訊息，然後傳回，而不需等待視窗處理訊息。|  
|[CWnd::PreCreateWindow](#precreatewindow)|在建立附加至此 `CWnd` 物件的 Windows 視窗前呼叫。|  
|[CWnd::PreSubclassWindow](#presubclasswindow)|允許發生其他必要的子類別[SubclassWindow](#subclasswindow)呼叫。|  
|[Cwnd:: Pretranslatemessage](#pretranslatemessage)|由 `CWinApp` 使用，可先篩選視窗訊息，再將它們分派至 `TranslateMessage` 和 `DispatchMessage` Windows 函式。|  
|[CWnd::Print](#print)|在指定的裝置內容中繪製目前的視窗。|  
|[CWnd::PrintClient](#printclient)|在指定的裝置內容中繪製任何視窗 (通常是印表機裝置內容)。|  
|[CWnd::PrintWindow](#printwindow)|將視覺視窗複製到指定的裝置內容，通常是印表機 DC。|  
|[CWnd::RedrawWindow](#redrawwindow)|更新工作區中指定的矩形或區域。|  
|[CWnd::RegisterTouchWindow](#registertouchwindow)|註冊/取消註冊視窗 Windows 觸控支援。|  
|[Cwnd:: Releasedc](#releasedc)|釋放用戶端和視窗裝置內容，釋放這些內容供其他應用程式使用。|  
|[CWnd::RepositionBars](#repositionbars)|工作區中的重新置放控制列。|  
|[CWnd::RunModalLoop](#runmodalloop)|擷取、轉換或分派處於強制回應狀態之視窗的訊息。|  
|[CWnd::ScreenToClient](#screentoclient)|將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。|  
|[CWnd::ScrollWindow](#scrollwindow)|捲動工作區的內容。|  
|[CWnd::ScrollWindowEx](#scrollwindowex)|捲動工作區的內容。 類似於 `ScrollWindow`，但具有額外的功能。|  
|[CWnd::SendChildNotifyLastMsg](#sendchildnotifylastmsg)|從父視窗中將通知訊息提供給子視窗，讓子視窗可以處理工作。|  
|[CWnd::SendDlgItemMessage](#senddlgitemmessage)|將訊息傳送至指定的控制項。|  
|[CWnd::SendMessage](#sendmessage)|傳送訊息給 `CWnd` 物件，在處理訊息後才會傳回。|  
|[CWnd::SendMessageToDescendants](#sendmessagetodescendants)|傳送訊息給視窗的所有下階視窗。|  
|[CWnd::SendNotifyMessage](#sendnotifymessage)|將指定的訊息傳送至視窗並儘速傳回，視呼叫執行緒是否建立視窗而定。|  
|[CWnd::SetActiveWindow](#setactivewindow)|啟用視窗。|  
|[CWnd::SetCapture](#setcapture)|導致所有後續滑鼠輸入傳送至 `CWnd`。|  
|[CWnd::SetCaretPos](#setcaretpos)|將插入號移動到指定的位置。|  
|[CWnd::SetClipboardViewer](#setclipboardviewer)|將 `CWnd` 新增到視窗的鏈結，每當剪貼簿的內容變更時就會通知這些視窗。|  
|[CWnd::SetDlgCtrlID](#setdlgctrlid)|設定視窗或視窗的控制項識別碼 (這可以是任何子視窗，而不只是對話方塊中的控制項)。|  
|[CWnd::SetDlgItemInt](#setdlgitemint)|將控制項的文字設為表示整數值的字串。|  
|[CWnd::SetDlgItemText](#setdlgitemtext)|在指定的對話方塊中設定控制項的標題或文字。|  
|[CWnd::SetFocus](#setfocus)|宣告輸入焦點。|  
|[CWnd::SetFont](#setfont)|設定目前的字型。|  
|[CWnd::SetForegroundWindow](#setforegroundwindow)|將建立視窗的執行緒放置到前景並啟動視窗。|  
|[CWnd::SetIcon](#seticon)|將控制代碼設為特定的圖示。|  
|[CWnd::SetLayeredWindowAttributes](#setlayeredwindowattributes)|設定分層視窗的不透明和透明色鍵。|  
|[CWnd::SetMenu](#setmenu)|將功能表設定為指定的功能表。|  
|[CWnd::SetOwner](#setowner)|變更 `CWnd` 的擁有者。|  
|[CWnd::SetParent](#setparent)|變更父視窗。|  
|[CWnd::SetProperty](#setproperty)|設定 ActiveX 控制項屬性。|  
|[CWnd::SetRedraw](#setredraw)|允許重新繪製 `CWnd` 中的變更，或防止重新繪製進行變更。|  
|[CWnd::SetScrollInfo](#setscrollinfo)|設定捲軸的相關資訊。|  
|[CWnd::SetScrollPos](#setscrollpos)|設定捲動方塊的目前位置，而且如果指定，會重新繪製捲軸以反映新位置。|  
|[CWnd::SetScrollRange](#setscrollrange)|設定給定捲軸的最小和最大位置值。|  
|[CWnd::SetTimer](#settimer)|安裝會傳送系統計時器[WM_TIMER](#ontimer)訊息時觸發。|  
|[CWnd::SetWindowContextHelpId](#setwindowcontexthelpid)|設定說明內容識別碼。|  
|[CWnd::SetWindowPlacement](#setwindowplacement)|設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|  
|[CWnd::SetWindowPos](#setwindowpos)|變更大小、位置和子系順序、快顯視窗，和最上層視窗。|  
|[CWnd::SetWindowRgn](#setwindowrgn)|設定視窗的區域。|  
|[CWnd::SetWindowText](#setwindowtext)|將視窗文字或標題 (如果有的話) 設為指定的文字。|  
|[CWnd::ShowCaret](#showcaret)|在畫面上插入號的目前位置上顯示插入號。 顯示後，插入號會開始自動閃爍。|  
|[CWnd::ShowOwnedPopups](#showownedpopups)|顯示或隱藏視窗擁有的所有快顯視窗。|  
|[CWnd::ShowScrollBar](#showscrollbar)|顯示或隱藏捲軸。|  
|[CWnd::ShowWindow](#showwindow)|顯示或隱藏視窗。|  
|[CWnd::SubclassDlgItem](#subclassdlgitem)|將 Windows 控制項附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|  
|[CWnd::SubclassWindow](#subclasswindow)|將視窗附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|  
|[CWnd::UnlockWindowUpdate](#unlockwindowupdate)|解除鎖定已使用 `CWnd::LockWindowUpdate` 鎖定的視窗。|  
|[CWnd::UnsubclassWindow](#unsubclasswindow)|卸離視窗從`CWnd`物件|  
|[CWnd::UpdateData](#updatedata)|從對話方塊中初始化或擷取資料。|  
|[CWnd::UpdateDialogControls](#updatedialogcontrols)|呼叫以更新對話方塊按鈕和其他控制項的狀態。|  
|[CWnd::UpdateLayeredWindow](#updatelayeredwindow)|更新分層視窗的位置、大小、形狀、內容和透明度。|  
|[CWnd::UpdateWindow](#updatewindow)|更新工作區。|  
|[CWnd::ValidateRect](#validaterect)|從目前的更新區域中移除矩形，驗證給定矩形內的工作區。|  
|[CWnd::ValidateRgn](#validatergn)|從目前的更新區域中移除區域，驗證給定區域內的工作區。|  
|[CWnd::WindowFromPoint](#windowfrompoint)|識別包含指定點的視窗。|  
|[CWnd::WinHelp](#winhelp)|呼叫以初始化 WinHelp 應用程式。|  
  
### <a name="protected-methods"></a>受保護的方法  
  
|名稱|說明|  
|----------|-----------------|  
|[CWnd::Default](#default)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|  
|[CWnd::DefWindowProc](#defwindowproc)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|  
|[CWnd::DoDataExchange](#dodataexchange)|適用於對話方塊資料交換和驗證。 由 `UpdateData` 呼叫。|  
|[CWnd::GetCurrentMessage](#getcurrentmessage)|傳回此視窗目前正在處理的訊息指標。 只能呼叫時`On`*訊息*訊息處理常式成員函式。|  
|[CWnd::InitDynamicLayout](#initdynamiclayout)|由架構呼叫以初始化視窗的動態配置。|  
|[CWnd::LoadDynamicLayoutResource](#loaddynamiclayoutresource)|從資源檔載入動態配置資訊。|  
|[CWnd::OnActivate](#onactivate)|當 `CWnd` 啟動或停用時呼叫。|  
|[CWnd::OnActivateApp](#onactivateapp)|當應用程式即將啟動或停用時呼叫。|  
|[CWnd::OnAppCommand](#onappcommand)|當使用者產生應用程式命令事件時呼叫。|  
|[CWnd::OnAskCbFormatName](#onaskcbformatname)|當剪貼簿擁有者將顯示剪貼簿內容時，由剪貼簿檢視器應用程式呼叫。|  
|[CWnd::OnCancelMode](#oncancelmode)|呼叫以讓 `CWnd` 取消任何內部的模式，例如滑鼠捕捉。|  
|[CWnd::OnCaptureChanged](#oncapturechanged)|將訊息傳送至正失去滑鼠捕捉的視窗。|  
|[CWnd::OnChangeCbChain](#onchangecbchain)|通知正在從鏈結中移除指定的視窗。|  
|[CWnd::OnChangeUIState](#onchangeuistate)|應變更使用者介面 (UI) 狀態時呼叫。|  
|[CWnd::OnChar](#onchar)|按鍵轉譯為非系統字元時呼叫。|  
|[CWnd::OnCharToItem](#onchartoitem)|由具有的子清單方塊呼叫[LBS_WANTKEYBOARDINPUT](list-box-styles.md)回應樣式[WM_CHAR](#onchar)訊息。|  
|[CWnd::OnChildActivate](#onchildactivate)|每當 `CWnd` 的大小或位置變更，或 `CWnd` 已啟動時，針對多重文件介面 (MDI) 子視窗呼叫。|  
|[On_xxx_reflect](#onchildnotify)|由父視窗呼叫，讓通知控制項有機會回應控制項通知。|  
|[CWnd::OnClipboardUpdate](#onclipboardupdate)|於剪貼簿內容已變更時呼叫。|  
|[CWnd::OnClose](#onclose)|呼叫以表示 `CWnd` 應該關閉。|  
|[CWnd::OnColorizationColorChanged](#oncolorizationcolorchanged)|當非工作區的轉譯原則已變更時呼叫。|  
|[CWnd::OnCommand](#oncommand)|當使用者選取命令時呼叫。|  
|[CWnd::OnCompacting](#oncompacting)|當 Windows 偵測到系統記憶體過低時呼叫。|  
|[CWnd::OnCompareItem](#oncompareitem)|呼叫以判斷子排序之主控描繪的下拉式方塊或清單方塊中新項目的相對位置。|  
|[CWnd::OnCompositionChanged](#oncompositionchanged)|當桌面視窗管理員 (DWM) 組合啟用或停用時，為所有最上層視窗呼叫。|  
|[CWnd::OnContextMenu](#oncontextmenu)|當使用者在視窗中按一下滑鼠右鍵時呼叫。|  
|[CWnd::OnCopyData](#oncopydata)|在應用程式之間複製資料。|  
|[CWnd::OnCreate](#oncreate)|在視窗建立過程中呼叫。|  
|[CWnd::OnCtlColor](#onctlcolor)|即將繪製控制項時，如果`CWnd` 是控制項的父代則呼叫。|  
|[CWnd::OnDeadChar](#ondeadchar)|當按鍵轉譯為非系統無效字元 (例如強調符號) 時呼叫。|  
|[CWnd::OnDeleteItem](#ondeleteitem)|當主控描繪子清單方塊或下拉式方塊損毀，或從控制項移除項目時呼叫。|  
|[CWnd::OnDestroy](#ondestroy)|`CWnd` 正在損毀時呼叫。|  
|[CWnd::OnDestroyClipboard](#ondestroyclipboard)|當透過呼叫 Windows 清空剪貼簿時，呼叫[EmptyClipboard](http://msdn.microsoft.com/library/windows/desktop/ms649037)函式。|  
|[CWnd::OnDeviceChange](#ondevicechange)|將裝置或電腦的硬體組態變更通知應用程式或裝置驅動程式。|  
|[CWnd::OnDevModeChange](#ondevmodechange)|當使用者變更裝置模式設定時，針對所有最上層視窗呼叫。|  
|[CWnd::OnDrawClipboard](#ondrawclipboard)|於剪貼簿內容變更時呼叫。|  
|[CWnd::OnDrawItem](#ondrawitem)|主控描繪子按鈕控制項、下拉式方塊控制項、清單方塊控制項或功能表的視覺外觀必須繪製時呼叫。|  
|[CWnd::OnDropFiles](#ondropfiles)|當使用者在視窗 (已本身註冊為捨棄檔案的收件者) 上放開滑鼠按鈕時呼叫。|  
|[CWnd::OnEnable](#onenable)|啟用或停用 `CWnd` 時呼叫。|  
|[CWnd::OnEndSession](#onendsession)|當工作階段正在結束時呼叫。|  
|[CWnd::OnEnterIdle](#onenteridle)|呼叫此函式，可將強制回應對話方塊或功能表正在進入閒置狀態的訊息，通知應用程式的主視窗程序。|  
|[CWnd::OnEnterMenuLoop](#onentermenuloop)|已進入功能表強制回應迴圈時呼叫。|  
|[CWnd::OnEnterSizeMove](#onentersizemove)|在受影響的視窗進入移動或調整大小的強制回應迴圈後呼叫。|  
|[CWnd::OnEraseBkgnd](#onerasebkgnd)|視窗背景需要清除時呼叫。|  
|[CWnd::OnExitMenuLoop](#onexitmenuloop)|已結束功能表強制回應迴圈時呼叫。|  
|[CWnd::OnExitSizeMove](#onexitsizemove)|在受影響的視窗結束移動或調整大小的強制回應迴圈後呼叫。|  
|[CWnd::OnFontChange](#onfontchange)|字型資源的集區變更時呼叫。|  
|[CWnd::OnGetDlgCode](#ongetdlgcode)|呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。|  
|[CWnd::OnGetMinMaxInfo](#ongetminmaxinfo)|每當 Windows 必須知道最大化的位置或維度，或最小或最大的追蹤大小時呼叫。|  
|[CWnd::OnHelpInfo](#onhelpinfo)|當使用者按下 F1 鍵時，由架構呼叫。|  
|[CWnd::OnHotKey](#onhotkey)|當使用者按下全系統的便捷鍵時呼叫。|  
|[CWnd::OnHScroll](#onhscroll)|當使用者按一下 `CWnd` 的水平捲軸時呼叫。|  
|[CWnd::OnHScrollClipboard](#onhscrollclipboard)|當剪貼簿擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|  
|[CWnd::OnIconEraseBkgnd](#oniconerasebkgnd)|當 `CWnd` 減到最小 (圖示)，且必須先填入圖示的背景再繪製圖示時呼叫。|  
|[CWnd::OnInitMenu](#oninitmenu)|當功能表即將變成現用時呼叫。|  
|[CWnd::OnInitMenuPopup](#oninitmenupopup)|當快顯功能表即將變成現用時呼叫。|  
|[CWnd::OnInputDeviceChange](#oninputdevicechange)|從系統中新增或移除 I/O 裝置時呼叫。|  
|[CWnd::OnInputLangChange](#oninputlangchange)|在應用程式的輸入語言變更後呼叫。|  
|[CWnd::OnInputLangChangeRequest](#oninputlangchangerequest)|當使用者選擇新的輸入語言時呼叫。|  
|[CWnd::OnKeyDown](#onkeydown)|按下非系統鍵時呼叫。|  
|[CWnd::OnKeyUp](#onkeyup)|放開非系統鍵時呼叫。|  
|[CWnd::OnKillFocus](#onkillfocus)|在 `CWnd` 遺失輸入焦點前立即呼叫。|  
|[CWnd::OnLButtonDblClk](#onlbuttondblclk)|當使用者按兩下滑鼠左鍵時呼叫。|  
|[CWnd::OnLButtonDown](#onlbuttondown)|當使用者按下滑鼠左鍵時呼叫。|  
|[CWnd::OnLButtonUp](#onlbuttonup)|當使用者放開滑鼠左鍵時呼叫。|  
|[CWnd::OnMButtonDblClk](#onmbuttondblclk)|當使用者按兩下滑鼠中鍵時呼叫。|  
|[CWnd::OnMButtonDown](#onmbuttondown)|當使用者按下滑鼠中鍵時呼叫。|  
|[CWnd::OnMButtonUp](#onmbuttonup)|當使用者放開滑鼠中鍵時呼叫。|  
|[CWnd::OnMDIActivate](#onmdiactivate)|當 MDI 子視窗啟用或停用時呼叫。|  
|[CWnd::OnMeasureItem](#onmeasureitem)|建立控制項時，針對主控描繪子下拉式方塊、清單方塊或功能表項目呼叫。 `CWnd` 會將控制項維度通知 Windows。|  
|[CWnd::OnMenuChar](#onmenuchar)|當使用者按下功能表的助憶鍵字元，且該字元不符合目前功能表中任何預先定義的助憶鍵時呼叫。|  
|[CWnd::OnMenuDrag](#onmenudrag)|當使用者開始拖曳功能表項目時呼叫。|  
|[CWnd::OnMenuGetObject](#onmenugetobject)|當滑鼠游標進入功能表項目，或從項目中央移到項目上方或下方時呼叫。|  
|[CWnd::OnMenuRButtonUp](#onmenurbuttonup)|當游標位於功能表項目上，而使用者放開滑鼠右鍵時呼叫。|  
|[CWnd::OnMenuSelect](#onmenuselect)|當使用者選取功能表項目時呼叫。|  
|[CWnd::OnMouseActivate](#onmouseactivate)|當游標處於非使用中視窗，且使用者按下滑鼠按鈕時呼叫。|  
|[CWnd::OnMouseHover](#onmousehover)|當游標停留在先前呼叫中指定的時間週期 視窗的工作區時呼叫[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。|  
|[CWnd::OnMouseHWheel](#onmousehwheel)|當目前的視窗由桌面視窗管理員 (DWM) 組成，且該視窗最大化時呼叫。|  
|[CWnd::OnMouseLeave](#onmouseleave)|當游標離開之前的呼叫中所指定視窗工作區時呼叫[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。|  
|[CWnd::OnMouseMove](#onmousemove)|當滑鼠游標移動時呼叫。|  
|[CWnd::OnMouseWheel](#onmousewheel)|當使用者旋轉滑鼠滾輪時呼叫。 使用 Windows NT 4.0 訊息處理。|  
|[CWnd::OnMove](#onmove)|在 `CWnd` 的位置變更後呼叫。|  
|[CWnd::OnMoving](#onmoving)|指出使用者正在移動 `CWnd` 物件。|  
|[CWnd::OnNcActivate](#onncactivate)|當非工作區需要變更以表示作用中或非作用中狀態時呼叫。|  
|[CWnd::OnNcCalcSize](#onnccalcsize)|需要計算工作區的大小和位置時呼叫。|  
|[CWnd::OnNcCreate](#onnccreate)|之前呼叫[OnCreate](#oncreate)建立非工作區時。|  
|[Cwnd::](#onncdestroy)|當非工作區正在損毀時呼叫。|  
|[CWnd::OnNcHitTest](#onnchittest)|每次移動滑鼠時，如果 `CWnd` 包含游標，或已使用 `SetCapture` 擷取滑鼠輸入時呼叫。|  
|[CWnd::OnNcLButtonDblClk](#onnclbuttondblclk)|當使用者按兩下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcLButtonDown](#onnclbuttondown)|當使用者按下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcLButtonUp](#onnclbuttonup)|當使用者放開滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcMButtonDblClk](#onncmbuttondblclk)|當使用者按兩下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcMButtonDown](#onncmbuttondown)|當使用者按下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcMButtonUp](#onncmbuttonup)|當使用者放開滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcMouseHover](#onncmousehover)|當游標停留在先前呼叫中指定的時間週期 視窗的非工作區時呼叫[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。|  
|[CWnd::OnNcMouseLeave](#onncmouseleave)|當游標離開之前的呼叫中所指定視窗的非工作區時，架構會呼叫此成員函式[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。|  
|[CWnd::OnNcMouseMove](#onncmousemove)|當游標在 `CWnd` 的非工作區內移動時呼叫。|  
|[CWnd::OnNcPaint](#onncpaint)|當非工作區需要繪製時呼叫。|  
|[CWnd::OnNcRButtonDblClk](#onncrbuttondblclk)|當使用者按兩下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcRButtonDown](#onncrbuttondown)|當使用者按下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcRButtonUp](#onncrbuttonup)|當使用者放開滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|  
|[CWnd::OnNcRenderingChanged](#onncrenderingchanged)|當非工作區的轉譯原則已變更時呼叫。|  
|[CWnd::OnNcXButtonDblClk](#onncxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|  
|[CWnd::OnNcXButtonDown](#onncxbuttondown)|當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|  
|[CWnd::OnNcXButtonUp](#onncxbuttonup)|當使用者放開滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|  
|[CWnd::OnNextMenu](#onnextmenu)|當使用向右鍵或向左鍵切換功能表列和系統功能表時呼叫。|  
|[Cwnd:: Onnotify](#onnotify)|由架構呼叫，將其中一個控制項已發生的事件，或控制項需要資訊等狀況通知父視窗。|  
|[CWnd::OnNotifyFormat](#onnotifyformat)|呼叫以決定目前視窗的 WM_NOTIFY 通知訊息中是否接受 ANSI 或 Unicode 結構。|  
|[CWnd::OnPaint](#onpaint)|呼叫以重新繪製視窗的一部份。|  
|[CWnd::OnPaintClipboard](#onpaintclipboard)|當需要重新繪製剪貼簿檢視器的工作區時呼叫。|  
|[CWnd::OnPaletteChanged](#onpalettechanged)|呼叫以允許使用調色盤的視窗調整其邏輯色板的大小，並更新其工作區。|  
|[CWnd::OnPaletteIsChanging](#onpaletteischanging)|當應用程式即將實現其邏輯色板時通知其他應用程式。|  
|[CWnd::OnParentNotify](#onparentnotify)|建立或終結子視窗時，或當使用者按一下滑鼠按鈕，而游標移至子視窗上方時，進行呼叫。|  
|[CWnd::OnPowerBroadcast](#onpowerbroadcast)|電源管理事件發生時呼叫。|  
|[CWnd::OnQueryDragIcon](#onquerydragicon)|最小化 (圖示化) `CWnd` 即將由使用者拖曳時呼叫。|  
|[CWnd::OnQueryEndSession](#onqueryendsession)|當使用者選擇結束 Windows 工作階段時呼叫。|  
|[CWnd::OnQueryNewPalette](#onquerynewpalette)|通知 `CWnd` 即將接收輸入焦點。|  
|[CWnd::OnQueryOpen](#onqueryopen)|當 `CWnd` 是圖示，且使用者要求開啟圖示時呼叫。|  
|[CWnd::OnQueryUIState](#onqueryuistate)|呼叫以擷取視窗的使用者介面 (UI) 狀態。|  
|[CWnd::OnRawInput](#onrawinput)|當目前視窗取得原始輸入時呼叫。|  
|[CWnd::OnRButtonDblClk](#onrbuttondblclk)|當使用者按兩下滑鼠右鍵時呼叫。|  
|[CWnd::OnRButtonDown](#onrbuttondown)|當使用者按下滑鼠右鍵時呼叫。|  
|[CWnd::OnRButtonUp](#onrbuttonup)|當使用者放開滑鼠右鍵時呼叫。|  
|[CWnd::OnRenderAllFormats](#onrenderallformats)|當擁有者應用程式正在被破壞，而且需要呈現其所有格式時呼叫。|  
|[CWnd::OnRenderFormat](#onrenderformat)|需要呈現具有延遲轉譯需求的特定格式時，針對剪貼簿擁有者呼叫。|  
|[CWnd::OnSessionChange](#onsessionchange)|呼叫以將工作階段狀態的變更通知應用程式。|  
|[CWnd::OnSetCursor](#onsetcursor)|如果不擷取滑鼠輸入，而且滑鼠導致游標在視窗內移動，則呼叫。|  
|[CWnd::OnSetFocus](#onsetfocus)|在 `CWnd` 取得輸入焦點後呼叫。|  
|[CWnd::OnSettingChange](#onsettingchange)|當 Win32 `SystemParametersInfo` 函式變更整個系統的設定時呼叫。|  
|[CWnd::OnShowWindow](#onshowwindow)|當 `CWnd` 要隱藏或顯示時呼叫。|  
|[CWnd::OnSize](#onsize)|在 `CWnd` 大小變更後呼叫。|  
|[CWnd::OnSizeClipboard](#onsizeclipboard)|當剪貼簿檢視器視窗中的工作區大小變更後呼叫。|  
|[CWnd::OnSizing](#onsizing)|表示使用者正在重新調整矩形的大小。|  
|[CWnd::OnSpoolerStatus](#onspoolerstatus)|每當加入工作或從列印管理員佇列中移除工作時，從列印管理員呼叫。|  
|[CWnd::OnStyleChanged](#onstylechanged)|表示[SetWindowLong](http://msdn.microsoft.com/library/windows/desktop/ms633591) Windows 函式已經變更一個或多個視窗的樣式。|  
|[CWnd::OnStyleChanging](#onstylechanging)|表示[SetWindowLong](http://msdn.microsoft.com/library/windows/desktop/ms633591) Windows 函式即將變更一或多個視窗的樣式。|  
|[CWnd::OnSysChar](#onsyschar)|按鍵轉譯為系統字元時呼叫。|  
|[CWnd::OnSysColorChange](#onsyscolorchange)|當系統色彩設定中進行變更時，為所有最上層視窗呼叫。|  
|[CWnd::OnSysCommand](#onsyscommand)|當使用者從 [控制] 功能表中選取命令時，或在使用者選取 [最大化] 或 [最小化] 按鈕時呼叫。|  
|[CWnd::OnSysDeadChar](#onsysdeadchar)|當按鍵轉譯為系統無效字元 (例如強調符號) 時呼叫。|  
|[CWnd::OnSysKeyDown](#onsyskeydown)|當使用者按住 ALT 鍵，然後按下另一個按鍵時呼叫。|  
|[CWnd::OnSysKeyUp](#onsyskeyup)|當使用者在按住 ALT 鍵時放開按下的按鍵時呼叫。|  
|[CWnd::OnTCard](#ontcard)|使用者按一下可設計的按鈕時呼叫。|  
|[CWnd::OnTimeChange](#ontimechange)|在系統時間變更後，針對所有最上層視窗呼叫。|  
|[CWnd::OnTimer](#ontimer)|指定在每個間隔之後呼叫[SetTimer](#settimer)。|  
|[CWnd::OnTouchInput](#ontouchinput)|處理來自 Windows 觸控的單一輸入。|  
|[CWnd::OnTouchInputs](#ontouchinputs)|處理來自 Windows 觸控的輸入。|  
|[CWnd::OnUniChar](#onunichar)|按下按鍵時呼叫。 也就是說，目前的視窗擁有鍵盤焦點和[WM_KEYDOWN](http://msdn.microsoft.com/library/windows/desktop/ms646280)訊息轉譯由[TranslateMessage](http://msdn.microsoft.com/library/windows/desktop/ms644955)函式。|  
|[CWnd::OnUnInitMenuPopup](#onuninitmenupopup)|於下拉式功能表或子功能表被終結時呼叫。|  
|[CWnd::OnUpdateUIState](#onupdateuistate)|呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。|  
|[CWnd::OnUserChanged](#onuserchanged)|在使用者登入或登出後呼叫。|  
|[CWnd::OnVKeyToItem](#onvkeytoitem)|由所擁有的清單方塊呼叫`CWnd`回應[WM_KEYDOWN](#onkeydown)訊息。|  
|[CWnd::OnVScroll](#onvscroll)|當使用者按一下視窗的垂直捲軸時呼叫。|  
|[CWnd::OnVScrollClipboard](#onvscrollclipboard)|當擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|  
|[CWnd::OnWindowPosChanged](#onwindowposchanged)|當呼叫的結果改變了大小、 位置或疊置順序呼叫[SetWindowPos](#setwindowpos)或另一個視窗管理函式。|  
|[CWnd::OnWindowPosChanging](#onwindowposchanging)|當大小、 位置或疊置順序即將因呼叫而變更時呼叫[SetWindowPos](#setwindowpos)或另一個視窗管理函式。|  
|[CWnd::OnWinIniChange](#onwininichange)|在 Windows 初始化檔案 (WIN.INI) 變更後，針所有最上層視窗呼叫。|  
|[CWnd::OnWndMsg](#onwndmsg)|指出是否已處理視窗訊息。|  
|[CWnd::OnXButtonDblClk](#onxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|  
|[CWnd::OnXButtonDown](#onxbuttondown)|當使用者按下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|  
|[CWnd::OnXButtonUp](#onxbuttonup)|當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|  
|[CWnd::PostNcDestroy](#postncdestroy)|此虛擬函式會呼叫預設[OnNcDestroy](#onncdestroy)函式終結視窗後。|  
|[CWnd::ReflectChildNotify](#reflectchildnotify)|將訊息反映至其來源的 Helper 函式。|  
|[CWnd::ReflectLastMsg](#reflectlastmsg)|將最後一個訊息反映到子視窗。|  
|[CWnd::ResizeDynamicLayout](#resizedynamiclayout)|如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。|  
|[CWnd::WindowProc](#windowproc)|提供 `CWnd` 的視窗程序。 透過訊息對應的預設分派訊息。|  
  
### <a name="public-operators"></a>公用運算子  
  
|名稱|說明|  
|----------|-----------------|  
|[HWND cwnd:: Operator](#operator_hwnd)|呼叫以取得視窗的控制代碼。|  
|[Cwnd:: Operator ！ =](#operator_neq)|判斷視窗是否不是控制代碼的視窗相同[m_hWnd](#m_hwnd)。|  
|[Cwnd:: Operator = =](#operator_eq_eq)|判斷視窗是否與視窗控制代碼是相同[m_hWnd](#m_hwnd)。|  
  
### <a name="public-data-members"></a>公用資料成員  
  
|名稱|描述|  
|----------|-----------------|  
|[CWnd::m_hWnd](#m_hwnd)|指出 `HWND` 附加至此 `CWnd`。|  
  
## <a name="remarks"></a>備註  
 `CWnd` 物件不同於 Windows 視窗，但兩者緊密連結。 `CWnd` 物件是由 `CWnd` 建構函式和解構函式所建立或終結。 Windows 視窗中，相反地，為 Windows 建立的內部資料結構**建立**成員函式和終結`CWnd`虛擬解構函式。 [DestroyWindow](#destroywindow)函式會終結 Windows 視窗而不會終結物件。  
  
 `CWnd`類別和訊息對應機制會隱藏**WndProc**函式。 透過訊息對應到適當自動路由連入 Windows 通知訊息**上***訊息*`CWnd`成員函式。 您覆寫**上***訊息*成員函式，以處理您的衍生類別中成員的特定訊息。  
  
 `CWnd` 類別也可讓您建立應用程式的 Windows 子視窗。 自 `CWnd` 衍生類別，然後將成員變數加入至衍生類別以儲存應用程式的特定資料。 實作訊息處理常式成員函式，和衍生類別中對應的訊息，以指定訊息被導向至視窗時會發生什麼事。  
  
 您在兩個步驟中建立子視窗。 首先，呼叫建構函式`CWnd`建構`CWnd`物件，然後呼叫[建立](#create)成員函式來建立子視窗，並將其附加至`CWnd`物件。  
  
 當使用者終止子視窗時，摧毀 `CWnd` 物件，或呼叫 `DestroyWindow` 成員函式來移除視窗並摧毀其資料結構。  
  
 在 Microsoft Foundation 類別庫中，會自 `CWnd` 衍生進一步類別以提供特定的視窗類型。 其中許多類別，包括[CFrameWnd](../../mfc/reference/cframewnd-class.md)， [CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)， [CMDIChildWnd](../../mfc/reference/cmdichildwnd-class.md)， [CView](../../mfc/reference/cview-class.md)，和[CDialog](../../mfc/reference/cdialog-class.md)，專為進一步衍生。 控制項類別衍生自`CWnd`，例如[CButton](../../mfc/reference/cbutton-class.md)，可以直接使用，或可用於進一步衍生的類別。  
  
 如需有關使用`CWnd`，請參閱[框架視窗](../../mfc/frame-windows.md)和[視窗物件](../../mfc/window-objects.md)。  
  
## <a name="inheritance-hierarchy"></a>繼承階層  
 [CObject](../../mfc/reference/cobject-class.md)  
  
 [CCmdTarget](../../mfc/reference/ccmdtarget-class.md)  
  
 `CWnd`  
  
## <a name="requirements"></a>需求  
 **標題:** afxwin.h  
  
##  <a name="accdodefaultaction"></a>CWnd::accDoDefaultAction  
 由架構呼叫以執行物件的預設動作。  
  
```  
virtual HRESULT accDoDefaultAction(VARIANT varChild);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要叫用的預設動作是物件或物件的子元素的其中一個。 這個參數可以是 CHILDID_SELF （於執行物件的預設動作） 或 （若要執行預設動作的其中一個物件的子元素） 的子識別碼。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::accDoDefaultAction](http://msdn.microsoft.com/library/windows/desktop/dd318470)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生的類別，以執行物件的預設動作。 如需詳細資訊，請參閱[IAccessible::accDoDefaultAction](http://msdn.microsoft.com/library/windows/desktop/dd318470)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="acchittest"></a>CWnd::accHitTest  
 由架構呼叫以擷取畫面中給定點的子項目或子物件。  
  
```  
virtual HRESULT accHitTest(
    long xLeft,  
    long yTop,  
    VARIANT* pvarChild);
```  
  
### <a name="parameters"></a>參數  
 `xLeft`  
 X 座標的點叫用測試 （以螢幕為單位）。  
  
 `yTop`  
 Y 座標的點叫用測試 （以螢幕為單位）。  
  
 `pvarChild`  
 接收資訊識別的物件所指定的點`xLeft`和`yTop`。 請參閱*pvarID*中[IAccessible::accHitTest](http://msdn.microsoft.com/library/windows/desktop/dd318471)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::accHitTest**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::accHitTest](http://msdn.microsoft.com/library/windows/desktop/dd318471)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="acclocation"></a>CWnd::accLocation  
 由架構呼叫以擷取指定物件目前畫面的位置。  
  
```  
virtual HRESULT accLocation(
    long* pxLeft,  
    long* pyTop,  
    long* pcxWidth,  
    long* pcyHeight,  
    VARIANT varChild);
```  
  
### <a name="parameters"></a>參數  
 *pxLeft*  
 收到的物件 （以螢幕為單位） 的左上角的 x 座標。  
  
 *pyTop*  
 收到的物件 （以螢幕為單位） 的左上角的 y 座標。  
  
 *pcxWidth*  
 接收寬度 （以螢幕為單位） 的物件。  
  
 *pcyHeight*  
 接收高度 （單位螢幕） 的物件。  
  
 `varChild`  
 指定是否要擷取的位置是物件或物件的子元素的其中一個。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::accLocation**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱**IAccessible::accLocation**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="accnavigate"></a>CWnd::accNavigate  
 由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。  
  
```  
virtual HRESULT accNavigate(
    long navDir,  
    VARIANT varStart,  
    VARIANT* pvarEndUpAt);
```  
  
### <a name="parameters"></a>參數  
 `navDir`  
 指定要巡覽的方向。 請參閱`navDir`中[IAccessible::accNavigate](http://msdn.microsoft.com/library/windows/desktop/dd318473)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `varStart`  
 指定起始的物件。 請參閱`varStart`中**IAccessible::accNavigate**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 *pvarEndUpAt*  
 接收目的使用者介面物件的相關資訊。 請參閱*pvarEnd*中**IAccessible::accNavigate**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::accNavigate**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::accNavigate](http://msdn.microsoft.com/library/windows/desktop/dd318473)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="accselect"></a>CWnd::accSelect  
 由架構呼叫以修改選取或移動指定物件的鍵盤焦點。  
  
```  
virtual HRESULT accSelect(
    long flagsSelect,  
    VARIANT varChild);
```  
  
### <a name="parameters"></a>參數  
 `flagsSelect`  
 指定如何變更目前的選取範圍或焦點。 請參閱`flagsSelect`中[IAccessible::accSelect](http://msdn.microsoft.com/library/windows/desktop/dd318474)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `varChild`  
 指定要選取的物件。 這個參數可以是 CHILDID_SELF （若要選取的物件本身） 或 （若要選取一個物件的子系） 子識別碼。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::accSelect**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::accSelect](http://msdn.microsoft.com/library/windows/desktop/dd318474)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="animatewindow"></a>CWnd::AnimateWindow  
 會產生特殊效果顯示或隱藏視窗時。  
  
```  
BOOL AnimateWindow(
    DWORD dwTime,  
    DWORD dwFlags);
```  
  
### <a name="parameters"></a>參數  
 *dwTime*  
 指定播放動畫，以毫秒為單位所需的時間長度。 一般而言，動畫會來播放 200 毫秒。  
  
 `dwFlags`  
 指定類型的動畫。 如需可能值的完整清單，請參閱[AnimateWindow](http://msdn.microsoft.com/library/windows/desktop/ms632669)。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[AnimateWindow](http://msdn.microsoft.com/library/windows/desktop/ms632669)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="arrangeiconicwindows"></a>CWnd::ArrangeIconicWindows  
 排列所有最小化 (圖示) 子視窗。  
  
```  
UINT ArrangeIconicWindows();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功; 圖示的一個資料列的高度否則便是 0。  
  
### <a name="remarks"></a>備註  
 此成員函式也會排列在桌面視窗中，其中涵蓋了整個畫面的圖示。 [GetDesktopWindow](#getdesktopwindow)成員函式會擷取桌面視窗物件的指標。  
  
 若要排列 MDI 用戶端視窗中的圖示 MDI 子視窗，呼叫[CMDIFrameWnd::MDIIconArrange](../../mfc/reference/cmdiframewnd-class.md#mdiiconarrange)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 66](../../mfc/reference/codesnippet/cpp/cwnd-class_1.cpp)]  
  
##  <a name="attach"></a>CWnd::Attach  
 將附加到 Windows 視窗`CWnd`物件。  
  
```  
BOOL Attach(HWND hWndNew);
```  
  
### <a name="parameters"></a>參數  
 `hWndNew`  
 指定 Windows 視窗的控制代碼。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="example"></a>範例  
 這個範例示範如何使用對應至 MDI 用戶端視窗的附加和卸離。  
  
 [!code-cpp[NVC_MFCWindowing # 67](../../mfc/reference/codesnippet/cpp/cwnd-class_2.h)]  
  
 [!code-cpp[NVC_MFCWindowing # 68](../../mfc/reference/codesnippet/cpp/cwnd-class_3.cpp)]  
  
 [!code-cpp[NVC_MFCWindowing # 69](../../mfc/reference/codesnippet/cpp/cwnd-class_4.cpp)]  
  
##  <a name="beginmodalstate"></a>CWnd::BeginModalState  
 呼叫此成員函式以製作框架視窗強制回應。  
  
```  
virtual void BeginModalState();
```  
  
##  <a name="beginpaint"></a>Cwnd:: Beginpaint  
 準備`CWnd`繪製和填滿`PAINTSTRUCT`繪製的相關資訊的資料結構。  
  
```  
CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
```  
  
### <a name="parameters"></a>參數  
 `lpPaint`  
 指向[PAINTSTRUCT](../../mfc/reference/paintstruct-structure.md)結構，這是接收繪製資訊。  
  
### <a name="return-value"></a>傳回值  
 識別的裝置內容`CWnd`。 指標可能是暫時性的不會儲存超出範圍的[EndPaint](#endpaint)。  
  
### <a name="remarks"></a>備註  
 小畫家結構包含已完全圍住更新區域和指定是否已清除的背景的旗標的最小矩形 RECT 資料結構。  
  
 更新區域由設定[失效](#invalidate)， [InvalidateRect](#invalidaterect)，或[InvalidateRgn](#invalidatergn)成員函式和系統之後其大小、 移動、 建立、 捲動，或執行會影響用戶端區域的其他任何作業。 如果更新區域標示為進行清除，`BeginPaint`傳送[WM_ONERASEBKGND](#onerasebkgnd)訊息。  
  
 請勿呼叫`BeginPaint`除了在回應中的成員函式[WM_PAINT](#onpaint)訊息。 每次呼叫`BeginPaint`成員函式必須有相符呼叫[EndPaint](#endpaint)成員函式。 如果插入號位於要繪製的區域`BeginPaint`成員函式自動隱藏插入號，以防止它被清除。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 70](../../mfc/reference/codesnippet/cpp/cwnd-class_5.cpp)]  
  
##  <a name="binddefaultproperty"></a>CWnd::BindDefaultProperty  
 將呼叫物件的預設簡單繫結的屬性 （例如編輯控制項），做為標記類型程式庫中的繫結至基礎資料來源控制項的資料來源、 使用者名稱、 密碼和 SQL 屬性所定義的資料指標。  
  
```  
void BindDefaultProperty(
    DISPID dwDispID,  
    VARTYPE vtProp,  
    LPCTSTR szFieldName,  
    CWnd* pDSCWnd);
```  
  
### <a name="parameters"></a>參數  
 `dwDispID`  
 指定要繫結至資料來源控制項的資料繫結控制項屬性的 DISPID。  
  
 `vtProp`  
 指定要繫結的屬性類型 — 例如， `VT_BSTR`， **VT_VARIANT**，依此類推。  
  
 `szFieldName`  
 指定資料來源控制項，屬性會繫結所提供的資料指標中的資料行的名稱。  
  
 `pDSCWnd`  
 指向視窗屬性會繫結該主機資料來源控制項。 呼叫`GetDlgItem`的網域控制站的主控視窗的資源識別碼，擷取這個指標。  
  
### <a name="remarks"></a>備註  
 `CWnd`呼叫此函式的物件必須是資料繫結控制項。  
  
### <a name="example"></a>範例  
 `BindDefaultProperty`可用於下列內容︰  
  
 [!code-cpp[NVC_MFC_AxDataBinding # 1](../../mfc/reference/codesnippet/cpp/cwnd-class_6.cpp)]  
[!code-cpp[NVC_MFC_AxDataBinding # 2](../../mfc/reference/codesnippet/cpp/cwnd-class_7.cpp)]  
[!code-cpp[NVC_MFC_AxDataBinding # 3](../../mfc/reference/codesnippet/cpp/cwnd-class_8.cpp)]  
  
##  <a name="bindproperty"></a>CWnd::BindProperty  
 將資料繫結控制項 （如方格控制項） 上的游標繫結屬性繫結至資料來源控制項，並註冊該關聯性與 MFC 繫結管理員。  
  
```  
void BindProperty(
    DISPID dwDispId,  
    CWnd* pWndDSC);
```  
  
### <a name="parameters"></a>參數  
 *dwDispId*  
 指定要繫結至資料來源控制項的資料繫結控制項屬性的 DISPID。  
  
 `pWndDSC`  
 指向視窗屬性會繫結該主機資料來源控制項。 呼叫`GetDlgItem`的網域控制站的主控視窗的資源識別碼，擷取這個指標。  
  
### <a name="remarks"></a>備註  
 `CWnd`呼叫此函式的物件必須是資料繫結控制項。  
  
### <a name="example"></a>範例  
 `BindProperty`可用於下列內容︰  
  
 [!code-cpp[NVC_MFC_AxDataBinding # 1](../../mfc/reference/codesnippet/cpp/cwnd-class_6.cpp)]  
[!code-cpp[NVC_MFC_AxDataBinding # 4](../../mfc/reference/codesnippet/cpp/cwnd-class_9.cpp)]  
[!code-cpp[NVC_MFC_AxDataBinding # 3](../../mfc/reference/codesnippet/cpp/cwnd-class_8.cpp)]  
  
##  <a name="bringwindowtotop"></a>CWnd::BringWindowToTop  
 將 `CWnd` 帶到重疊視窗堆疊的最上層。  
  
```  
void BringWindowToTop();
```  
  
### <a name="remarks"></a>備註  
 此外，`BringWindowToTop` 會啟用快顯、最上層和 MDI 子視窗。 需使用 `BringWindowToTop` 成員函式，才能顯示出重疊視窗部分或完全遮住的視窗。  
  
 此函式只會呼叫 Win32 [BringWindowToTop](http://msdn.microsoft.com/library/windows/desktop/ms632673\(v=vs.85\).aspx)函式。 呼叫[SetWindowPos](#setwindowpos)函式來變更圖層順序中的視窗的位置。 `BringWindowToTop` 函式不會將視窗樣式變更為最上層視窗。 如需詳細資訊，請參閱[What's difference between HWND_TOP 和 hwnd_topmost 有何不同](http://blogs.msdn.com/b/oldnewthing/archive/2005/11/21/495246.aspx)  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 71](../../mfc/reference/codesnippet/cpp/cwnd-class_10.cpp)]  
  
##  <a name="calcwindowrect"></a>CWnd::CalcWindowRect  
 計算視窗矩形可以包含指定的用戶端矩形。  
  
```  
virtual void CalcWindowRect(
    LPRECT lpClientRect,  
    UINT nAdjustType = adjustBorder);
```  
  
### <a name="parameters"></a>參數  
 [in、out] `lpClientRect`  
 矩形結構的指標。 輸入時，此結構包含用戶端矩形。 此方法完成之後，這個結構會包含可以包含指定的用戶端矩形視窗矩形。  
  
 [in] `nAdjustType`  
 使用`CWnd::adjustBorder`計算視窗座標不含`WS_EX_CLIENTEDGE`樣式; 否則，請使用`CWnd::adjustOutside`。  
  
### <a name="remarks"></a>備註  
 計算的視窗矩形的大小不包含功能表列的空間。  
  
 如需使用限制，請參閱[AdjustWindowRectEx](http://msdn.microsoft.com/library/windows/desktop/ms632667)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 72](../../mfc/reference/codesnippet/cpp/cwnd-class_11.cpp)]  
  
##  <a name="canceltooltips"></a>CWnd::CancelToolTips  
 呼叫此成員函式如果工具提示目前顯示從螢幕中移除的工具提示。  
  
```  
static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
```  
  
### <a name="parameters"></a>參數  
 *bKeys*  
 **TRUE**取消工具提示時按下金鑰和狀態列文字設定為預設值; 否則**FALSE**。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  使用此成員函式擁有不受您的程式碼的工具提示會影響。 它只會影響所管理之工具提示控制項[CWnd::EnableToolTips](#enabletooltips)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 73](../../mfc/reference/codesnippet/cpp/cwnd-class_12.cpp)]  
  
##  <a name="centerwindow"></a>CWnd::CenterWindow  
 將相對於其父系的視窗置中。  
  
```  
void CenterWindow(CWnd* pAlternateOwner = NULL);
```  
  
### <a name="parameters"></a>參數  
 `pAlternateOwner`  
 它將會相對於其他視窗的指標，置中 （而不是父視窗）。  
  
### <a name="remarks"></a>備註  
 通常從呼叫[CDialog::OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)中心對話方塊相對於主要視窗的應用程式。 根據預設，函式會將子視窗相對於其父視窗和相對於其擁有者的快顯視窗。 如果不擁有快顯視窗，它會置中與相對螢幕。 若要從左至中相對於特定的視窗不擁有者或父視窗`pAlternateOwner`參數可能會設定為有效的視窗。 若要強制將置中與相對螢幕，傳遞所傳回的值[CWnd::GetDesktopWindow](#getdesktopwindow)為`pAlternateOwner`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 74](../../mfc/reference/codesnippet/cpp/cwnd-class_13.cpp)]  
  
##  <a name="changeclipboardchain"></a>CWnd::ChangeClipboardChain  
 移除`CWnd`從所指定視窗的剪貼簿檢視器，讓鏈結`hWndNext`之下階的`CWnd`鏈結中的上階。  
  
```  
BOOL ChangeClipboardChain(HWND hWndNext);
```  
  
### <a name="parameters"></a>參數  
 `hWndNext`  
 識別遵循視窗`CWnd`剪貼簿檢視器鏈結中。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
##  <a name="checkdlgbutton"></a>CWnd::CheckDlgButton  
 （放置旁的核取記號） 選取或清除 （移除從的核取記號） 按鈕，或它的三種狀態按鈕狀態變更。  
  
```  
void CheckDlgButton(
    int nIDButton,  
    UINT nCheck);
```  
  
### <a name="parameters"></a>參數  
 `nIDButton`  
 指定要修改的按鈕。  
  
 `nCheck`  
 指定要採取的動作。 如果`nCheck`非零，`CheckDlgButton`成員函式會將按鈕旁邊的核取記號; 如果為 0，則會移除核取記號。 三種狀態的按鈕，如果`nCheck`為 2，按鈕狀態尚未確定。  
  
### <a name="remarks"></a>備註  
 `CheckDlgButton`函式傳送[BM_SETCHECK](http://msdn.microsoft.com/library/windows/desktop/bb775989)指定按鈕的訊息。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 75](../../mfc/reference/codesnippet/cpp/cwnd-class_14.cpp)]  
  
##  <a name="checkradiobutton"></a>CWnd::CheckRadioButton  
 選取 （加上核取記號，以） 指定的選項按鈕群組中，清除 （移除核取記號） 所有其他選項按鈕群組中的。  
  
```  
void CheckRadioButton(
    int nIDFirstButton,  
    int nIDLastButton,  
    int nIDCheckButton);
```  
  
### <a name="parameters"></a>參數  
 `nIDFirstButton`  
 指定群組中的第一個選項按鈕的整數識別碼。  
  
 `nIDLastButton`  
 指定群組中的最後一個選項按鈕的整數識別碼。  
  
 `nIDCheckButton`  
 指定要檢查的選項按鈕的整數識別碼。  
  
### <a name="remarks"></a>備註  
 `CheckRadioButton`函式傳送[BM_SETCHECK](http://msdn.microsoft.com/library/windows/desktop/bb775989)訊息至指定的選項按鈕。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 76](../../mfc/reference/codesnippet/cpp/cwnd-class_15.cpp)]  
  
##  <a name="childwindowfrompoint"></a>CWnd::ChildWindowFromPoint  
 決定哪一個，如果有的話，屬於的子視窗`CWnd`包含指定的點。  
  
```  
CWnd* ChildWindowFromPoint(POINT point) const;  
  
CWnd* ChildWindowFromPoint(
    POINT point,  
    UINT nFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 `point`  
 指定要測試之點的用戶端座標。  
  
 *nflags*  
 指定要略過的子視窗。 這個參數可以是下列值的組合︰  
  
|值|意義|  
|-----------|-------------|  
|**CWP_ALL**|請勿略過任何子視窗|  
|**CWP_SKIPINVISIBLE**|略過不可見的子視窗|  
|**CWP_SKIPDISABLED**|略過停用子視窗|  
|**CWP_SKIPTRANSPARENT**|略過的透明子視窗|  
  
### <a name="return-value"></a>傳回值  
 識別點所在的子視窗。 它是**NULL**若指定的點在用戶端區域之外。 如果用戶端區域內的點，它未包含任何子視窗，在`CWnd`傳回。  
  
 此成員函式會傳回包含指定的點的隱藏或停用子視窗。  
  
 多個視窗可能會包含指定的點。 不過，此函式只會傳回`CWnd`* 遇到含有點的第一個視窗。  
  
 `CWnd`* 傳回可能是暫時性的不會儲存供稍後使用。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 77](../../mfc/reference/codesnippet/cpp/cwnd-class_16.cpp)]  
  
##  <a name="clienttoscreen"></a>CWnd::ClientToScreen  
 將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。  
  
```  
void ClientToScreen(LPPOINT lpPoint) const;  void ClientToScreen(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoint`  
 指向[POINT 結構](../../mfc/reference/point-structure1.md)或`CPoint`来轉換的物件，包含用戶端座標。  
  
 `lpRect`  
 指向[RECT 結構](../../mfc/reference/rect-structure1.md)或`CRect`来轉換的物件，包含用戶端座標。  
  
### <a name="remarks"></a>備註  
 `ClientToScreen`成員函式的使用中的用戶端座標**點**或`RECT`結構或`CPoint`或`CRect`指向的物件`lpPoint`或`lpRect`來計算新的螢幕座標中，並以新的座標，然後取代結構中的座標。 新的螢幕座標是相對於系統顯示左上角。  
  
 `ClientToScreen`成員函式會假設指定的點或矩形是在用戶端座標。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 78](../../mfc/reference/codesnippet/cpp/cwnd-class_17.cpp)]  
  
##  <a name="closewindow"></a>CWnd::CloseWindow  
 將視窗最小化。  
  
```  
void CloseWindow();
```  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[CloseWindow](http://msdn.microsoft.com/library/windows/desktop/ms632678)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="continuemodal"></a>CWnd::ContinueModal  
 此成員函式會呼叫[runmodalloop 呼叫](#runmodalloop)判斷強制回應狀態應已結束。  
  
```  
virtual BOOL ContinueModal();
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果強制回應迴圈會繼續執行。0 [EndModalLoop](#endmodalloop)呼叫。  
  
### <a name="remarks"></a>備註  
 根據預設，它會傳回非零直到`EndModalLoop`呼叫。  
  
##  <a name="create"></a>Cwnd:: Create  
 建立指定的子視窗，並將它附加至[CWnd](../../mfc/reference/cwnd-class.md)物件。  
  
```  
virtual BOOL Create(
    LPCTSTR lpszClassName,  
    LPCTSTR lpszWindowName,  
    DWORD dwStyle,  
    Const RECT& rect,  
    CWnd* pParentWnd,  
    UINT nID,  
    CCreateContext* pContext = NULL);
```  
  
### <a name="parameters"></a>參數  
 [in] `lpszClassName`  
 以 null 終止的字串，其中包含系統註冊的視窗類別; 名稱的指標或預先定義的系統視窗類別名稱。  
  
 [in] `lpszWindowName`  
 以 null 終止的字串，包含視窗的指標會顯示名稱。否則`NULL`任何視窗的顯示名稱。  
  
 [in] `dwStyle`  
 位元組合 (OR)[視窗樣式](../../mfc/reference/window-styles.md)。 `WS_POPUP`選項不是有效的樣式。  
  
 [in] `rect`  
 大小和視窗相對於父視窗的左上角的位置。  
  
 [in] `pParentWnd`  
 父視窗的指標。  
  
 [in] `nID`  
 視窗的識別碼。  
  
 [in] `pContext`  
 指標[CCreateContext](../../mfc/reference/ccreatecontext-structure.md)用於自訂應用程式的文件檢視架構的結構。  
  
### <a name="return-value"></a>傳回值  
 `TRUE`如果該方法成功。否則`FALSE`。  
  
### <a name="remarks"></a>備註  
  
> [!WARNING]
> `CWnd::PreCreateWindow`現在將指派的 hMenu 成員及其`CREATESTRUCT`參數`this`指標，如果是`NULL`和樣式包含`WS_CHILD`。 功能正常運作，請確定對話方塊控制項具有 ID 不是`NULL`。  
>   
>  這項變更的 managed/原生 interop 案例中修正損毀。 A`TRACE`陳述式中的`CWnd::Create`警示問題的開發人員。  
  
 使用[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函式，註冊視窗類別。 使用者定義 視窗的模組中的類別可註冊的位置。  
  
 [CWnd::OnCreate](#oncreate)方法之前呼叫`Create`方法傳回時，以及之前的視窗隨即顯示。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 79](../../mfc/reference/codesnippet/cpp/cwnd-class_18.cpp)]  
  
##  <a name="createaccessibleproxy"></a>CWnd::CreateAccessibleProxy  
 建立指定物件的 Active Accessibility Proxy。  
  
```  
virtual HRESULT CreateAccessibleProxy(
    WPARAM wParam,  
    LPARAM lParam,  
    LRESULT* pResult);
```  
   
### <a name="parameters"></a>參數  
 `wParam`  
 識別由 Active Accessibility proxy 存取的物件。 可以是下列值之一  
  
|值|意義|  
|-----------|-------------|  
|**OBJID_CLIENT**|指的是視窗工作區。|  
  
 `lParam`  
 提供額外的訊息相關資訊。  
  
 `pResult`  
 指標**LRESULT**其中存放結果碼。  
  
### <a name="remarks"></a>備註  
 建立指定物件的 Active Accessibility Proxy。  
  
##  <a name="createcaret"></a>CWnd::CreateCaret  
 建立系統游標的新形狀，並宣告插入號的擁有權。  
  
```  
void CreateCaret(CBitmap* pBitmap);
```  
  
### <a name="parameters"></a>參數  
 `pBitmap`  
 識別定義的插入號形狀的點陣圖。  
  
### <a name="remarks"></a>備註  
 點陣圖必須先前已建立的[CBitmap::CreateBitmap](../../mfc/reference/cbitmap-class.md#createbitmap)成員函式， [CreateDIBitmap](http://msdn.microsoft.com/library/windows/desktop/dd183491) Windows 函式，或[cbitmap:: Loadbitmap](../../mfc/reference/cbitmap-class.md#loadbitmap)成員函式。  
  
 `CreateCaret`如果不論哪一個視窗的任何擁有插入號，則會自動終結上一個插入號圖案。 一旦建立，則將插入號一開始會隱藏。 若要顯示插入號， [ShowCaret](#showcaret)必須呼叫成員函式。  
  
 系統游標是共用的資源。 `CWnd`只有在具有輸入的焦點或作用中時，應該建立插入號。 失去輸入的焦點或變成非使用中之前，它應終結插入號。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 80](../../mfc/reference/codesnippet/cpp/cwnd-class_19.cpp)]  
  
##  <a name="createcontrol"></a>Cwnd:: Createcontrol  
 若要建立 ActiveX 控制項，就會顯示由 MFC 程式中使用此成員函式`CWnd`物件。  
  
```  
BOOL CreateControl(
    LPCTSTR pszClass,  
    LPCTSTR pszWindowName,  
    DWORD dwStyle,  
    const RECT& rect,  
    CWnd* pParentWnd,  
    UINT nID,  
    CFile* pPersist = NULL,  
    BOOL bStorage = FALSE,  
    BSTR bstrLicKey = NULL);

 
BOOL CreateControl(
    REFCLSID clsid,  
    LPCTSTR pszWindowName,  
    DWORD dwStyle,  
    const RECT& rect,  
    CWnd* pParentWnd,  
    UINT nID,  
    CFile* pPersist = NULL,  
    BOOL bStorage = FALSE,  
    BSTR bstrLicKey = NULL);

 
BOOL CreateControl(
    REFCLSID clsid,  
    LPCTSTR pszWindowName,  
    DWORD dwStyle,  
    const POINT* ppt,  
    const SIZE* psize,  
    CWnd* pParentWnd,  
    UINT nID,  
    CFile* pPersist = NULL,  
    BOOL bStorage = FALSE,  
    BSTR bstrLicKey = NULL);
```  
  
### <a name="parameters"></a>參數  
 *pszClass*  
 這個字串可能包含 OLE 「 簡短名稱 」 (ProgID) 類別，例如，"CIRC3。Circ3Ctrl.1"。 名稱必須符合控制項註冊相同的名稱。 或者，此字串可能包含的字串形式**CLSID**，包含在大括號，例如"{9DBAFCCF-592F-101B-85CE-00608CEC297B}"。 在任一情況下，`CreateControl`將字串轉換成對應的類別識別碼。  
  
 *pszWindowName*  
 要在控制項中顯示的文字指標。 （如果有的話），請設定控制項的標題或文字屬性的值。 如果**NULL**，則不會變更控制項的標題或文字屬性。  
  
 `dwStyle`  
 視窗樣式。 可用的樣式列在 < 備註 >。  
  
 `rect`  
 指定控制項的大小和位置。 它可以是[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](../../mfc/reference/rect-structure1.md)。  
  
 `ppt`  
 指向[POINT 結構](../../mfc/reference/point-structure1.md)或`CPoint`物件，包含控制項的左上的角。  
  
 `pSize`  
 指向[大小](http://msdn.microsoft.com/library/windows/desktop/dd145106)結構或`CSize`物件，包含控制項的大小  
  
 `pParentWnd`  
 指定控制項的父視窗。 它不得為**NULL**。  
  
 `nID`  
 指定控制項的 id。  
  
 `pPersist`  
 指標[CFile](../../mfc/reference/cfile-class.md)包含控制項的永續性狀態。 預設值是**NULL**，指出此控制項，而不還原其狀態從任何永續性儲存體初始化本身。 如果沒有**NULL**，它應該指向的`CFile`-衍生物件，其中包含控制項的永續性資料，請在資料流或儲存體的格式。 這項資料可以儲存在用戶端上啟用。 `CFile`可以包含其他資料，但必須設定的持續性資料的第一個位元組時呼叫其讀寫指標`CreateControl`。  
  
 `bStorage`  
 指出是否在資料`pPersist`應該解譯為 IStorage 或 IStream 的資料。 如果中的資料`pPersist`是儲存體，`bStorage`應該**TRUE**。 如果在資料`pPersist`是 stream，`bStorage`應該**FALSE**。 預設值是**FALSE**。  
  
 *bstrLicKe*y  
 選擇性的授權金鑰資料。 此資料只需要建立需要的執行階段授權識別碼的控制項。 如果此控制項支援授權，您必須提供控制項才會成功建立授權金鑰。 預設值是**NULL**。  
  
 `clsid`  
 控制項的唯一類別 ID。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 `CreateControl`是直接的類比[cwnd:: Create](#create)函式，這會建立為視窗`CWnd`。 `CreateControl`建立 ActiveX 控制項而不是一般的視窗。  
  
 只有 Windows 子集`dwStyle`旗標受到支援`CreateControl`:  
  
- **WS_VISIBLE**建立一開始即可見的視窗。 如果您想看見立即像一般的 windows 控制項的必要項。  
  
- **WS_DISABLED**建立視窗一開始停用。 停用的視窗無法接收使用者輸入。 如果控制項具有已啟用屬性，可以設定。  
  
- `WS_BORDER`建立具有精簡列框線的視窗。 如果控制項的框線樣式屬性，可以設定。  
  
- **WS_GROUP**指定控制項群組的第一個控制項。 使用者可以變更鍵盤焦點從一個控制項群組中至下一個使用方向鍵。 使用定義的所有控制項**WS_GROUP**樣式之後的第一個控制項隸屬於相同的群組。 下一個控制項與**WS_GROUP**樣式結束的群組，並啟動下一個群組。  
  
- **WS_TABSTOP**指定控制項可接收鍵盤焦點時使用者按下 TAB 鍵。 按下 TAB 鍵的鍵盤焦點變更到下一個控制項的**WS_TABSTOP**樣式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 81](../../mfc/reference/codesnippet/cpp/cwnd-class_20.h)]  
  
##  <a name="createex"></a>CWnd::CreateEx  
 建立指定的視窗，並將它附加至`CWnd`物件。  
  
```  
virtual BOOL CreateEx(
    DWORD dwExStyle,  
    LPCTSTR lpszClassName,  
    LPCTSTR lpszWindowName,  
    DWORD dwStyle,  
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    HWND hWndParent,  
    HMENU nIDorHMenu,  
    LPVOID lpParam = NULL);

 
virtual BOOL CreateEx(
    DWORD dwExStyle,  
    LPCTSTR lpszClassName,  
    LPCTSTR lpszWindowName,  
    DWORD dwStyle,  
    const RECT& rect,  
    CWnd* pParentWnd,  
    UINT nID,  
    LPVOID lpParam = NULL);
```  
  
### <a name="parameters"></a>參數  
 `dwExStyle`  
 位元組合 (OR)[延伸視窗樣式](../../mfc/reference/extended-window-styles.md)，否則為`NULL`預設延伸視窗樣式。  
  
 `lpszClassName`  
 以 null 終止的字串，其中包含系統註冊的視窗類別; 名稱的指標或預先定義的系統視窗類別名稱。  
  
 `lpszWindowName`  
 以 null 終止的字串，包含視窗的指標會顯示名稱。否則`NULL`任何視窗的顯示名稱。  
  
 `dwStyle`  
 位元組合 (OR)[視窗樣式](../../mfc/reference/window-styles.md)，否則為`NULL`預設視窗樣式。  
  
 `x`  
 從螢幕的左半部視窗或父視窗的初始的水平距離。  
  
 `y`  
 從畫面頂端視窗或父視窗的初始的垂直距離。  
  
 `nWidth`  
 寬度 （以像素的視窗）。  
  
 `nHeight`  
 高度 （以像素的視窗）。  
  
 `hwndParent`  
 子視窗，父視窗控制代碼。否則，如果視窗擁有者擁有者視窗的控制代碼。  
  
 `nIDorHMenu`  
 子視窗的視窗識別碼;否則，視窗功能表的識別碼。  
  
 `lpParam`  
 傳遞至的使用者資料指標[CWnd::OnCreate](#oncreate)方法中的`lpCreateParams`欄位。  
  
 `rect`  
 大小和視窗相對於螢幕或父視窗的位置。  
  
 `pParentWnd`  
 子視窗，父視窗; 的指標否則，如果視窗擁有者擁有者視窗指標。  
  
 `nID`  
 子視窗的視窗識別碼;否則，視窗功能表的識別碼。  
  
### <a name="return-value"></a>傳回值  
 `TRUE`如果該方法成功。否則`FALSE`。  
  
### <a name="remarks"></a>備註  
  
> [!WARNING]
> `CWnd::PreCreateWindow`現在將指派的 hMenu 成員及其`CREATESTRUCT`參數`this`指標，如果是`NULL`和樣式包含`WS_CHILD`。 功能正常運作，請確定對話方塊控制項具有 ID 不是`NULL`。  
>   
>  這項變更的 managed/原生 interop 案例中修正損毀。 A`TRACE`陳述式中的`CWnd::Create`警示問題的開發人員。  
  
 延伸視窗樣式的預設值是`WS_EX_LEFT`。 在預設視窗樣式是`WS_OVERLAPPED`。  
  
 使用[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函式，註冊視窗類別。 使用者定義 視窗的模組中的類別可註冊的位置。  
  
 子視窗的維度是相對於父視窗的工作區的左上角。 為最上層視窗的維度是相對於螢幕左上角。  
  
 [CWnd::OnCreate](#oncreate)方法之前呼叫`CreateEx`方法傳回時，以及之前的視窗隨即顯示。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 82](../../mfc/reference/codesnippet/cpp/cwnd-class_21.cpp)]  
  
##  <a name="creategraycaret"></a>CWnd::CreateGrayCaret  
 建立系統游標的灰色矩形，以及宣告插入號的擁有權。  
  
```  
void CreateGrayCaret(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `nWidth`  
 指定 （以邏輯單位表示） 插入號寬度。 如果這個參數是 0，則會將寬度設定為系統定義的視窗框線寬度。  
  
 `nHeight`  
 指定的高度 （以邏輯單位表示） 插入號。 如果這個參數是 0，會將高度設的系統定義的視窗框線的高度。  
  
### <a name="remarks"></a>備註  
 插入號圖案可以是線條或區塊。  
  
 參數`nWidth`和`nHeight`的精確寬度和高度 （單位為像素為單位） 取決於對應模式; 指定將插入號寬度和高度 （以邏輯單位表示）。  
  
 可以藉由擷取系統的視窗框線的寬度或高度[GetSystemMetrics](http://msdn.microsoft.com/library/windows/desktop/ms724385) Windows 函式與**SM_CXBORDER**和**SM_CYBORDER**索引。 使用視窗框線的寬度或高度可確保插入號會顯示在高解析度的顯示器上。  
  
 `CreateGrayCaret`成員函式會自動終結上一個插入號圖案，如果任何，不論哪一個視窗擁有插入號。 一旦建立，則將插入號一開始會隱藏。 若要顯示插入號， [ShowCaret](#showcaret)必須呼叫成員函式。  
  
 系統游標是共用的資源。 `CWnd`只有在具有輸入的焦點或作用中時，應該建立插入號。 失去輸入的焦點或變成非使用中之前，它應終結插入號。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 83](../../mfc/reference/codesnippet/cpp/cwnd-class_22.cpp)]  
  
##  <a name="createsolidcaret"></a>CWnd::CreateSolidCaret  
 建立系統游標的實心矩形，以及宣告插入號的擁有權。  
  
```  
void CreateSolidCaret(
    int nWidth,  
    int nHeight);
```  
  
### <a name="parameters"></a>參數  
 `nWidth`  
 指定 （以邏輯單位表示） 插入號寬度。 如果這個參數是 0，則會將寬度設定為系統定義的視窗框線寬度。  
  
 `nHeight`  
 指定的高度 （以邏輯單位表示） 插入號。 如果這個參數是 0，會將高度設的系統定義的視窗框線的高度。  
  
### <a name="remarks"></a>備註  
 插入號圖案可以是線條或區塊。  
  
 參數`nWidth`和`nHeight`的精確寬度和高度 （單位為像素為單位） 取決於對應模式; 指定將插入號寬度和高度 （以邏輯單位表示）。  
  
 可以藉由擷取系統的視窗框線的寬度或高度[GetSystemMetrics](http://msdn.microsoft.com/library/windows/desktop/ms724385) Windows 函式與**SM_CXBORDER**和**SM_CYBORDER**索引。 使用視窗框線的寬度或高度可確保插入號會顯示在高解析度的顯示器上。  
  
 `CreateSolidCaret`成員函式會自動終結上一個插入號圖案，如果任何，不論哪一個視窗擁有插入號。 一旦建立，則將插入號一開始會隱藏。 若要顯示插入號， [ShowCaret](#showcaret)必須呼叫成員函式。  
  
 系統游標是共用的資源。 `CWnd`只有在具有輸入的焦點或作用中時，應該建立插入號。 失去輸入的焦點或變成非使用中之前，它應終結插入號。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 84](../../mfc/reference/codesnippet/cpp/cwnd-class_23.cpp)]  
  
##  <a name="cwnd"></a>CWnd::CWnd  
 建構 `CWnd` 物件。  
  
```  
CWnd();
```  
  
### <a name="remarks"></a>備註  
 Windows 視窗不會在建立，並附加直到[CreateEx](#createex)或[建立](#create)呼叫成員函式。  
  
##  <a name="default"></a>CWnd::Default  
 呼叫預設視窗程序。  
  
```  
LRESULT Default();
```  
  
### <a name="return-value"></a>傳回值  
 視傳送的訊息。  
  
### <a name="remarks"></a>備註  
 預設視窗程序提供的預設應用程式不會處理任何視窗訊息處理。 此成員函式可確保每個訊息處理的。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 85](../../mfc/reference/codesnippet/cpp/cwnd-class_24.cpp)]  
  
##  <a name="defwindowproc"></a>CWnd::DefWindowProc  
 呼叫預設視窗程序，提供應用程式不會處理任何視窗訊息的預設處理。  
  
```  
virtual LRESULT DefWindowProc(
    UINT message,  
    WPARAM wParam,  
    LPARAM lParam);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定要處理的 Windows 訊息。  
  
 `wParam`  
 指定訊息相關的其他資訊。  
  
 `lParam`  
 指定訊息相關的其他資訊。  
  
### <a name="return-value"></a>傳回值  
 視傳送的訊息。  
  
### <a name="remarks"></a>備註  
 此成員函式可確保每個訊息處理的。 它應該呼叫所收到的視窗程序參數相同。  
  
##  <a name="deletetempmap"></a>CWnd::DeleteTempMap  
 由的閒置時間處理常式自動呼叫`CWinApp`物件。  
  
```  
static void PASCAL DeleteTempMap();
```  
  
### <a name="remarks"></a>備註  
 刪除任何暫存`CWnd`所建立的物件`FromHandle`成員函式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # x86](../../mfc/reference/codesnippet/cpp/cwnd-class_25.cpp)]  
  
##  <a name="destroywindow"></a>Cwnd:: Destroywindow  
 終結附加的 Windowd 視窗`CWnd`物件。  
  
```  
virtual BOOL DestroyWindow();
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果視窗終結時。否則便是 0。  
  
### <a name="remarks"></a>備註  
 `DestroyWindow`成員函式會將適當的訊息傳送至視窗，以將其停用和移除輸入的焦點。 它也會終結視窗的功能表、 排清應用程式佇列、 終結尚未處理完畢的計時器，會移除剪貼簿的擁有權，並且會中斷剪貼簿檢視器鏈結，如果`CWnd`位於檢視器鏈結的最上層。 它會傳送[WM_DESTROY](#ondestroy)和[控制](#onncdestroy)至視窗的訊息。 它不會終結`CWnd`物件。  
  
 `DestroyWindow`是預留位置執行清理。 因為`DestroyWindow`是虛擬函式，它會顯示在任何`CWnd`-衍生的類別檢視 中的類別。 不過，即使您覆寫這個函式中的您`CWnd`-衍生的類別，`DestroyWindow`一定不會呼叫。 如果`DestroyWindow`中不會呼叫 MFC 程式碼中，則必須明確呼叫它自己的程式碼中如果您想要呼叫。  
  
 例如，假設，您已覆寫`DestroyWindow`中`CView`-衍生的類別。 因為 MFC 程式碼不會呼叫`DestroyWindow`任一其`CFrameWnd`-衍生的類別，您覆寫的`DestroyWindow`將不會呼叫除非您明確地呼叫。  
  
 如果視窗是任何視窗的父代，這些子視窗會自動終結時終結父視窗。 `DestroyWindow`成員函式會終結子視窗然後再視窗本身。  
  
 `DestroyWindow`成員函式也會終結所建立的非強制回應對話方塊[CDialog::Create](../../mfc/reference/cdialog-class.md#create)。  
  
 如果`CWnd`終結子視窗，並沒有[WS_EX_NOPARENTNOTIFY](../../mfc/reference/extended-window-styles.md)樣式集合，然後在[WM_PARENTNOTIFY](https://msdn.microsoft.com/library/ms632638.aspx)訊息傳送至父代。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 87](../../mfc/reference/codesnippet/cpp/cwnd-class_26.cpp)]  
  
##  <a name="detach"></a>CWnd::Detach  
 從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。  
  
```  
HWND Detach();
```  
  
### <a name="return-value"></a>傳回值  
 A `HWND` Windows 物件。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::Attach](#attach)。  
  
##  <a name="dlgdirlist"></a>CWnd::DlgDirList  
 使用檔案或目錄清單填入清單方塊。  
  
```  
int DlgDirList(
    LPTSTR lpPathSpec,  
    int nIDListBox,  
    int nIDStaticPath,  
    UINT nFileType);
```  
  
### <a name="parameters"></a>參數  
 `lpPathSpec`  
 指向以 null 終止的字串，包含的路徑或檔名。 `DlgDirList`修改此字串應該夠長，包含所做的修改。 如需詳細資訊，請參閱下列 < 備註 > 一節。  
  
 `nIDListBox`  
 指定清單方塊的識別碼。 如果`nIDListBox`為 0，`DlgDirList`假設清單方塊中不存在，而且不會嘗試以填滿其中一個。  
  
 `nIDStaticPath`  
 指定用來顯示目前的磁碟機和目錄的靜態文字控制項的識別項。 如果`nIDStaticPath`為 0，`DlgDirList`假設這類文字控制項，也會顯示。  
  
 `nFileType`  
 指定要顯示之檔案的屬性。 它可以是下列值的任何組合︰  
  
- **DDL_READWRITE**讀寫資料檔案不含任何額外的屬性。  
  
- **DDL_READONLY**唯讀檔案。  
  
- **DDL_HIDDEN**隱藏檔案。  
  
- **DDL_SYSTEM**系統檔案。  
  
- **DDL_DIRECTORY**目錄。  
  
- **DDL_ARCHIVE**封存。  
  
- **DDL_POSTMSGS LB_DIR**旗標。 如果**LB_DIR**設定旗標時，Windows 會將所產生的訊息`DlgDirList`在應用程式的佇列中; 否則它們會直接傳送至對話方塊程序。  
  
- **DDL_DRIVES**磁碟機。 如果**DDL_DRIVES**設定旗標， **DDL_EXCLUSIVE**旗標會自動設定。 因此，若要建立包含磁碟機和檔案的目錄清單，您必須呼叫`DlgDirList`兩次︰ 一次使用**DDL_DRIVES**清單上的其他的旗標與旗標集，另一次。  
  
- **DDL_EXCLUSIVE**獨佔的位元。 如果設定獨佔的位元，會列出指定類型的檔案;否則會列出一般的檔案和檔案指定的類型。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 `DlgDirList`傳送[LB_RESETCONTENT](http://msdn.microsoft.com/library/windows/desktop/bb761325)和[LB_DIR](http://msdn.microsoft.com/library/windows/desktop/bb775185)訊息至清單方塊。 填入清單方塊中所指定`nIDListBox`符合所指定的路徑的所有檔案的名稱取代`lpPathSpec`。  
  
 `lpPathSpec`參數具有下列格式︰  
  
 `[drive:] [ [\u]directory[\idirectory]...\u] [filename]`  
  
 在此範例中，`drive`磁碟機代號，`directory`是有效的目錄名稱，和*filename*是有效的檔案名稱必須包含至少一個萬用字元。 萬用字元是問號 （*），這表示比對任何字元，以及使用星號 ( **\***)，這表示比對任何數目的字元。  
  
 如果您指定的 0 長度字串`lpPathSpec`，或如果您只有指定的目錄名稱，但不是包含任何檔案規格時，將字串變更為"*。\*"。  
  
 如果`lpPathSpec`包括磁碟機及/或目錄的名稱、 目前的磁碟機和目錄都會變更為指定的磁碟機和目錄會填入清單方塊之前。 所識別的文字控制項`nIDStaticPath`也會更新與新的磁碟機及/或目錄名稱。  
  
 填入清單方塊之後，`lpPathSpec`更新藉由移除磁碟機及/或目錄路徑的一部分。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 88](../../mfc/reference/codesnippet/cpp/cwnd-class_27.cpp)]  
  
##  <a name="dlgdirlistcombobox"></a>CWnd::DlgDirListComboBox  
 使用檔案或目錄清單來填入下拉式方塊的清單方塊。  
  
```  
int DlgDirListComboBox(
    LPTSTR lpPathSpec,  
    int nIDComboBox,  
    int nIDStaticPath,  
    UINT nFileType);
```  
  
### <a name="parameters"></a>參數  
 `lpPathSpec`  
 指向以 null 終止的字串，包含的路徑或檔名。 `DlgDirListComboBox`會修改這個字串，因此這項資料不應該是字串常值的形式。 請參閱下列 < 備註 > 一節。  
  
 `nIDComboBox`  
 在對話方塊中指定下拉式方塊的識別碼。 如果`nIDComboBox`為 0，`DlgDirListComboBox`假設沒有下拉式方塊存在，而且不會嘗試以填滿其中一個。  
  
 `nIDStaticPath`  
 指定用來顯示目前的磁碟機和目錄的靜態文字控制項的識別項。 如果`nIDStaticPath`為 0，`DlgDirListComboBox`假設這類文字控制項，也會顯示。  
  
 `nFileType`  
 指定要顯示之檔案的 DOS 檔案屬性。 它可以是下列值的任何組合︰  
  
- **DDL_READWRITE**讀寫資料檔案不含任何額外的屬性。  
  
- **DDL_READONLY**唯讀檔案。  
  
- **DDL_HIDDEN**隱藏檔案。  
  
- **DDL_SYSTEM**系統檔案。  
  
- **DDL_DIRECTORY**目錄。  
  
- **DDL_ARCHIVE**封存。  
  
- **DDL_POSTMSGS CB_DIR**旗標。 如果**CB_DIR**設定旗標時，Windows 會將所產生的訊息`DlgDirListComboBox`在應用程式的佇列中; 否則它們會直接傳送至對話方塊程序。  
  
- **DDL_DRIVES**磁碟機。 如果**DDL_DRIVES**設定旗標， **DDL_EXCLUSIVE**旗標會自動設定。 因此，若要建立包含磁碟機和檔案的目錄清單，您必須呼叫`DlgDirListComboBox`兩次︰ 一次使用**DDL_DRIVES**清單上的其他的旗標與旗標集，另一次。  
  
- **DDL_EXCLUSIVE**獨佔的位元。 如果設定獨佔的位元，會列出指定類型的檔案;否則會列出一般的檔案和檔案指定的類型。  
  
### <a name="return-value"></a>傳回值  
 指定函式的結果。 如果清單已進行，即使是空的清單，就會為非零。 0 的傳回值表示在輸入的字串未包含有效的搜尋路徑。  
  
### <a name="remarks"></a>備註  
 `DlgDirListComboBox`傳送[CB_RESETCONTENT](http://msdn.microsoft.com/library/windows/desktop/bb775878)和[CB_DIR](http://msdn.microsoft.com/library/windows/desktop/bb775832)下拉式方塊的訊息。 填入清單方塊的下拉式方塊所指定`nIDComboBox`符合所指定的路徑的所有檔案的名稱取代`lpPathSpec`。  
  
 `lpPathSpec`參數具有下列格式︰  
  
 `[drive:] [ [\u]directory[\idirectory]...\u] [filename]`  
  
 在此範例中，`drive`磁碟機代號，`directory`是有效的目錄名稱，和*filename*是有效的檔案名稱必須包含至少一個萬用字元。 萬用字元是問號 （*），這表示比對任何字元，以及使用星號 ( **\***)，這表示比對任何數目的字元。  
  
 如果您指定零長度字串`lpPathSpec`，將會使用目前的目錄和`lpPathSpec`將不會修改。 如果您只有指定的目錄名稱，但不是包含任何檔案規格時，將字串變更為"*"。  
  
 如果`lpPathSpec`包括磁碟機及/或目錄的名稱、 目前的磁碟機和目錄都會變更為指定的磁碟機和目錄會填入清單方塊之前。 所識別的文字控制項`nIDStaticPath`也會更新與新的磁碟機及/或目錄名稱。  
  
 下拉式方塊清單方塊會填滿之後，`lpPathSpec`更新藉由移除磁碟機及/或目錄路徑的一部分。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 89](../../mfc/reference/codesnippet/cpp/cwnd-class_28.cpp)]  
  
##  <a name="dlgdirselect"></a>CWnd::DlgDirSelect  
 從清單方塊擷取目前的選取範圍。  
  
```  
BOOL DlgDirSelect(
    LPTSTR lpString,  
    int nIDListBox);
```  
  
### <a name="parameters"></a>參數  
 `lpString`  
 指出在清單方塊中接收目前選取範圍的緩衝區。  
  
 `nIDListBox`  
 在對話方塊中，指定清單方塊的整數識別碼。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 它會假設清單方塊已填滿由[DlgDirList](#dlgdirlist)成員函式，並選取磁碟機代號、 檔案或目錄名稱。  
  
 `DlgDirSelect`成員函式會將選取範圍複製到所指定的緩衝區`lpString`。 如果未選取任何範圍，`lpString`不會變更。  
  
 `DlgDirSelect`傳送[LB_GETCURSEL](http://msdn.microsoft.com/library/windows/desktop/bb775197)和[LB_GETTEXT](http://msdn.microsoft.com/library/windows/desktop/bb761313)訊息至清單方塊。  
  
 不允許一個以上的檔案名稱，傳回從清單方塊。 清單方塊不能多重選擇清單方塊。  
  
##  <a name="dlgdirselectcombobox"></a>CWnd::DlgDirSelectComboBox  
 從下拉式方塊的清單方塊中擷取目前的選取範圍。  
  
```  
BOOL DlgDirSelectComboBox(
    LPTSTR lpString,  
    int nIDComboBox);
```  
  
### <a name="parameters"></a>參數  
 `lpString`  
 指出會接收選取的路徑的緩衝區。  
  
 `nIDComboBox`  
 在對話方塊中指定下拉式方塊的整數識別碼。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 它會假設清單方塊已填滿由[DlgDirListComboBox](#dlgdirlistcombobox)成員函式，並選取磁碟機代號、 檔案或目錄名稱。  
  
 `DlgDirSelectComboBox`成員函式會將選取範圍複製到指定的緩衝區。 如果沒有選取範圍，將緩衝區的內容不會變更。  
  
 `DlgDirSelectComboBox`傳送[CB_GETCURSEL](http://msdn.microsoft.com/library/windows/desktop/bb775845)和[CB_GETLBTEXT](http://msdn.microsoft.com/library/windows/desktop/bb775862)下拉式方塊的訊息。  
  
 不允許一個以上的檔案名稱，傳回從下拉式方塊。  
  
##  <a name="dodataexchange"></a>CWnd::DoDataExchange  
 由架構呼叫以交換和驗證對話方塊資料。  
  
```  
virtual void DoDataExchange(CDataExchange* pDX);
```  
  
### <a name="parameters"></a>參數  
 `pDX`  
 `CDataExchange` 物件的指標。  
  
### <a name="remarks"></a>備註  
 永遠不會直接呼叫此函式。 呼叫此方法[UpdateData](#updatedata)成員函式。 呼叫`UpdateData`初始化對話方塊的控制項，或從對話方塊中擷取資料。  
  
 當您衍生的特定應用程式的對話方塊類別從[CDialog](../../mfc/reference/cdialog-class.md)，您需要覆寫此成員函式，如果您想要利用架構的自動資料交換和驗證。 加入變數 精靈會為您包含所需撰寫覆寫的版本，此成員函式的 「 資料對應 」 的對話方塊資料交換 (DDX) 和驗證 (DDV) 全域函式呼叫。  
  
 若要自動產生的覆寫此成員函式版本，請先使用對話方塊編輯器中，建立對話方塊資源，然後衍生的特定應用程式的對話方塊類別。 變數、 資料和驗證範圍與新的對話方塊中的各種控制項，然後使用 加入變數的精靈。 然後精靈將覆寫`DoDataExchange`，其中包含資料對應。 以下是加入變數 精靈所產生的範例 DDX/DDV 程式碼區塊︰  
  
 [!code-cpp[NVC_MFCWindowing # 90](../../mfc/reference/codesnippet/cpp/cwnd-class_29.cpp)]  
  
 `DoDataExchange`覆寫的成員函式必須在原始程式檔中之前的巨集陳述式。  
  
 如需有關對話資料交換和驗證的詳細資訊，請參閱[顯示和操作表單中的資料](../../data/odbc/displaying-and-manipulating-data-in-a-form.md)和[對話方塊資料交換和驗證](../../mfc/dialog-data-exchange-and-validation.md)。 如需加入變數 精靈所產生的 DDX_ 和 DDV_ 巨集的說明，請參閱[技術提示 26](../../mfc/tn026-ddx-and-ddv-routines.md)。  
  
##  <a name="dragacceptfiles"></a>CWnd::DragAcceptFiles  
 在視窗中，呼叫此成員函式，從使用`CWnd`指標，在您的應用程式中[Afxenablecontrolcontainer](../../mfc/reference/cwinapp-class.md#initinstance)函式來表示視窗接受從 Windows 檔案管理員 或 [檔案總管] 中卸除檔案。  
  
```  
void DragAcceptFiles(BOOL bAccept = TRUE);
```  
  
### <a name="parameters"></a>參數  
 *BAccept*  
 旗標，指出是否接受拖曳的檔案。  
  
### <a name="remarks"></a>備註  
 呼叫的視窗`DragAcceptFiles`與`bAccept`參數設定為**TRUE**識別本身為能夠處理 Windows 訊息`WM_DROPFILES`。 例如，在 MDI 應用程式，如果`CMDIFrameWnd`中使用視窗指標`DragAcceptFiles`函式呼叫，只有`CMDIFrameWnd`視窗取得`WM_DROPFILES`訊息。 此訊息不會傳送給所有開啟`CMDIChildWnd`windows。 如`CMDIChildWnd`視窗收到這個訊息，您必須呼叫`DragAcceptFiles`與`CMDIChildWnd`視窗指標。  
  
 若要停止接收拖曳的檔案，呼叫成員函式`bAccept`設**FALSE**。  
  
##  <a name="dragdetect"></a>CWnd::DragDetect  
 擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。  
  
```  
BOOL DragDetect(POINT pt) const;  
```  
  
### <a name="parameters"></a>參數  
 `pt`  
 在螢幕座標中的滑鼠，初始位置。 函式會使用此點，以判斷拖曳矩形的座標。  
  
### <a name="return-value"></a>傳回值  
 如果使用者按住左鍵同時移動滑鼠拖曳矩形外的，傳回的值不是零。  
  
 如果使用者未按住左鍵同時移動滑鼠拖曳矩形外的，傳回的值為零。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[DragDetect](http://msdn.microsoft.com/library/windows/desktop/ms646256)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="drawanimatedrects"></a>CWnd::DrawAnimatedRects  
 繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。  
  
```  
BOOL DrawAnimatedRects(
    int idAni,  
    CONST RECT* lprcFrom,  
    CONST RECT* lprcTo);
```  
  
### <a name="parameters"></a>參數  
 *idAni*  
 指定類型的動畫。 如果您指定**IDANI_CAPTION**，視窗標題會從所指定的位置以動畫顯示`lprcFrom`所指定的位置`lprcTo`。 若要最小化或最大化視窗相似的效果。  
  
 `lprcFrom`  
 指標[RECT](http://msdn.microsoft.com/library/windows/desktop/dd162897)結構，指定最小化的視窗之圖示的大小與位置。  
  
 `lprcTo`  
 指標[RECT](http://msdn.microsoft.com/library/windows/desktop/dd162897)結構，指定的位置和 [還原] 視窗的大小  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[DrawAnimatedRects](http://msdn.microsoft.com/library/windows/desktop/dd162475)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="drawcaption"></a>CWnd::DrawCaption  
 繪製視窗標題。  
  
```  
BOOL DrawCaption(
    CDC* pDC,  
    LPCRECT lprc,  
    UINT uFlags);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 裝置內容的指標。 函式會放入此裝置的內容繪製視窗標題。  
  
 `lprc`  
 指定視窗標題的週框矩形結構的指標。  
  
 `uFlags`  
 指定繪圖選項。 如需完整的值清單，請參閱[DrawCaption](http://msdn.microsoft.com/library/windows/desktop/dd162476)。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[DrawCaption](http://msdn.microsoft.com/library/windows/desktop/dd162476)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="drawmenubar"></a>CWnd::DrawMenuBar  
 重新繪製功能表列。  
  
```  
void DrawMenuBar();
```  
  
### <a name="remarks"></a>備註  
 如果 Windows 視窗建立之後變更功能表列，，呼叫此函式可繪製已變更的功能表列。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::GetMenu](#getmenu)。  
  
##  <a name="enableactiveaccessibility"></a>CWnd::EnableActiveAccessibility  
 可讓使用者定義 Active Accessibility 函式。  
  
```  
void EnableActiveAccessibility();
```  
  
### <a name="remarks"></a>備註  
 MFC 的預設 Active Accessibility 支援就足以應付標準的視窗和控制項，包括 ActiveX 控制項。不過，如果您`CWnd`-衍生的類別包含 nonwindowed 使用者介面項目，MFC 會具有無從得知其相關。 在此情況下，您必須覆寫適當[Active Accessibility 成員函式](http://msdn.microsoft.com/en-us/68af04ac-4eb9-4b7d-b33f-c45512097a74)在類別中，您必須呼叫**EnableActiveAccessibility**類別的建構函式中。  
  
##  <a name="enabledynamiclayout"></a>Cwnd:: Enabledynamiclayout  
 啟用或停用動態配置管理員。 啟用動態配置時，會在使用者調整視窗大小時動態調整子視窗的位置與大小。  
  
```  
void EnableDynamicLayout(BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bEnable`  
 TRUE 表示啟用動態配置；FALSE 則停用動態配置。  
  
### <a name="remarks"></a>備註  
 如果您想要啟用動態配置，除了呼叫這個方法之外，還必須執行其他作業。 您還必須提供動態配置資訊，該資訊指定視窗中的控制項如何回應大小變更。 您可以在資源編輯器中或以程式設計方式，為每個控制項指定這項資訊。 請參閱[動態配置](../../mfc/dynamic-layout.md)。  
  
##  <a name="enabled2dsupport"></a>CWnd::EnableD2DSupport  
 啟用或停用視窗 D2D 支援。 初始化主視窗之前先呼叫這個方法。  
  
```  
void EnableD2DSupport(
    BOOL bEnable = TRUE,  
    BOOL bUseDCRenderTarget = FALSE);
```  
  
### <a name="parameters"></a>參數  
 `bEnable`  
 指定是否開啟或關閉 D2D 支援。  
  
 `bUseDCRenderTarget`  
 指定是否要使用裝置內容 (DC) 呈現目標 CDCRenderTarget。 如果為 FALSE，則會使用 CHwndRenderTarget。  
  
##  <a name="enablescrollbar"></a>CWnd::EnableScrollBar  
 啟用或停用一個捲軸的一或兩個箭號。  
  
```  
BOOL EnableScrollBar(
    int nSBFlags,  
    UINT nArrowFlags = ESB_ENABLE_BOTH);
```  
  
### <a name="parameters"></a>參數  
 *nSBFlags*  
 指定捲軸類型。 可以有下列值之一︰  
  
- **SB_BOTH**啟用或停用與視窗相關聯的水平和垂直捲軸之捲動箭號。  
  
- **SB_HORZ**啟用或停用與視窗相關聯的水平捲軸之捲動箭號。  
  
- **SB_VERT**啟用或停用與視窗相關聯的垂直捲軸之捲動箭號。  
  
 `nArrowFlags`  
 指定捲軸箭號是否已啟用或停用和啟用或停用的箭號。 可以有下列值之一︰  
  
- **ESB_ENABLE_BOTH**可讓這兩個捲軸之捲動箭號列 （預設值）。  
  
- **ESB_DISABLE_LTUP**停用水平捲軸的左箭號或在垂直捲軸上的向上箭號。  
  
- **ESB_DISABLE_RTDN**水平捲軸的向右鍵或向下箭號，垂直捲軸的停用。  
  
- **ESB_DISABLE_BOTH**停用這兩個捲軸之捲動箭號。  
  
### <a name="return-value"></a>傳回值  
 非零，如果啟用或停用所述的箭號。 否則，它會是 0，表示箭號已在要求的狀態，或發生錯誤。  
  
##  <a name="enablescrollbarctrl"></a>CWnd::EnableScrollBarCtrl  
 啟用或停用此視窗的捲軸。  
  
```  
void EnableScrollBarCtrl(
    int nBar,  
    BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 捲軸的識別項。  
  
 `bEnable`  
 指定捲軸是否要啟用或停用。  
  
### <a name="remarks"></a>備註  
 如果視窗有同層級捲軸控制項，則使用捲軸。否則會使用視窗的捲軸。  
  
##  <a name="enabletooltips"></a>CWnd::EnableToolTips  
 可讓給定視窗工具提示。  
  
```  
BOOL EnableToolTips(BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bEnable`  
 指定是否啟用或停用工具提示控制項。 **TRUE**啟用的控制項。**FALSE**停用控制項。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**工具提示是否已啟用，否則為**FALSE**。  
  
### <a name="remarks"></a>備註  
 覆寫[OnToolHitTest](#ontoolhittest)提供[TOOLINFO](http://msdn.microsoft.com/library/windows/desktop/bb760256)結構或結構視窗。  
  
> [!NOTE]
>  一些視窗，例如[CToolBar](../../mfc/reference/ctoolbar-class.md)，提供的內建實作[OnToolHitTest](#ontoolhittest)。  
  
 請參閱[TOOLINFO](http://msdn.microsoft.com/library/windows/desktop/bb760256)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需有關這個結構。  
  
 只要呼叫`EnableToolTips`不足以顯示工具提示，針對您的子女控制項的父視窗衍生自除非`CFrameWnd`。 這是因為`CFrameWnd`提供的預設處理常式**TTN_NEEDTEXT**通知。 如果父視窗不衍生自`CFrameWnd`，亦即，如果是在對話方塊或表單檢視，工具提示控制項將無法正確顯示除非您提供的處理常式子女**TTN_NEEDTEXT**工具提示通知。 請參閱[工具提示](../../mfc/tool-tips-in-windows-not-derived-from-cframewnd.md)。  
  
 為您的 windows 所提供的預設工具提示`EnableToolTips`沒有與其相關聯的文字。 若要擷取要顯示的工具提示文字**TTN_NEEDTEXT**會顯示工具提示視窗之前，傳送通知給工具提示控制項的父視窗。 如果沒有指派至某些值，這個訊息處理常式`pszText`隸屬**TOOLTIPTEXT**結構，會有任何顯示的工具提示的文字。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 91](../../mfc/reference/codesnippet/cpp/cwnd-class_30.cpp)]  
  
 [!code-cpp[NVC_MFCWindowing # 92](../../mfc/reference/codesnippet/cpp/cwnd-class_31.cpp)]  
  
##  <a name="enabletrackingtooltips"></a>CWnd::EnableTrackingToolTips  
 啟用或停用追蹤工具提示。  
  
```  
BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bEnable`  
 指定是否追蹤的工具提示已啟用或停用。 如果這個參數是**TRUE**，提示將會啟用此追蹤工具。 如果這個參數是**FALSE**，提示將會停用追蹤工具。  
  
### <a name="return-value"></a>傳回值  
 表示之前的狀態`EnableWindow`呼叫成員函式。 傳回值為非零，如果之前已停用視窗。 如果之前已啟用視窗或發生錯誤，則傳回值為 0。  
  
### <a name="remarks"></a>備註  
 追蹤工具提示是您可以動態地放置在螢幕的工具提示視窗。 藉由快速更新位置，工具提示視窗隨即出現，移動或 「 追蹤 」。 這項功能很有用，如果您需要遵循指標的位置移動的工具提示文字。  
  
##  <a name="enablewindow"></a>CWnd::EnableWindow  
 啟用或停用滑鼠和鍵盤輸入。  
  
```  
BOOL EnableWindow(BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bEnable`  
 指定是否要啟用或停用指定的視窗。 如果這個參數是**TRUE**，視窗就會啟用。 如果這個參數是**FALSE**，視窗將會停用。  
  
### <a name="return-value"></a>傳回值  
 表示之前的狀態`EnableWindow`呼叫成員函式。 傳回值為非零，如果之前已停用視窗。 如果之前已啟用視窗或發生錯誤，則傳回值為 0。  
  
### <a name="remarks"></a>備註  
 停用輸入時，例如滑鼠點按的按鍵輸入會被忽略的輸入。 啟用輸入時，視窗會處理所有的輸入。  
  
 如果已啟用的狀態已變更， [WM_ENABLE](#onenable)此函數會傳回前傳送訊息。  
  
 如果停用，所有的子視窗會隱含停用，雖然不會傳送`WM_ENABLE`訊息。  
  
 必須啟用一個視窗，才能啟動。 例如，如果應用程式會顯示非強制回應對話方塊，並已停用其主視窗，主視窗必須啟用之前的對話方塊時終結。 否則，另一個視窗會收到輸入的焦點，而且在啟動。 如果已停用子視窗，則會忽略時，Windows 會嘗試判斷哪一個視窗應該會收到滑鼠訊息。  
  
 根據預設，在建立時，會啟用視窗。 應用程式可以指定**WS_DISABLED**中設定樣式[建立](#create)或[CreateEx](#createex)成員函式來建立的視窗，一開始停用。 在建立視窗之後，也可以使用應用程式`EnableWindow`成員函式來啟用或停用視窗。  
  
 若要啟用或停用的控制項在對話方塊中，應用程式可以使用此函式。 停用的控制項無法接收輸入的焦點，也不在使用者可以存取它。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 93](../../mfc/reference/codesnippet/cpp/cwnd-class_32.cpp)]  
  
##  <a name="endmodalloop"></a>CWnd::EndModalLoop  
 結束呼叫`RunModalLoop`。  
  
```  
virtual void EndModalLoop(int nResult);
```  
  
### <a name="parameters"></a>參數  
 `nResult`  
 包含要傳回的呼叫端的值[runmodalloop 呼叫](#runmodalloop)。  
  
### <a name="remarks"></a>備註  
 `nResult`參數會傳播到傳回的值從`RunModalLoop`。  
  
##  <a name="endmodalstate"></a>CWnd::EndModalState  
 呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。  
  
```  
virtual void EndModalState();
```  
  
##  <a name="endpaint"></a>CWnd::EndPaint  
 標記繪製在指定的視窗中的結束。  
  
```  
void EndPaint(LPPAINTSTRUCT lpPaint);
```  
  
### <a name="parameters"></a>參數  
 `lpPaint`  
 指向[PAINTSTRUCT](../../mfc/reference/paintstruct-structure.md)結構，其中包含所擷取之繪製資訊[BeginPaint](#beginpaint)成員函式。  
  
### <a name="remarks"></a>備註  
 `EndPaint`成員函式是需要每次呼叫`BeginPaint`成員函式，但僅限於繪製完成之後。  
  
 如果插入號已隱藏`BeginPaint`成員函式，`EndPaint`將插入號還原至螢幕。  
  
### <a name="example"></a>範例  
  請參閱範例的[cwnd:: Beginpaint](#beginpaint)。  
  
##  <a name="executedlginit"></a>CWnd::ExecuteDlgInit  
 初始化對話方塊資源。  
  
```  
BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);  
BOOL ExecuteDlgInit(LPVOID lpResource);
```  
  
### <a name="parameters"></a>參數  
 `lpszResourceName`  
 以 null 終止的字串，指定的資源名稱的指標。  
  
 `lpResource`  
 資源的指標。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**對話方塊資源已執行，否則如果**FALSE**。  
  
### <a name="remarks"></a>備註  
 `ExecuteDlgInit`將來自其他來源使用繫結至執行模組中的資源。 若要達成此目的，`ExecuteDlgInit`尋找資源控制代碼藉由呼叫`AfxFindResourceHandle`。 如果您的 MFC 應用程式不使用共用的 DLL (MFCx0 [U] [D]。DLL) **AfxFindResourceHandle**呼叫[AfxGetResourceHandle](http://msdn.microsoft.com/library/d0eff6c4-f566-471a-96b7-a5a70a751a92)，它會傳回目前的資源控制代碼，可執行檔。 如果您使用 MFCx0 的 MFC 應用程式 [U] [D]。DLL，`AfxFindResourceHandle`周遊**CDynLinkLibrary**共用的物件清單和處理擴充 Dll 尋找正確的資源。  
  
##  <a name="filtertooltipmessage"></a>CWnd::FilterToolTipMessage  
 由架構呼叫以顯示工具提示訊息。  
  
```  
void FilterToolTipMessage(MSG* pMsg);
```  
  
### <a name="parameters"></a>參數  
 `pMsg`  
 工具提示訊息指標。  
  
### <a name="remarks"></a>備註  
 大多數的 MFC 應用程式中呼叫這個方法由從架構[PreTranslateMessage](#pretranslatemessage)和[EnableToolTips](#enabletooltips)，而且您不需要自行呼叫。  
  
 不過，在特定應用程式，例如某些 ActiveX 控制項，這些方法可能不會叫用由 framework，您必須自行呼叫 FilterToolTipMessage。 如需詳細資訊，請參閱[方法的建立工具提示](../../mfc/methods-of-creating-tool-tips.md)。  
  
##  <a name="findwindow"></a>CWnd::FindWindow  
 傳回最上層`CWnd`其視窗類別由提供`lpszClassName`和其視窗名稱或標題，由提供`lpszWindowName`。  
  
```  
static CWnd* PASCAL FindWindow(
    LPCTSTR lpszClassName,  
    LPCTSTR lpszWindowName);
```  
  
### <a name="parameters"></a>參數  
 `lpszClassName`  
 指向以 null 結束的字串，指定視窗的類別名稱 ( **WNDCLASS**結構)。 如果`lpClassName`是**NULL**，所有的類別名稱相符。  
  
 `lpszWindowName`  
 指向以 null 終止的字串，指定視窗名稱 （該視窗的標題）。 如果`lpWindowName`是**NULL**，所有的視窗名稱相符。  
  
### <a name="return-value"></a>傳回值  
 識別具有指定的類別名稱和視窗名稱的視窗。 它是**NULL**如果找到這類的時段。  
  
 `CWnd`* 可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 此函式不會搜尋子視窗。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 94](../../mfc/reference/codesnippet/cpp/cwnd-class_33.cpp)]  
  
##  <a name="findwindowex"></a>CWnd::FindWindowEx  
 擷取視窗物件的類別名稱和視窗名稱符合指定的字串。  
  
```  
static CWnd* FindWindowEx(
    HWND hwndParent,  
    HWND hwndChildAfter,  
    LPCTSTR lpszClass,  
    LPCTSTR lpszWindow);
```  
  
### <a name="parameters"></a>參數  
 *hwndParent*  
 父視窗的子視窗是要搜尋的控制代碼。  
  
 *hwndChildAfter*  
 子視窗的控制代碼。 與中的疊置順序的下一個子視窗開始搜尋。 子視窗必須是子視窗的*hwndParent*，不只是一個下階視窗。  
  
 `lpszClass`  
 以 null 終止的字串，指定類別名稱或由先前呼叫所建立的類別 atom 指標[RegisterClass](http://msdn.microsoft.com/library/windows/desktop/ms633586)或[RegisterClassEx](http://msdn.microsoft.com/library/windows/desktop/ms633587)。  
  
 *lpszWindow*  
 以 null 終止的字串，指定視窗名稱 （該視窗的標題） 的指標。 如果這個參數是**NULL**，所有的視窗名稱相符。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則傳回的值會是具有指定的類別和視窗名稱的視窗物件的指標。 如果函式失敗，傳回值是**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[FindWindowEx](http://msdn.microsoft.com/library/windows/desktop/ms633500)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="flashwindow"></a>CWnd::FlashWindow  
 指定的視窗 閃爍一次。  
  
```  
BOOL FlashWindow(BOOL bInvert);
```  
  
### <a name="parameters"></a>參數  
 `bInvert`  
 指定是否`CWnd`快閃記憶體中或傳回到其原始狀態。 `CWnd`從某個狀態快閃記憶體中其他如果`bInvert`是**TRUE**。 如果`bInvert`是**FALSE**，視窗會傳回到其原始狀態 （作用中或非使用中）。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果視窗是作用中的呼叫之前`FlashWindow`成員函式，否則傳回 0。  
  
### <a name="remarks"></a>備註  
 後續的閃爍，建立系統計時器並重複呼叫`FlashWindow`。 閃爍`CWnd`表示變更其標題列的外觀如同`CWnd`已變更為 作用中的非作用中狀態，從，反之亦然。 （非使用中的標題變更為使用中的標題列，使用中的標題變更為非作用中的標題列）。  
  
 一般而言，視窗快閃來通知使用者，它需要注意但，它目前沒有輸入的焦點。  
  
 `bInvert`參數應該是**FALSE**應該僅當視窗已取得輸入的焦點，而且將不再閃爍; **TRUE**在等候取得輸入的焦點時的後續呼叫。  
  
 此函式一律會傳回非零代表最小化視窗。 如果視窗最小化，`FlashWindow`只是快閃視窗的圖示。`bInvert`忽略的最小化視窗。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 95](../../mfc/reference/codesnippet/cpp/cwnd-class_34.cpp)]  
  
##  <a name="flashwindowex"></a>CWnd::FlashWindowEx  
 指定的視窗 閃爍。  
  
```  
BOOL FlashWindowEx(
    DWORD dwFlags,  
    UINT uCount,  
    DWORD dwTimeout);
```  
  
### <a name="parameters"></a>參數  
 `dwFlags`  
 指定的快閃的狀態。 如需完整的值清單，請參閱[FLASHWINFO](http://msdn.microsoft.com/library/windows/desktop/ms679348)結構。  
  
 `uCount`  
 指定的次數閃爍視窗。  
  
 `dwTimeout`  
 指定頻率，以毫秒為單位，視窗會在快閃記憶體中。 如果`dwTimeout`為零，此函數會使用預設游標閃爍頻率。  
  
### <a name="return-value"></a>傳回值  
 傳回值指定視窗的狀態，再呼叫`FlashWindowEx`函式。 如果為作用中的呼叫之前，已繪製視窗標題，傳回的值不是零。 否則，傳回的值為零。  
  
### <a name="remarks"></a>備註  
 這個方法會模擬函式的功能[FlashWindowEx](http://msdn.microsoft.com/library/windows/desktop/ms679347)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="fromhandle"></a>Cwnd:: Fromhandle  
 將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。  
  
```  
static CWnd* PASCAL FromHandle(HWND hWnd);
```  
  
### <a name="parameters"></a>參數  
 `hWnd`  
 `HWND` Windows 視窗。  
  
### <a name="return-value"></a>傳回值  
 將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。  
  
 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
##  <a name="fromhandlepermanent"></a>CWnd::FromHandlePermanent  
 將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。  
  
```  
static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
```  
  
### <a name="parameters"></a>參數  
 `hWnd`  
 `HWND` Windows 視窗。  
  
### <a name="return-value"></a>傳回值  
 指標`CWnd`物件。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`物件沒有附加至控制代碼， **NULL**傳回。  
  
 此函式不同的是[FromHandle](#fromhandle)，不會建立暫存物件。  
  
##  <a name="get_accchild"></a>CWnd::get_accChild  
 由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。  
  
```  
virtual HRESULT get_accChild(
    VARIANT varChild,  
    IDispatch** ppdispChild);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 識別的子系的`IDispatch`介面的擷取。  
  
 *ppdispChild*  
 接收的子物件的位址`IDispatch`介面。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accChild](http://msdn.microsoft.com/library/windows/desktop/dd318475)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::get_accChild](http://msdn.microsoft.com/library/windows/desktop/dd318475)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accchildcount"></a>CWnd::get_accChildCount  
 由架構呼叫以擷取屬於此物件的子物件數目。  
  
```  
virtual HRESULT get_accChildCount(long* pcountChildren);
```  
  
### <a name="parameters"></a>參數  
 *pcountChildren*  
 接收子系的數目。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accChildCount](http://msdn.microsoft.com/library/windows/desktop/dd318476)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。 呼叫基底類別版本，然後再加入 nonwindowed 子項目。  
  
 如需詳細資訊，請參閱[IAccessible::get_accChildCount](http://msdn.microsoft.com/library/windows/desktop/dd318476)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accdefaultaction"></a>CWnd::get_accDefaultAction  
 由架構呼叫以擷取具有物件預設動作描述的字串。  
  
```  
virtual HRESULT get_accDefaultAction(
    VARIANT varChild,  
    BSTR* pszDefaultAction);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取的預設動作是物件或物件的子元素的其中一個。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 *pszDefaultAction*  
 位址`BSTR`接收的當地語系化的字串。 如果這個物件沒有預設動作描述指定的物件，則為 NULL 的預設動作。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accDefaultAction](http://msdn.microsoft.com/library/windows/desktop/dd318477)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生的類別來描述物件的預設動作。  
  
 如需詳細資訊，請參閱[IAccessible::get_accDefaultAction](http://msdn.microsoft.com/library/windows/desktop/dd318477)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accdescription"></a>CWnd::get_accDescription  
 由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。  
  
```  
virtual HRESULT get_accDescription(
    VARIANT varChild,  
    BSTR* pszDescription);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取的描述是物件或物件的子元素的其中一個。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 `pszDescription`  
 位址`BSTR`接收當地語系化的字串描述指定的物件，或如果沒有描述適用於此物件為 NULL。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accDescription](http://msdn.microsoft.com/library/windows/desktop/dd318478)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生的類別來描述您的物件。 呼叫基底類別版本，並加入您的描述。  
  
 如需詳細資訊，請參閱[IAccessible::get_accDescription](http://msdn.microsoft.com/library/windows/desktop/dd318478)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accfocus"></a>CWnd::get_accFocus  
 由架構呼叫以擷取具有鍵盤焦點的物件。  
  
```  
virtual HRESULT get_accFocus(VARIANT* pvarChild);
```  
  
### <a name="parameters"></a>參數  
 `pvarChild`  
 收到具有焦點之物件的相關資訊。 請參閱*pvarID*中[IAccessible::get_accFocus](http://msdn.microsoft.com/library/windows/desktop/dd318479)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::get_accFocus**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::get_accFocus](http://msdn.microsoft.com/library/windows/desktop/dd318479)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_acchelp"></a>CWnd::get_accHelp  
 由架構呼叫以擷取物件的**協助**屬性字串。  
  
```  
virtual HRESULT get_accHelp(
    VARIANT varChild,  
    BSTR* pszHelp);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取的說明資訊之物件或其中一個物件的子元素。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 *pszHelp*  
 位址`BSTR`接收的當地語系化的字串，包含指定的物件，則為 NULL 的說明資訊，如果沒有說明資訊功能。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accHelp](http://msdn.microsoft.com/library/windows/desktop/dd318480)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生的類別物件提供說明文字。  
  
 如需詳細資訊，請參閱[IAccessible::get_accHelp](http://msdn.microsoft.com/library/windows/desktop/dd318480)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_acchelptopic"></a>CWnd::get_accHelpTopic  
 由架構呼叫以擷取的完整路徑**WinHelp**與指定的物件和該檔案中適切主題的識別項相關聯的檔案。  
  
```  
virtual HRESULT get_accHelpTopic(
    BSTR* pszHelpFile,  
    VARIANT varChild,  
    long* pidTopic);
```  
  
### <a name="parameters"></a>參數  
 `pszHelpFile`  
 位址`BSTR`接收的完整路徑`WinHelp`任何與指定的物件有關聯的檔案。  
  
 `varChild`  
 指定是否要擷取之說明主題是物件或物件的子元素的其中一個。 這個參數可以是子的 CHILDID_SELF （若要取得說明 主題的物件） 或 （若要取得說明主題的其中一個物件元素） 的子識別碼。  
  
 `pidTopic`  
 識別指定之物件相關聯的說明檔主題。 請參閱`pidTopic`中[IAccessible::get_accHelpTopic](http://msdn.microsoft.com/library/windows/desktop/dd318481)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::get_accHelpTopic**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生的類別提供您物件的說明資訊。  
  
 如需詳細資訊，請參閱[IAccessible::get_accHelpTopic](http://msdn.microsoft.com/library/windows/desktop/dd318481)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_acckeyboardshortcut"></a>CWnd::get_accKeyboardShortcut  
 由架構呼叫以擷取指定物件的快速鍵或便捷鍵。  
  
```  
virtual HRESULT get_accKeyboardShortcut(
    VARIANT varChild,  
    BSTR* pszKeyboardShortcut);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取的鍵盤快速鍵是物件或物件的子元素的其中一個。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 *pszKeyboardShortcut*  
 位址`BSTR`接收的當地語系化字串識別鍵盤快速鍵，或如果沒有鍵盤快速鍵是以指定的物件相關聯，則為 NULL。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accKeyboardShortcut](http://msdn.microsoft.com/library/windows/desktop/dd318482)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生的類別來識別物件的鍵盤快速鍵。  
  
 如需詳細資訊，請參閱[IAccessible::get_accKeyboardShortcut](http://msdn.microsoft.com/library/windows/desktop/dd318482)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accname"></a>CWnd::get_accName  
 由架構呼叫以擷取指定物件的名稱。  
  
```  
virtual HRESULT get_accName(
    VARIANT varChild,  
    BSTR* pszName);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取的名稱是物件或物件的子元素的其中一個。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 `pszName`  
 位址`BSTR`接收包含指定的物件名稱的字串。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accName](http://msdn.microsoft.com/library/windows/desktop/dd318483)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，以傳回物件的名稱。  
  
 如需詳細資訊，請參閱[IAccessible::get_accName](http://msdn.microsoft.com/library/windows/desktop/dd318483)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accparent"></a>CWnd::get_accParent  
 由架構呼叫以擷取物件之父代的 `IDispatch` 介面。  
  
```  
virtual HRESULT get_accParent(IDispatch** ppdispParent);
```  
  
### <a name="parameters"></a>參數  
 *ppdispParent*  
 接收的父物件的位址`IDispatch`介面。 如果沒有父代存在，或如果子系無法存取其父代，變數會設為 NULL。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accParent](http://msdn.microsoft.com/library/windows/desktop/dd318484)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在大部分情況下，您不必覆寫這個函式。  
  
 如需詳細資訊，請參閱[IAccessible::get_accParent](http://msdn.microsoft.com/library/windows/desktop/dd318484)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accrole"></a>CWnd::get_accRole  
 由架構呼叫以擷取含有指定物件的角色描述資訊。  
  
```  
virtual HRESULT get_accRole(
    VARIANT varChild,  
    VARIANT* pvarRole);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取角色資訊的物件或其中一個物件的子元素。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 `pvarRole`  
 接收角色資訊。 請參閱`pvarRole`中[IAccessible::get_accRole](http://msdn.microsoft.com/library/windows/desktop/dd318485)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::get_accRole**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::get_accRole](http://msdn.microsoft.com/library/windows/desktop/dd318485)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accselection"></a>CWnd::get_accSelection  
 由架構呼叫以擷取此物件的選取子物件。  
  
```  
virtual HRESULT get_accSelection(VARIANT* pvarChildren);
```  
  
### <a name="parameters"></a>參數  
 `pvarChildren`  
 接收的資訊的已選取的子系。 請參閱`pvarChildren`中[IAccessible::get_accSelection](http://msdn.microsoft.com/library/windows/desktop/dd318486)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::get_accSelection**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::get_accSelection](http://msdn.microsoft.com/library/windows/desktop/dd318486)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accstate"></a>CWnd::get_accState  
 由架構呼叫以擷取指定物件的目前狀態。  
  
```  
virtual HRESULT get_accState(
    VARIANT varChild,  
    VARIANT* pvarState);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取的狀態資訊的物件或其中一個物件的子元素。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 `pvarState`  
 接收物件的狀態資訊。 請參閱`pvarState`中[IAccessible::get_accState](http://msdn.microsoft.com/library/windows/desktop/dd318487)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中**IAccessible::get_accState**中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::get_accState](http://msdn.microsoft.com/library/windows/desktop/dd318487)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="get_accvalue"></a>CWnd::get_accValue  
 由架構呼叫以擷取指定物件的值。  
  
```  
virtual HRESULT get_accValue(
    VARIANT varChild,  
    BSTR* pszValue);
```  
  
### <a name="parameters"></a>參數  
 `varChild`  
 指定是否要擷取的值資訊的物件或其中一個物件的子元素。 這個參數可以是 CHILDID_SELF （若要取得之物件的相關資訊） 或 （若要取得有關物件的子元素） 的子識別碼。  
  
 `pszValue`  
 位址`BSTR`接收包含物件的目前值的當地語系化的字串。  
  
### <a name="return-value"></a>傳回值  
 成功時，COM 錯誤碼失敗會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accValue](http://msdn.microsoft.com/library/windows/desktop/dd318488)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 此函式是 MFC 的一部分[Active Accessibility](http://msdn.microsoft.com/library/windows/desktop/dd373592)支援。  
  
 在這個函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。  
  
 如需詳細資訊，請參閱[IAccessible::get_accValue](http://msdn.microsoft.com/library/windows/desktop/dd318488)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getactivewindow"></a>CWnd::GetActiveWindow  
 擷取作用中視窗的指標。  
  
```  
static CWnd* PASCAL GetActiveWindow();
```  
  
### <a name="return-value"></a>傳回值  
 使用中視窗或**NULL**如果沒有任何視窗呼叫時仍作用中。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
### <a name="remarks"></a>備註  
 使用中的視窗是具有目前的輸入的焦點的視窗或明確設為作用中的視窗[SetActiveWindow](#setactivewindow)成員函式。  
  
##  <a name="getancestor"></a>CWnd::GetAncestor  
 擷取指定視窗的上階視窗物件。  
  
```  
CWnd* GetAncestor(UINT gaFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 *gaFlags*  
 指定要擷取的上階。 如需可能值的完整清單，請參閱[GetAncestor](http://msdn.microsoft.com/library/windows/desktop/ms633502)。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則傳回的值會是上階視窗物件的指標。 如果函式失敗，傳回值是**NULL**。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetAncestor](http://msdn.microsoft.com/library/windows/desktop/ms633502)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getcapture"></a>CWnd::GetCapture  
 擷取具有滑鼠捕捉的視窗。  
  
```  
static CWnd* PASCAL GetCapture();
```  
  
### <a name="return-value"></a>傳回值  
 識別具有滑鼠捕捉的視窗。 它是**NULL**如果沒有任何視窗具有滑鼠捕捉。  
  
 傳回的值可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 只有一個視窗具有滑鼠擷取任何給定的時間。 視窗會收到滑鼠捕捉時[SetCapture](#setcapture)呼叫成員函式。 此視窗會收到滑鼠輸入，在資料指標的框線內。  
  
##  <a name="getcaretpos"></a>CWnd::GetCaretPos  
 擷取插入號的目前位置的用戶端座標並傳回它們作為`CPoint`。  
  
```  
static CPoint PASCAL GetCaretPos();
```  
  
### <a name="return-value"></a>傳回值  
 [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，包含插入號位置的座標。  
  
### <a name="remarks"></a>備註  
 插入號位置指定的用戶端座標中`CWnd`視窗。  
  
##  <a name="getcheckedradiobutton"></a>CWnd::GetCheckedRadioButton  
 擷取指定的群組中的目前選取的選項按鈕的識別碼。  
  
```  
int GetCheckedRadioButton(
    int nIDFirstButton,  
    int nIDLastButton);
```  
  
### <a name="parameters"></a>參數  
 `nIDFirstButton`  
 指定群組中的第一個選項按鈕的整數識別碼。  
  
 `nIDLastButton`  
 指定群組中的最後一個選項按鈕的整數識別碼。  
  
### <a name="return-value"></a>傳回值  
 選取的選項按鈕或 0，如果沒有選取任何的識別碼。  
  
##  <a name="getclientrect"></a>CWnd::GetClientRect  
 將複製的用戶端座標`CWnd`到結構的用戶端區域所指`lpRect`。  
  
```  
void GetClientRect(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[RECT 結構](../../mfc/reference/rect-structure1.md)或`CRect`物件接收的用戶端座標。 **左**和**頂端**成員將會是 0。 **右**和**底部**成員將包含視窗的高度與寬度。  
  
### <a name="remarks"></a>備註  
 用戶端座標指定工作區的左上角和右下角。 因為用戶端座標是相對於的左上角`CWnd`工作區，左上角的座標為 (0，0)。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::IsIconic](#isiconic)。  
  
##  <a name="getclipboardowner"></a>CWnd::GetClipboardOwner  
 擷取剪貼簿的目前擁有者。  
  
```  
static CWnd* PASCAL GetClipboardOwner();
```  
  
### <a name="return-value"></a>傳回值  
 識別擁有剪貼簿，如果函式成功的視窗。 否則，它是**NULL**。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 剪貼簿仍可以包含資料，即使目前並未擁有。  
  
##  <a name="getclipboardviewer"></a>CWnd::GetClipboardViewer  
 擷取剪貼簿檢視器鏈結中的第一個視窗。  
  
```  
static CWnd* PASCAL GetClipboardViewer();
```  
  
### <a name="return-value"></a>傳回值  
 識別目前負責顯示剪貼簿成功; 如果視窗否則**NULL** （例如，如果沒有任何檢視器）。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
##  <a name="getcontrolunknown"></a>CWnd::GetControlUnknown  
 呼叫此成員函式可擷取未知的 OLE 控制項的指標。  
  
```  
LPUNKNOWN GetControlUnknown();
```  
  
### <a name="return-value"></a>傳回值  
 指標[IUnknown](http://msdn.microsoft.com/library/windows/desktop/ms680509)所代表的 OLE 控制項的介面`CWnd`物件。 如果此物件不代表 OLE 控制項，則傳回值是**NULL**。  
  
### <a name="remarks"></a>備註  
 您就不會釋放這**IUnknown**指標。 一般而言，您會使用來取得特定控制項的介面。  
  
 所傳回的介面指標**GetControlUnknown**不參考計數。 請勿呼叫[Iunknown](http://msdn.microsoft.com/library/windows/desktop/ms682317)指標除非您先前已經呼叫[iunknown:: Addref](http://msdn.microsoft.com/library/windows/desktop/ms691379)在其上。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 96](../../mfc/reference/codesnippet/cpp/cwnd-class_35.cpp)]  
  
##  <a name="getcurrentmessage"></a>CWnd::GetCurrentMessage  
 傳回此視窗目前正在處理的訊息指標。 只能呼叫時**上***訊息*訊息處理常式成員函式。  
  
```  
static const MSG* PASCAL GetCurrentMessage();
```  
  
### <a name="return-value"></a>傳回值  
 將指標傳回至[MSG](../../mfc/reference/msg-structure1.md)目前正在處理包含視窗之訊息的結構。 只能呼叫時**上***訊息*處理常式。  
  
### <a name="example"></a>範例  
  請參閱範例的[CMDIFrameWnd::MDICascade](../../mfc/reference/cmdiframewnd-class.md#mdicascade)。  
  
##  <a name="getdc"></a>Cwnd:: Getdc  
 擷取至共同的指標、 類別或依據指定的類別樣式的工作區的私用的裝置內容`CWnd`。  
  
```  
CDC* GetDC();
```  
  
### <a name="return-value"></a>傳回值  
 識別的裝置內容`CWnd`用戶端區域如果成功，否則傳回值就會是**NULL**。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
### <a name="remarks"></a>備註  
 常見的裝置內容，如`GetDC`擷取每次將預設屬性指派至內容。 類別和私用的內容，`GetDC`離開之前指派的屬性不變。 裝置內容可以用於後續的圖形裝置介面 (GDI) 函式，來繪製工作區中。  
  
 裝置內容所屬的視窗類別，除非[ReleaseDC](#releasedc)成員函式必須呼叫以繪製之後釋出內容。  
  
 裝置內容屬於`CWnd`類別由`GetDC`成員函式，如果**CS_CLASSDC**， **CS_OWNDC**，或**CS_PARENTDC**指定中的樣式為**WNDCLASS**結構註冊類別時。  
  
##  <a name="getdcex"></a>CWnd::GetDCEx  
 擷取裝置內容控制代碼`CWnd`視窗。  
  
```  
CDC* GetDCEx(
    CRgn* prgnClip,  
    DWORD flags);
```  
  
### <a name="parameters"></a>參數  
 `prgnClip`  
 識別可能會與用戶端視窗的可見區域結合的裁剪區域。  
  
 `flags`  
 可以有下列的預設值的其中一個︰  
  
- **DCX_CACHE**從快取傳回裝置內容而非**OWNDC**或**CLASSDC**視窗。 覆寫**CS_OWNDC**和**CS_CLASSDC**。  
  
- **DCX_CLIPCHILDREN**排除所有的子視窗下方的可見區域`CWnd`視窗。  
  
- **DCX_CLIPSIBLINGS**排除所有同層級視窗上方的可見區域`CWnd`視窗。  
  
- **DCX_EXCLUDERGN**排除所識別的裁剪區域`prgnClip`從傳回的裝置內容的可見區域。  
  
- **DCX_INTERSECTRGN**交集所識別的裁剪區域`prgnClip`內傳回的裝置內容的可見區域。  
  
- **DCX_LOCKWINDOWUPDATE**允許繪圖，即使沒有`LockWindowUpdate`呼叫，否則會排除此視窗的作用中。 這個值用於繪製在追蹤期間而定。  
  
- **DCX_PARENTCLIP**會使用父視窗的可見區域並忽略父視窗的**WS_CLIPCHILDREN**和**WS_PARENTDC**樣式位元。 這個值會設定裝置內容來源的左上角`CWnd`視窗。  
  
- **DCX_WINDOW**視窗矩形，而不是用戶端矩形會傳回對應的裝置內容。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功; 指定的視窗裝置內容否則**NULL**。  
  
### <a name="remarks"></a>備註  
 裝置內容可以用於後續的 GDI 函式，來繪製工作區中。  
  
 此函式是延伸模組來[GetDC](http://msdn.microsoft.com/library/windows/desktop/dd144871)函式，讓應用程式更充分掌控如何及是否會經過裁剪視窗裝置內容。  
  
 裝置內容所屬的視窗類別，除非[ReleaseDC](http://msdn.microsoft.com/library/windows/desktop/dd162920)呼叫函式必須在 繪圖之後釋出內容。 只有五個常見的裝置內容可用在任何指定時間，因為無法釋放裝置內容可以防止其他應用程式，使其無法存取的裝置內容。  
  
 若要取得的快取的裝置內容，必須指定應用程式[DCX_CACHE](http://msdn.microsoft.com/library/windows/desktop/dd144873)。 如果**DCX_CACHE**未指定，既不是視窗**CS_OWNDC**也[CS_CLASSDC](http://msdn.microsoft.com/library/windows/desktop/ms633576)，此函數會傳回**NULL**。  
  
 裝置內容中使用特殊的特性由[GetDCEx](http://msdn.microsoft.com/library/windows/desktop/dd144873)函式如果**CS_CLASSDC**， [CS_OWNDC](http://msdn.microsoft.com/library/windows/desktop/ms633576)，或[CS_PARENTDC](http://msdn.microsoft.com/library/windows/desktop/ms633576)樣式中指定了[WNDCLASS](http://msdn.microsoft.com/library/windows/desktop/ms633576)結構註冊類別時。  
  
 如需這些特性的詳細資訊，請參閱描述**WNDCLASS**結構[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getdcrendertarget"></a>CWnd::GetDCRenderTarget  
 擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。  
  
```  
CDCRenderTarget* GetDCRenderTarget();
```  
  
### <a name="return-value"></a>傳回值  
 裝置內容會呈現指定視窗的目標，如果函式成功;否則**NULL**。  
  
### <a name="remarks"></a>備註  
  
##  <a name="getdescendantwindow"></a>CWnd::GetDescendantWindow  
 呼叫此成員函式，以尋找子系給定識別碼所指定的視窗  
  
```  
CWnd* GetDescendantWindow(
    int nID,  
    BOOL bOnlyPerm = FALSE) const;  
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 指定要擷取控制項或子視窗的識別項。  
  
 `bOnlyPerm`  
 指定是否要傳回視窗可能是暫時性。 如果**TRUE**，永久視窗可以傳回; 如果**為 FALSE，**函式會傳回暫時的視窗。 如需有關暫存的 windows，請參閱[技術附註 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。  
  
### <a name="return-value"></a>傳回值  
 指標`CWnd`物件，或**NULL**如果不找到任何子視窗。  
  
### <a name="remarks"></a>備註  
 此成員函式會搜尋整個樹狀結構的子視窗，而不只是直屬子系的 windows。  
  
##  <a name="getdesktopwindow"></a>CWnd::GetDesktopWindow  
 傳回的 Windows 桌面視窗。  
  
```  
static CWnd* PASCAL GetDesktopWindow();
```  
  
### <a name="return-value"></a>傳回值  
 識別 Windows 桌面視窗。 此指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 桌面視窗涵蓋整個螢幕，而且是之上的所有圖示和其他視窗上漆所在的區域。  
  
##  <a name="getdlgctrlid"></a>CWnd::GetDlgCtrlID  
 會傳回任何子視窗、 視窗或控制項 ID 值不只是，在對話方塊中的控制項。  
  
```  
int GetDlgCtrlID() const;  
```  
  
### <a name="return-value"></a>傳回值  
 數值識別碼`CWnd`子視窗，如果函式成功，則為，否則為 0。  
  
### <a name="remarks"></a>備註  
 由於最上層視窗不會有的識別碼值，這個函式的傳回值不正確如果`CWnd`成為最上層視窗。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::OnCtlColor](#onctlcolor)。  
  
##  <a name="getdlgitem"></a>CWnd::GetDlgItem  
 擷取在對話方塊中指定的控制項或子視窗或其他視窗的指標。  
  
```  
CWnd* GetDlgItem(int nID) const;  
  
void GetDlgItem(
    int nID,  
    HWND* phWnd) const;  
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 指定要擷取控制項或子視窗的識別項。  
  
 `phWnd`  
 子視窗的指標。  
  
### <a name="return-value"></a>傳回值  
 指定的控制項或子視窗的指標。 如果沒有具有所指定的整數識別碼控制項`nID`參數存在，則值為**NULL**。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 傳回的指標通常控制項所識別的型別轉型`nID`。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 97](../../mfc/reference/codesnippet/cpp/cwnd-class_36.cpp)]  
  
##  <a name="getdlgitemint"></a>CWnd::GetDlgItemInt  
 擷取控制項所識別的文字`nID`。  
  
```  
UINT GetDlgItemInt(
    int nID,  
    BOOL* lpTrans = NULL,  
    BOOL bSigned = TRUE) const;  
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 指定要轉譯的對話方塊控制項的整數識別碼。  
  
 `lpTrans`  
 指向要接收已轉換的旗標的布林值變數。  
  
 `bSigned`  
 指定要擷取的值是否已經過簽署。  
  
### <a name="return-value"></a>傳回值  
 指定對話方塊中的項目文字的已翻譯的值。 0 是有效的傳回值，因為`lpTrans`必須用來偵測錯誤。 如果想要使用帶正負號的傳回值，轉換為`int`型別。  
  
 該函數會傳回 0，表示已轉換的數字大於 INT_MAX （適用於帶正負號的數字） 或 UINT_MAX （表示不帶正負號）。  
  
 發生錯誤時，發生非數字字元再超出上述的最大值，例如`GetDlgItemInt`複製到所指位置的 0 `lpTrans`。 如果沒有任何錯誤，`lpTrans`接收非零值。 如果`lpTrans`是**NULL**，`GetDlgItemInt`不是錯誤的相關警告。  
  
### <a name="remarks"></a>備註  
 它會在指定的對話方塊中指定之控制項的文字轉譯成整數值條狀配置任何額外的空格開頭的文字，並將轉換的十進位數字。 它會停止轉譯它到達文字末端，或在遇到任何非數字字元。  
  
 如果`bSigned`是**TRUE**，`GetDlgItemInt`檢查減號 （-） 開頭的文字，並將文字方塊轉譯成帶正負號的數字。 否則，它會建立一個不帶正負號的值。  
  
 它會傳送[WM_GETTEXT](http://msdn.microsoft.com/library/windows/desktop/ms632627)訊息至控制項。  
  
##  <a name="getdlgitemtext"></a>CWnd::GetDlgItemText  
 呼叫此成員函式可擷取的標題或在對話方塊中控制項相關聯的文字。  
  
```  
int GetDlgItemText(
    int nID,  
    LPTSTR lpStr,  
    int nMaxCount) const;  
  
int GetDlgItemText(
    int nID,  
    CString& rString) const;  
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 指定要擷取其標題控制項的整數識別碼。  
  
 `lpStr`  
 指向接收控制項的標題或文字緩衝區。  
  
 `nMaxCount`  
 指定要複製到字串的長度上限 （以字元為單位） `lpStr`。 如果字串長度超過`nMaxCount`，則會遭到截斷。  
  
 `rString`  
 若要參考[CString](../../atl-mfc-shared/reference/cstringt-class.md)。  
  
### <a name="return-value"></a>傳回值  
 指定實際的字元複製到緩衝區，不包括結束的 null 字元數。 如果文字不會複製，則值為 0。  
  
### <a name="remarks"></a>備註  
 `GetDlgItemText`成員函式會將文字複製到所指向的位置`lpStr`，並傳回複製的位元組數的計數。  
  
##  <a name="getdsccursor"></a>CWnd::GetDSCCursor  
 呼叫此成員函式可擷取基礎資料來源控制項的資料來源、 使用者名稱、 密碼和 SQL 屬性所定義的資料指標的指標。  
  
```  
IUnknown* GetDSCCursor();
```  
  
### <a name="return-value"></a>傳回值  
 定義資料來源控制項的資料指標的指標。 MFC 會負責呼叫`AddRef`指標。  
  
### <a name="remarks"></a>備註  
 若要設定的複雜資料繫結控制項，例如資料繫結方格控制項 ICursor 屬性使用傳回的指標。 資料來源控制項的作用中才會第一個繫結的控制項要求其資料指標。 這種情形是明確地呼叫`GetDSCCursor`或隱含地 MFC 繫結管理員。 在任一情況下，您可以強制藉由呼叫變成作用中的資料來源控制項`GetDSCCursor`，然後再呼叫**發行**上要傳回的指標**IUnknown**。 啟用會嘗試連接到基礎資料來源的資料來源控制項。 傳回的指標可能會用於下列內容︰  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFC_AxDataBinding # 1](../../mfc/reference/codesnippet/cpp/cwnd-class_6.cpp)]  
[!code-cpp[NVC_MFC_AxDataBinding # 5](../../mfc/reference/codesnippet/cpp/cwnd-class_37.cpp)]  
[!code-cpp[NVC_MFC_AxDataBinding # 3](../../mfc/reference/codesnippet/cpp/cwnd-class_8.cpp)]  
  
##  <a name="getdynamiclayout"></a>Cwnd:: Getdynamiclayout  
 擷取動態配置管理員物件的指標。  
  
```  
CMFCDynamicLayout* GetDynamicLayout();
```  
  
### <a name="return-value"></a>傳回值  
 動態配置管理員物件的指標，或是如果未啟用動態配置，則為 NULL。  
  
### <a name="remarks"></a>備註  
 視窗物件擁有及管理傳回的指標存留期，因此它只應該用來存取物件；請勿永久刪除指標或儲存指標。  
  
##  <a name="getexstyle"></a>CWnd::GetExStyle  
 傳回視窗的延伸樣式。  
  
```  
DWORD GetExStyle() const;  
```  
  
### <a name="return-value"></a>傳回值  
 視窗的延伸樣式。 如需在 MFC 中使用延伸的視窗樣式的詳細資訊，請參閱[延伸的視窗樣式](../../mfc/reference/extended-window-styles.md)。  
  
##  <a name="getfocus"></a>CWnd::GetFocus  
 擷取的指標`CWnd`的目前擁有輸入的焦點。  
  
```  
static CWnd* PASCAL GetFocus();
```  
  
### <a name="return-value"></a>傳回值  
 具有目前的焦點，視窗的指標或**NULL**如果沒有焦點視窗。  
  
 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
##  <a name="getfont"></a>CWnd::GetFont  
 傳送`WM_GETFONT`視窗訊息，以擷取目前的字型。  
  
```  
CFont* GetFont() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標[CFont](../../mfc/reference/cfont-class.md)物件附加至目前視窗的字型。  
  
### <a name="remarks"></a>備註  
 這個方法沒有作用，除非已處理的視窗`WM_GETFONT`訊息。 MFC 類別衍生自`CWnd`處理此訊息，因為它們附加至預先定義的視窗類別，其中包含的訊息處理常式`WM_GETFONT`訊息。 若要使用此方法，衍生自的`CWnd`必須定義方法的處理常式`WM_GETFONT`訊息。  
  
##  <a name="getforegroundwindow"></a>CWnd::GetForegroundWindow  
 讓指標回到前景視窗 （使用者目前使用的視窗）。  
  
```  
static CWnd* PASCAL GetForegroundWindow();
```  
  
### <a name="return-value"></a>傳回值  
 前景視窗的指標。 這可能是暫存`CWnd`物件。  
  
### <a name="remarks"></a>備註  
 前景視窗只適用於最上層視窗 （框架視窗或對話方塊）。  
  
##  <a name="geticon"></a>CWnd::GetIcon  
 呼叫此成員函式，以取得可能是大型 (32x32) 的控制代碼或小型 (16 x 16) 圖示的控制代碼所示`bBigIcon`。  
  
```  
HICON GetIcon(BOOL bBigIcon) const;  
```  
  
### <a name="parameters"></a>參數  
 `bBigIcon`  
 指定 32 像素 32 像素圖示，如果**TRUE**; 指定 16 像素 16 像素圖示，如果**FALSE**。  
  
### <a name="return-value"></a>傳回值  
 圖示的控制代碼。 如果不成功，傳回**NULL**。  
  
##  <a name="getlastactivepopup"></a>CWnd::GetLastActivePopup  
 判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。  
  
```  
CWnd* GetLastActivePopup() const;  
```  
  
### <a name="return-value"></a>傳回值  
 識別最活躍的快顯視窗。 傳回的值將是視窗本身，如果符合下列任何一個狀況︰  
  
-   視窗本身是最近啟用。  
  
-   視窗未擁有任何快顯視窗。  
  
-   視窗不是最上層視窗，或隸屬於另一個視窗。  
  
 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::FindWindow](#findwindow)。  
  
##  <a name="getlayeredwindowattributes"></a>CWnd::GetLayeredWindowAttributes  
 擷取分層視窗的不透明和透明色鍵。  
  
```  
BOOL GetLayeredWindowAttributes(
    COLORREF* pcrKey,  
    BYTE* pbAlpha,  
    DWORD* pdwFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 *pcrKey*  
 指標**COLORREF**接收撰寫層疊的視窗時使用的透明色彩索引鍵的值。 以此種色彩視窗所繪製的所有像素會為透明的。 這可以是**NULL**如果不需要引數。  
  
 `pbAlpha`  
 指標**位元組**接收用來描述層疊視窗的不透明度的 Alpha 值。 當變數所參考`pbAlpha`是 0，此視窗會完全透明。 當變數所參考`pbAlpha`為 255，視窗是不透明。 這可以是**NULL**如果不需要引數。  
  
 *pdwFlags*  
 指標`DWORD`接收分層旗標。 這可以是**NULL**如果不需要引數。 如需可能值的完整清單，請參閱[GetLayeredWindowAttributes](http://msdn.microsoft.com/library/windows/desktop/ms633508)。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetLayeredWindowAttributes](http://msdn.microsoft.com/library/windows/desktop/ms633508)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getmenu"></a>CWnd::GetMenu  
 擷取這個視窗功能表的指標。  
  
```  
CMenu* GetMenu() const;  
```  
  
### <a name="return-value"></a>傳回值  
 識別功能表。 值是**NULL**如果`CWnd`有沒有功能表。 如果傳回值未定義`CWnd`是子視窗。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 此函式不應為子視窗因為不會有功能表。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 98](../../mfc/reference/codesnippet/cpp/cwnd-class_38.cpp)]  
  
##  <a name="getmenubarinfo"></a>CWnd::GetMenuBarInfo  
 擷取指定的功能表列的相關資訊。  
  
```  
BOOL GetMenuBarInfo(
    LONG idObject,  
    LONG idItem,  
    PMENUBARINFO pmbi) const;  
```  
  
### <a name="parameters"></a>參數  
 `idObject`  
 指定功能表物件。 如需可能值的清單，請參閱[GetMenuBarInfo](http://msdn.microsoft.com/library/windows/desktop/ms647833)。  
  
 `idItem`  
 指定要擷取的資訊項目。 如果此參數為零，則此函數會擷取功能表本身的相關資訊。 如果這個參數是 1，此函數會擷取功能表上，等第一個項目的資訊。  
  
 *pmbi*  
 指標[MENUBARINFO](http://msdn.microsoft.com/library/windows/desktop/ms647564)接收資訊的結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetMenuBarInfo](http://msdn.microsoft.com/library/windows/desktop/ms647833)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getnextdlggroupitem"></a>CWnd::GetNextDlgGroupItem  
 搜尋上一個或下一個控制項 對話方塊中的控制項群組內。  
  
```  
CWnd* GetNextDlgGroupItem(
    CWnd* pWndCtl,  
    BOOL bPrevious = FALSE) const;  
  
COleControlSiteOrWnd* GetNextDlgGroupItem(
    COleControlSiteOrWnd* pCurSiteOrWnd = NULL) const;  
```  
  
### <a name="parameters"></a>參數  
 `pWndCtl`  
 識別要作為搜尋的起始點的控制項。  
  
 `bPrevious`  
 指定要搜尋控制項群組，在對話方塊中的函式的方式。 如果**TRUE**，如果函式會搜尋上一個控制項中群組; **FALSE**，它會搜尋群組中的下一個控制項。  
  
 `pCurSiteOrWnd`  
 識別**COleControlSiteOrWnd**控制項。 如需有關`COleControlSiteOrWnd`，請參閱**備註**。  
  
### <a name="return-value"></a>傳回值  
 上一個或下一個控制項中群組的成員函式成功時的指標。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 控制項群組的開頭所建立的控制項[WS_GROUP](../../mfc/reference/window-styles.md)樣式，且結尾為不使用建立的最後控制項**WS_GROUP**樣式。  
  
 根據預設，`GetNextDlgGroupItem`成員函式會傳回群組中的下一個控制項的指標。 如果`pWndCtl`識別群組中的第一個控制項和`bPrevious`是**TRUE**，`GetNextDlgGroupItem`傳回群組中的最後一個控制項的指標。  
  
> [!NOTE]
>  MFC 支援無視窗的 ActiveX 控制項、 標準 ActiveX 控制項和 windows，所以無法再參考只 HWND 控制項就夠了。 `COleControlSiteOrWnd`物件包含的資訊，如下所示為視窗型的 ActiveX 控制項、 將無視窗的 ActiveX 控制項或視窗中，識別的物件︰  
  
|控制項或視窗型別|識別資訊|  
|----------------------------|-----------------------------|  
|視窗型的 ActiveX 控制項|包含 HWND，並將相關聯[COleControlSite](../../mfc/reference/colecontrolsite-class.md)與它的物件。 `m_hWnd`隸屬`COleControlSiteOrWnd`設為控制項的 HWND 和**m_pSite**成員指向控制項的`COleControlSite`。|  
|無視窗的 ActiveX 控制項|未包含任何`HWND`。 **M_pSite**隸屬`COleControlSiteOrWnd`指向控制項的`COleControlSite`，而**m_hWnd**成員是**NULL**。|  
|標準的視窗|只包含`HWND`。 `m_hWnd`隸屬`COleControlSiteOrWnd`設`HWND`的視窗和**m_pSite**成員是**NULL**。|  
  
##  <a name="getnextdlgtabitem"></a>CWnd::GetNextDlgTabItem  
 擷取所建立的第一個控制項指標[WS_TABSTOP](window-styles.md)樣式和的前面或後面指定的控制項。  
  
```  
CWnd* GetNextDlgTabItem(
    CWnd* pWndCtl,  
    BOOL bPrevious = FALSE) const;  
  
COleControlSiteOrWnd* GetNextDlgTabItem(
    COleControlSiteOrWnd* pCurSiteOrWnd,  
    BOOL bPrevious) const;  
```  
  
### <a name="parameters"></a>參數  
 `pWndCtl`  
 識別要作為搜尋的起始點的控制項。  
  
 `pCurSiteOrWnd`  
 識別**COleControlSiteOrWnd**控制項。 如需有關`COleControlSiteOrWnd`，請參閱[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)。  
  
 `bPrevious`  
 指定要搜尋對話方塊中的函式的方式。 如果**TRUE**，如果函式會搜尋上一個控制項在對話方塊中; **FALSE**，它會搜尋下一個控制項。  
  
### <a name="return-value"></a>傳回值  
 具有的上一個或下一個控制項指標**WS_TABSTOP**樣式，如果此成員函式成功。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
 如需有關`COleControlSiteOrWnd`，請參閱[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)。  
  
##  <a name="getnextwindow"></a>CWnd::GetNextWindow  
 搜尋下一個 （或上一個） 視窗的視窗管理員清單中。  
  
```  
CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;  
```  
  
### <a name="parameters"></a>參數  
 `nFlag`  
 指定是否函式會傳回下一個視窗或前一個視窗的指標。 它可以是**GW_HWNDNEXT**，它會傳回遵循視窗`CWnd`視窗管理員清單上的物件或**GW_HWNDPREV**，視窗管理員清單上傳回的上一個視窗。  
  
### <a name="return-value"></a>傳回值  
 識別下一個 （或上一個） 視窗的視窗管理員清單成員函式是否成功。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 視窗管理員清單包含所有最上層視窗、 其相關聯的子視窗和任何子視窗的子視窗的項目。  
  
 如果`CWnd`是最上層視窗，函式搜尋下一個 （或舊版） 最上層視窗; 如果`CWnd`是子視窗，函式搜尋下一個 （或舊版） 子視窗。  
  
##  <a name="getolecontrolsite"></a>CWnd::GetOleControlSite  
 擷取指定的 ActiveX 控制項的自訂網站。  
  
```  
COleControlSite* GetOleControlSite(UINT idControl) const;  
```  
  
### <a name="parameters"></a>參數  
 `idControl`  
 ActiveX 控制項的識別碼。  
  
##  <a name="getopenclipboardwindow"></a>CWnd::GetOpenClipboardWindow  
 擷取目前已開啟剪貼簿的視窗控制代碼。  
  
```  
static CWnd* PASCAL GetOpenClipboardWindow();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功; 目前已開啟剪貼簿的視窗控制代碼否則**NULL**。  
  
##  <a name="getowner"></a>CWnd::GetOwner  
 擷取視窗的擁有者的指標。  
  
```  
CWnd* GetOwner() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CWnd`物件。  
  
### <a name="remarks"></a>備註  
 如果視窗有沒有擁有者，則會傳回預設的父視窗物件的指標。 請注意的擁有者和擁有之間的關聯性與父子式外觀，在數個重要層面。 例如，與父視窗會侷限於其父視窗的工作區。 擁有的 windows 可以繪製的任何位置，在桌面上。  
  
 此函式的擁有權概念是不同的擁有權概念[GetWindow](http://msdn.microsoft.com/library/windows/desktop/ms633515)。  
  
##  <a name="getparent"></a>CWnd::GetParent  
 呼叫此函式可取得子視窗的父視窗 （如果有的話） 的指標。  
  
```  
CWnd* GetParent() const;  
```  
  
### <a name="return-value"></a>傳回值  
 請參閱中的傳回值 」 一節[GetParent](http://msdn.microsoft.com/library/windows/desktop/ms633510)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 `GetParent`函式會傳回指標的直接父系 （如果有的話）。 相反地， [GetParentOwner](#getparentowner)函式傳回的指標不是子視窗的最立即父系或擁有者視窗 (並沒有**WS_CHILD**樣式)。 如果您有子視窗內的子視窗`GetParent`和`GetParentOwner`傳回不同的結果。  
  
##  <a name="getparentframe"></a>CWnd::GetParentFrame  
 呼叫此成員函式可擷取父框架視窗。  
  
```  
CFrameWnd* GetParentFrame() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果成功; 框架視窗的指標否則**NULL**。  
  
### <a name="remarks"></a>備註  
 成員函式會搜尋父鏈結，直到[CFrameWnd](../../mfc/reference/cframewnd-class.md) （或衍生類別中） 找到的物件。  
  
##  <a name="getparentowner"></a>CWnd::GetParentOwner  
 呼叫此成員函式可取得子視窗的父視窗或主控視窗的指標。  
  
```  
CWnd* GetParentOwner() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指標`CWnd`物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
### <a name="remarks"></a>備註  
 `GetParentOwner`傳回不是子視窗的最立即父系或擁有者視窗的指標 (沒有**WS_CHILD**樣式)。 目前的擁有者視窗可以設定與[SetOwner](#setowner)。 根據預設，在視窗的父代是其擁有者。  
  
 相反地， [GetParent](#getparent)函式會傳回指標的直接父系，是否不是子視窗。 如果您有子視窗內的子視窗`GetParent`和`GetParentOwner`傳回不同的結果。  
  
##  <a name="getproperty"></a>CWnd::GetProperty  
 呼叫此成員函式，以取得所指定的 ActiveX 控制項屬性`dwDispID`。  
  
```  
void GetProperty(
    DISPID dwDispID,  
    VARTYPE vtProp,  
    void* pvProp)const;  
```  
  
### <a name="parameters"></a>參數  
 `dwDispID`  
 識別要擷取的屬性。  
  
 `vtProp`  
 指定要擷取屬性的型別。 可能的值，請參閱 < 備註 > 一節[coledispatchdriver:: Invokehelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)。  
  
 `pvProp`  
 將這個變數的位址將會收到屬性值。 它必須符合所指定之類型`vtProp`。  
  
### <a name="remarks"></a>備註  
 **GetProperty**傳回值到`pvProp`。  
  
> [!NOTE]
>  應該只有在呼叫此函式`CWnd`物件，表示 ActiveX 控制項。  
  
 如需此成員函式使用 ActiveX 控制項容器的詳細資訊，請參閱文章[ActiveX 控制項容器︰ 在 ActiveX 控制項容器中程式設計 ActiveX 控制項](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。  
  
##  <a name="getrendertarget"></a>CWnd::GetRenderTarget  
 取得與此視窗相關聯的呈現目標。  
  
```  
CHwndRenderTarget* GetRenderTarget();
```  
  
### <a name="return-value"></a>傳回值  
 呈現目標或 NULL 指標。  
  
##  <a name="getsafehwnd"></a>CWnd::GetSafeHwnd  
 傳回`m_hWnd`，或**NULL**如果**這**指標**NULL**。  
  
```  
HWND GetSafeHwnd() const;  
```  
  
### <a name="return-value"></a>傳回值  
 傳回視窗的視窗控制代碼。 傳回**NULL**如果`CWnd`未附加至視窗或如果它搭配**NULL CWnd**指標。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::SubclassWindow](#subclasswindow)。  
  
##  <a name="getsafeowner"></a>CWnd::GetSafeOwner  
 呼叫此成員函式可擷取主控視窗應該用於對話方塊或其他的強制回應視窗。  
  
```  
static CWnd* GetSafeOwner(
    CWnd* pParent = NULL,  
    HWND* pWndTop = NULL);
```  
  
### <a name="parameters"></a>參數  
 `pParent`  
 父代的指標`CWnd`視窗。 可能是**NULL**。  
  
 *pWndTop*  
 目前位於最上方的視窗的指標。 可能是**NULL**。  
  
### <a name="return-value"></a>傳回值  
 安全的擁有者指定視窗的指標。  
  
### <a name="remarks"></a>備註  
 安全的擁有者是第一個非子系的父視窗的`pParent`。 如果`pParent`是**NULL**，執行緒的主視窗 (透過擷取[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)) 用來尋找擁有者。  
  
> [!NOTE]
>  架構本身會使用這個函式，以判斷正確的主控視窗對話方塊和屬性工作表，未指定擁有者。  
  
##  <a name="getscrollbarctrl"></a>Cwnd:: Getscrollbarctrl  
 呼叫此成員函式，來取得指向指定的同層級捲軸或分隔視窗。  
  
```  
virtual CScrollBar* GetScrollBarCtrl(int nBar) const;  
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定捲軸類型。 參數可以採用下列值之一︰  
  
- **SB_HORZ**擷取水平捲軸的位置。  
  
- **SB_VERT**擷取垂直捲軸的位置。  
  
### <a name="return-value"></a>傳回值  
 同層級捲軸控制項，或**NULL**如果 none。  
  
### <a name="remarks"></a>備註  
 此成員函式無法運作時所建立的捲軸上**WS_HSCROLL**或**WS_VSCROLL**視窗的建立期間所設定的位元。 `CWnd`此函式的實作只會傳回**NULL**。 衍生類別，例如`CView`，實作所述的功能。  
  
##  <a name="getscrollbarinfo"></a>CWnd::GetScrollBarInfo  
 擷取所指定之捲軸的相關資訊。  
  
```  
BOOL GetScrollBarInfo(
    LONG idObject,  
    PSCROLLBARINFO psbi) const;  
```  
  
### <a name="parameters"></a>參數  
 `idObject`  
 指定功能表物件。 如需可能值的清單，請參閱[GetScrollBarInfo](http://msdn.microsoft.com/library/windows/desktop/bb787581)。  
  
 *psbi*  
 指標[SCROLLBARINFO](http://msdn.microsoft.com/library/windows/desktop/bb787535)接收資訊的結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetScrollBarInfo](http://msdn.microsoft.com/library/windows/desktop/bb787581)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getscrollinfo"></a>CWnd::GetScrollInfo  
 呼叫此成員函式，以擷取資訊的`SCROLLINFO`結構維護的捲軸相關。  
  
```  
BOOL GetScrollInfo(
    int nBar,  
    LPSCROLLINFO lpScrollInfo,  
    UINT nMask = SIF_ALL);
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定捲軸控制項或視窗之非工作區的一部分。 如果是中, 非工作區的一部分`nBar`也會指出是否捲軸置於水平、 垂直或兩者。 它必須是下列其中一項︰  
  
- **SB_CTL**擷取捲軸控制項的參數。 `m_hWnd`資料僝磟饡瑢捲軸控制項的控制代碼。  
  
- **SB_HORZ**擷取視窗的標準水平捲軸的參數。  
  
- **SB_VERT**擷取視窗的標準的垂直捲軸的參數。  
  
 `lpScrollInfo`  
 指標[SCROLLINFO](http://msdn.microsoft.com/library/windows/desktop/bb787537)結構。 請參閱[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需有關這個結構。  
  
 `nMask`  
 指定要擷取的捲軸列參數。 預設值是指定的組合**SIF_PAGE**， **SIF_POS**， **SIF_TRACKPOS**，和**SIF_RANGE**。 請參閱`SCROLLINFO`如需有關*nMask*值。  
  
### <a name="return-value"></a>傳回值  
 如果訊息擷取的任何值，傳回是**TRUE**。 否則，它是**FALSE**。  
  
### <a name="remarks"></a>備註  
 `GetScrollInfo`讓應用程式使用 32 位元捲動位置。  
  
 [SCROLLINFO](http://msdn.microsoft.com/library/windows/desktop/bb787537)結構包含捲軸，包括最小值和最大值捲動位置、 頁面大小和捲軸方塊 （捲動方塊） 的位置的相關資訊。 請參閱`SCROLLINFO`結構中的主題[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需有關變更結構的預設值。  
  
 MFC 視窗訊息處理常式，以指出捲軸位置[CWnd::OnHScroll](#onhscroll)和[CWnd::OnVScroll](#onvscroll)，提供只有 16 位元的位置資料。 `GetScrollInfo`和`SetScrollInfo`提供 32 位元的捲軸位置資料。 因此，應用程式可以呼叫`GetScrollInfo`處理其中時`CWnd::OnHScroll`或`CWnd::OnVScroll`取得 32 位元的捲軸位置資料。  
  
##  <a name="getscrolllimit"></a>CWnd::GetScrollLimit  
 呼叫此成員函式可擷取最大捲軸的捲動位置。  
  
```  
int GetScrollLimit(int nBar);
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定捲軸類型。 參數可以採用下列值之一︰  
  
- **SB_HORZ**擷取水平捲軸的捲動限制。  
  
- **SB_VERT**擷取垂直捲軸的捲動限制。  
  
### <a name="return-value"></a>傳回值  
 指定成功; 如果捲軸的最大位置否則便是 0。  
  
##  <a name="getscrollpos"></a>CWnd::GetScrollPos  
 擷取捲軸的捲動方塊的目前位置。  
  
```  
int GetScrollPos(int nBar) const;  
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定捲軸來檢查。 參數可以採用下列值之一︰  
  
- **SB_HORZ**擷取水平捲軸的位置。  
  
- **SB_VERT**擷取垂直捲軸的位置。  
  
### <a name="return-value"></a>傳回值  
 指定成功; 如果捲軸的捲動方塊目前的位置否則便是 0。  
  
### <a name="remarks"></a>備註  
 目前的位置是取決於目前的捲動範圍的相對值。 例如，如果捲動的範圍是 50 到 100 的捲動方塊位於列中間，目前位置為 75。  
  
##  <a name="getscrollrange"></a>CWnd::GetScrollRange  
 將目前的給定的捲軸的最小和最大捲軸位置複製到指定的位置`lpMinPos`和`lpMaxPos`。  
  
```  
void GetScrollRange(
    int nBar,  
    LPINT lpMinPos,  
    LPINT lpMaxPos) const;  
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定捲軸來檢查。 參數可以採用下列值之一︰  
  
- **SB_HORZ**擷取水平捲軸的位置。  
  
- **SB_VERT**擷取垂直捲軸的位置。  
  
 `lpMinPos`  
 指向要接收的最小位置的整數變數。  
  
 `lpMaxPos`  
 指向要接收的最大位置的整數變數。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`沒有捲軸，然後在`GetScrollRange`成員函式會複製 0 到`lpMinPos`和`lpMaxPos`。  
  
 標準的捲軸的預設範圍是 0 到 100。 捲軸控制項的預設範圍是空的 （這兩個值是 0）。  
  
##  <a name="getstyle"></a>CWnd::GetStyle  
 傳回目前的視窗樣式。  
  
```  
DWORD GetStyle() const;  
```  
  
### <a name="return-value"></a>傳回值  
 視窗的樣式。 如需在 MFC 中使用的視窗樣式的詳細資訊，請參閱[視窗樣式](../../mfc/reference/window-styles.md)。  
  
##  <a name="getsystemmenu"></a>CWnd::GetSystemMenu  
 可讓應用程式存取控制功能表以進行複製和修改。  
  
```  
CMenu* GetSystemMenu(BOOL bRevert) const;  
```  
  
### <a name="parameters"></a>參數  
 `bRevert`  
 指定要採取的動作。 如果`bRevert`是**FALSE**，`GetSystemMenu`傳回一份目前使用中的控制項功能表的控制代碼。 此複本與在控制項功能表相同，但是可以修改。 如果`bRevert`是**TRUE**，`GetSystemMenu`將控制功能表以重設回預設狀態。 如果任何項目，會終結之前，可能已經過修改，控制功能表上。 傳回值未在此情況下定義。  
  
### <a name="return-value"></a>傳回值  
 識別控制項功能表中的複本，如果`bRevert`是**FALSE**。 如果`bRevert`是**TRUE**，傳回值會是未定義。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 不使用任何視窗`GetSystemMenu`功能表讓它自己的控制項複本接收標準控制項功能表。  
  
 傳回的指標`GetSystemMenu`成員函式可以搭配[CMenu::AppendMenu](../../mfc/reference/cmenu-class.md#appendmenu)， [CMenu::InsertMenu](../../mfc/reference/cmenu-class.md#insertmenu)，或[CMenu::ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu)函式來變更控制項功能表。  
  
 控制項功能表一開始只包含項目，例如使用不同的識別碼值識別**SC_CLOSE**， **SC_MOVE**，和**SC_SIZE**。 在 [控制項] 功能表上的項目產生[WM_SYSCOMMAND](#onsyscommand)訊息。 所有預先定義的控制項功能表項目具有大於 0xF000 ID 編號。 如果應用程式會將項目加入至 [控制] 功能表，它應該使用小於 F000 識別碼數字。  
  
 Windows 可能會自動使項目無法使用標準控制項功能表。 `CWnd`可以自己選取項目或無法使用藉由完成回應[WM_INITMENU](#oninitmenu)就會顯示任何功能表之前傳送出去的訊息。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 99](../../mfc/reference/codesnippet/cpp/cwnd-class_39.cpp)]  
  
##  <a name="gettitlebarinfo"></a>CWnd::GetTitleBarInfo  
 擷取指定之標題列的相關資訊。  
  
```  
BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;  
```  
  
### <a name="parameters"></a>參數  
 *pti*  
 指標[TITLEBARINFO](http://msdn.microsoft.com/library/windows/desktop/ms632608)接收資訊的結構。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetTitleBarInfo](http://msdn.microsoft.com/library/windows/desktop/ms633513)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="gettoplevelframe"></a>CWnd::GetTopLevelFrame  
 呼叫此成員函式可擷取視窗的上層框架視窗中，如果有的話。  
  
```  
CFrameWnd* GetTopLevelFrame() const;  
```  
  
### <a name="return-value"></a>傳回值  
 識別視窗的最上層框架視窗。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`沒有附加的視窗，或不是其最上層的父代[CFrameWnd](../../mfc/reference/cframewnd-class.md)-衍生物件，此函數會傳回**NULL**。  
  
##  <a name="gettoplevelowner"></a>CWnd::GetTopLevelOwner  
 呼叫此成員函式可擷取的最上層視窗。  
  
```  
CWnd* GetTopLevelOwner() const;  
```  
  
### <a name="return-value"></a>傳回值  
 識別的最上層視窗。 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 最上層的視窗為桌面的子系的視窗。 如果`CWnd`有任何附加的視窗，此函數會傳回**NULL**。  
  
##  <a name="gettoplevelparent"></a>CWnd::GetTopLevelParent  
 呼叫此成員函式，以擷取視窗的最上層的父代。  
  
```  
CWnd* GetTopLevelParent() const;  
```  
  
### <a name="return-value"></a>傳回值  
 識別視窗的最上層的父視窗。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 `GetTopLevelParent`類似於[GetTopLevelFrame](#gettoplevelframe)和[GetTopLevelOwner](#gettoplevelowner); 不過，它會忽略為目前的擁有者視窗設定的值。  
  
##  <a name="gettopwindow"></a>CWnd::GetTopWindow  
 搜尋所屬的最上層的子視窗`CWnd`。  
  
```  
CWnd* GetTopWindow() const;  
```  
  
### <a name="return-value"></a>傳回值  
 識別在最上層的子視窗`CWnd`子視窗的連結的清單。 如果不存在任何子視窗，這個值是**NULL**。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`有任何子系，此函數會傳回**NULL**。  
  
##  <a name="getupdaterect"></a>CWnd::GetUpdateRect  
 擷取完全圍住更新區域的最小矩形座標。  
  
```  
BOOL GetUpdateRect(
    LPRECT lpRect,  
    BOOL bErase = FALSE);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向`CRect`物件或[RECT 結構](../../mfc/reference/rect-structure1.md)以接收更新圍住更新區域的用戶端座標。  
  
 這個參數設定為**NULL**來判斷是否更新區域會出現在`CWnd`。 如果`lpRect`是**NULL**、`GetUpdateRect`成員函式傳回非零，如果更新區域存在，而且如果有一個 0 並不會。 這種方式來判斷是否`WM_PAINT`訊息導致無效的區域。 未設定此參數為**NULL** 3.0 或更早版本 Windows 中。  
  
 `bErase`  
 指定是否要清除的背景更新區域中。  
  
### <a name="return-value"></a>傳回值  
 指定更新區域的狀態。 值為非零，如果更新區域不是空的。否則便是 0。  
  
 如果`lpRect`參數設定為**NULL**，則傳回值是更新區域是否有非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`以建立**CS_OWNDC**樣式和的對應模式不是`MM_TEXT`、`GetUpdateRect`成員函式提供矩形的邏輯座標。 否則，`GetUpdateRect`可讓用戶端中的矩形座標。 如果沒有任何更新區域，`GetUpdateRect`設定為空白 （設定座標都為 0） 的矩形。  
  
 `bErase`參數會指定是否`GetUpdateRect`應該清除更新區域的背景。 如果`bErase`是**TRUE**並不是空的更新區域，背景會被清除。 若要清除的背景，`GetUpdateRect`傳送[WM_ERASEBKGND](#onerasebkgnd)訊息。  
  
 更新矩形擷取[BeginPaint](#beginpaint)成員函式是相同的擷取`GetUpdateRect`成員函式。  
  
 `BeginPaint`成員函式會自動驗證更新區域，所以任何呼叫至`GetUpdateRect`呼叫之後立即進行`BeginPaint`擷取空的更新區域。  
  
##  <a name="getupdatergn"></a>CWnd::GetUpdateRgn  
 擷取更新區域到區域，由`pRgn`。  
  
```  
int GetUpdateRgn(
    CRgn* pRgn,  
    BOOL bErase = FALSE);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 識別更新區域。  
  
 `bErase`  
 指定是否將清除的背景，以及將繪製子視窗的非工作區。 如果值為**FALSE**，不完成任何繪圖。  
  
### <a name="return-value"></a>傳回值  
 指定的短整數旗標，指出產生的區域類型。 值可以採取下列其中一項動作︰  
  
- **SIMPLEREGION**區域有任何重疊的框線。  
  
- **COMPLEXREGION**區域具有重疊的框線。  
  
- **NULLREGION**區域是空白。  
  
- **錯誤**已建立的任何區域。  
  
### <a name="remarks"></a>備註  
 此區域的座標是相對於左上角 （座標）。  
  
 [BeginPaint](#beginpaint)成員函式會自動驗證更新區域，所以任何呼叫至`GetUpdateRgn`呼叫之後立即進行`BeginPaint`擷取空的更新區域。  
  
##  <a name="getwindow"></a>CWnd::GetWindow  
 將指標傳回至要求，在視窗或**NULL**如果 none。  
  
```  
CWnd* GetWindow(UINT nCmd) const;  
```  
  
### <a name="parameters"></a>參數  
 `nCmd`  
 指定之間的關聯性`CWnd`和傳回的視窗。 它可以接受下列值之一︰  
  
- **GW_CHILD**識別`CWnd`第一個子視窗。  
  
- **GW_HWNDFIRST**如果`CWnd`是子視窗，會傳回第一個同層級視窗。 否則，它會傳回第一個最上層的視窗清單中。  
  
- **GW_HWNDLAST**如果`CWnd`是子視窗，會傳回最後一個同層級視窗。 否則，會傳回清單中的最後一個最上層視窗。  
  
- **GW_HWNDNEXT**傳回視窗管理員清單上的下一個視窗。  
  
- **GW_HWNDPREV**傳回視窗管理員清單上的上一個視窗。  
  
- **GW_OWNER**識別`CWnd`擁有者。  
  
### <a name="return-value"></a>傳回值  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
##  <a name="getwindowcontexthelpid"></a>CWnd::GetWindowContextHelpId  
 呼叫此成員函式可擷取的說明內容識別碼，如果任何項目，與視窗相關聯。  
  
```  
DWORD GetWindowContextHelpId() const;  
```  
  
### <a name="return-value"></a>傳回值  
 說明內容識別碼。 如果視窗並沒有任何會傳回 0。  
  
##  <a name="getwindowedchildcount"></a>CWnd::GetWindowedChildCount  
 呼叫此成員函式可擷取相關聯的子視窗的數目。  
  
```  
long GetWindowedChildCount();
```  
  
### <a name="return-value"></a>傳回值  
 與相關聯的子視窗數目`CWnd`物件。  
  
##  <a name="getwindowdc"></a>Cwnd:: Getwindowdc  
 擷取整個視窗中，包括標題列、 功能表和捲軸的顯示內容。  
  
```  
CDC* GetWindowDC();
```  
  
### <a name="return-value"></a>傳回值  
 識別特定視窗的顯示內容，如果函式成功。否則**NULL**。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。 [ReleaseDC](#releasedc)應該每次成功呼叫一次呼叫`GetWindowDC`。  
  
### <a name="remarks"></a>備註  
 視窗顯示內容允許在任何位置繪製`CWnd`，因為內容的來源的左上角`CWnd`而不是工作區。  
  
 預設屬性會指派給顯示內容，它會擷取內容每次。 先前的屬性都會遺失。  
  
 `GetWindowDC`適用於在特殊的繪製效果`CWnd`中非工作區。 不要繪製任何視窗的非工作區中。  
  
 [GetSystemMetrics](http://msdn.microsoft.com/library/windows/desktop/ms724385) Windows 函式可以用來擷取非工作區，例如標題列、 功能表和捲軸的各個組件的維度。  
  
 繪製完成之後， [ReleaseDC](#releasedc)釋放顯示內容，必須呼叫成員函式。 要釋放的顯示內容的失敗會嚴重影響由於可同時開啟的裝置內容的數目限制的應用程式要求的繪製。  
  
##  <a name="getwindowinfo"></a>CWnd::GetWindowInfo  
 擷取視窗的相關資訊。  
  
```  
BOOL GetWindowInfo(PWINDOWINFO pwi) const;  
```  
  
### <a name="parameters"></a>參數  
 *pwi*  
 指標[WINDOWINFO](http://msdn.microsoft.com/library/windows/desktop/ms632610)結構。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[GetWindowInfo](http://msdn.microsoft.com/library/windows/desktop/ms633516)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="getwindowlesschildcount"></a>CWnd::GetWindowlessChildCount  
 擷取相關聯的無視窗子視窗數目。  
  
```  
long GetWindowlessChildCount();
```  
  
### <a name="return-value"></a>傳回值  
 與相關聯的無視窗子視窗數目`CWnd`物件。  
  
##  <a name="getwindowplacement"></a>CWnd::GetWindowPlacement  
 擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。  
  
```  
BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpwndpl`  
 指向`WINDOWPLACEMENT`接收顯示狀態和位置資訊的結構。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 **旗標**隸屬[WINDOWPLACEMENT](../../mfc/reference/windowplacement-structure.md)這個函式所擷取的結構一定是 0。 如果`CWnd`最大化**showCmd**隸屬`WINDOWPLACEMENT`是**sw_showmaximized 其中一個**。 如果視窗最小化，則**SW_SHOWMINIMIZED。** 它是**SW_SHOWNORMAL**否則。  
  
##  <a name="getwindowrect"></a>CWnd::GetWindowRect  
 將複製的週框矩形的尺寸`CWnd`指向的物件結構`lpRect`。  
  
```  
void GetWindowRect(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向`CRect`物件或[RECT 結構](../../mfc/reference/rect-structure1.md)，將會收到的左上角和右下角的螢幕座標。  
  
### <a name="remarks"></a>備註  
 維度會提供在螢幕座標中相對於顯示畫面的左上角。 維度的標題、 框線和捲軸，如果有的話，會包含。  
  
##  <a name="getwindowrgn"></a>CWnd::GetWindowRgn  
 呼叫此成員函式，以取得視窗的視窗區域。  
  
```  
int GetWindowRgn(HRGN hRgn)const;  
```  
  
### <a name="parameters"></a>參數  
 `hRgn`  
 視窗區域控制代碼。  
  
### <a name="return-value"></a>傳回值  
 傳回值會指定的區域，這個函數會取得型別。 它可以是下列值之一︰  
  
- **NULLREGION**區域是空白。  
  
- **SIMPLEREGION**區域是一個矩形。  
  
- **COMPLEXREGION**區域是一個以上的矩形。  
  
- **錯誤**發生錯誤，則會受影響的區域。  
  
### <a name="remarks"></a>備註  
 視窗區域判斷作業系統其中允許繪製視窗內的區域。 作業系統不會顯示在視窗的視窗區域外部的任何部分。  
  
 視窗的視窗區域的座標是相對於視窗，而非工作區視窗的左上角。  
  
 若要設定的視窗區域的視窗，呼叫[CWnd::SetWindowRgn](#setwindowrgn)。  
  
##  <a name="getwindowtext"></a>CWnd::GetWindowText  
 複製`CWnd`標題標題 （如果有的話） 所指向的緩衝區`lpszStringBuf`或插入目的地字串`rString`。  
  
```  
int GetWindowText(
    LPTSTR lpszStringBuf,  
    int nMaxCount) const;  
  
void GetWindowText(
    CString& rString) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpszStringBuf`  
 指向要接收的視窗的標題所複製的字串的緩衝區。  
  
 `nMaxCount`  
 指定要複製到緩衝區，包括結束的 null 字元的字元數目上限。 如果字串中指定的字元數超過`nMaxCount`，則會遭到截斷。  
  
 `rString`  
 A [CString](../../atl-mfc-shared/reference/cstringt-class.md)要接收的視窗的標題所複製的字串的物件。  
  
### <a name="return-value"></a>傳回值  
 指定長度，以複製的字串，不包括結束的 null 字元的字元為單位。 如果是 0`CWnd`沒有標題或標題是空的。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`物件是一個控制項，`GetWindowText`成員函式會將複製的文字，而不要複製標題控制項內。  
  
 此成員函式會導致[WM_GETTEXT](http://msdn.microsoft.com/library/windows/desktop/ms632627)訊息傳送至`CWnd`物件。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::SetWindowText](#setwindowtext)。  
  
##  <a name="getwindowtextlength"></a>CWnd::GetWindowTextLength  
 傳回的長度`CWnd`物件標題的標題。  
  
```  
int GetWindowTextLength() const;  
```  
  
### <a name="return-value"></a>傳回值  
 指定以字元為單位，不包括任何 null 結束字元的文字長度。 如果沒有這類文字存在，則值為 0。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`是一個控制項，`GetWindowTextLength`成員函式會傳回而不是標題控制項中文字的長度。  
  
 此成員函式會導致[WM_GETTEXTLENGTH](http://msdn.microsoft.com/library/windows/desktop/ms632628)訊息傳送至`CWnd`物件。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::SetWindowText](#setwindowtext)。  
  
##  <a name="hidecaret"></a>CWnd::HideCaret  
 藉由從顯示畫面移除插入號來隱藏該插入號。  
  
```  
void HideCaret();
```  
  
### <a name="remarks"></a>備註  
 雖然不會再顯示插入號，就會顯示一次使用[ShowCaret](#showcaret)成員函式。 隱藏插入號不會終結其目前的圖形。  
  
 隱藏是累計的。 如果`HideCaret`呼叫的五倍的資料列，`ShowCaret`成員函式前，必須呼叫五次時，會顯示插入號。  
  
##  <a name="hilitemenuitem"></a>CWnd::HiliteMenuItem  
 反白顯示，或從最上層 （功能表列） 的功能表項目移除反白顯示。  
  
```  
BOOL HiliteMenuItem(
    CMenu* pMenu,  
    UINT nIDHiliteItem,  
    UINT nHilite);
```  
  
### <a name="parameters"></a>參數  
 `pMenu`  
 識別包含要反白顯示的項目最上層功能表。  
  
 `nIDHiliteItem`  
 指定功能表項目會反白顯示，根據的值`nHilite`參數。  
  
 `nHilite`  
 指定功能表項目會反白顯示或移除反白顯示。 它可以是項目的組合**MF_HILITE**或**MF_UNHILITE**與**MF_BYCOMMAND**或**MF_BYPOSITION**。 值可以使用位元 OR 運算子結合起來。 這些值具有下列意義︰  
  
- **MF_BYCOMMAND** Interprets`nIDHiliteItem`為功能表項目 ID （預設解譯）。  
  
- **MF_BYPOSITION** Interprets`nIDHiliteItem`功能表項目的以零為起始的位移。  
  
- **MF_HILITE**會反白顯示的項目。 如果沒有指定這個值，反白顯示，會移除從項目。  
  
- **MF_UNHILITE**從項目移除反白顯示。  
  
### <a name="return-value"></a>傳回值  
 指定功能表項目是否已反白顯示。 為非零，如果項目已反白顯示。否則便是 0。  
  
### <a name="remarks"></a>備註  
 **MF_HILITE**和**MF_UNHILITE**旗標只能搭配此成員函式; 它們不能與[CMenu::ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu)成員函式。  
  
##  <a name="htmlhelp"></a>CWnd::HtmlHelp  
 呼叫此成員函式叫用 HTMLHelp 應用程式。  
  
```  
virtual void HtmlHelp(
    DWORD_PTR dwData,  
    UINT nCmd = 0x000F);
```  
  
### <a name="parameters"></a>參數  
 `dwData`  
 指定其他資料。 所使用的值取決於值`nCmd`參數。  
  
 `nCmd`  
 指定要求的說明類型。 如需可能的值，以及它們如何影響`dwData`參數，請參閱`uCommand`HTML 說明 API 中的參考中所述的參數[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 請參閱[CWinApp::HtmlHelp](../../mfc/reference/cwinapp-class.md#htmlhelp)如需詳細資訊。  
  
##  <a name="initdynamiclayout"></a>CWnd::InitDynamicLayout  
 由架構呼叫以初始化視窗的動態配置。  
  
```  
void InitDynamicLayout();
```  
  
### <a name="remarks"></a>備註  
 請勿直接呼叫這個方法。  
  
##  <a name="invalidate"></a>CWnd::Invalidate  
 使整個工作區`CWnd`。  
  
```  
void Invalidate(BOOL bErase = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bErase`  
 指定是否要清除的背景更新區域內。  
  
### <a name="remarks"></a>備註  
 工作區已標示為繪製時的下一步 [WM_PAINT](#onpaint)就會出現訊息。 區域也之前先驗證`WM_PAINT`訊息發生[ValidateRect](#validaterect)或[ValidateRgn](#validatergn)成員函式。  
  
 `bErase`參數會指定是否要處理的更新區域時清除背景更新區域內。 如果`bErase`是**TRUE**，背景會被清除時[BeginPaint](#beginpaint)呼叫成員函式; 如果`bErase`是**FALSE**，背景會維持不變。 如果`bErase`是**TRUE**更新區域的任何部分，在整個區域中，不只是在特定的組件，背景會被清除。  
  
 Windows 會傳送[WM_PAINT](#onpaint)每當訊息`CWnd`更新區域不是空白，且該視窗的應用程式佇列中沒有其他訊息。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::UpdateWindow](#updatewindow)。  
  
##  <a name="invalidaterect"></a>CWnd::InvalidateRect  
 藉由新增該矩形內，才能使給定矩形內的用戶端區域`CWnd`更新區域。  
  
```  
void InvalidateRect(
    LPCRECT lpRect,  
    BOOL bErase = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向`CRect`物件或[RECT 結構](../../mfc/reference/rect-structure1.md)包含要加入到更新區域的矩形 （用戶端座標表示）。 如果`lpRect`是**NULL**，整個工作區加入到區域中。  
  
 `bErase`  
 指定是否要清除的背景更新區域內。  
  
### <a name="remarks"></a>備註  
 失效的矩形，以及所有的其他區域中更新區域中，標示為進行繪製時的下一步 [WM_PAINT](#onpaint)傳送訊息。 失效的區域會累積更新區域中，直到處理區域時在下一個`WM_PAINT`呼叫發生，或直到區域所驗證的[ValidateRect](#validaterect)或[ValidateRgn](#validatergn)成員函式。  
  
 `bErase`參數會指定是否要處理的更新區域時清除背景更新區域內。 如果`bErase`是**TRUE**，背景會被清除時[BeginPaint](#beginpaint)呼叫成員函式; 如果`bErase`是**FALSE**，背景會維持不變。 如果`bErase`是**TRUE**更新區域的任何部分，整個區域的背景會被清除，不只是在特定的組件。  
  
 Windows 會傳送[WM_PAINT](#onpaint)每當訊息`CWnd`更新區域不是空白，且該視窗的應用程式佇列中沒有其他訊息。  
  
##  <a name="invalidatergn"></a>CWnd::InvalidateRgn  
 使給定區域內的工作區加入至目前的更新區域的`CWnd`。  
  
```  
void InvalidateRgn(
    CRgn* pRgn,  
    BOOL bErase = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 指標[CRgn](../../mfc/reference/crgn-class.md)物件，可識別要加入到更新區域的區域。 區域會假設用戶端座標。 如果這個參數是**NULL**，整個工作區加入到更新區域。  
  
 `bErase`  
 指定是否要清除的背景更新區域內。  
  
### <a name="remarks"></a>備註  
 失效的區域，以及所有的其他區域中更新區域中，標示為進行繪製時[WM_PAINT](#onpaint)接著傳送訊息。 失效的區域會累積更新區域中，直到處理區域時`WM_PAINT`接下來會傳送訊息，或直到區域經過[ValidateRect](#validaterect)或[ValidateRgn](#validatergn)成員函式。  
  
 `bErase`參數會指定是否要處理的更新區域時清除背景更新區域內。 如果`bErase`是**TRUE**，背景會被清除時[BeginPaint](#beginpaint)呼叫成員函式; 如果`bErase`是**FALSE**，背景會維持不變。 如果`bErase`是**TRUE**更新區域的任何部分，在整個區域中，不只是在特定的組件，背景會被清除。  
  
 Windows 會傳送[WM_PAINT](#onpaint)每當訊息`CWnd`更新區域不是空白，且該視窗的應用程式佇列中沒有其他訊息。  
  
 給定的區域必須擁有先前所建立的區域函式。  
  
##  <a name="invokehelper"></a>CWnd::InvokeHelper  
 呼叫此成員函式叫用的 ActiveX 控制項方法或屬性所指定`dwDispID`，所指定的內容中`wFlags`。  
  
```  
void AFX_CDECL InvokeHelper(
    DISPID dwDispID,  
    WORD wFlags,  
    VARTYPE vtRet,  
    void* pvRet,  
    const BYTE* pbParamInfo,  
 ...);
```  
  
### <a name="parameters"></a>參數  
 `dwDispID`  
 指定所要叫用的屬性或方法。  
  
 `wFlags`  
 描述要呼叫 **IDispatch::Invoke**時之內容的旗標。  
  
 `vtRet`  
 指定傳回值的類型。 可能的值，請參閱 < 備註 > 一節[coledispatchdriver:: Invokehelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)。  
  
 `pvRet`  
 將接收的屬性值，將這個變數的位址，或傳回值。 其必須符合 `vtRet`所指定的類型。  
  
 `pbParamInfo`  
 指定以 null終止，並尾隨在 `pbParamInfo`之後之參數類型的位元組的字串指標。 可能的值，請參閱 < 備註 > 一節`COleDispatchDriver::InvokeHelper`。  
  
 *...*  
 在指定的型別參數的變數清單`pbParamInfo`。  
  
### <a name="remarks"></a>備註  
 `pbParamInfo` 參數會指定傳遞給方法或屬性的參數類型。 引數的變數清單由*...*語法宣告。  
  
 此函式會將轉換的參數**VARIANTARG**值，然後再叫用**idispatch:: Invoke** ActiveX 控制項的方法。 如果呼叫**idispatch:: Invoke**失敗，此函式將會擲回例外狀況。 如果`SCODE`（狀態碼） 所傳回**idispatch:: Invoke**是`DISP_E_EXCEPTION`，此函式會擲回[COleException](../../mfc/reference/coleexception-class.md)物件，否則會擲回[COleDispatchException](../../mfc/reference/coledispatchexception-class.md)。  
  
> [!NOTE]
>  應該只有在呼叫此函式`CWnd`物件，表示 ActiveX 控制項。  
  
 如需此成員函式使用 ActiveX 控制項容器的詳細資訊，請參閱文章[ActiveX 控制項容器︰ 在 ActiveX 控制項容器中程式設計 ActiveX 控制項](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。  
  
##  <a name="ischild"></a>CWnd::IsChild  
 表示視窗是否指定由`pWnd`是子視窗，還是的其他直屬下階`CWnd`。  
  
```  
BOOL IsChild(const CWnd* pWnd) const;  
```  
  
### <a name="parameters"></a>參數  
 `pWnd`  
 識別要測試視窗。  
  
### <a name="return-value"></a>傳回值  
 指定函式的結果。 值為非零，如果所識別的視窗`pWnd`是子視窗的`CWnd`; 否則為 0。  
  
### <a name="remarks"></a>備註  
 子視窗是的直接下階`CWnd`如果`CWnd`物件是在父視窗的鏈結中，會導致從原始的快顯視窗的子視窗。  
  
##  <a name="isd2dsupportenabled"></a>CWnd::IsD2DSupportEnabled  
 決定是否啟用 D2D 支援。  
  
```  
BOOL IsD2DSupportEnabled();
```  
  
### <a name="return-value"></a>傳回值  
 如果已啟用的功能，則為 TRUE否則為 FALSE。  
  
##  <a name="isdialogmessage"></a>CWnd::IsDialogMessage  
 呼叫以判斷給定的訊息是否適用於非強制回應對話方塊; 此成員函式如果是，此函式會處理訊息。  
  
```  
BOOL IsDialogMessage(LPMSG lpMsg);
```  
  
### <a name="parameters"></a>參數  
 `lpMsg`  
 指向[MSG](../../mfc/reference/msg-structure1.md)結構，其中包含要檢查的訊息。  
  
### <a name="return-value"></a>傳回值  
 指定此成員函式是否已處理指定的訊息。 如果已處理訊息，就會為非零，否則便是 0。 傳回為 0，如果呼叫[cwnd:: Pretranslatemessage](#pretranslatemessage)來處理訊息的基底類別成員函式。 中的覆寫`CWnd::PreTranslateMessage`成員函式程式碼看起來像這樣︰  
  
 [!code-cpp[NVC_MFCWindowing # 100](../../mfc/reference/codesnippet/cpp/cwnd-class_40.cpp)]  
  
### <a name="remarks"></a>備註  
 當`IsDialogMessage`函式處理訊息時，它會檢查鍵盤訊息並將它們轉換成對應的對話方塊中的選取範圍命令。 例如，TAB 鍵選取下一個控制項或群組的控制項，並向下鍵選取群組中的下一個控制項。  
  
 您必須傳遞所處理的訊息`IsDialogMessage`至[TranslateMessage](http://msdn.microsoft.com/library/windows/desktop/ms644955)或[DispatchMessage](http://msdn.microsoft.com/library/windows/desktop/ms644934) Windows 函式，因為它已經處理。  
  
##  <a name="isdlgbuttonchecked"></a>CWnd::IsDlgButtonChecked  
 決定按鈕控制項是否擁有它旁邊的核取記號。  
  
```  
UINT IsDlgButtonChecked(int nIDButton) const;  
```  
  
### <a name="parameters"></a>參數  
 `nIDButton`  
 指定按鈕控制項的整數識別碼。  
  
### <a name="return-value"></a>傳回值  
 如果會檢查指定的控制項，則為非零，0，如果未核取。 只有選項按鈕，可以選取核取方塊。 三種狀態的按鈕，傳回值可以是 2，如果不確定 按鈕。 此成員函式會傳回 0 的按鈕。  
  
### <a name="remarks"></a>備註  
 如果按鈕是三種狀態控制項，此成員函式判斷是否就會呈暗灰色，選取此選項，或兩者都關閉。  
  
##  <a name="isdynamiclayoutenabled"></a>Cwnd:: Isdynamiclayoutenabled  
 決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。  
  
```  
BOOL IsDynamicLayoutEnabled() const;  
```  
  
### <a name="return-value"></a>傳回值  
 如果啟用動態配置則為 TRUE，否則為 FALSE。  
  
### <a name="remarks"></a>備註  
  
##  <a name="isiconic"></a>CWnd::IsIconic  
 指定是否`CWnd`降到最低 （圖示）。  
  
```  
BOOL IsIconic() const;  
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果`CWnd`最小化; 否則為 0。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]  
  
##  <a name="istouchwindow"></a>CWnd::IsTouchWindow  
 指定 `CWnd` 是否有觸控支援。  
  
```  
BOOL IsTouchWindow() const;  
```  
  
### <a name="return-value"></a>傳回值  
 `TRUE`如果`CWnd`有觸控支援; 否則`FALSE`。  
  
### <a name="remarks"></a>備註  
  
##  <a name="iswindowenabled"></a>CWnd::IsWindowEnabled  
 指定是否`CWnd`滑鼠和鍵盤輸入已啟用。  
  
```  
BOOL IsWindowEnabled() const;  
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果`CWnd`已啟用; 否則為 0。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 102](../../mfc/reference/codesnippet/cpp/cwnd-class_42.cpp)]  
  
##  <a name="iswindowvisible"></a>CWnd::IsWindowVisible  
 判斷指定的視窗的可見性狀態。  
  
```  
BOOL IsWindowVisible() const;  
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果`CWnd`可見 (具有[WS_VISIBLE](../../mfc/reference/window-styles.md)樣式位元集，以及父視窗為可見)。 因為傳回的值反映出狀態**WS_VISIBLE**樣式位元，傳回的值可能為非零，即使`CWnd`完全遮住其他視窗。  
  
### <a name="remarks"></a>備註  
 視窗擁有所指定的可見性狀態**WS_VISIBLE**樣式位元。 當此樣式位元設定呼叫[ShowWindow](#showwindow)成員函式，會顯示和後續的繪圖，視窗會顯示，只要在視窗有樣式位元集。  
  
 視窗具有任何繪圖**WS_VISIBLE**如果涵蓋的其他 windows 視窗，或由其父視窗會裁剪，將不會顯示樣式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 103](../../mfc/reference/codesnippet/cpp/cwnd-class_43.cpp)]  
  
##  <a name="iszoomed"></a>CWnd::IsZoomed  
 決定是否`CWnd`已經最大化。  
  
```  
BOOL IsZoomed() const;  
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果`CWnd`最大化; 否則為 0。  
  
##  <a name="killtimer"></a>CWnd::KillTimer  
 刪除所識別的計時器事件`nIDEvent`从早先的电话`SetTimer`。  
  
```  
BOOL KillTimer(UINT_PTR nIDEvent);
```  
  
### <a name="parameters"></a>參數  
 `nIDEvent`  
 計時器事件的值傳遞至[SetTimer](#settimer)。  
  
### <a name="return-value"></a>傳回值  
 指定函式的結果。 此值為非零，如果已清除的事件。 如果是 0`KillTimer`成員函式找不到指定的計時器事件。  
  
### <a name="remarks"></a>備註  
 暫止[WM_TIMER](#ontimer)計時器相關聯的訊息不會從訊息佇列中移除。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::SetTimer](#settimer)。  
  
##  <a name="loaddynamiclayoutresource"></a>CWnd::LoadDynamicLayoutResource  
 由架構呼叫以從資源檔載入動態配置資訊。  
  
```  
BOOL LoadDynamicLayoutResource(LPCTSTR lpszResourceName);
```  
  
### <a name="parameters"></a>參數  
 `lpszResourceName`  
 包含此視窗所需之動態配置資訊的資源名稱。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則為非零。 如果發生失敗，則為 0。  
  
### <a name="remarks"></a>備註  
 請勿直接呼叫這個方法。  
  
##  <a name="lockwindowupdate"></a>CWnd::LockWindowUpdate  
 在給定視窗中繪製停用。  
  
```  
BOOL LockWindowUpdate();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則為非零。 它會是 0，如果發生失敗或`LockWindowUpdate`函式已用來鎖定另一個視窗。  
  
### <a name="remarks"></a>備註  
 無法移動鎖定的視窗。 只有一個視窗可以鎖定一次。 若要解除鎖定與鎖定的視窗`LockWindowUpdate`，呼叫[UnlockWindowUpdate](#unlockwindowupdate)。  
  
 如果鎖定的視窗 （或任何鎖定的子視窗） 的應用程式呼叫[GetDC，](http://msdn.microsoft.com/library/windows/desktop/dd144871) [GetDCEx，](http://msdn.microsoft.com/library/windows/desktop/dd144873)或[BeginPaint](http://msdn.microsoft.com/library/windows/desktop/dd183362) Windows 函式，呼叫的函式會傳回其可見的區域是空的裝置內容。 藉由呼叫應用程式解除鎖定的視窗之前，會發生此情況`UnlockWindowUpdate`成員函式。  
  
 視窗更新鎖定後，系統會追蹤的任何繪圖作業的鎖定視窗相關聯的裝置內容的週框矩形。 時重新繪製，這個週框矩形失效中鎖定的視窗，並強制最終其子視窗[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)更新螢幕的訊息。 如果沒有繪圖發生視窗更新已鎖定時，不含區域將會失效。  
  
 `LockWindowUpdate`成員函式不會讓指定的視窗變成不可見，並不會清除[WS_VISIBLE](../../mfc/reference/window-styles.md)樣式位元。  
  
##  <a name="m_hwnd"></a>CWnd::m_hWnd  
 Windows 視窗的控制代碼附加至此`CWnd`。  
  
```  
HWND m_hWnd;  
```  
  
### <a name="remarks"></a>備註  
 `m_hWnd`資料成員是類型的公用變數`HWND`。  
  
##  <a name="mapwindowpoints"></a>CWnd::MapWindowPoints  
 將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。  
  
```  
void MapWindowPoints(
    CWnd* pwndTo,  
    LPRECT lpRect) const;  
  
void MapWindowPoints(
    CWnd* pwndTo,  
    LPPOINT lpPoint,  
    UINT nCount) const;  
```  
  
### <a name="parameters"></a>參數  
 *pwndTo*  
 識別點轉換成視窗。 如果這個參數是**NULL**，轉換為螢幕座標的點。  
  
 `lpRect`  
 指定的點是要轉換的矩形。 只有 Windows 3.1 和更新版本使用此函式的第一個版本。  
  
 `lpPoint`  
 陣列的指標[POINT 結構](../../mfc/reference/point-structure1.md)，包含要轉換的點集合。  
  
 `nCount`  
 指定的數目**點**所指陣列中的結構`lpPoint`。  
  
##  <a name="messagebox"></a>CWnd::MessageBox  
 建立並顯示視窗，其中包含應用程式所提供的訊息和標題，再加上預先定義的圖示與按鈕中所述的組合[訊息方塊樣式](../../mfc/reference/message-box-styles.md)清單。  
  
```  
int MessageBox(
    LPCTSTR lpszText,  
    LPCTSTR lpszCaption = NULL,  
    UINT nType = MB_OK);
```  
  
### <a name="parameters"></a>參數  
 `lpszText`  
 指向`CString`物件或 null 結束的字串，包含要顯示的訊息。  
  
 `lpszCaption`  
 指向`CString`物件或 null 結束的字串，用於訊息方塊標題。 如果`lpszCaption`是**NULL**，用 「 錯誤 」 的預設標題。  
  
 `nType`  
 指定的內容和訊息方塊的行為。  
  
### <a name="return-value"></a>傳回值  
 這個方法會利用[MessageBox](http://msdn.microsoft.com/library/windows/desktop/ms645505)函式中所定義[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 這個方法會傳回呼叫此函式的結果。  
  
### <a name="remarks"></a>備註  
 使用全域函式[AfxMessageBox](../../mfc/reference/cstring-formatting-and-message-box-display.md#afxmessagebox)而不是此成員函式，在您的應用程式中實作的訊息方塊。  
  
 下圖顯示可用在訊息方塊中的各種系統圖示︰  
  
|||  
|-|-|  
|![停止 (x) 圖示](../../mfc/reference/media/vc364f1.gif "vc364f1")|**MB_ICONHAND**， **MB_ICONSTOP**，和**MB_ICONERROR**|  
|![說明 （） 圖示](../../mfc/reference/media/vc364f2.gif "vc364f2")|**MB_ICONQUESTION**|  
|![重要 （！） 圖示](../../mfc/reference/media/vc364f3.gif "vc364f3")|**MB_ICONEXCLAMATION**和**MB_ICONWARNING**|  
|![資訊 (i) 圖示](../../mfc/reference/media/vc364f4.gif "vc364f4")|**MB_ICONASTERISK**和**MB_ICONINFORMATION**|  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 104](../../mfc/reference/codesnippet/cpp/cwnd-class_44.cpp)]  
  
##  <a name="modifystyle"></a>CWnd::ModifyStyle  
 呼叫此成員函式來修改視窗的樣式。  
  
```  
BOOL ModifyStyle(
    DWORD dwRemove,  
    DWORD dwAdd,  
    UINT nFlags = 0);
```  
  
### <a name="parameters"></a>參數  
 `dwRemove`  
 指定要移除樣式修改期間的視窗樣式。  
  
 `dwAdd`  
 指定要新增樣式修改期間的視窗樣式。  
  
 `nFlags`  
 旗標，以傳遞至[SetWindowPos](#setwindowpos)，或如果`SetWindowPos`不應呼叫。 預設值是零。 請參閱 < 備註 > 一節清單的預設旗標。  
  
### <a name="return-value"></a>傳回值  
 如果已成功修改樣式; 非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 加入或移除樣式可以結合使用位元 OR (|) 運算子。 請參閱主題[視窗樣式](http://msdn.microsoft.com/library/windows/desktop/ms632600)和[CreateWindow](http://msdn.microsoft.com/library/windows/desktop/ms632679)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需有關可用的視窗樣式資訊。  
  
 如果`nFlags`非零，`ModifyStyle`呼叫 Windows API 函式[SetWindowPos](http://msdn.microsoft.com/library/windows/desktop/ms633545)並結合重新繪製視窗`nFlags`與下列四個預設旗標︰  
  
- `SWP_NOSIZE`會保留目前的大小。  
  
- `SWP_NOMOVE`會保留目前的位置。  
  
- `SWP_NOZORDER`會保留目前的 Z 順序。  
  
- `SWP_NOACTIVATE`不會啟動視窗。  
  
 若要修改視窗的延伸樣式，請參閱[ModifyStyleEx](#modifystyleex)。  
  
> [!NOTE]
>  在某些控制項中的某些樣式 ( **ES_READONLY**中編輯控制項，例如樣式)， **ModifyStyle**可能不正確地變更樣式因為控制項可能需要執行特殊的內部處理。 在這些情況下，對應的訊息，若要變更樣式可 ( **EM_SETREADONLY**在範例中所述)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 105](../../mfc/reference/codesnippet/cpp/cwnd-class_45.cpp)]  
  
##  <a name="modifystyleex"></a>CWnd::ModifyStyleEx  
 呼叫此成員函式來修改視窗的延伸的樣式。  
  
```  
BOOL ModifyStyleEx(
    DWORD dwRemove,  
    DWORD dwAdd,  
    UINT nFlags = 0);
```  
  
### <a name="parameters"></a>參數  
 `dwRemove`  
 指定要移除樣式修改期間的延伸的樣式。  
  
 `dwAdd`  
 指定要新增樣式修改期間的延伸的樣式。  
  
 `nFlags`  
 旗標，以傳遞至[SetWindowPos](#setwindowpos)，或如果`SetWindowPos`不應呼叫。 預設值是零。 請參閱 < 備註 > 一節清單的預設旗標。  
  
### <a name="return-value"></a>傳回值  
 如果已成功修改樣式; 非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 加入或移除樣式可以結合使用位元 OR (|) 運算子。 請參閱主題[延伸的視窗樣式](../../mfc/reference/extended-window-styles.md)這個活頁簿中和[CreateWindowEx](http://msdn.microsoft.com/library/windows/desktop/ms632680)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]可用的相關資訊的延伸樣式  
  
 如果`nFlags`非零，`ModifyStyleEx`呼叫 Windows API 函式[SetWindowPos](http://msdn.microsoft.com/library/windows/desktop/ms633545)並結合重新繪製視窗`nFlags`與下列四個預設旗標︰  
  
- `SWP_NOSIZE`會保留目前的大小。  
  
- `SWP_NOMOVE`會保留目前的位置。  
  
- `SWP_NOZORDER`會保留目前的 Z 順序。  
  
- `SWP_NOACTIVATE`不會啟動視窗。  
  
 若要修改 windows 的一般視窗樣式，請參閱[ModifyStyle](#modifystyle)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 106](../../mfc/reference/codesnippet/cpp/cwnd-class_46.cpp)]  
  
##  <a name="movewindow"></a>CWnd::MoveWindow  
 變更大小和位置。  
  
```  
void MoveWindow(
    int x,  
    int y,  
    int nWidth,  
    int nHeight,  
    BOOL bRepaint = TRUE);

 
void MoveWindow(
    LPCRECT lpRect,
    BOOL bRepaint = TRUE);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新位置的左半部`CWnd`。  
  
 *y*  
 指定新位置上方的`CWnd`。  
  
 `nWidth`  
 指定新的寬度`CWnd`。  
  
 `nHeight`  
 指定新的高度`CWnd`。  
  
 `bRepaint`  
 指定是否`CWnd`會重新繪製。 如果**TRUE**，`CWnd`接收[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)訊息中其[OnPaint](#onpaint)如往常般訊息處理常式。 如果這個參數是**FALSE**、 任何種類的不重新繪製時發生。 這適用於用戶端區域、 非工作區 （包括標題和捲軸），以及未涵蓋範圍的父任何的視窗部分`CWnd`的移動。 當此參數是**FALSE**，應用程式必須明確失效或重新繪製的任何部分`CWnd`和父視窗，必須重新繪製。  
  
 `lpRect`  
 [CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](../../mfc/reference/rect-structure1.md)，指定新的大小和位置。  
  
### <a name="remarks"></a>備註  
 上層`CWnd`物件*x*和*y*參數都是相對於螢幕左上角。 子`CWnd`物件中，相對於父視窗工作區左上角。  
  
 `MoveWindow`函式傳送[WM_GETMINMAXINFO](#ongetminmaxinfo)訊息。 處理此訊息提供`CWnd`有機會修改最大和最小可能 windows 的預設值。 如果參數`MoveWindow`成員函式超過這些值，這些值可能會取代中的最小值或最大值`WM_GETMINMAXINFO`處理常式。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::ClientToScreen](#clienttoscreen)。  
  
##  <a name="notifywinevent"></a>CWnd::NotifyWinEvent  
 表示發生預先定義之事件的系統。 如果任何用戶端應用程式註冊了事件的攔截函式，系統就會呼叫用戶端的攔截函式。  
  
```  
void NotifyWinEvent(
    DWORD event,  
    LONG idObjectType,  
    LONG idObject);
```  
  
### <a name="parameters"></a>參數  
 `event`  
 指定發生的事件。 此值必須是其中[事件常數](http://msdn.microsoft.com/library/windows/desktop/dd318066)。  
  
 *idObjectType*  
 識別產生事件的物件種類。 這個值是其中一個預先定義[物件識別項](http://msdn.microsoft.com/library/windows/desktop/dd373606)或自訂物件的識別碼值。  
  
 `idObject`  
 識別產生事件的物件或物件的子元素。 如果此值為**CHILDID_SELF**，物件本身所產生的事件。 如果沒有，此值是產生事件的項目子系識別碼。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[NotifyWinEvent](http://msdn.microsoft.com/library/windows/desktop/dd373603)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="onactivate"></a>CWnd::OnActivate  
 架構會呼叫此成員函式時`CWnd`物件正在啟動或停用。  
  
```  
afx_msg void OnActivate(
    UINT nState,  
    CWnd* pWndOther,  
    BOOL bMinimized);
```  
  
### <a name="parameters"></a>參數  
 `nState`  
 指定是否`CWnd`啟動或停用。 它可以是下列值之一︰  
  
- **WA_INACTIVE**視窗正在停用。  
  
- **WA_ACTIVE**視窗正在被啟動透過某些方法以外 （例如，藉由使用的鍵盤介面，以選取的視窗） 中按一下滑鼠。  
  
- **WA_CLICKACTIVE**滑鼠點按正在啟用視窗。  
  
 *pWndOther*  
 指標`CWnd`正在啟動或停用。 指標可以是**NULL**，並可能是暫時性。  
  
 *bMinimized*  
 指定的最小化的狀態`CWnd`正在啟動或停用。 值為**TRUE**指出視窗最小化。  
  
 如果**TRUE**、`CWnd`正在被啟動; 否則為停用。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`物件啟動按一下滑鼠，它也會收到[OnMouseActivate](#onmouseactivate)成員函式呼叫。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onactivateapp"></a>CWnd::OnActivateApp  
 架構會呼叫此成員函式給所有最上層視窗啟動的工作與工作已停用的所有最上層視窗。  
  
```  
afx_msg void OnActivateApp(
    BOOL bActive,  
    DWORD dwThreadID);
```  
  
### <a name="parameters"></a>參數  
 `bActive`  
 指定是否`CWnd`啟動或停用。 **TRUE**表示`CWnd`正在啟用。 **FALSE**表示`CWnd`正在停用。  
  
 *dwThreadID*  
 指定之值的執行緒識別碼。 如果`bActive`是**TRUE**， *dwThreadID*識別擁有的執行緒`CWnd`正在停用。 如果`bActive`是**FALSE**， *dwThreadID*識別擁有的執行緒`CWnd`正在啟用。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onambientproperty"></a>CWnd::OnAmbientProperty  
 架構會呼叫此成員函式，從包含 OLE 控制項的視窗取得環境屬性值。  
  
```  
virtual BOOL OnAmbientProperty(
    COleControlSite* pSite,  
    DISPID dispid,  
    VARIANT* pvar);
```  
  
### <a name="parameters"></a>參數  
 `pSite`  
 要求環境屬性的控制項的站台的指標。  
  
 `dispid`  
 要求的環境屬性的分派識別碼。  
  
 `pvar`  
 呼叫端配置的指標`VARIANT`結構，透過將傳回環境的屬性值。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**支援環境的屬性; 如果**FALSE**如果不是。  
  
### <a name="remarks"></a>備註  
 覆寫這個函式來變更的預設的 OLE 控制項容器環境屬性值傳回給它的控制項。 覆寫的函式不會處理任何環境屬性要求應該被轉送到基底類別實作。  
  
##  <a name="onappcommand"></a>CWnd::OnAppCommand  
 使用者產生應用程式命令事件時，架構會呼叫此成員函式。 這類事件發生於使用者按一下應用程式的命令按鈕或類型應用程式的命令按鍵時。  
  
```  
afx_msg void OnAppCommand(
    CWnd* pWnd,  
    UINT nCmd,  
    UINT nDevice,  
    UINT nKey);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `pWnd`|指標`CWnd`物件，代表的視窗，其中使用者已按下命令按鈕或按下命令按鍵。 此視窗可以是子視窗的視窗接收訊息。|  
|[in] `nCmd`|表示應用程式命令。 如需可能值的清單，請參閱底下的命令*cmd*區段`lParam`參數[WM_APPCOMMAND](http://msdn.microsoft.com/library/windows/desktop/ms646275)。|  
|[in] `nDevice`|產生的輸入的事件的輸入的裝置。 如需可能值的清單，請參閱下的裝置*uDevice*區段`lParam`參數[WM_APPCOMMAND](http://msdn.microsoft.com/library/windows/desktop/ms646275)。|  
|[in] `nKey`|表示已關機、 CTRL 鍵或滑鼠左的按鈕等任何虛擬按鍵。 如需可能值的清單，請參閱下方的索引鍵*dwKeys*區段`lParam`參數[WM_APPCOMMAND](http://msdn.microsoft.com/library/windows/desktop/ms646275)。 如需詳細資訊，請參閱中的 「 訊息參數 」 子標題[有關滑鼠輸入](http://msdn.microsoft.com/library/windows/desktop/ms645601)。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_APPCOMMAND](http://msdn.microsoft.com/library/windows/desktop/ms646275)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onaskcbformatname"></a>CWnd::OnAskCbFormatName  
 當剪貼簿包含資料控制代碼時，架構會呼叫此成員函式`CF_OWNERDISPLAY`格式化 （也就是當剪貼簿擁有者，將顯示剪貼簿內容）。  
  
```  
afx_msg void OnAskCbFormatName(
    UINT nMaxCount,  
    LPTSTR lpszString);
```  
  
### <a name="parameters"></a>參數  
 `nMaxCount`  
 指定要複製位元組的數目上限。  
  
 `lpszString`  
 指向要儲存副本的格式名稱緩衝區。  
  
### <a name="remarks"></a>備註  
 剪貼簿擁有者應該提供它的格式的名稱。  
  
 覆寫此成員函式和複製名稱`CF_OWNERDISPLAY`格式到指定的緩衝區不超過指定的位元組數目上限。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oncancelmode"></a>CWnd::OnCancelMode  
 架構會呼叫此成員函式，以通知`CWnd`取消任何內部的模式。  
  
```  
afx_msg void OnCancelMode();
```  
  
### <a name="remarks"></a>備註  
 如果`CWnd`物件具有焦點，其`OnCancelMode`顯示對話方塊或訊息方塊時，呼叫成員函式。 這可讓`CWnd`取消模式，例如滑鼠捕捉的機會。  
  
 預設實作會藉由呼叫回應[ReleaseCapture](http://msdn.microsoft.com/library/windows/desktop/ms646261) Windows 函式。 覆寫此成員函式，在衍生類別處理其他模式。  
  
##  <a name="oncapturechanged"></a>CWnd::OnCaptureChanged  
 架構會呼叫此成員函式，以通知正失去滑鼠捕捉的視窗。  
  
```  
afx_msg void OnCaptureChanged(CWnd* pWnd);
```  
  
### <a name="parameters"></a>參數  
 `pWnd`  
 若要獲得滑鼠捕捉視窗的指標  
  
### <a name="remarks"></a>備註  
 視窗收到這個訊息，即使它會呼叫[ReleaseCapture](http://msdn.microsoft.com/library/windows/desktop/ms646261)本身。 應用程式不應嘗試設定滑鼠擷取，以回應這個訊息。 當它收到這個訊息時，視窗應該重繪其本身，如有必要，以反映新的滑鼠擷取狀態。  
  
 請參閱[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]有關`ReleaseCapture`Windows 函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onchangecbchain"></a>CWnd::OnChangeCbChain  
 架構會呼叫此成員函式以通知它，正在從鏈結移除視窗的剪貼簿檢視器鏈結中每一個視窗。  
  
```  
afx_msg void OnChangeCbChain(
    HWND hWndRemove,  
    HWND hWndAfter);
```  
  
### <a name="parameters"></a>參數  
 `hWndRemove`  
 指定正在從剪貼簿檢視器鏈結中移除的視窗控制代碼。  
  
 `hWndAfter`  
 指定遵循正在從剪貼簿檢視器鏈結中移除的視窗的視窗控制代碼。  
  
### <a name="remarks"></a>備註  
 每個`CWnd`物件，可接收`OnChangeCbChain`呼叫中，應該使用[SendMessage](http://msdn.microsoft.com/library/windows/desktop/ms644950) Windows 函式以傳送[WM_CHANGECBCHAIN](http://msdn.microsoft.com/library/windows/desktop/ms649019)剪貼簿檢視器鏈結中下一個視窗的訊息 (所傳回的控制代碼`SetClipboardViewer`)。 如果`hWndRemove`是由所指定視窗鏈結中的下一個視窗`hWndAfter`成為下一個視窗，和剪貼簿訊息會傳遞給它。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onchangeuistate"></a>CWnd::OnChangeUIState  
 應變更使用者介面 (UI) 狀態時呼叫。  
  
```  
afx_msg void OnChangeUIState(
    UINT nAction,  
    UINT nUIElement);
```  
  
### <a name="parameters"></a>參數  
 `nAction`  
 指定要採取的動作。 可為下列其中一個值：  
  
- **UIS_CLEAR** UI 狀態項目 (所指定`nUIElement`) 應該隱藏。  
  
- **UIS_INITIALIZE** UI 狀態項目 (所指定`nUIElement`) 應該變更為根據的最後一個輸入的事件。 如需詳細資訊，請參閱**備註**區段[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342)。  
  
- **UIS_SET** UI 狀態項目 (所指定`nUIElement`) 應該為可見的。  
  
 `nUIElement`  
 指定受影響的 UI 狀態項目或控制項的樣式。 可為下列其中一個值：  
  
- **UISF_HIDEACCEL**鍵盤快速鍵。  
  
- **UISF_HIDEFOCUS**專注指標。  
  
- **UISF_ACTIVE Windows XP:**控制項應該繪製在使用中控制項所使用的樣式。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬的功能[WM_CHANGEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646342)訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="onchar"></a>CWnd::OnChar  
 按鍵轉譯為非系統字元時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnChar(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 包含索引鍵的字元程式碼值。  
  
 `nRepCnt`  
 包含的重複計數的按鍵會重複，當使用者按住按鍵的次數。  
  
 `nFlags`  
 包含掃描程式碼、 索引鍵轉換程式碼、 前一個索引鍵的狀態，與內容的程式碼，如下列清單所示︰  
  
|值|意義|  
|-----------|-------------|  
|0-15|指定的重複計數。 值是使用者按住鍵，因此重複按鍵的次數。|  
|16-23|指定的掃描程式碼。 值取決於原始設備製造商 (OEM)|  
|24|指定索引鍵是否延伸的金鑰，例如增強 101 或 102 鍵鍵盤會出現右 ALT 和 CTRL 鍵。 值為 1，如果它是擴充的金鑰;否則，它可以是 0。|  
|25-28|Windows 在內部使用。|  
|29|指定的內容程式碼。 值為 1，如果按下按鍵; 時，按住 ALT 鍵否則，值為 0。|  
|30|指定前一個索引鍵的狀態。 值為 1，如果索引鍵已關閉，才能傳送訊息，或如果機碼設定為 0。|  
|31|指定的轉換狀態。 值為 1，如果索引鍵將被釋放，或如果被按下按鍵，則會是 0。|  
  
### <a name="remarks"></a>備註  
 此函式之前，會呼叫[OnKeyUp](#onkeyup)成員函式及之後[OnKeyDown](#onkeydown)呼叫成員函式。 `OnChar`包含所按下或釋放的鍵盤按鍵的值。  
  
 因為有不一定是一對一對應已按下的索引鍵之間和`OnChar`產生呼叫中的資訊`nFlags`但通常不實用的應用程式。 中的資訊`nFlags`只適用於最新呼叫`OnKeyUp`成員函式或`OnKeyDown`成員函式之前呼叫`OnChar`。  
  
 IBM 增強 101 和 102 鍵鍵盤、 增強的金鑰為右 alt 鍵與右 CTRL 鍵鍵盤; 的主要區段單元、 DEL、 HOME、 END、 PAGE UP、 PAGE DOWN 和箭號左邊的數字鍵台; 在叢集的索引鍵斜線 （/） 和數字鍵台 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元`nFlags`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onchartoitem"></a>CWnd::OnCharToItem  
 當清單方塊呼叫[LBS_WANTKEYBOARDINPUT](../../mfc/reference/list-box-styles.md)樣式會傳送其擁有者[WM_CHARTOITEM](http://msdn.microsoft.com/library/windows/desktop/bb761358)訊息以回應[WM_CHAR](#onchar)訊息。  
  
```  
afx_msg int OnCharToItem(
    UINT nChar,  
    CListBox* pListBox,  
    UINT nIndex);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定的使用者按下的索引鍵的值。  
  
 `pListBox`  
 指定清單方塊的指標。 它可能是暫時性。  
  
 `nIndex`  
 指定目前插入號位置。  
  
### <a name="return-value"></a>傳回值  
 架構會呼叫此成員函式，來指定要呼叫的回應中的應用程式執行的動作。 – 2 的傳回值會指出應用程式處理所有層面的選取項目，並想要在清單方塊的任何進一步的動作。 傳回值-1 表示清單方塊應該執行的預設動作，以回應按鍵。 傳回大於或等於 0 的值清單方塊中指定的項目以零為起始的索引，並指出清單方塊應該對指定的項目上的按鍵動作執行預設動作。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onchildactivate"></a>CWnd::OnChildActivate  
 如果`CWnd`物件是在多個文件介面 (MDI) 子視窗`OnChildActivate`是當使用者按一下視窗的標題列，由架構呼叫或啟動視窗時，移動或調整大小。  
  
```  
afx_msg void OnChildActivate();
```  
  
##  <a name="onchildnotify"></a>On_xxx_reflect  
 此視窗的父視窗收到此視窗的通知訊息時，會呼叫此成員函式。  
  
```  
virtual BOOL OnChildNotify(
    UINT message,  
    WPARAM wParam,  
    LPARAM lParam,  
    LRESULT* pResult);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 Windows 訊息編號，傳送至父視窗。  
  
 `wParam`  
 **Wparam**與訊息相關聯。  
  
 `lParam`  
 **Lparam**與訊息相關聯。  
  
 `pLResult`  
 從父系的視窗程序傳回值的指標。 此指標會**NULL**如果卻沒有傳回值。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果這個視窗會負責處理訊息傳送給其父代。否則便是 0。  
  
### <a name="remarks"></a>備註  
 永遠不會直接呼叫此成員函式。  
  
 此成員函式的預設實作會傳回 0，表示父代應該處理訊息。  
  
 覆寫此成員函式，以擴充控制項通知訊息至回應的方式。  
  
##  <a name="onclipboardupdate"></a>CWnd::OnClipboardUpdate  
 剪貼簿內容已變更時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnClipboardUpdate();
```  
  
##  <a name="onclose"></a>CWnd::OnClose  
 架構會呼叫此成員函式的信號，`CWnd`或應用程式已終止。  
  
```  
afx_msg void OnClose();
```  
  
### <a name="remarks"></a>備註  
 預設實作會呼叫`DestroyWindow`。  
  
##  <a name="oncolorizationcolorchanged"></a>CWnd::OnColorizationColorChanged  
 當非工作區的轉譯原則已變更時，架構會呼叫這個成員。  
  
```  
afx_msg void OnColorizationColorChanged(
    DWORD dwColorizationColor,   
    BOOL bOpacity);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `dwColorizationColor`|指定新的顏色標示色彩。<br /><br /> 色彩格式是十六進位數字的表單 0xAARRGGBB，其中每四個元件範圍從 0x00 到 0xFF。 AA 元件是 alpha 值、 RR 是紅色、 GG 為綠色，、 BB 是藍色。|  
|[in] `bOpacity`|`true`如果新的色彩會與不透明度; 混合`false`如果不是。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_DWMNCRENDERINGCHANGED](http://msdn.microsoft.com/library/windows/desktop/dd388198)通知訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oncommand"></a>CWnd::OnCommand  
 當使用者會選取功能表項目或快速鍵的按鍵輸入會轉譯子控制項來傳送通知訊息時，架構會呼叫此成員函式。  
  
```  
virtual BOOL OnCommand(
    WPARAM wParam,  
    LPARAM lParam);
```  
  
### <a name="parameters"></a>參數  
 `wParam`  
 低序位字組的`wParam`識別功能表項目、 控制項或快速鍵的命令識別碼。 高序位字組的`wParam`指定通知訊息，如果訊息是從控制項。 如果訊息是來自加速器，高序位文字會是 1。 如果訊息是從功能表中，高序位文字會是 0。  
  
 `lParam`  
 識別訊息是否從控制項傳送訊息的控制項。 否則，`lParam`為 0。  
  
### <a name="return-value"></a>傳回值  
 應用程式會傳回非零，如果它會處理此訊息。否則便是 0。  
  
### <a name="remarks"></a>備註  
 `OnCommand`處理控制項通知訊息對應和`ON_COMMAND`項目，並呼叫適當的成員函式。  
  
 在衍生類別處理此成員函式會覆寫[WM_COMMAND](http://msdn.microsoft.com/library/windows/desktop/ms647591)訊息。 覆寫不會處理訊息對應，除非基底類別`OnCommand`呼叫。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oncompacting"></a>CWnd::OnCompacting  
 當 Windows 偵測到，超過 12.5%的系統時間 30 至 60 秒的時間間隔，花在壓縮的記憶體時，架構會呼叫此成員函式的所有最上層視窗。  
  
```  
afx_msg void OnCompacting(UINT nCpuTime);
```  
  
### <a name="parameters"></a>參數  
 *nCpuTime*  
 指定目前由 Windows 壓縮的記憶體，以 CPU 時間花在執行其他作業所花費的 CPU 時間的比率。 例如，8000 h 表示 50%的 CPU 花時間壓縮記憶體。  
  
### <a name="remarks"></a>備註  
 這表示系統記憶體過低。  
  
 當`CWnd`物件收到此呼叫時，它應該盡可能考慮應用程式和 Windows 中執行的應用程式總數活動的目前層級來釋放記憶體。 應用程式可以呼叫 Windows 函式，以判定多少應用程式正在執行。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oncompareitem"></a>CWnd::OnCompareItem  
 架構會呼叫此成員函式，以子排序之主控描繪下拉式或清單方塊中指定新的項目相對位置。  
  
```  
afx_msg int OnCompareItem(
    int nIDCtl,  
    LPCOMPAREITEMSTRUCT lpCompareItemStruct);
```  
  
### <a name="parameters"></a>參數  
 `nIDCtl`  
 傳送的控制項識別碼`WM_COMPAREITEM`訊息。  
  
 `lpCompareItemStruct`  
 包含的長指標[COMPAREITEMSTRUCT](../../mfc/reference/compareitemstruct-structure.md)資料結構，其中包含的識別項和應用程式提供兩個項目組合或清單方塊中的資料。  
  
### <a name="return-value"></a>傳回值  
 表示兩個項目相對位置。 它可能是下列值之一︰  
  
|值|意義|  
|-----------|-------------|  
|–1|項目 1 排序項目 2 之前。|  
|0|項目 1 和 2 的項目排序相同。|  
|1|項目 1 排序項目 2 之後。|  
  
### <a name="remarks"></a>備註  
 如果以建立下拉式或清單方塊[CBS_SORT](../../mfc/reference/combo-box-styles.md)或[LBS_SORT](../../mfc/reference/list-box-styles.md)樣式，Windows 會傳送下拉式方塊或清單方塊的擁有者`WM_COMPAREITEM`訊息每當應用程式會將新項目。  
  
 在組合或清單方塊中的兩個項目在新式`COMPAREITEMSTRUCT`結構所指`lpCompareItemStruct`。 `OnCompareItem`應該會傳回值，指出哪些項目應該會出現其他之前。 一般而言，Windows 會發出此呼叫多次直到摘要判斷新項目的確切的位置。  
  
 如果**hwndItem**隸屬`COMPAREITEMSTRUCT`所屬的結構[CListBox](../../mfc/reference/clistbox-class.md)或[CComboBox](../../mfc/reference/ccombobox-class.md)物件，然後在`CompareItem`呼叫虛擬函式的適當類別。 覆寫`CComboBox::CompareItem`或`CListBox::CompareItem`中衍生`CListBox`或`CComboBox`類別來比較項目。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oncompositionchanged"></a>CWnd::OnCompositionChanged  
 當桌面視窗管理員 (DWM) 組合啟用或停用時，架構會呼叫此成員函式的所有最上層視窗。  
  
```  
afx_msg void OnCompositionChanged();
```  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_DWMCOMPOSITIONCHANGED](http://msdn.microsoft.com/library/windows/desktop/dd388199)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oncontextmenu"></a>CWnd::OnContextMenu  
 使用者已按一下滑鼠右鍵 （按一下滑鼠右鍵） 視窗中的按鈕時由架構呼叫。  
  
```  
afx_msg void OnContextMenu(
    CWnd* pWnd,  
    CPoint pos);
```  
  
### <a name="parameters"></a>參數  
 `pWnd`  
 這在使用者以滑鼠右鍵按一下滑鼠的視窗控制代碼。 這可以是子視窗的視窗接收訊息。 如需有關如何處理此訊息的詳細資訊，請參閱 < 備註 > 一節。  
  
 `pos`  
 按一下滑鼠時的螢幕座標中的資料指標，位置。  
  
### <a name="remarks"></a>備註  
 您可以藉由顯示使用內容功能表處理此訊息[TrackPopupMenu](../../mfc/reference/cmenu-class.md#trackpopupmenu)。  
  
 如果您不會顯示內容功能表，您就應該傳遞到此訊息[DefWindowProc](#defwindowproc)函式。 如果您的視窗是子視窗，`DefWindowProc`將訊息傳送至父代。 否則，`DefWindowProc`如果指定的位置是在視窗的標題會顯示預設快顯功能表。  
  
##  <a name="oncopydata"></a>CWnd::OnCopyData  
 資料複製到另一個應用程式架構會呼叫此成員函式。  
  
```  
afx_msg BOOL OnCopyData(
    CWnd* pWnd,  
    COPYDATASTRUCT* pCopyDataStruct);
```  
  
### <a name="parameters"></a>參數  
 `pWnd`  
 指標`CWnd`正在傳送資料的物件。  
  
 `pCopyDataStruct`  
 指標[COPYDATASTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms649010)結構，其中包含要傳送的資料。  
  
### <a name="return-value"></a>傳回值  
 傳回**TRUE**如果接收應用程式已成功接受資料。 反之則傳回**FALSE**。  
  
### <a name="remarks"></a>備註  
 傳遞的資料不能包含指標或其他無法存取應用程式接收資料的物件的參考。  
  
 複製資料時，雖然它不能變更由傳送程序的另一個執行緒。  
  
 接收應用程式應該考慮資料唯讀狀態。 參數所指向的結構`pCopyDataStruct`無效，只會在傳輸資料; 不過，接收應用程式應該不會釋放與結構相關聯的記憶體。  
  
 如果接收應用程式需要存取資料，此函式傳回後，它必須複製到本機緩衝區收到的資料。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oncreate"></a>CWnd::OnCreate  
 架構會呼叫此成員函式時，會建立 Windows 視窗呼叫的應用程式要求[建立](#create)或[CreateEx](#createex)成員函式。  
  
```  
afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
```  
  
### <a name="parameters"></a>參數  
 `lpCreateStruct`  
 指向[CREATESTRUCT](../../mfc/reference/createstruct-structure.md)包含的相關資訊的結構`CWnd`正在建立的物件。  
  
### <a name="return-value"></a>傳回值  
 `OnCreate`必須傳回 0，以繼續建立`CWnd`物件。 如果應用程式會傳回 – 1，就會終結視窗。  
  
### <a name="remarks"></a>備註  
 `CWnd`視窗建立之後，但尚未變成可見之前，物件會接收此呼叫。 `OnCreate`之前，會呼叫**建立**或`CreateEx`成員函式傳回。  
  
 若要執行任何所需的初始化衍生類別的這個成員函式會覆寫。  
  
 `CREATESTRUCT`結構包含用來建立視窗之參數的複本。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onctlcolor"></a>CWnd::OnCtlColor  
 要繪製的子控制項時，架構會呼叫此成員函式。  
  
```  
afx_msg HBRUSH OnCtlColor(
    CDC* pDC,  
    CWnd* pWnd,  
    UINT nCtlColor);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 包含子視窗的顯示內容的指標。 可能是暫時性的。  
  
 `pWnd`  
 包含要求之色彩的控制項的指標。 可能是暫時性的。  
  
 `nCtlColor`  
 包含下列的值，指定的控制項類型的其中一個︰  
  
- **CTLCOLOR_BTN**按鈕控制項  
  
- **CTLCOLOR_DLG**對話方塊  
  
- **CTLCOLOR_EDIT**編輯控制項  
  
- **CTLCOLOR_LISTBOX**清單方塊控制項  
  
- **CTLCOLOR_MSGBOX**訊息方塊  
  
- **CTLCOLOR_SCROLLBAR**捲軸控制項  
  
- **CTLCOLOR_STATIC**靜態控制項  
  
### <a name="return-value"></a>傳回值  
 `OnCtlColor`必須要用來繪製控制項背景的筆刷傳回的控制代碼。  
  
### <a name="remarks"></a>備註  
 大部分控制項傳送此訊息至其父代 （通常為對話方塊） 若要準備`pDC`繪製控制項使用正確的色彩。  
  
 若要變更文字色彩，請呼叫`SetTextColor`成員函式所需的紅色、 綠色和藍色 (RGB) 值。  
  
 若要變更的單行編輯控制項的背景色彩，設定筆刷的控制代碼在**CTLCOLOR_EDIT**和**CTLCOLOR_MSGBOX**訊息碼，然後呼叫[CDC::SetBkColor](../../mfc/reference/cdc-class.md#setbkcolor)函式以回應**CTLCOLOR_EDIT**程式碼。  
  
 `OnCtlColor`不會呼叫下拉式清單方塊的清單方塊因為下拉式清單方塊實際上下拉式方塊的子系，而不在視窗的子系。 若要變更色彩的下拉式清單方塊，建立`CComboBox`的覆寫與`OnCtlColor`，以檢查**CTLCOLOR_LISTBOX**中`nCtlColor`參數。 在這個處理常式，`SetBkColor`成員函式必須用來設定文字的背景色彩。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。 將下列方法加入至對話方塊類別，使用 Visual Studio 屬性 窗格加入 WM_CTLCOLOR 訊息處理常式。 或者，您可以手動新增 ON_WM_CTLCOLOR() 項目至訊息對應中。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 107](../../mfc/reference/codesnippet/cpp/cwnd-class_47.cpp)]  
  
##  <a name="ondeadchar"></a>CWnd::OnDeadChar  
 架構會呼叫此成員函式時[OnKeyUp](#onkeyup)成員函式和[OnKeyDown](#onkeydown)成員函式的呼叫。  
  
```  
afx_msg void OnDeadChar(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定的索引鍵的寄不出的字元值。  
  
 `nRepCnt`  
 指定的重複計數。  
  
 `nFlags`  
 指定的掃描程式碼、 索引鍵轉換程式碼、 前一個索引鍵的狀態和內容的程式碼，如下列清單所示︰  
  
|值|描述|  
|-----------|-----------------|  
|0–7|掃描代碼 （OEM 相依值）。 高序位字組的低位元組。|  
|8|擴充索引鍵，例如函式的索引鍵或 （1，表示它是一種擴充的金鑰; 否則為 0） 的數字鍵台上的索引鍵。|  
|9–10|未使用。|  
|11–12|Windows 在內部使用。|  
|13|（若按下按鍵時，按住 ALT 鍵為 1; 否則為 0） 的內容程式碼。|  
|14|先前的主要狀態 (1，表示在呼叫之前，0，如果索引鍵是往上已關閉的索引鍵)。|  
|15|轉換狀態 （1，表示被釋放，索引鍵，0，如果要按下按鍵）。|  
  
### <a name="remarks"></a>備註  
 此成員函式可以用來指定無作用的索引鍵的字元值。 無作用的索引鍵是索引鍵，例如母音變化 （雙點） 字元，就會結合其他字元，以構成複合字元。 例如，母音變化-O 字元所組成的無作用的索引鍵、 母音變化和 O 鍵。  
  
 應用程式通常使用`OnDeadChar`到使用者的相關意見反應已按下每個索引鍵。 例如，應用程式可以顯示腔調字在目前的字元位置而不移動插入號。  
  
 因為沒有不一定是一對一的對應已按下的索引鍵之間和`OnDeadChar`呼叫時，資訊`nFlags`但通常不實用的應用程式。 中的資訊`nFlags`只適用於最新呼叫[OnKeyUp](#onkeyup)成員函式或[OnKeyDown](#onkeydown)之前的成員函式`OnDeadChar`呼叫。  
  
 IBM 增強 101 和 102 鍵鍵盤、 增強的金鑰為右 alt 鍵與右 CTRL 鍵鍵盤; 的主要區段單元、 DEL、 HOME、 END、 PAGE UP、 PAGE DOWN 和箭號左邊的數字鍵台; 在叢集的索引鍵斜線 （/） 和數字鍵台 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元`nFlags`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="ondeleteitem"></a>CWnd::OnDeleteItem  
 架構會呼叫此成員函式，以通知主控描繪清單方塊或下拉式方塊的擁有者的清單方塊或下拉式方塊損毀或由已經移除項目[CComboBox::DeleteString](../../mfc/reference/ccombobox-class.md#deletestring)， [CListBox::DeleteString](../../mfc/reference/clistbox-class.md#deletestring)， [CComboBox::ResetContent](../../mfc/reference/ccombobox-class.md#resetcontent)，或[CListBox::ResetContent](../../mfc/reference/clistbox-class.md#resetcontent)。  
  
```  
afx_msg void OnDeleteItem(
    int nIDCtl,  
    LPDELETEITEMSTRUCT lpDeleteItemStruct);
```  
  
### <a name="parameters"></a>參數  
 `nIDCtl`  
 傳送的控制項識別碼`WM_DELETEITEM`訊息。  
  
 `lpDeleteItemStruct`  
 指定的長指標[DELETEITEMSTRUCT](../../mfc/reference/deleteitemstruct-structure.md)資料結構，其中包含已刪除的清單方塊項目的相關資訊。  
  
### <a name="remarks"></a>備註  
 如果**hwndItem**隸屬`DELETEITEMSTRUCT`結構屬於下拉式方塊或清單方塊中，然後在`DeleteItem`呼叫虛擬函式的適當類別。 覆寫`DeleteItem`刪除項目專屬資料的適當的控制項類別成員函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="ondestroy"></a>CWnd::OnDestroy  
 架構會呼叫此成員函式，以通知`CWnd`物件它正在被終結。  
  
```  
afx_msg void OnDestroy();
```  
  
### <a name="remarks"></a>備註  
 `OnDestroy`之後就會呼叫`CWnd`物件從螢幕中移除。  
  
 `OnDestroy`針對第一次呼叫`CWnd`被損毀，然後為子視窗的`CWnd`時終結。 可以假定在所有子視窗仍然都存在時`OnDestroy`執行。  
  
 如果`CWnd`物件被終結是剪貼簿檢視器鏈結的一部分 (藉由呼叫設定[SetClipboardViewer](#setclipboardviewer)成員函式)，則`CWnd`必須移除本身從剪貼簿檢視器鏈結藉由呼叫[ChangeClipboardChain](#changeclipboardchain)成員函式傳回前的`OnDestroy`函式。  
  
##  <a name="ondestroyclipboard"></a>CWnd::OnDestroyClipboard  
 架構會呼叫剪貼簿擁有者的此成員函式時透過呼叫清空剪貼簿[EmptyClipboard](http://msdn.microsoft.com/library/windows/desktop/ms649037) Windows 函式。  
  
```  
afx_msg void OnDestroyClipboard();
```  
  
##  <a name="ondevicechange"></a>CWnd::OnDeviceChange  
 架構會呼叫此成員函式，以通知應用程式或裝置或電腦的硬體組態變更的裝置驅動程式。  
  
```  
afx_msg BOOL OnDeviceChange(
    UINT nEventType,  
    DWORD_PTR dwData);
```  
  
### <a name="parameters"></a>參數  
 *nEventType*  
 事件類型。 請參閱 < 備註 > 一節說明可用的值  
  
 `dwData`  
 包含事件的特定資料結構的位址。 其意義取決於指定的事件。  
  
### <a name="remarks"></a>備註  
 提供軟體可控制功能，例如退出和鎖定的裝置作業系統通常會傳送**DBT_DEVICEREMOVEPENDING**傳送訊息給可讓應用程式，以及裝置驅動程式正常結束其使用此裝置。  
  
 如果作業系統強制移除的裝置，它可能不會傳送**DBT_DEVICEQUERYREMOVE**這麼做之前的訊息。  
  
 *NEvent*參數可以是下列值之一︰  
  
- [DBT_DEVICEARRIVAL](http://msdn.microsoft.com/library/windows/desktop/aa363205)裝置已插入，現在變成可用。  
  
- [DBT_DEVICEQUERYREMOVE](http://msdn.microsoft.com/library/windows/desktop/aa363206)移除裝置的權限要求。 任何應用程式可以拒絕此要求，並取消移除。  
  
- [DBT_DEVICEQUERYREMOVEFAILED](http://msdn.microsoft.com/library/windows/desktop/aa363207)移除裝置的要求已被取消。  
  
- [DBT_DEVICEREMOVEPENDING](http://msdn.microsoft.com/library/windows/desktop/aa363209)即將移除裝置。 無法拒絕。  
  
- [DBT_DEVICEREMOVECOMPLETE](http://msdn.microsoft.com/library/windows/desktop/aa363208)已移除的裝置。  
  
- [DBT_DEVICETYPESPECIFIC](http://msdn.microsoft.com/library/windows/desktop/aa363210)裝置特有的事件。  
  
- [DBT_CONFIGCHANGED](http://msdn.microsoft.com/library/windows/desktop/aa363203)目前的組態已變更。  
  
- **DBT_DEVNODES_CHANGED**裝置節點已變更。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="ondevmodechange"></a>CWnd::OnDevModeChange  
 架構會呼叫此成員函式，為所有最上層`CWnd`當使用者變更裝置模式設定的物件。  
  
```  
afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
```  
  
### <a name="parameters"></a>參數  
 *lpDeviceName*  
 指向 Windows 初始化檔案、 WIN 中指定的裝置名稱。INI。  
  
### <a name="remarks"></a>備註  
 應用程式處理`WM_DEVMODECHANGE`訊息可能會重新初始化其裝置模式設定。 使用 Windows 應用程式**ExtDeviceMode**函式，儲存並還原裝置的設定通常不會處理此函式。  
  
 當使用者變更預設印表機控制台中，不會呼叫此函式。 在此情況下，`OnWinIniChange`呼叫函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="ondrawclipboard"></a>CWnd::OnDrawClipboard  
 剪貼簿的內容變更時，架構會呼叫此成員函式的剪貼簿檢視器鏈結中每個視窗。  
  
```  
afx_msg void OnDrawClipboard();
```  
  
### <a name="remarks"></a>備註  
 已加入剪貼簿檢視器鏈結藉由呼叫應用程式[SetClipboardViewer](#setclipboardviewer)必須回應此呼叫成員函式。  
  
 接收的每個視窗`OnDrawClipboard`呼叫應該呼叫[SendMessage](http://msdn.microsoft.com/library/windows/desktop/ms644950) Windows 函式傳遞[WM_DRAWCLIPBOARD](http://msdn.microsoft.com/library/windows/desktop/ms649025)入剪貼簿檢視器鏈結中下一個視窗的訊息。 下一個視窗的控制代碼由[SetClipboardViewer](#setclipboardviewer)成員函式; 它可能會修改回應[OnChangeCbChain](#onchangecbchain)成員函式呼叫。  
  
##  <a name="ondrawiconicthumbnailorlivepreview"></a>CWnd::OnDrawIconicThumbnailOrLivePreview  
 需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。  
  
```  
virtual void OnDrawIconicThumbnailOrLivePreview(
    CDC& dc,  
    CRect rect,  
    CSize szRequiredThumbnailSize,  
    BOOL bIsThumbnail,  
    BOOL& bAlphaChannelSet);
```  
  
### <a name="parameters"></a>參數  
 `dc`  
 指定的裝置內容。  
  
 `rect`  
 指定要呈現之區域的周框矩形。  
  
 `szRequiredThumbnailSize`  
 指定目標縮圖大小。 如果應該忽略`bIsThumbnail`是`FALSE`。  
  
 `bIsThumbnail`  
 指定是否會呼叫這個方法對縮圖或即時預覽 （查看）。  
  
 `bAlphaChannelSet`  
 [out]將它設定為`TRUE`如果您實作初始化中選取一個點陣圖的 alpha 色板`dc`。  
  
### <a name="remarks"></a>備註  
 在衍生類別中置換此方法並指定的裝置內容上繪製自訂縮圖和查看。 如果`bThumbnail`是`TRUE`，`szRequiredThumbnailSize`可以忽略。 在此情況下您應該要知道您繪製完整大小的點陣圖 （也就是說，涵蓋整個工作區是點陣圖）。 裝置內容 ( `dc`) 隨附選取 32 位元點陣圖。 預設實作會將 WM_PRINT 傳送到這個視窗使用 PRF_CLIENT、 PRF_CHILDREN 和 PRF_NONCLIENT 旗標。  
  
##  <a name="ondrawitem"></a>CWnd::OnDrawItem  
 架構會呼叫此成員函式的主控描繪按鈕控制項、 下拉式方塊控制項、 清單方塊控制項或功能表控制項的視覺外觀的擁有者或已變更功能表。  
  
```  
afx_msg void OnDrawItem(
    int nIDCtl,  
    LPDRAWITEMSTRUCT lpDrawItemStruct);
```  
  
### <a name="parameters"></a>參數  
 `nIDCtl`  
 包含傳送之控制項的識別項`WM_DRAWITEM`訊息。 如果功能表傳送訊息，`nIDCtl`包含 0。  
  
 `lpDrawItemStruct`  
 指定的長指標`DRAWITEMSTRUCT`資料結構，包含要繪製的項目和所需的繪圖的類型資訊。  
  
### <a name="remarks"></a>備註  
 **ItemAction**隸屬[DRAWITEMSTRUCT](../../mfc/reference/drawitemstruct-structure.md)結構會定義要執行之繪圖作業。 這個成員內的資料可讓控制項的擁有者，來判斷需要哪些繪圖動作。  
  
 無法處理此訊息在傳回之前應用程式應確保所識別的裝置內容`hDC`隸屬`DRAWITEMSTRUCT`結構會還原成預設狀態。  
  
 如果**hwndItem**成員屬於[CButton](../../mfc/reference/cbutton-class.md)， [CMenu](../../mfc/reference/cmenu-class.md)， [CListBox](../../mfc/reference/clistbox-class.md)，或[CComboBox](../../mfc/reference/ccombobox-class.md)物件，然後在`DrawItem`呼叫虛擬函式的適當類別。 覆寫`DrawItem`繪製項目至適當的控制項類別成員函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="ondropfiles"></a>CWnd::OnDropFiles  
 當使用者已本身註冊為捨棄檔案的收件者的視窗上放開滑鼠左的按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnDropFiles(HDROP hDropInfo);
```  
  
### <a name="parameters"></a>參數  
 *hDropInfo*  
 描述的已卸除的檔案的內部資料結構的指標。 這個控制代碼由**DragFinish**， **DragQueryFile**，和**DragQueryPoint** Windows 函式來擷取已卸除檔案的相關資訊。  
  
### <a name="remarks"></a>備註  
 一般而言，衍生的類別會設計為支援卸除的檔案，它將會註冊本身視窗建構期間。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onenable"></a>CWnd::OnEnable  
 應用程式變更的啟用的狀態時，架構會呼叫此成員函式`CWnd`物件。  
  
```  
afx_msg void OnEnable(BOOL bEnable);
```  
  
### <a name="parameters"></a>參數  
 `bEnable`  
 指定是否`CWnd`啟用或停用物件。 這個參數是**TRUE**如果`CWnd`已啟用; 它是**FALSE**如果`CWnd`已停用。  
  
### <a name="remarks"></a>備註  
 `OnEnable`之前，會呼叫[EnableWindow](#enablewindow)成員函式傳回，但是在啟用的視窗狀態之後 ( [WS_DISABLED](../../mfc/reference/window-styles.md)樣式位元) 已變更。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onendsession"></a>CWnd::OnEndSession  
 架構會呼叫此成員函式之後,`CWnd`物件已傳回非零的值從[OnQueryEndSession](#onqueryendsession)成員函式呼叫。  
  
```  
afx_msg void OnEndSession(BOOL bEnding);
```  
  
### <a name="parameters"></a>參數  
 `bEnding`  
 指定要結束工作階段。 它是**TRUE**如果工作階段正在結束; 否則為**FALSE**。  
  
### <a name="remarks"></a>備註  
 `OnEndSession`呼叫會通知`CWnd`物件實際上是否正在結束工作階段。  
  
 如果`bEnding`是**TRUE**，Windows 會終止所有的應用程式都無法處理此呼叫傳回之後的任何時間。 因此，會有應用程式執行所需的終止內的所有工作`OnEndSession`。  
  
 您不需要呼叫[DestroyWindow](#destroywindow)成員函式或[PostQuitMessage](http://msdn.microsoft.com/library/windows/desktop/ms644945)工作階段結束時，Windows 函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onenteridle"></a>CWnd::OnEnterIdle  
 架構會呼叫此成員函式，以通知應用程式的主視窗程序強制回應對話方塊或功能表正在進入閒置狀態。  
  
```  
afx_msg void OnEnterIdle(
    UINT nWhy,  
    CWnd* pWho);
```  
  
### <a name="parameters"></a>參數  
 `nWhy`  
 指定訊息是否在對話方塊或功能表所顯示的結果。 這個參數可以是下列值之一︰  
  
- **MSGF_DIALOGBOX**系統處於閒置狀態，因為正在顯示對話方塊。  
  
- **MSGF_MENU**系統處於閒置狀態，因為會顯示功能表。  
  
 *pWho*  
 指定對話方塊中的指標 (如果`nWhy`是**MSGF_DIALOGBOX**)，或包含顯示的功能表中的視窗 (如果`nWhy`是**MSGF_MENU**)。 此指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 強制回應對話方塊或功能表進入閒置狀態，其佇列中不等候任何訊息處理一或多個先前的訊息時。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onentermenuloop"></a>CWnd::OnEnterMenuLoop  
 已進入功能表強制回應迴圈時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
```  
  
### <a name="parameters"></a>參數  
 `bIsTrackPopupMenu`  
 指定相關的功能表是否為快顯功能表。 包含非零值，如果函式成功。否則便是 0。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onentersizemove"></a>CWnd::OnEnterSizeMove  
 架構會呼叫此成員函式受影響的視窗進入移動或調整大小強制回應迴圈後的一次。  
  
```  
afx_msg void OnEnterSizeMove();
```  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_ENTERSIZEMOVE](http://msdn.microsoft.com/library/windows/desktop/ms632622)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 視窗進入移動或調整大小強制回應迴圈，當使用者按一下視窗的標題列或縮放邊框或視窗傳遞[WM_SYSCOMMAND](http://msdn.microsoft.com/library/windows/desktop/ms646360)傳送訊息給[CWnd::DefWindowProc](#defwindowproc)函式和`wParam`該訊息的參數會指定`SC_MOVE`或`SC_SIZE`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onerasebkgnd"></a>CWnd::OnEraseBkgnd  
 架構會呼叫此成員函式時`CWnd`物件背景需要清除 （例如，當調整大小時）。  
  
```  
afx_msg BOOL OnEraseBkgnd(CDC* pDC);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 指定裝置內容物件。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果它會清除的背景。否則便是 0。  
  
### <a name="remarks"></a>備註  
 呼叫它來準備繪製失效的區域。  
  
 預設實作會清除在背景使用所指定的視窗類別背景筆刷**hbrBackground**視窗類別結構的成員。  
  
 如果**hbrBackground**成員是**NULL**，覆寫的版本`OnEraseBkgnd`應該清除的背景色彩。 您的版本也應該對齊與預期的筆刷的原點`CWnd`藉由第一個呼叫的座標[UnrealizeObject](http://msdn.microsoft.com/library/windows/desktop/dd145164)的筆刷，，然後選取 筆刷。  
  
 透過覆寫`OnEraseBkgnd`應該傳回非零，以回應`WM_ERASEBKGND`如果處理訊息，並清除背景; 這表示，再清除不需要。 它會傳回 0，如果視窗仍標示為需要清除。 (一般而言，這表示， **fErase**隸屬`PAINTSTRUCT`結構可**TRUE**。)  
  
 Windows 會假設與計算背景`MM_TEXT`對應模式。 如果裝置內容使用任何其他對應模式下，清除的區域可能無法在用戶端區域的可見部分。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onexitmenuloop"></a>CWnd::OnExitMenuLoop  
 已結束功能表強制回應迴圈時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
```  
  
### <a name="parameters"></a>參數  
 `bIsTrackPopupMenu`  
 指定相關的功能表是否為快顯功能表。 包含非零值，如果函式成功。否則便是 0。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onexitsizemove"></a>CWnd::OnExitSizeMove  
 架構會呼叫此成員函式受影響的視窗結束移動或調整大小強制回應迴圈後的一次。  
  
```  
afx_msg void OnExitSizeMove();
```  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_EXITSIZEMOVE](http://msdn.microsoft.com/library/windows/desktop/ms632623)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 視窗進入移動或調整大小強制回應迴圈，當使用者按一下視窗的標題列或縮放邊框或視窗傳遞[WM_SYSCOMMAND](http://msdn.microsoft.com/library/windows/desktop/ms646360)傳送訊息給[CWnd::DefWindowProc](#defwindowproc)函式和`wParam`該訊息的參數會指定`SC_MOVE`或`SC_SIZE`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onfontchange"></a>CWnd::OnFontChange  
 在系統中的所有最上層視窗收到`OnFontChange`應用程式變更的字型資源集區之後，由架構呼叫。  
  
```  
afx_msg void OnFontChange();
```  
  
### <a name="remarks"></a>備註  
 加入或移除系統字型的應用程式 (例如，透過[AddFontResource](http://msdn.microsoft.com/library/windows/desktop/dd183326)或[RemoveFontResource](http://msdn.microsoft.com/library/windows/desktop/dd162922) Windows 函式) 應該傳送[WM_FONTCHANGE](http://msdn.microsoft.com/library/windows/desktop/dd145211)所有最上層視窗的訊息。  
  
 若要傳送此訊息，使用[SendMessage](http://msdn.microsoft.com/library/windows/desktop/ms644950) Windows 函式與`hWnd`參數設定為**HWND_BROADCAST**。  
  
##  <a name="ongetdlgcode"></a>CWnd::OnGetDlgCode  
 呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。  
  
```  
afx_msg UINT OnGetDlgCode();
```  
  
### <a name="return-value"></a>傳回值  
 一或多個下列值，指出哪一種類型的輸入應用程式處理序︰  
  
- **DLGC_BUTTON** （一般） 按鈕。  
  
- **DLGC_DEFPUSHBUTTON**預設按鈕。  
  
- **DLGC_HASSETSEL EM_SETSEL**訊息。  
  
- **DLGC_UNDEFPUSHBUTTON**任何預設按鈕的處理。 (應用程式可以使用這個旗標與**DLGC_BUTTON**表示它會處理按鈕的輸入，但依賴預設按鈕處理系統。)  
  
- **DLGC_RADIOBUTTON**選項按鈕。  
  
- **DLGC_STATIC**靜態控制項。  
  
- **DLGC_WANTALLKEYS**所有鍵盤輸入。  
  
- **DLGC_WANTARROWS**方向鍵。  
  
- **DLGC_WANTCHARS** `WM_CHAR`訊息。  
  
- **DLGC_WANTMESSAGE**所有鍵盤輸入。 應用程式傳遞此訊息至控制項。  
  
- **DLGC_WANTTAB** TAB 鍵。  
  
### <a name="remarks"></a>備註  
 一般來說，Windows 會處理所有方向鍵和 TAB 鍵輸入`CWnd`控制項。 藉由覆寫`OnGetDlgCode`、`CWnd`控制項可以選擇特定類型的輸入處理本身。  
  
 預設值`OnGetDlgCode`函式的預先定義的控制項類別，傳回碼適用於每個類別。  
  
##  <a name="ongetminmaxinfo"></a>CWnd::OnGetMinMaxInfo  
 每當 Windows 必須知道最大化的位置或維度，或最小值或追蹤大小的最大值時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
```  
  
### <a name="parameters"></a>參數  
 *lpMMI*  
 指向`MINMAXINFO`結構，其中包含視窗的相關資訊的最大化的大小和位置和大小的最小和最大的追蹤。 如需這個結構相關資訊，請參閱[MINMAXINFO](../../mfc/reference/minmaxinfo-structure.md)結構。  
  
### <a name="remarks"></a>備註  
 最大化的大小的框線會完全延伸時視窗的大小。 追蹤的視窗大小的上限為可藉由使用框線，調整視窗大小的最大視窗大小。 追蹤視窗的大小最小值是可藉由使用框線，調整視窗大小的最小視窗大小。  
  
 Windows 會填入指定不同的位置和維度的預設值的點陣列。 應用程式可能會變更這些值`OnGetMinMaxInfo`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onhelp"></a>CWnd::OnHelp  
 在應用程式 (使用目前的內容) 中處理 F1 說明。  
  
```  
afx_msg void OnHelp();
```  
  
### <a name="remarks"></a>備註  
 請參閱[CWinApp::OnHelp](../../mfc/reference/cwinapp-class.md#onhelp)如需詳細資訊。  
  
##  <a name="onhelpfinder"></a>CWnd::OnHelpFinder  
 處理**ID_HELP_FINDER**和**ID_DEFAULT_HELP**命令。  
  
```  
afx_msg void OnHelpFinder();
```  
  
### <a name="remarks"></a>備註  
 請參閱[CWinApp::OnHelpFinder](../../mfc/reference/cwinapp-class.md#onhelpfinder)如需詳細資訊。  
  
##  <a name="onhelpindex"></a>CWnd::OnHelpIndex  
 處理**ID_HELP_INDEX**命令，並提供預設的說明主題。  
  
```  
afx_msg void OnHelpIndex();
```  
  
### <a name="remarks"></a>備註  
 請參閱[CWinApp::OnHelpIndex](../../mfc/reference/cwinapp-class.md#onhelpindex)如需詳細資訊。  
  
##  <a name="onhelpinfo"></a>CWnd::OnHelpInfo  
 當使用者按下 F1 鍵時，由架構呼叫。  
  
```  
afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
```  
  
### <a name="parameters"></a>參數  
 *lpHelpInfo*  
 指標[HELPINFO](http://msdn.microsoft.com/library/windows/desktop/bb773313)包含功能表項目、 控制項、 對話方塊中或要求說明 視窗的相關資訊的結構。  
  
### <a name="return-value"></a>傳回值  
 或如果視窗擁有鍵盤焦點是否在作用中視窗內功能表，則傳回 TRUE。 如果沒有任何視窗擁有鍵盤焦點，則傳回 FALSE。  
  
### <a name="remarks"></a>備註  
 功能表是否在作用中，按下 F1 時， **WM_HELP**傳送至功能表與關聯的視窗，否則**WM_HELP**傳送至具有鍵盤焦點的視窗。 如果沒有任何視窗擁有鍵盤焦點， **WM_HELP**傳送到目前作用中視窗。  
  
##  <a name="onhelpusing"></a>CWnd::OnHelpUsing  
 處理**ID_HELP_USING**命令。  
  
```  
afx_msg void OnHelpUsing();
```  
  
### <a name="remarks"></a>備註  
 請參閱[CWinApp::OnHelpUsing](../../mfc/reference/cwinapp-class.md#onhelpusing)如需詳細資訊。  
  
##  <a name="onhotkey"></a>CWnd::OnHotKey  
 當使用者按下全系統的便捷鍵時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnHotKey(
    UINT nHotKeyId,   
    UINT nKey1,   
    UINT nKey2);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nHotKeyId`|熱鍵產生訊息識別項。 如果訊息已由系統定義的快速鍵產生，此參數將會是下列值之一︰<br /><br /> - `IDHOT_SNAPDESKTOP`的已按下嵌入式管理單元桌面熱鍵。<br />- `IDHOT_SNAPWINDOW`的已按下嵌入式管理單元視窗熱鍵。|  
|[in] `nKey1`|位元組合 (OR) 旗標，表示已按下組合與所指定之索引鍵的索引鍵`nKey2`參數。 可能值為：<br /><br /> - `MOD_ALT`-向下保留任一 ALT 鍵。<br />- `MOD_CONTROL`-向下保留任一 CTRL 鍵。<br />- `MOD_SHIFT`-向下保留任一 SHIFT 鍵。<br />- `MOD_WIN`-任一 WINDOWS 金鑰已同時按住。 Microsoft Windows 爦羆則標示為這些機碼。|  
|[in] `nKey2`|熱鍵虛擬按鍵碼。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_HOTKEY](http://msdn.microsoft.com/library/windows/desktop/ms646279)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 此訊息會放在頂端的已註冊的熱鍵的執行緒相關聯的訊息佇列。 使用[RegisterHotKey](http://msdn.microsoft.com/library/windows/desktop/ms646309)註冊全系統的便捷鍵的函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onhscroll"></a>CWnd::OnHScroll  
 當使用者按一下視窗的水平捲軸，架構會呼叫此成員函式。  
  
```  
afx_msg void OnHScroll(
    UINT nSBCode,  
    UINT nPos,  
    CScrollBar* pScrollBar);
```  
  
### <a name="parameters"></a>參數  
 `nSBCode`  
 指定捲軸程式碼，表示使用者的捲動要求。 這個參數可以是下列其中一項︰  
  
- **SB_LEFT**捲動至最左邊。  
  
- **SB_ENDSCROLL**結束捲軸。  
  
- **SB_LINELEFT**向左。  
  
- **SB_LINERIGHT**向右捲動。  
  
- **SB_PAGELEFT**捲動一頁的左邊。  
  
- **SB_PAGERIGHT**向右捲動一頁。  
  
- **SB_RIGHT**捲動至最右側。  
  
- **SB_THUMBPOSITION**捲動至絕對位置。 目前的位置由指定`nPos`參數。  
  
- **SB_THUMBTRACK**拖曳捲動方塊到指定的位置。 目前的位置由指定`nPos`參數。  
  
 `nPos`  
 如果捲軸的程式碼指定捲動方塊位置**SB_THUMBPOSITION**或**SB_THUMBTRACK**，否則為未使用。 根據初始的捲軸範圍，`nPos`可以是負數，而且應該轉換成`int`如有必要。  
  
 `pScrollBar`  
 如果捲動訊息來自捲軸控制項，包含控制項的指標。 如果使用者按一下視窗的捲軸，這個參數是**NULL**。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
### <a name="remarks"></a>備註  
 **SB_THUMBTRACK**捲軸程式碼通常會被用捲動方塊被拖曳的期間，提供一些意見的應用程式。  
  
 如果應用程式捲動捲軸所控制的內容，也必須重設的捲動方塊位置[SetScrollPos](#setscrollpos)成員函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 108](../../mfc/reference/codesnippet/cpp/cwnd-class_48.cpp)]  
  
##  <a name="onhscrollclipboard"></a>CWnd::OnHScrollClipboard  
 剪貼簿擁有者的`OnHScrollClipboard`剪貼簿資料時，[剪貼簿檢視器] 便會呼叫成員函式`CF_OWNERDISPLAY`格式化，並在剪貼簿檢視器的水平捲軸上沒有的事件。  
  
```  
afx_msg void OnHScrollClipboard(
    CWnd* pClipAppWnd,  
    UINT nSBCode,  
    UINT nPos);
```  
  
### <a name="parameters"></a>參數  
 `pClipAppWnd`  
 指定 剪貼簿檢視器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
 `nSBCode`  
 指定的其中一個下捲軸代碼低序位字組︰  
  
- **SB_BOTTOM**捲動至右下方。  
  
- **SB_ENDSCROLL**結束捲軸。  
  
- **SB_LINEDOWN**向下捲動一行。  
  
- **SB_LINEUP**向上捲動一行。  
  
- **SB_PAGEDOWN**向下捲動一頁。  
  
- **SB_PAGEUP**向上捲動一頁。  
  
- **SB_THUMBPOSITION**捲動至絕對位置。 目前的位置所提供的`nPos`。  
  
- **SB_TOP**捲動至左上方。  
  
 `nPos`  
 如果捲軸的程式碼包含捲動方塊位置**SB_THUMBPOSITION**; 否則為未使用。  
  
### <a name="remarks"></a>備註  
 擁有者應該捲動剪貼簿影像、 使適當的區段失效，並更新捲軸值。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oniconerasebkgnd"></a>CWnd::OnIconEraseBkgnd  
 架構會呼叫此成員函式，針對最小化 （圖示）`CWnd`物件時必須填入圖示的背景再繪製圖示。  
  
```  
afx_msg void OnIconEraseBkgnd(CDC* pDC);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 指定的裝置內容物件的圖示。 可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 `CWnd`收到此呼叫，只有當定義視窗的預設實作; 類別圖示否則[OnEraseBkgnd](#onerasebkgnd)呼叫。  
  
 [DefWindowProc](#defwindowproc)成員函式填滿圖示背景與父視窗的背景筆刷。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oninitmenu"></a>CWnd::OnInitMenu  
 當功能表即將變成現用時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnInitMenu(CMenu* pMenu);
```  
  
### <a name="parameters"></a>參數  
 `pMenu`  
 指定要初始化的功能表。 可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 `OnInitMenu`當使用者按一下功能表列上的項目，或按下功能表鍵時呼叫。 若要修改的功能表之前它會顯示, 此成員函式會覆寫。  
  
 `OnInitMenu`只會呼叫一次，功能表第一次存取時 （例如，當使用者按一下功能表列上的項目）。 這個方法不提供功能表項目的相關資訊。 當使用者移動功能表中的項目 （例如，藉由跨數個功能表項目移動滑鼠） 函式不會呼叫一次。 一旦使用者從功能表結束 （例如，藉由按一下應用程式用戶端區域），並稍後按一下功能表列上的項目，則會再次呼叫此函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oninitmenupopup"></a>CWnd::OnInitMenuPopup  
 快顯功能表即將變成作用中時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnInitMenuPopup(
    CMenu* pPopupMenu,  
    UINT nIndex,  
    BOOL bSysMenu);
```  
  
### <a name="parameters"></a>參數  
 *pPopupMenu*  
 指定快顯功能表的功能表的物件。 可能是暫時性的不會儲存供稍後使用。  
  
 `nIndex`  
 指定在主功能表中的快顯功能表的索引。  
  
 *bSysMenu*  
 **TRUE**快顯功能表是否在控制項功能表; 否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 這可讓應用程式來修改快顯功能表，而不會變更整個功能表顯示之前。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oninputdevicechange"></a>CWnd::OnInputDeviceChange  
 加入或從系統移除 I/O 裝置時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnInputDeviceChange(unsigned short uFlag);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `uFlag`|這個旗標可以包含下列值︰<br /><br /> - `GIDC_ARRIVAL`-新的裝置已經加入至系統。<br />- `GIDC_REMOVAL`-裝置已從系統中移除。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_INPUT_DEVICE_CHANGE](http://msdn.microsoft.com/library/windows/desktop/ms645591)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 是一般輸入的裝置訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oninputlangchange"></a>CWnd::OnInputLangChange  
 變更應用程式的輸入的語言之後，架構會呼叫這個成員的最上層受影響的視窗。  
  
```  
afx_msg void OnInputLangChange(
    UINT nCharSet,   
    UINT nLocaleId);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nCharSet`|新的地區設定的字元集。 如需詳細資訊，請參閱`lfCharSet`參數[LOGFONT](http://msdn.microsoft.com/library/windows/desktop/dd145037)結構。|  
|[in] `nLocaleId`|輸入法地區設定識別項。 如需詳細資訊，請參閱[語言識別項常數和字串](http://msdn.microsoft.com/library/windows/desktop/dd318693)。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_INPUTLANGCHANGE](http://msdn.microsoft.com/library/windows/desktop/ms632629)通知訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="oninputlangchangerequest"></a>CWnd::OnInputLangChangeRequest  
 當使用者選擇新的輸入的語言時，架構會呼叫這個成員具有焦點的視窗。  
  
```  
afx_msg void OnInputLangChangeRequest(
    UINT nFlags,   
    UINT nLocaleId);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nFlags`|位元 (OR) 旗標的組合，以指出從上一個或下一個地區設定的地區設定中，已安裝的清單中選取新的地區設定或新輸入地區設定的鍵盤配置可以搭配系統字元集。<br /><br /> 可能的值為`INPUTLANGCHANGE_BACKWARD`， `INPUTLANGCHANGE_FORWARD`，和`INPUTLANGCHANGE_SYSCHARSET`。|  
|[in] `nLocaleId`|輸入法地區設定識別項。 如需詳細資訊，請參閱[語言識別項常數和字串](http://msdn.microsoft.com/library/windows/desktop/dd318693)。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_INPUTLANGCHANGEREQUEST](http://msdn.microsoft.com/library/windows/desktop/ms632630)通知訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 當使用者選擇新的輸入的語言，與在鍵盤控制台應用程式，或從系統工作列上的指示指定的任一快速鍵，就會公佈此訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onkeydown"></a>CWnd::OnKeyDown  
 按下非系統鍵時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnKeyDown(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定指定的索引鍵的虛擬按鍵碼。 標準虛擬按鍵碼的清單，請參閱 Winuser.h  
  
 `nRepCnt`  
 重複計數 （次數按鍵重複使用者按住鍵）。  
  
 `nFlags`  
 指定的掃描程式碼、 索引鍵轉換程式碼、 前一個索引鍵的狀態和內容的程式碼，如下列清單所示︰  
  
|值|描述|  
|-----------|-----------------|  
|0–7|掃描代碼 （OEM 相依值）。|  
|8|擴充索引鍵，例如函式的索引鍵或 (1，表示它是擴充的索引鍵) 的數字鍵台上的索引鍵。|  
|9–10|未使用。|  
|11–12|Windows 在內部使用。|  
|13|（若按下按鍵時，按住 ALT 鍵為 1; 否則為 0） 的內容程式碼。|  
|14|先前的主要狀態 (1，表示在呼叫之前，0，如果索引鍵是往上已關閉的索引鍵)。|  
|15|轉換狀態 （1，表示被釋放，索引鍵，0，如果要按下按鍵）。|  
  
 如`WM_KEYDOWN`訊息 （位元 15） 索引鍵轉換位元為 0，和 （位元 13） 的內容程式碼位元為 0。  
  
### <a name="remarks"></a>備註  
 非系統鍵會是未按下 ALT 鍵時按下鍵盤按鍵或鍵盤按鍵時按`CWnd`具有輸入的焦點。  
  
 因為自動重複，超過一個`OnKeyDown`呼叫可能會發生之前[OnKeyUp](#onkeyup)成員函式呼叫。 表示索引鍵的先前狀態的位元可以用來判斷是否`OnKeyDown`呼叫是第一個向下轉換或重複向下轉換。  
  
 IBM 增強 101 和 102 鍵鍵盤、 增強的金鑰為右 alt 鍵與右 CTRL 鍵鍵盤; 的主要區段單元、 DEL、 HOME、 END、 PAGE UP、 PAGE DOWN 和箭號左邊的數字鍵台; 在叢集的索引鍵斜線 （/） 和數字鍵台 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元`nFlags`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onkeyup"></a>CWnd::OnKeyUp  
 放開非系統鍵時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnKeyUp(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定指定的索引鍵的虛擬按鍵碼。 標準虛擬按鍵碼的清單，請參閱 Winuser.h  
  
 `nRepCnt`  
 重複計數 （次數按鍵重複使用者按住鍵）。  
  
 `nFlags`  
 指定的掃描程式碼、 索引鍵轉換程式碼、 前一個索引鍵的狀態和內容的程式碼，如下列清單所示︰  
  
|值|描述|  
|-----------|-----------------|  
|0–7|掃描代碼 （OEM 相依值）。 高序位字組的低位元組。|  
|8|擴充索引鍵，例如函式的索引鍵或 （1，表示它是一種擴充的金鑰; 否則為 0） 的數字鍵台上的索引鍵。|  
|9–10|未使用。|  
|11–12|Windows 在內部使用。|  
|13|（若按下按鍵時，按住 ALT 鍵為 1; 否則為 0） 的內容程式碼。|  
|14|先前的主要狀態 (1，表示在呼叫之前，0，如果索引鍵是往上已關閉的索引鍵)。|  
|15|轉換狀態 （1，表示被釋放，索引鍵，0，如果要按下按鍵）。|  
  
 如`WM_KEYUP`訊息 （位元 15） 索引鍵轉換位元為 1 和內容程式碼位元 （位元 13） 為 0。  
  
### <a name="remarks"></a>備註  
 非系統鍵會是未按下 ALT 鍵時按下鍵盤按鍵或鍵盤按鍵時按`CWnd`具有輸入的焦點。  
  
 IBM 增強 101 和 102 鍵鍵盤、 增強的金鑰為右 alt 鍵與右 CTRL 鍵鍵盤; 的主要區段單元、 DEL、 HOME、 END、 PAGE UP、 PAGE DOWN 和箭號左邊的數字鍵台; 在叢集的索引鍵斜線 （/） 和數字鍵台 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元`nFlags`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onkillfocus"></a>CWnd::OnKillFocus  
 架構會失去輸入的焦點前立即呼叫此成員函式。  
  
```  
afx_msg void OnKillFocus(CWnd* pNewWnd);
```  
  
### <a name="parameters"></a>參數  
 *pNewWnd*  
 指定收到輸入的焦點的視窗的指標 (可能是**NULL**或可能是暫時性)。  
  
### <a name="remarks"></a>備註  
 如果`CWnd`物件顯示插入號，此時應該予以終結插入號。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onlbuttondblclk"></a>CWnd::OnLButtonDblClk  
 當使用者按兩下滑鼠左鍵，架構會呼叫此成員函式。  
  
```  
afx_msg void OnLButtonDblClk(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
 只有具有 windows **CS_DBLCLKS** [WNDCLASS](http://msdn.microsoft.com/library/windows/desktop/ms633576)樣式會收到`OnLButtonDblClk`呼叫。 這是 Microsoft Foundation Class windows 的預設值。 Windows 呼叫`OnLButtonDblClk`使用者按下，釋出，然後再按下滑鼠左的按鈕系統內重新時按兩下時間限制。 按兩下滑鼠左鍵實際上會產生四個事件︰ [WM_LBUTTONDOWN](#onlbuttondown)， [WM_LBUTTONUP](#onlbuttonup)訊息，`WM_LBUTTONDBLCLK`呼叫，而另一個`WM_LBUTTONUP`訊息時放開按鍵時。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onlbuttondown"></a>CWnd::OnLButtonDown  
 當使用者按下滑鼠左的按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnLButtonDown(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onlbuttonup"></a>CWnd::OnLButtonUp  
 當使用者放開滑鼠左的按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnLButtonUp(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmbuttondblclk"></a>CWnd::OnMButtonDblClk  
 當使用者按兩下滑鼠中間鍵時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnMButtonDblClk(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
 只有具有 windows **CS_DBLCLKS** [WNDCLASS](http://msdn.microsoft.com/library/windows/desktop/ms633576)樣式會收到`OnMButtonDblClk`呼叫。 這是所有 Microsoft Foundation Class 視窗的預設值。 Windows 會產生`OnMButtonDblClk`呼叫時使用者按下、 版本，然後按下滑鼠按鈕一次在系統中按兩下時間限制。 按兩下滑鼠中間鍵實際上會產生四個事件︰ [WM_MBUTTONDOWN](#onmbuttondown)和[WM_MBUTTONUP](#onmbuttonup)訊息，`WM_MBUTTONDBLCLK`呼叫，而另一個`WM_MBUTTONUP`訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmbuttondown"></a>CWnd::OnMButtonDown  
 當使用者按下滑鼠中間鍵時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnMButtonDown(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmbuttonup"></a>CWnd::OnMButtonUp  
 當使用者放開滑鼠中鍵時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnMButtonUp(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmdiactivate"></a>CWnd::OnMDIActivate  
 正在停用子視窗和要啟動的子視窗時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnMDIActivate(
    BOOL bActivate,  
    CWnd* pActivateWnd,  
    CWnd* pDeactivateWnd);
```  
  
### <a name="parameters"></a>參數  
 `bActivate`  
 **TRUE**如果啟動的子系和**FALSE**如果正在停用。  
  
 `pActivateWnd`  
 包含要啟動的 MDI 子視窗的指標。 當收到 MDI 子視窗，`pActivateWnd`包含正在啟用的子視窗的指標。 此指標可能是暫時性的不會儲存供稍後使用。  
  
 *pDeactivateWnd*  
 包含已停用的 MDI 子視窗的指標。 此指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 啟動 MDI 子視窗與 MDI 框架視窗無關。 當框架會變成作用中、 與上次啟動的子視窗`OnMDIActivate`呼叫都會收到[WM_NCACTIVATE](#onncactivate)訊息來繪製作用中視窗框架和標題列，但是不會收到另一個`OnMDIActivate`呼叫。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmeasureitem"></a>CWnd::OnMeasureItem  
 架構會呼叫此成員函式由架構擁有者的主控描繪按鈕、 下拉式方塊、 清單方塊或功能表項目建立控制項時。  
  
```  
afx_msg void OnMeasureItem(
    int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
```  
  
### <a name="parameters"></a>參數  
 `nIDCtl`  
 控制項的識別碼。  
  
 `lpMeasureItemStruct`  
 指向[MEASUREITEMSTRUCT](../../mfc/reference/measureitemstruct-structure.md)資料結構，包含主控描繪控制項的維度。  
  
### <a name="remarks"></a>備註  
 覆寫此成員函式，並填寫`MEASUREITEMSTRUCT`資料結構所指`lpMeasureItemStruct`和傳回，這樣通知視窗的控制項的維度，並允許 Windows，才能正確處理使用者與控制項互動。  
  
 如果清單方塊或下拉式方塊以建立[LBS_OWNERDRAWVARIABLE](../../mfc/reference/list-box-styles.md)或[CBS_OWNERDRAWVARIABLE](../../mfc/reference/combo-box-styles.md)樣式，架構會呼叫此函式的每個項目在控制項中的擁有者; 否則會呼叫此函數一次。  
  
 Windows 會起始呼叫`OnMeasureItem`下拉式方塊和清單方塊的擁有者建立與**OWNERDRAWFIXED**傳送之前樣式[WM_INITDIALOG](http://msdn.microsoft.com/library/windows/desktop/ms645428)訊息。 如此一來，當擁有者會收到此呼叫，Windows 不尚未判定的高度和寬度的控制項; 中所使用的字型函式呼叫和要求這些值的計算要在應用程式或文件庫的主要功能。  
  
 如果要測量的項目`CMenu`，`CListBox`或`CComboBox`物件，然後在`MeasureItem`呼叫虛擬函式的適當類別。 覆寫`MeasureItem`計算，並設定每個項目的大小適當的控制項類別成員函式。  
  
 `OnMeasureItem`控制項的類別會建立在執行階段，或與其建立時，才會呼叫**LBS_OWNERDRAWVARIABLE**或**CBS_OWNERDRAWVARIABLE**樣式。 如果控制項以對話方塊編輯器中，建立`OnMeasureItem`將不會呼叫。 這是因為[WM_MEASUREITEM](http://msdn.microsoft.com/library/windows/desktop/bb775925)的控制項建立的過程中提早傳送訊息。 如果您子類別化使用`DDX_Control`， `SubclassDlgItem`，或`SubclassWindow`，子類別化在建立程序之後，通常會發生。 因此，沒有任何方法來處理[WM_MEASUREITEM](http://msdn.microsoft.com/library/windows/desktop/bb775925)控制項中的訊息`OnChildNotify`函式，是一種機制，MFC 會使用來實作**ON_WM_MEASUREITEM_REFLECT**。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmenuchar"></a>CWnd::OnMenuChar  
 當使用者按下功能表的助憶鍵字元不符合任何目前功能表中預先定義的助憶鍵時，架構會呼叫此成員函式。  
  
```  
afx_msg LRESULT OnMenuChar(
    UINT nChar,  
    UINT nFlags,  
    CMenu* pMenu);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 根據的建置設定，指定使用者按下的 ANSI 或 Unicode 字元。  
  
 `nFlags`  
 包含**MF_POPUP**如果功能表快顯功能表的旗標。 它包含**MF_SYSMENU**如果的功能表控制項功能表的旗標。  
  
 `pMenu`  
 包含所選的指標`CMenu`。 指標可能是暫時性的不會儲存。  
  
### <a name="return-value"></a>傳回值  
 傳回值的高序位文字應該包含下列指令碼的其中一個︰  
  
|值|描述|  
|-----------|-----------------|  
|0|會告知 Windows 捨棄使用者按下並系統喇叭上建立簡短的嗶聲的字元。|  
|1|會告知 Windows 關閉目前的功能表。|  
|2|通知視窗傳回值的低序位字組包含特定項目的項目數目。 Windows 會選取此項目。|  
  
 如果高序位文字包含 0 或 1，則會忽略低序位字組。 快速鍵 （快速鍵） 會用來選取放在功能表中的點陣圖時，應用程式應該處理此訊息。  
  
### <a name="remarks"></a>備註  
 它會傳送至`CWnd`擁有功能表。 `OnMenuChar`也稱為時使用者按下 alt 鍵和任何其他金鑰，即使索引鍵未對應到助憶鍵字元。 在此情況下，`pMenu`指向所擁有的功能表`CWnd`，和`nFlags`為 0。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmenudrag"></a>CWnd::OnMenuDrag  
 當使用者開始拖曳功能表項目時，架構會呼叫此成員函式，目前的拖放功能表。  
  
```  
afx_msg UINT OnMenuDrag(
    UINT nPos,   
    CMenu* pMenu);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nPos`|在拖曳作業開始時之功能表項目的索引位置。|  
|[in] `pMenu`|指標[CMenu](../../mfc/reference/cmenu-class.md)物件，其中包含功能表項目。|  
  
### <a name="return-value"></a>傳回值  
  
|傳回值|意義|  
|------------------|-------------|  
|`MND_CONTINUE`|功能表應該仍作用中。 放開滑鼠時，應該忽略。|  
|`MND_ENDMENU`|功能表應該結束。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_MENUDRAG](http://msdn.microsoft.com/library/windows/desktop/ms647606)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmenugetobject"></a>CWnd::OnMenuGetObject  
 將滑鼠游標進入功能表項目，或從項目中央移到頂端或底端的項目時，架構會呼叫此成員函式，目前的拖放功能表。  
  
```  
afx_msg UINT OnMenuGetObject(MENUGETOBJECTINFO* pMenuGetObjectInfo);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `pMenu`|指標[MENUGETOBJECTINFO](http://msdn.microsoft.com/library/windows/desktop/ms647572)上是結構，其中包含滑鼠游標拖放功能表的相關資訊。|  
  
### <a name="return-value"></a>傳回值  
  
|傳回值|意義|  
|------------------|-------------|  
|`MNGO_NOERROR`|介面指標，支援卸除拖曳作業中傳回`pvObj`隸屬[MENUGETOBJECTINFO](http://msdn.microsoft.com/library/windows/desktop/ms647572)結構。 目前，只有[IDropTarget](http://msdn.microsoft.com/library/windows/desktop/ms679679)支援介面。|  
|`MNGO_NOINTERFACE`|支援不卸除並拖曳的介面。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_MENUGETOBJECT](http://msdn.microsoft.com/library/windows/desktop/ms647607)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmenurbuttonup"></a>CWnd::OnMenuRButtonUp  
 當使用者放開滑鼠按鈕，而游標位於功能表項目上時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnMenuRButtonUp(
    UINT nPos,  
    CMenu* pMenu);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nPos`|放開滑鼠按鈕時，功能表項目的索引位置。|  
|[in] `pMenu`|指標[CMenu](../../mfc/reference/cmenu-class.md)物件，其中包含功能表項目。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_MENURBUTTONUP](http://msdn.microsoft.com/library/windows/desktop/ms647610)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 [WM_MENURBUTTONUP](http://msdn.microsoft.com/library/windows/desktop/ms647610)訊息可讓應用程式功能表項目指定的訊息中提供的內容相關性功能表。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmenuselect"></a>CWnd::OnMenuSelect  
 如果`CWnd`物件都與一個功能表，`OnMenuSelect`使用者選取功能表項目時，由架構呼叫。  
  
```  
afx_msg void OnMenuSelect(
    UINT nItemID,  
    UINT nFlags,  
    HMENU hSysMenu);
```  
  
### <a name="parameters"></a>參數  
 `nItemID`  
 識別選取的項目。 如果選取的項目是功能表項目，`nItemID`包含功能表項目識別碼。 如果選取的項目包含快顯功能表，`nItemID`包含快顯功能表的索引，和*hSysMenu*包含主要 （按下入） 功能表的控制代碼。  
  
 `nFlags`  
 包含下列功能表旗標的組合︰  
  
- **MF_BITMAP**項目是一種點陣圖。  
  
- **MF_CHECKED**檢查項目。  
  
- **MF_DISABLED**項目已停用。  
  
- **MF_GRAYED**項目會呈暗灰色。  
  
- **MF_MOUSESELECT**使用滑鼠選取項目。  
  
- `MF_OWNERDRAW`項目是主控描繪項目。  
  
- **MF_POPUP**項目包含快顯功能表。  
  
- **MF_SEPARATOR**項目是功能表項目分隔符號。  
  
- **MF_SYSMENU**項目包含在控制項功能表中。  
  
 `hSysMenu`  
 如果`nFlags`包含**MF_SYSMENU**，識別與訊息相關的功能表。 如果`nFlags`包含**MF_POPUP**，識別主功能表的控制代碼。 如果`nFlags`包含這兩個**MF_SYSMENU**也**MF_POPUP**，它是未使用。  
  
### <a name="remarks"></a>備註  
 如果`nFlags`包含 0xFFFF 和`hSysMenu`包含 0 時，Windows 已關閉功能表，因為使用者按下 ESC 鍵或按下功能表外部。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmouseactivate"></a>CWnd::OnMouseActivate  
 當游標處於非作用中視窗，而且使用者按下滑鼠按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg int OnMouseActivate(
    CWnd* pDesktopWnd,  
    UINT nHitTest,  
    UINT message);
```  
  
### <a name="parameters"></a>參數  
 *pDesktopWnd*  
 指定正在啟用視窗的最上層的父視窗的指標。 指標可能是暫時性的不會儲存。  
  
 `nHitTest`  
 指定[點擊測試](#onnchittest)區碼。 點擊的測試是測試，決定游標的位置。  
  
 `message`  
 指定滑鼠訊息數目。  
  
### <a name="return-value"></a>傳回值  
 指定是否要啟動`CWnd`以及是否要捨棄的滑鼠事件。 它必須是下列值之一︰  
  
- **MA_ACTIVATE** Activate`CWnd`物件。  
  
- **MA_NOACTIVATE**不要啟動`CWnd`物件。  
  
- **MA_ACTIVATEANDEAT** Activate`CWnd`物件，並捨棄滑鼠事件。  
  
- **MA_NOACTIVATEANDEAT**不要啟動`CWnd`物件，並捨棄滑鼠事件。  
  
### <a name="remarks"></a>備註  
 預設實作會將這則訊息傳遞至父視窗中前進行任何處理。 如果父視窗傳回**TRUE**，停止處理。  
  
 如需個別的點擊測試區域代碼的說明，請參閱[OnNcHitTest](#onnchittest)成員函式  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCAxCtl # 9](../../mfc/reference/codesnippet/cpp/cwnd-class_49.cpp)]  
  
##  <a name="onmousehover"></a>CWnd::OnMouseHover  
 當游標停留在先前呼叫中指定的時間週期 視窗的工作區時，架構會呼叫此成員函式[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。  
  
```  
afx_msg void OnMouseHover(
    UINT nFlags,   
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nFlags`|的位元組合 (OR) 旗標，表示哪個輔助按鍵按下按鍵。 例如，`MK_CONTROL`旗標表示，按下 CTRL 鍵。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於工作區的左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_MOUSEHOVER](http://msdn.microsoft.com/library/windows/desktop/ms645613)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `nFlags`參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱[有關滑鼠輸入](http://msdn.microsoft.com/library/windows/desktop/ms645601)。  
  
|輔助按鍵|描述|  
|------------------|-----------------|  
|MK_CONTROL|已按下 CTRL 鍵。|  
|MK_LBUTTON|已按下滑鼠左的按鈕。|  
|MK_MBUTTON|已按下滑鼠中間鍵。|  
|MK_RBUTTON|已按下滑鼠右按鈕。|  
|MK_SHIFT|已按下 SHIFT 鍵。|  
|MK_XBUTTON1|文件拉的 XBUTTON1 滑鼠按鈕已按下。|  
|MK_XBUTTON2|文件拉 XBUTTON2 滑鼠按鈕已按下。|  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmousehwheel"></a>CWnd::OnMouseHWheel  
 當目前視窗由所組成的桌面視窗管理員 (DWM)，而且該視窗最大化時，架構會呼叫這個成員。  
  
```  
afx_msg void OnMouseHWheel(
    UINT nFlags,   
    short zDelta,   
    CPoint pt);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nFlags`|的位元組合 (OR) 旗標，表示哪個輔助按鍵按下按鍵。 例如，`MK_CONTROL`旗標表示，按下 CTRL 鍵。<br /><br /> 如需旗標的清單，請參閱中的 「 訊息參數 」 子標題[有關滑鼠輸入](http://msdn.microsoft.com/library/windows/desktop/ms645601)。|  
|[in] `zDelta`|表示旋轉滾輪，在倍數或部門中的距離`WHEEL_DELTA`，這是 120。 正值表示滾輪已旋轉至右側。負數值表示滾輪已向左旋轉。|  
|[in] `pt`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於工作區的左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_MOUSEHWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645614)通知訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 此訊息會傳送至視窗具有焦點時滑鼠的水平滾輪傾斜或旋轉。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmouseleave"></a>CWnd::OnMouseLeave  
 當游標離開之前的呼叫中所指定視窗工作區時，架構會呼叫此成員函式[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。  
  
```  
afx_msg void OnMouseLeave();
```  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_MOUSELEAVE](http://msdn.microsoft.com/library/windows/desktop/ms645615)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmousemove"></a>CWnd::OnMouseMove  
 當滑鼠游標移動時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnMouseMove(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
 如果沒有擷取滑鼠，`WM_MOUSEMOVE`所收到的訊息`CWnd`物件下方滑鼠資料指標; 否則訊息會移至已捕捉滑鼠的視窗。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmousewheel"></a>CWnd::OnMouseWheel  
 當使用者滾動滑鼠滾輪，並遇到滾輪的下一個刻度，架構會呼叫此成員函式。  
  
```  
afx_msg BOOL OnMouseWheel(
    UINT nFlags,  
    short zDelta,  
    CPoint pt);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `zDelta`  
 表示距離旋轉。 `zDelta`倍數或部門中的值表示**WHEEL_DELTA**，這是 120。 小於零的值會指出繞回 （向使用者） 時的值大於零，表示向前旋轉 （遠離使用者）。 使用者可以藉由滑鼠軟體的滾輪設反轉此回應。 如需詳細資訊，此參數的相關註解，請參閱。  
  
 `pt`  
 指定資料指標 x 和 y 座標。 這些座標是一律相對於螢幕左上角。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果已啟用滑鼠滾輪捲動;否則便是 0。  
  
### <a name="remarks"></a>備註  
 覆寫時，除非`OnMouseWheel`呼叫預設值是[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617)。 Windows 會自動會將訊息傳送至焦點在控制項或子視窗。 Win32 函式[DefWindowProc](http://msdn.microsoft.com/library/windows/desktop/ms633572)傳播父鏈結來加以處理的視窗訊息。  
  
 `zDelta`參數是倍數**WHEEL_DELTA**，方向會設在 120。 這個值是要採取的動作的臨界值，以及一個這類動作 （例如，捲動正向一波陷） 應該為每個差異。  
  
 **WHEEL_DELTA**以便解析度更精細的滾輪，例如自由旋轉滾輪沒有色塊與已設定為 120。 解析度更精細的滾輪傳送更多的訊息，每次旋轉，但每個訊息具有較小的差異值。 若要使用這類滾輪的滑鼠，請新增連入`zDelta`值直到**WHEEL_DELTA**為止 （以便讓您可以取得相同的回應為給定的差異旋轉），或捲動以回應較頻繁的訊息部分行。 您也可以選擇捲動的資料粒度及累積直到差異**WHEEL_DELTA**為止。  
  
 覆寫此成員函式，以提供您自己的滑鼠滾輪捲動行為。  
  
> [!NOTE]
> `OnMouseWheel`為 Windows NT 4.0 和更新版本中處理訊息。 對於 Windows 95/98 或 Windows NT 3.51 訊息處理，使用[OnRegisteredMouseWheel](#onregisteredmousewheel)。  
  
##  <a name="onmove"></a>CWnd::OnMove  
 架構會呼叫此成員函式之後,`CWnd`移動物件。  
  
```  
afx_msg void OnMove(
    int x,  
    int y);
```  
  
### <a name="parameters"></a>參數  
 *x*  
 指定新的工作區的左上角 x 座標位置。 這個新的位置會在螢幕座標的重疊和快顯視窗中，且子視窗的父用戶端座標。  
  
 *y*  
 指定新的工作區的左上角 y 座標位置。 這個新的位置會在螢幕座標的重疊和快顯視窗中，且子視窗的父用戶端座標。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onmoving"></a>CWnd::OnMoving  
 當使用者正在移動時，架構會呼叫此成員函式`CWnd`物件。  
  
```  
afx_msg void OnMoving(
    UINT nSide,  
    LPRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `nSide`  
 要移動的視窗邊緣。  
  
 `lpRect`  
 位址[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 結構](../../mfc/reference/rect-structure1.md)，就會包含項目的座標。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncactivate"></a>CWnd::OnNcActivate  
 當非工作區需要變更以表示作用中或非使用中狀態時，架構會呼叫此成員函式。  
  
```  
afx_msg BOOL OnNcActivate(BOOL bActive);
```  
  
### <a name="parameters"></a>參數  
 `bActive`  
 指定當標題列或圖示需要變更以表示作用中或非使用中狀態。 `bActive`參數是**TRUE**如果現用標題或圖示是否會繪製。 它是**FALSE**非現用標題或圖示。  
  
### <a name="return-value"></a>傳回值  
 如果視窗應該繼續使用預設處理，則為非零0 表示已停用防止標題列或圖示。  
  
### <a name="remarks"></a>備註  
 預設實作會繪製的標題列和標題列文字，其作用中的色彩中如果`bActive`是**TRUE**和其非使用中的色彩中如果`bActive`是**FALSE**。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onnccalcsize"></a>CWnd::OnNcCalcSize  
 計算需要的大小和用戶端區域的位置時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcCalcSize(
    BOOL bCalcValidRects,  
    NCCALCSIZE_PARAMS* lpncsp);
```  
  
### <a name="parameters"></a>參數  
 `bCalcValidRects`  
 指定應用程式是否應該指定用戶端區域的哪一個部分包含有效的資訊。 Windows 會將有效的資訊複製到新的用戶端區域內的指定區域中。 如果這個參數是**TRUE**，應用程式應該指定用戶端區域的哪一部分無效。  
  
 `lpncsp`  
 指向[NCCALCSIZE_PARAMS](../../mfc/reference/nccalcsize-params-structure.md)資料結構，其中包含應用程式可用來計算新的大小和位置資訊`CWnd`（包括用戶端區域、 框線、 標題、 捲軸等） 的矩形。  
  
### <a name="remarks"></a>備註  
 藉由處理這個訊息，應用程式可以控制視窗的工作區的內容大小或視窗位置變更時。  
  
 值為何`bCalcValidRects`，所指定之陣列的第一個矩形**rgrc**結構成員的`NCCALCSIZE_PARAMS`結構包含視窗的座標。 子視窗，座標是相對於父視窗工作區。 為最上層的視窗的螢幕座標。 應用程式應該修改**rgrc [0]**矩形以反映用戶端區域的位置與大小。  
  
 **Rgrc [1]**和**rgrc [2]**矩形有效值才`bCalcValidRects`是**TRUE**。 在此情況下， **rgrc [1]**移動或調整大小之前，矩形會包含視窗的座標。 **Rgrc [2]**矩形包含視窗的工作區的座標之前已移動的視窗。 所有座標都是相對於父視窗或畫面。  
  
 預設實作會計算視窗特性 （顯示捲軸、 功能表等），為基礎的用戶端區域的大小，並會在將結果放`lpncsp`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onnccreate"></a>CWnd::OnNcCreate  
 架構會呼叫此成員函式之前[WM_CREATE](#oncreate)訊息時`CWnd`先建立的物件。  
  
```  
afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
```  
  
### <a name="parameters"></a>參數  
 `lpCreateStruct`  
 指向[CREATESTRUCT](../../mfc/reference/createstruct-structure.md)資料結構`CWnd`。  
  
### <a name="return-value"></a>傳回值  
 如果建立非工作區，則為非零。 它是 0，如果發生錯誤。**建立**函式會傳回**失敗**在此情況下。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncdestroy"></a>Cwnd::  
 當非工作區正在損毀，而最後一個成員函式稱為當 Windows 視窗終結時由架構呼叫。  
  
```  
afx_msg void OnNcDestroy();
```  
  
### <a name="remarks"></a>備註  
 預設實作會執行某些清除，則會呼叫虛擬成員函式[PostNcDestroy](#postncdestroy)。  
  
 覆寫`PostNcDestroy`如果您想要執行您自己的清除，例如**刪除此**作業。 如果您覆寫`OnNcDestroy`，您必須呼叫`OnNcDestroy`您基底類別，以確保視窗會釋出內部配置任何記憶體中。  
  
##  <a name="onnchittest"></a>CWnd::OnNcHitTest  
 架構會呼叫此成員函式`CWnd`物件，其中包含資料指標 (或`CWnd`物件使用[SetCapture](#setcapture)擷取滑鼠輸入的成員函式) 每次移動滑鼠時。  
  
```  
afx_msg LRESULT OnNcHitTest(CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `point`  
 包含游標 x 和 y 座標。 這些座標是一律螢幕座標。  
  
### <a name="return-value"></a>傳回值  
 滑鼠點擊測試的其中一個列舉值下, 面所列。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onnclbuttondblclk"></a>CWnd::OnNcLButtonDblClk  
 架構會呼叫此成員函式，當使用者按兩下滑鼠左鍵，而游標位於的非工作區內`CWnd`。  
  
```  
afx_msg void OnNcLButtonDblClk(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
 如果可行， [WM_SYSCOMMAND](#onsyscommand)傳送訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onnclbuttondown"></a>CWnd::OnNcLButtonDown  
 架構會呼叫此成員函式，當使用者按下滑鼠左鍵，而游標位於的非工作區內`CWnd`物件。  
  
```  
afx_msg void OnNcLButtonDown(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
 如果可行， [WM_SYSCOMMAND](#onsyscommand)傳送。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至您的函式的參數反映收到訊息時架構所收到的參數。如果您呼叫此函式的基底類別實作時，該實作會使用原本隨訊息並不是您提供參數至函式的參數。  
  
##  <a name="onnclbuttonup"></a>CWnd::OnNcLButtonUp  
 當使用者放開滑鼠左鍵，而游標位於的非工作區內，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcLButtonUp(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
 如果可行， [WM_SYSCOMMAND](#onsyscommand)傳送。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncmbuttondblclk"></a>CWnd::OnNcMButtonDblClk  
 當使用者按兩下滑鼠中間鍵的非工作區內的資料指標時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcMButtonDblClk(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncmbuttondown"></a>CWnd::OnNcMButtonDown  
 當使用者按下滑鼠中間鍵的非工作區內的資料指標時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcMButtonDown(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncmbuttonup"></a>CWnd::OnNcMButtonUp  
 當使用者放開滑鼠中鍵，而游標位於的非工作區內，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcMButtonUp(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncmousehover"></a>CWnd::OnNcMouseHover  
 當游標停留在先前呼叫中指定的時間週期 視窗中非工作區時，架構會呼叫此成員函式[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。  
  
```  
afx_msg void OnNcMouseHover(
    UINT nHitTest,   
    CPoint point);  
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nHitTest`|所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](http://msdn.microsoft.com/library/windows/desktop/ms645618)訊息。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於螢幕左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_NCMOUSEHOVER](http://msdn.microsoft.com/library/windows/desktop/ms645625)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncmouseleave"></a>CWnd::OnNcMouseLeave  
 當游標離開之前的呼叫中所指定視窗中非工作區時，架構會呼叫此成員函式[TrackMouseEvent](http://msdn.microsoft.com/library/windows/desktop/ms646265)。  
  
```  
afx_msg void OnNcMouseLeave();
```  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_NCMOUSELEAVE](http://msdn.microsoft.com/library/windows/desktop/ms645626)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncmousemove"></a>CWnd::OnNcMouseMove  
 當游標移動時的非工作區內，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcMouseMove(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
 如果可行， [WM_SYSCOMMAND](#onsyscommand)傳送訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncpaint"></a>CWnd::OnNcPaint  
 當非工作區需要繪製時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcPaint();
```  
  
### <a name="remarks"></a>備註  
 預設實作會繪製視窗框架。  
  
 應用程式可以覆寫此呼叫，並繪製自己自訂的視窗框架。 即使更改框架的形狀，會一律矩形，裁剪區域。  
  
##  <a name="onncrbuttondblclk"></a>CWnd::OnNcRButtonDblClk  
 當使用者按兩下滑鼠按鈕的非工作區內的資料指標時，架構會呼叫此成員函式`CWnd`。  
  
```  
afx_msg void OnNcRButtonDblClk(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncrbuttondown"></a>CWnd::OnNcRButtonDown  
 當使用者按滑鼠右鍵，而游標位於的非工作區內，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcRButtonDown(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncrbuttonup"></a>CWnd::OnNcRButtonUp  
 當使用者放開滑鼠按鈕，而游標位於的非工作區內，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcRButtonUp(
    UINT nHitTest,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nHitTest`  
 指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。  
  
 `point`  
 指定`CPoint`物件，其中包含 x 和 y 螢幕座標的游標位置。 這些座標是一律相對於螢幕左上角。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncrenderingchanged"></a>CWnd::OnNcRenderingChanged  
 當非工作區的轉譯原則已變更時，架構會呼叫這個成員。  
  
```  
afx_msg void OnNcRenderingChanged(BOOL bIsRendering);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `bIsRendering`|`true`如果有啟用桌面視窗管理員 (DWM) 呈現之非工作區視窗;`false`如果轉譯已停用。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_DWMNCRENDERINGCHANGED](http://msdn.microsoft.com/library/windows/desktop/dd388200)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncxbuttondblclk"></a>CWnd::OnNcXButtonDblClk  
 當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗中非工作區中，架構會呼叫此成員函式。  
  
```  
void OnNcXButtonDblClk(
    short nHitTest,   
    UINT nButton,   
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nHitTest`|所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](http://msdn.microsoft.com/library/windows/desktop/ms645618)訊息。|  
|[in] `nButton`|值為`XBUTTON1`，按兩下第一個 Microsoft intellimouse 滑鼠的 X 按鈕時或`XBUTTON2`如果第二個 X 按鈕按兩下時。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於工作區的左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_XBUTTONDBLCLK](http://msdn.microsoft.com/library/windows/desktop/ms646244)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 此訊息會發佈到包含游標的視窗。 如果視窗已捕捉滑鼠，這個訊息將不會張貼。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncxbuttondown"></a>CWnd::OnNcXButtonDown  
 當使用者按下 XBUTTON1 或 XBUTTON2 的滑鼠游標位於視窗中非工作區中，架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcXButtonDown(
    short nHitTest,   
    UINT nButton,   
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nHitTest`|所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](http://msdn.microsoft.com/library/windows/desktop/ms645618)訊息。|  
|[in] `nButton`|值為`XBUTTON1`如果按下的第一個滑鼠 X 按鈕時，或`XBUTTON2`如果第二個 X 按鈕按下。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於螢幕左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_NCXBUTTONDOWN](http://msdn.microsoft.com/library/windows/desktop/ms645632)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 此訊息會發佈到包含游標的視窗。 如果視窗已捕捉滑鼠，這個訊息將不會張貼。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onncxbuttonup"></a>CWnd::OnNcXButtonUp  
 當使用者放開 XBUTTON1 或 XBUTTON2 的滑鼠游標位於視窗之非工作區中，而架構會呼叫此成員函式。  
  
```  
afx_msg void OnNcXButtonUp(
    short nHitTest,   
    UINT nButton,   
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nHitTest`|所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](http://msdn.microsoft.com/library/windows/desktop/ms645618)訊息。|  
|[in] `nButton`|值為`XBUTTON1`放開第一個滑鼠 X 按鈕時，或`XBUTTON2`如果第二個 X 按鈕已釋放。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於螢幕左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_NCXBUTTONUP](http://msdn.microsoft.com/library/windows/desktop/ms646240)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 此訊息會發佈到包含游標的視窗。 如果視窗已捕捉滑鼠，這個訊息將不會張貼。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onnextmenu"></a>CWnd::OnNextMenu  
 架構會呼叫此成員函式時向右或向左鍵使用時切換功能表列和系統功能表。  
  
```  
afx_msg void OnNextMenu(
    UINT nKey,  
    LPMDINEXTMENU lpMdiNextMenu);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nKey`|的位元組合 (OR) 旗標，表示哪個輔助按鍵按下按鍵。 例如，`MK_CONTROL`旗標表示，按下 CTRL 鍵。<br /><br /> 如需旗標的清單，請參閱中的 「 訊息參數 」 子標題[有關滑鼠輸入](http://msdn.microsoft.com/library/windows/desktop/ms645601)。|  
|[in] `lpMdiNextMenu`|指標[MDINEXTMENU](http://msdn.microsoft.com/library/windows/desktop/ms647561)結構，其中包含 [啟動] 功能表的相關資訊。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_UNINITMENUPOPUP](http://msdn.microsoft.com/library/windows/desktop/ms647614)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 回應這個訊息，在您的應用程式可以設定`hmenuNext`隸屬[MDINEXTMENU](http://msdn.microsoft.com/library/windows/desktop/ms647561)結構，以指定要切換的功能表和`hwndNext`成員，以指定的視窗來接收功能表通知訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onnotify"></a>Cwnd:: Onnotify  
 架構會呼叫此成員函式，以通知控制項的父視窗，在控制項中已發生事件或控制項需要某些種類的資訊。  
  
```  
virtual BOOL OnNotify(
    WPARAM wParam,  
    LPARAM lParam,  
    LRESULT* pResult);
```  
  
### <a name="parameters"></a>參數  
 `wParam`  
 識別訊息是否從控制項傳送訊息的控制項。 否則，`wParam`為 0。  
  
 `lParam`  
 通知訊息的指標 ( **NMHDR**) 結構，其中包含通知程式碼和其他資訊。 對於某些通知的訊息，此參數會指向具有較大結構**NMHDR**結構做為其第一個成員。  
  
 `pResult`  
 指標**LRESULT**用來儲存結果的程式碼，如果處理訊息的變數。  
  
### <a name="return-value"></a>傳回值  
 應用程式會傳回非零，如果它會處理此訊息。否則便是 0。  
  
### <a name="remarks"></a>備註  
 `OnNotify`處理控制項通知訊息對應。  
  
 在衍生類別處理此成員函式會覆寫**WM_NOTIFY**訊息。 覆寫不會處理訊息對應，除非基底類別`OnNotify`呼叫。  
  
 如需有關 WM_NOTIFY 訊息的詳細資訊，請參閱 < 技術提示 61 (TN061)， [ON_NOTIFY 和 WM_NOTIFY 訊息](../../mfc/tn061-on-notify-and-wm-notify-messages.md)。 您可能也會想要的相關的主題中所述[控制主題](../../mfc/controls-mfc.md)，和 TN062，[訊息反映的 Windows 控制項](../../mfc/tn062-message-reflection-for-windows-controls.md)。  
  
##  <a name="onnotifyformat"></a>CWnd::OnNotifyFormat  
 架構會呼叫此成員函式，來判斷是否目前的視窗接受 ANSI 或 Unicode 結構的 WM_NOTIFY 通知訊息中。  
  
```  
afx_msg UINT OnNotifyFormat(
    CWnd* pWnd,   
    UINT nCommand);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `pWnd`|指標`CWnd`物件，表示視窗傳送[WM_NOTIFY](http://msdn.microsoft.com/library/windows/desktop/bb775583)訊息。<br /><br /> 這個參數是控制項的指標，如果`nCommand`參數是`NF_QUERY`，控制項的父視窗的指標或如果`nCommand`是`NF_REQUERY`。|  
|[in] `nCommand`|特製化的命令值**WM_NOTIFY**訊息。 可能值為：<br /><br /> - `NF_QUERY` -<br />     訊息是一個查詢，以判斷是否應在使用 ANSI 或 Unicode 結構**WM_NOTIFY**訊息。 此訊息會傳送自控制項至其父視窗建立控制項，並在回應期間`NF_REQUERY`此訊息的形式。<br />- `NF_REQUERY` -<br />     訊息是將控制項傳送的要求`NF_QUERY`此訊息至其父視窗的形式。 此要求從父視窗，傳送，會要求重新查詢中使用之型別的結構相關父控制項**WM_NOTIFY**訊息。 如果`nCommand`參數是`NF_REQUERY`，則傳回值是重新查詢作業的結果。|  
  
### <a name="return-value"></a>傳回值  
  
|傳回值|意義|  
|------------------|-------------|  
|`NFR_ANSI`|應該在使用 ANSI 結構**WM_NOTIFY**控制項所傳送訊息。|  
|`NFR_UNICODE`|應該在使用 Unicode 結構**WM_NOTIFY**控制項所傳送訊息。|  
|0|發生錯誤。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_NOTIFYFORMAT](http://msdn.microsoft.com/library/windows/desktop/bb775584)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 **WM_NOTIFY**訊息傳送至其父視窗，將通用控制項從和到通用控制項的父視窗。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onpaint"></a>CWnd::OnPaint  
 Windows 或應用程式提出要求來重新繪製的應用程式視窗的一部份時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnPaint();
```  
  
### <a name="remarks"></a>備註  
 [WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145137)訊息時，送[UpdateWindow](#updatewindow)或[RedrawWindow](#redrawwindow)呼叫成員函式。  
  
 視窗可能會接收呼叫的結果的內部小畫家訊息`RedrawWindow`成員函式**RDW_INTERNALPAINT**旗標組。 在此情況下視窗可能沒有更新區域。 應用程式應該呼叫[GetUpdateRect](#getupdaterect)成員函式來判斷視窗是否有更新區域。 如果`GetUpdateRect`傳回 0 時，應用程式不應該呼叫[BeginPaint](#beginpaint)和[EndPaint](#endpaint)成員函式。  
  
 檢查是否有任何必要的內部重繪或藉由查看其內部資料結構，每個更新的應用程式必須負責`WM_PAINT`訊息，因為`WM_PAINT`訊息可能造成無效的區域並呼叫`RedrawWindow`成員函式**RDW_INTERNALPAINT**旗標設。  
  
 發生內部`WM_PAINT`訊息在 Windows 中有不同的傳送一次。 之後發生內部`WM_PAINT`訊息傳送至視窗`UpdateWindow`成員函式，無法進一步`WM_PAINT`訊息會傳送或張貼直到視窗無效，或直到`RedrawWindow`以一次呼叫成員函式**RDW_INTERNALPAINT**旗標設。  
  
 在轉譯的文件/檢視應用程式中的映像的資訊，請參閱[cview:: Ondraw](../../mfc/reference/cview-class.md#ondraw)。  
  
 如需有關使用**WM_Paint**，請參閱下列主題[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]:  
  
- [WM_PAINT 訊息](http://msdn.microsoft.com/library/windows/desktop/dd145137)  
  
- [使用 WM_PAINT 訊息](http://msdn.microsoft.com/library/windows/desktop/dd145193)  
  
##  <a name="onpaintclipboard"></a>CWnd::OnPaintClipboard  
 當 [剪貼簿] 擁有者將資料以 `OnPaintClipboard` 格式放在 [剪貼簿]，導致 [剪貼簿] 檢視者的工作區需要重新繪製時，[剪貼簿] 檢視者可以呼叫 [剪貼簿] 擁有者的 `CF_OWNERDISPLAY` 成員函式。  
  
```  
afx_msg void OnPaintClipboard(
    CWnd* pClipAppWnd,  
    HGLOBAL hPaintStruct);
```  
  
### <a name="parameters"></a>參數  
 `pClipAppWnd`  
 指定 [剪貼簿] 應用程式視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
 *hPaintStruct*  
 識別[PAINTSTRUCT](../../mfc/reference/paintstruct-structure.md)資料結構，定義要繪製的用戶端區域的哪一部分。  
  
### <a name="remarks"></a>備註  
 若要判斷整個工作區或它的部分是否需要重新繪製，剪貼簿擁有者必須比較中的繪圖區域的維度**rcpaint**隸屬`PAINTSTRUCT`結構中最新的維度[OnSizeClipboard](#onsizeclipboard)成員函式呼叫。  
  
 `OnPaintClipboard`應該使用[GlobalLock](http://msdn.microsoft.com/library/windows/desktop/aa366584)鎖定的記憶體，其中包含 Windows 函式`PAINTSTRUCT`資料結構，並解除鎖定該記憶體與[GlobalUnlock](http://msdn.microsoft.com/library/windows/desktop/aa366595) Windows 函式結束前。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onpalettechanged"></a>CWnd::OnPaletteChanged  
 具有輸入焦點的視窗有實現其邏輯色板，藉此變更系統調色盤之後，架構會呼叫此成員函式的所有最上層視窗。  
  
```  
afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
```  
  
### <a name="parameters"></a>參數  
 `pFocusWnd`  
 指定造成系統調色盤來變更視窗的指標。 指標可能是暫時性的不會儲存。  
  
### <a name="remarks"></a>備註  
 這個呼叫可讓不使用色彩調色盤來實現其邏輯色板和更新其工作區的輸入焦點的視窗。  
  
 `OnPaletteChanged`成員函式針對所有最上層和重疊視窗中，包括變更系統調色盤，而且導致呼叫`WM_PALETTECHANGED`来傳送訊息。 如果任何子視窗使用調色盤的色彩，此訊息必須傳遞給它。  
  
 若要避免無限迴圈，視窗不應該實現其色板除非它判斷`pFocusWnd`不包含本身的指標。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onpaletteischanging"></a>CWnd::OnPaletteIsChanging  
 架構會呼叫此成員函式，以通知應用程式的應用程式即將實現其邏輯色板。  
  
```  
afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
```  
  
### <a name="parameters"></a>參數  
 *pRealizeWnd*  
 指定即將實現其邏輯色板的視窗。  
  
### <a name="remarks"></a>備註  
 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onparentnotify"></a>CWnd::OnParentNotify  
 父`OnParentNotify`建立或終結，所以它的子視窗時，或將游標移至子視窗時，使用者按一下滑鼠按鈕時由架構呼叫成員函式。  
  
```  
afx_msg void OnParentNotify(
    UINT message,  
    LPARAM lParam);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定的事件其正在通知父和子視窗的識別項。 事件是低序位字組的`message`。 如果事件是`WM_CREATE`或`WM_DESTROY`，高序位字組的`message`是識別項的子視窗; 否則高序位文字未定義。 事件 (低序位字組的`message`) 可以是下列值︰  
  
- `WM_CREATE`正在建立子視窗。  
  
- `WM_DESTROY`子視窗正在被終結。  
  
- `WM_LBUTTONDOWN`使用者已放置滑鼠游標移至子視窗，並按下滑鼠左的按鈕。  
  
- `WM_MBUTTONDOWN`使用者已放置滑鼠游標移至子視窗，並按下滑鼠中間鍵。  
  
- `WM_RBUTTONDOWN`使用者已放置滑鼠游標移至子視窗，並按一下滑鼠右鍵。  
  
 `lParam`  
 如果事件 （低序位字組） 的`message`是`WM_CREATE`或`WM_DESTROY`，`lParam`指定的子視窗的視窗控制代碼，否則為`lParam`包含 x 和 y 座標的資料指標。 X 座標是低序位字組中且的 y 座標，位於高序位文字。  
  
### <a name="remarks"></a>備註  
 建立子視窗時，系統會呼叫`OnParentNotify`之前[建立](#create)建立視窗的成員函式傳回。 終結子視窗時，系統會呼叫`OnParentNotify`會執行任何處理終結的視窗之前。  
  
 `OnParentNotify`是針對所有上階視窗的子視窗，包括最上層視窗呼叫。  
  
 所有的子視窗，但不包括具有[WS_EX_NOPARENTNOTIFY](../../mfc/reference/extended-window-styles.md)樣式傳送此訊息至其父視窗。 根據預設，在對話方塊中的子視窗有**WS_EX_NOPARENTNOTIFY**樣式，除非沒有這個樣式建立子視窗呼叫[CreateEx](#createex)成員函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onpowerbroadcast"></a>CWnd::OnPowerBroadcast  
 電源管理事件發生時，架構會呼叫此成員函式。  
  
```  
afx_msg UINT OnPowerBroadcast(
    UINT nPowerEvent,   
    UINT nEventData);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nPowerEvent`|電源管理事件。|  
|[in] `nEventData`|事件的特定資料。|  
  
### <a name="return-value"></a>傳回值  
 如果事件的要求，傳回`true`授與要求，或`BROADCAST_QUERY_DENY`為拒絕要求。  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_POWERBROADCAST](http://msdn.microsoft.com/library/windows/desktop/aa373247)訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `nPowerEvent`參數指定的事件，例如電池電力不足、 電源狀態已變更、 要求或拒絕擱置作業的權限、 事件後自動繼續作業，系統正在暫止的作業，或暫停之後繼續執行作業。 `nEventData`通常不使用參數。 如需詳細資訊，請參閱`wParam`和`lParam`參數[WM_POWERBROADCAST](http://msdn.microsoft.com/library/windows/desktop/aa373247)訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onquerydragicon"></a>CWnd::OnQueryDragIcon  
 架構會呼叫此成員函式的最小化 （圖示） 視窗中，但是沒有針對其類別定義的圖示。  
  
```  
afx_msg HCURSOR OnQueryDragIcon();
```  
  
### <a name="return-value"></a>傳回值  
 包含游標或圖示的控制代碼，以低序位字組的 doubleword 值。 資料指標或圖示必須是相容的顯示器驅動程式的解決方法。 如果應用程式會傳回**NULL**，系統會顯示預設資料指標。 預設會傳回值為**NULL**。  
  
### <a name="remarks"></a>備註  
 系統會發出此呼叫來取得要顯示 當使用者拖曳最小化的視窗的游標。 如果應用程式傳回圖示或游標的控制代碼，則系統會將它轉換成黑白。 如果應用程式傳回的控制代碼，此控制代碼必須識別單色游標或圖示相容顯示器驅動程式的解決方法。 應用程式可以呼叫[CWinApp::LoadCursor](../../mfc/reference/cwinapp-class.md#loadcursor)或[CWinApp::LoadIcon](../../mfc/reference/cwinapp-class.md#loadicon)成員函式從其可執行檔中的資源載入的資料指標或圖示，並取得此控制代碼。  
  
##  <a name="onqueryendsession"></a>CWnd::OnQueryEndSession  
 架構會呼叫此成員函式，當使用者選擇結束 Windows 工作階段，或當應用程式呼叫[ExitWindows](http://msdn.microsoft.com/library/windows/desktop/aa376867) Windows 函式。  
  
```  
afx_msg BOOL OnQueryEndSession();
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果應用程式可以輕鬆地關機;否則便是 0。  
  
### <a name="remarks"></a>備註  
 如果任何應用程式會傳回 0，就不會結束 Windows 工作階段。 Windows 會停止呼叫`OnQueryEndSession`只要一個應用程式會傳回 0，並傳送[WM_ENDSESSION](#onendsession)訊息使用的參數值的**FALSE**已傳回非零的任何應用程式。  
  
##  <a name="onquerynewpalette"></a>CWnd::OnQueryNewPalette  
 架構會呼叫此成員函式時`CWnd`物件即將接收輸入的焦點，給予`CWnd`得以實現其邏輯色板收到焦點時。  
  
```  
afx_msg BOOL OnQueryNewPalette();
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果`CWnd`實現其邏輯色板; 否則為 0。  
  
##  <a name="onqueryopen"></a>CWnd::OnQueryOpen  
 架構會呼叫此成員函式時`CWnd`物件最小化，且使用者要求的`CWnd`還原至其 preminimized 的大小和位置。  
  
```  
afx_msg BOOL OnQueryOpen();
```  
  
### <a name="return-value"></a>傳回值  
 為非零，如果可以開啟圖示，或是 0，表示正在開啟時，防止圖示。  
  
### <a name="remarks"></a>備註  
 在`OnQueryOpen`，`CWnd`應該不會執行任何動作，會導致啟動或焦點變更 （例如，建立對話方塊）。  
  
##  <a name="onqueryuistate"></a>CWnd::OnQueryUIState  
 呼叫以擷取視窗的使用者介面 (UI) 狀態。  
  
```  
afx_msg UINT OnQueryUIState();
```  
  
### <a name="return-value"></a>傳回值  
 傳回值是**NULL**如果會顯示焦點指標和鍵盤快速鍵。 否則，傳回值可以是一或多個下列值︰  
  
- **UISF_HIDEFOCUS**焦點指標會隱藏。  
  
- **UISF_HIDEACCEL**隱藏鍵盤快速鍵。  
  
- **UISF_ACTIVE Windows XP:**控制項應該繪製在使用中控制項所使用的樣式。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬的功能[WM_QUERYUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646355)訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="onrawinput"></a>CWnd::OnRawInput  
 當目前視窗取得原始輸入時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnRawInput(
    UINT nInputCode,  
    HRAWINPUT hRawInput);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nInputCode`|指出輸入發生時應用程式已在前景或未驗證的輸入程式碼。 在任一情況下，應用程式必須呼叫[CWnd::DefWindowProc](#defwindowproc)讓系統可以執行清除作業。<br /><br /> 這個參數可以是下列值之一︰<br /><br /> - `RIM_INPUT`輸入時發生應用程式在前景。<br />- `RIM_INPUTSINK`輸入應用程式不在前景時發生。|  
|[in] `hRawInput`|控制代碼[RAWINPUT](http://msdn.microsoft.com/library/windows/desktop/ms645562)結構，其中包含從裝置的原始輸入。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[澗](http://msdn.microsoft.com/library/windows/desktop/ms646275)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onrbuttondblclk"></a>CWnd::OnRButtonDblClk  
 當使用者按兩下滑鼠按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnRButtonDblClk(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定的 x 和 y 座標的資料指標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
 只有具有 windows **CS_DBLCLKS** [WNDCLASS](http://msdn.microsoft.com/library/windows/desktop/ms633576)樣式可以接收`OnRButtonDblClk`呼叫。 這是 Microsoft Foundation 類別庫中的視窗的預設值。 Windows 呼叫`OnRButtonDblClk`當使用者按下，釋出，然後再次按下滑鼠右按鈕在系統中的按兩下時間限制。 按兩下滑鼠右鍵實際上會產生四個事件︰ [WM_RBUTTONDOWN](#onrbuttondown)和[WM_RBUTTONUP](#onrbuttonup)訊息，`OnRButtonDblClk`呼叫，而另一個`WM_RBUTTONUP`訊息時放開按鍵時。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onrbuttondown"></a>CWnd::OnRButtonDown  
 當使用者按下滑鼠按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnRButtonDown(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_RBUTTON**設定如果滑鼠按鈕已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定的 x 和 y 座標的資料指標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onrbuttonup"></a>CWnd::OnRButtonUp  
 當使用者放開滑鼠按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnRButtonUp(
    UINT nFlags,  
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
 `nFlags`  
 表示各種虛擬按鍵是否關閉。 這個參數可以是下列值的任何組合︰  
  
- **MK_CONTROL** CTRL 鍵時所設定。  
  
- **MK_LBUTTON**設定如果滑鼠左鍵已關閉。  
  
- **MK_MBUTTON**設定如果滑鼠中間鍵已關閉。  
  
- **MK_SHIFT**設定如果 SHIFT 鍵已關閉。  
  
 `point`  
 指定的 x 和 y 座標的資料指標。 這些座標是一律相對於視窗左上角。  
  
### <a name="remarks"></a>備註  
 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onregisteredmousewheel"></a>CWnd::OnRegisteredMouseWheel  
 當使用者滾動滑鼠滾輪，並遇到滾輪的下一個刻度，架構會呼叫此成員函式。  
  
```  
afx_msg LRESULT OnRegisteredMouseWheel(
    WPARAM wParam,  
    LPARAM lParam);
```  
  
### <a name="parameters"></a>參數  
 `wParam`  
 水平位置的指標。  
  
 `lParam`  
 垂直位置的指標。  
  
### <a name="return-value"></a>傳回值  
 在此階段不重要。 一律為零。  
  
### <a name="remarks"></a>備註  
 覆寫時，除非`OnRegisteredMouseWheel`會將訊息路由至適當視窗 （具有焦點的父視窗），並呼叫[WM_MOUSEWHEEL](http://msdn.microsoft.com/library/windows/desktop/ms645617)該視窗的處理常式。  
  
 覆寫此成員函式，提供您自己的訊息路由，或改變滑鼠滾輪捲動行為。  
  
> [!NOTE]
> `OnRegisteredMouseWheel`Windows 95/98 和 Windows NT 3.51 處理訊息。 Windows NT 4.0 訊息處理，使用[OnMouseWheel](#onmousewheel)。  
  
##  <a name="onrenderallformats"></a>CWnd::OnRenderAllFormats  
 剪貼簿擁有者的`OnRenderAllFormats`終結擁有者應用程式時由架構呼叫成員函式。  
  
```  
afx_msg void OnRenderAllFormats();
```  
  
### <a name="remarks"></a>備註  
 剪貼簿擁有者應該轉譯它能夠產生，並將每一種格式的資料控制代碼傳遞至剪貼簿中，藉由呼叫的所有格式中的資料[SetClipboardData](http://msdn.microsoft.com/library/windows/desktop/ms649051) Windows 函式。 這可確保剪貼簿包含有效的資料，即使呈現資料的應用程式損毀。 應用程式應該呼叫[OpenClipboard](#openclipboard)成員函式，然後再呼叫[SetClipboardData](http://msdn.microsoft.com/library/windows/desktop/ms649051) Windows 函式和呼叫[CloseClipboard](http://msdn.microsoft.com/library/windows/desktop/ms649035) Windows 函式之後。  
  
##  <a name="onrenderformat"></a>CWnd::OnRenderFormat  
 剪貼簿擁有者的`OnRenderFormat`需要呈現具有延遲轉譯的特定格式時由架構呼叫成員函式。  
  
```  
afx_msg void OnRenderFormat(UINT nFormat);
```  
  
### <a name="parameters"></a>參數  
 `nFormat`  
 指定的剪貼簿格式。  
  
### <a name="remarks"></a>備註  
 收件者應該呈現以該格式的資料，並將它傳遞到剪貼簿中，藉由呼叫[SetClipboardData](http://msdn.microsoft.com/library/windows/desktop/ms649051) Windows 函式。  
  
 請勿呼叫`OpenClipboard`成員函式或**CloseClipboard** Windows 函式，從`OnRenderFormat`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsessionchange"></a>CWnd::OnSessionChange  
 架構會呼叫此成員函式，以通知應用程式的工作階段狀態的變更。  
  
```  
afx_msg void OnSessionChange(
    UINT nSessionState,   
    UINT nId);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nSessionState`|狀態碼說明工作階段狀態變更。|  
|[in] `nId`|工作階段識別項。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_WTSSESSION_CHANGE](http://msdn.microsoft.com/library/aa383828)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
 `nSessionState`參數指定的工作階段接上電源插座或從主控台或遠端終端機、 使用者登入或登出、 工作階段中已鎖定或解除鎖定，或工作階段已變更為遠端控制的狀態。 如需詳細資訊，請參閱`wParam`參數[WM_WTSSESSION_CHANGE](http://msdn.microsoft.com/library/aa383828)訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsetcursor"></a>CWnd::OnSetCursor  
 架構會呼叫此成員函式如果不擷取滑鼠輸入，而且滑鼠導致游標移動內`CWnd`物件。  
  
```  
afx_msg BOOL OnSetCursor(
    CWnd* pWnd,  
    UINT nHitTest,  
    UINT message);
```  
  
### <a name="parameters"></a>參數  
 `pWnd`  
 指定包含游標的視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
 `nHitTest`  
 指定[點擊測試](#onnchittest)區碼。 資料指標的位置來決定點擊的測試。  
  
 `message`  
 指定滑鼠訊息數目。  
  
### <a name="return-value"></a>傳回值  
 若要停止進一步處理，或是 0，表示繼續為非零。  
  
### <a name="remarks"></a>備註  
 預設實作會呼叫父視窗的`OnSetCursor`處理之前。 如果父視窗傳回**TRUE**，停止進一步處理。 呼叫父視窗可讓父視窗控制子視窗中的資料指標的設定。  
  
 預設實作資料指標為箭號，如果不是工作區中或者設定為類別註冊的資料指標才。  
  
 如果`nHitTest`是**HTERROR**和`message`滑鼠 button-down 訊息， **MessageBeep**呼叫成員函式。  
  
 `message`參數是 0 時`CWnd`進入功能表模式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsetfocus"></a>CWnd::OnSetFocus  
 架構會呼叫此成員函式之後獲得輸入的焦點。  
  
```  
afx_msg void OnSetFocus(CWnd* pOldWnd);
```  
  
### <a name="parameters"></a>參數  
 *pOldWnd*  
 包含`CWnd`失去輸入的焦點的物件 (可能是**NULL**)。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
### <a name="remarks"></a>備註  
 若要顯示插入號，`CWnd`此時應該呼叫適當的插入號函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsettingchange"></a>CWnd::OnSettingChange  
 這個架構會呼叫`OnSettingChange`Win32 SystemParametersInfo 函式變更整個系統的設定時的所有最上層視窗。  
  
```  
afx_msg void OnSettingChange(
    UINT uFlags,  
    LPCTSTR lpszSection);
```  
  
### <a name="parameters"></a>參數  
 `uFlags`  
 當系統傳送的訊息**SystemParametersInfo**呼叫，這個參數是旗標，指出已變更系統參數。 如需值的清單，請參閱[SystemParametersInfo](http://msdn.microsoft.com/library/windows/desktop/ms724947)中[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 當應用程式傳送訊息時，這個參數必須是 0。  
  
 `lpszSection`  
 指向字串，指定已變更區段的名稱。 （字串不包含方括號括住的區段名稱）。  
  
### <a name="remarks"></a>備註  
 應用程式應將訊息傳送至所有最上層視窗，當它變更系統參數，而 Windows 會傳送訊息，如果使用者變更透過 控制台設定。  
  
 **ON_WM_SETTINGCHANGE**訊息會類似於**ON_WM_WININICHANGE**訊息，但是有下列差異︰  
  
-   使用**ON_WM_SETTINGCHANGE**時執行 Windows NT 4.0 或更新版本中，或在 Windows 95/98。  
  
-   使用**ON_WININICHANGE**當執行 Windows NT 3.51 或更舊版本。 此訊息已經過時。  
  
 您只能有一個這些巨集的訊息對應中。 若要撰寫的程式，適用於 Windows 95/98 和 Windows NT 4.0，寫入的處理常式**ON_WM_SETTINGCHANGE**。 在 Windows NT 3.51 下您的處理常式會先呼叫`OnSettingChange`和`uFlags`而且將永遠為零。  
  
##  <a name="onshowwindow"></a>CWnd::OnShowWindow  
 架構會呼叫此成員函式時`CWnd`物件即將隱藏或顯示。  
  
```  
afx_msg void OnShowWindow(
    BOOL bShow,  
    UINT nStatus);
```  
  
### <a name="parameters"></a>參數  
 `bShow`  
 指定是否要顯示視窗。 它是**TRUE**視窗已經顯示; 如果它是**FALSE**如果視窗已經隱藏。  
  
 `nStatus`  
 指定要顯示的視窗狀態。 如果因為傳送訊息，則會是 0`ShowWindow`成員函式呼叫，否則為`nStatus`是下列其中之一︰  
  
- **SW_PARENTCLOSING**父視窗已關閉 （正在進行圖示），或快顯視窗將會被隱藏。  
  
- **SW_PARENTOPENING**父視窗已開啟 （正在顯示），或正在顯示快顯視窗。  
  
### <a name="remarks"></a>備註  
 隱藏或顯示當視窗`ShowWindow`呼叫成員函式，當重疊的視窗最大化或還原，或重疊或快顯視窗已關閉時 （進行圖示），或是已開啟 （顯示在螢幕上）。 重疊的視窗關閉時，會隱藏該視窗相關聯的所有快顯視窗。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsize"></a>CWnd::OnSize  
 視窗的大小已變更之後，架構會呼叫此成員函式。  
  
```  
afx_msg void OnSize(
    UINT nType,  
    int cx,  
    int cy);
```  
  
### <a name="parameters"></a>參數  
 `nType`  
 指定調整大小要求的類型。 這個參數可以是下列值之一︰  
  
- **SIZE_MAXIMIZED**最大化視窗。  
  
- **SIZE_MINIMIZED**已最小化視窗。  
  
- **SIZE_RESTORED**調整視窗大小，但**SIZE_MINIMIZED**也**SIZE_MAXIMIZED**套用。  
  
- **SIZE_MAXHIDE**一些其他視窗最大化時傳送訊息給所有的快顯視窗。  
  
- **SIZE_MAXSHOW**訊息傳送至所有快顯視窗時已將一些其他視窗還原成其先前的大小。  
  
 `cx`  
 指定新的用戶端區域的寬度。  
  
 `cy`  
 指定新的用戶端區域的高度。  
  
### <a name="remarks"></a>備註  
 如果[SetScrollPos](#setscrollpos)或[MoveWindow](#movewindow)從子視窗呼叫成員函式`OnSize`、`bRedraw`參數`SetScrollPos`或`MoveWindow`應為零會造成`CWnd`重新繪製。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 109](../../mfc/reference/codesnippet/cpp/cwnd-class_50.cpp)]  
  
##  <a name="onsizeclipboard"></a>CWnd::OnSizeClipboard  
 剪貼簿擁有者的`OnSizeClipboard`剪貼簿包含資料時，呼叫成員函式以剪貼簿檢視器`CF_OWNERDISPLAY`屬性和工作區的 [剪貼簿檢視器] 視窗的大小已變更。  
  
```  
afx_msg void OnSizeClipboard(
    CWnd* pClipAppWnd,  
    HGLOBAL hRect);
```  
  
### <a name="parameters"></a>參數  
 `pClipAppWnd`  
 識別在剪貼簿應用程式視窗。 指標可能是暫時性的不會儲存。  
  
 *hRect*  
 全域記憶體物件識別。 記憶體物件包含指定剪貼簿擁有者來繪製區域的矩形資料結構。  
  
### <a name="remarks"></a>備註  
 `OnSizeClipboard`呼叫成員函式是以 null 矩形 (0,0,0,0) 做為新的大小即將終結或最小化剪貼簿應用程式時。 這可讓以釋出其顯示資源的剪貼簿擁有者。  
  
 內`OnSizeClipboard`，應用程式必須使用[GlobalLock](http://msdn.microsoft.com/library/windows/desktop/aa366584) Windows 函式鎖定包含 RECT 資料結構的記憶體。 已解除鎖定該記憶體與應用程式[GlobalUnlock](http://msdn.microsoft.com/library/windows/desktop/aa366595) Windows 函式會產生或傳回控制項之前。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsizing"></a>CWnd::OnSizing  
 架構會呼叫此成員函式，以指出使用者已重新調整大小的矩形。  
  
```  
afx_msg void OnSizing(
    UINT nSide,  
    LPRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `nSide`  
 要移動的視窗邊緣。  
  
 `lpRect`  
 位址[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 結構](../../mfc/reference/rect-structure1.md)，就會包含項目的座標。  
  
### <a name="remarks"></a>備註  
 藉由處理這個訊息，應用程式可以監視的大小和拖曳矩形的位置，如有需要變更其大小或位置。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 110](../../mfc/reference/codesnippet/cpp/cwnd-class_51.cpp)]  
  
##  <a name="onspoolerstatus"></a>CWnd::OnSpoolerStatus  
 每當加入或從列印管理員佇列中移除工作時，架構會呼叫此成員函式從列印管理員。  
  
```  
afx_msg void OnSpoolerStatus(
    UINT nStatus,  
    UINT nJobs);
```  
  
### <a name="parameters"></a>參數  
 `nStatus`  
 指定**SP_JOBSTATUS**旗標。  
  
 *nJobs*  
 指定列印管理員佇列中剩餘的工作數目。  
  
### <a name="remarks"></a>備註  
 這個呼叫是僅供參考之用。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onstylechanged"></a>CWnd::OnStyleChanged  
 架構會呼叫此成員函式之後, [SetWindowLong](http://msdn.microsoft.com/library/windows/desktop/ms633591)函式已經變更一個或多個視窗的樣式。  
  
```  
afx_msg void OnStyleChanged(
    int nStyleType,  
    LPSTYLESTRUCT lpStyleStruct);
```  
  
### <a name="parameters"></a>參數  
 `nStyleType`  
 指定視窗的延伸或 nonextended 的樣式已變更。 這個參數可以是下列值的組合︰  
  
- **GWL_EXSTYLE**視窗的延伸的樣式已變更。  
  
- **GWL_STYLE**視窗的 nonextended 的樣式已變更。  
  
 `lpStyleStruct`  
 指向[STYLESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632607)結構，其中包含新的視窗樣式。 應用程式可以檢查樣式，但可以變更它們。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onstylechanging"></a>CWnd::OnStyleChanging  
 架構會呼叫此成員函式時[SetWindowLong](http://msdn.microsoft.com/library/windows/desktop/ms633591)函式即將變更一或多個視窗的樣式。  
  
```  
afx_msg void OnStyleChanging(
    int nStyleType,  
    LPSTYLESTRUCT lpStyleStruct);
```  
  
### <a name="parameters"></a>參數  
 `nStyleType`  
 指定視窗的延伸或 nonextended 的樣式已變更。 這個參數可以是下列值的組合︰  
  
- **GWL_EXSTYLE**視窗的延伸的樣式已變更。  
  
- **GWL_STYLE**視窗的 nonextended 的樣式已變更。  
  
 `lpStyleStruct`  
 指向[STYLESTRUCT](http://msdn.microsoft.com/library/windows/desktop/ms632607)結構，其中包含新的視窗樣式。 應用程式可以檢查的樣式，並加以變更。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsyschar"></a>CWnd::OnSysChar  
 架構會呼叫此成員函式，如果`CWnd`具有輸入的焦點和[WM_SYSKEYUP](#onsyskeyup)和[WM_SYSKEYDOWN](#onsyskeydown)訊息翻譯成。  
  
```  
afx_msg void OnSysChar(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定的 ASCII 字元的按鍵碼的控制項功能表鍵。  
  
 `nRepCnt`  
 指定的重複計數 （次數按鍵重複使用者按住鍵）。  
  
 `nFlags`  
 `nFlags`參數可以有下列這些值︰  
  
|值|意義|  
|-----------|-------------|  
|0-15|指定的重複計數。 值是使用者按住鍵，因此重複按鍵次數...|  
|16-23|指定的掃描程式碼。 值取決於原始設備製造商 (OEM)|  
|24|指定索引鍵是否延伸的金鑰，例如增強 101 或 102 鍵鍵盤會出現右 ALT 和 CTRL 鍵。 值為 1，如果它是擴充的金鑰;否則，它可以是 0。|  
|25-28|Windows 在內部使用。|  
|29|指定的內容程式碼。 值為 1，如果按下按鍵; 時，按住 ALT 鍵否則，值為 0。|  
|30|指定前一個索引鍵的狀態。 值為 1，如果索引鍵已關閉，才能傳送訊息，或如果機碼設定為 0。|  
|31|指定的轉換狀態。 值為 1，如果索引鍵將被釋放，或如果被按下按鍵，則會是 0。|  
  
### <a name="remarks"></a>備註  
 它會指定控制項功能表鍵的虛擬按鍵碼。 （如標準虛擬按鍵碼的清單，請參閱 Winuser.h）  
  
 當內容程式碼為 0，`WM_SYSCHAR`可以傳遞[WM_SYSCHAR](http://msdn.microsoft.com/library/windows/desktop/ms646357)傳送訊息給[translateaccelerator 呼叫](http://msdn.microsoft.com/library/windows/desktop/ms646373)Windows 函式，將會處理它就如同一般的按鍵訊息，而不是系統的字元索引鍵一樣。 這可讓以即使作用中視窗並沒有輸入的焦點用於作用中視窗的快速鍵。  
  
 IBM 增強 101 和 102 鍵鍵盤、 增強的金鑰為右 alt 鍵與右 CTRL 鍵鍵盤; 的主要區段單元、 DEL、 HOME、 END、 PAGE UP、 PAGE DOWN 和箭號左邊的數字鍵台; 在叢集的索引鍵斜線 （/） 和數字鍵台 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元`nFlags`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsyscolorchange"></a>CWnd::OnSysColorChange  
 當系統色彩設定中進行變更時，架構會呼叫此成員函式的所有最上層視窗。  
  
```  
afx_msg void OnSysColorChange();
```  
  
### <a name="remarks"></a>備註  
 Windows 呼叫`OnSysColorChange`系統色彩變更會影響任何視窗。  
  
 使用現有的系統色彩的筆刷的應用程式應該刪除這些筆刷，並重新建立它們使用新的系統色彩。  
  
##  <a name="onsyscommand"></a>CWnd::OnSysCommand  
 使用者控制項 功能表中選取命令時，或在使用者選取最大化或最小化按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnSysCommand(
    UINT nID,  
    LPARAM lParam);
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 指定系統所要求的命令類型。 這個參數可以是下列值之一︰  
  
- **SC_CLOSE**關閉`CWnd`物件。  
  
- **SC_HOTKEY** Activate`CWnd`應用程式指定熱索引鍵相關聯的物件。 低序位字組的`lParam`識別`HWND`来啟動的視窗。  
  
- **SC_HSCROLL**水平捲動。  
  
- **SC_KEYMENU**擷取透過按鍵動作的功能表。  
  
- **SC_MAXIMIZE** (或**SC_ZOOM**) 最大化`CWnd`物件。  
  
- **SC_MINIMIZE** (或**SC_ICON**) 最小化`CWnd`物件。  
  
- **SC_MOUSEMENU**透過滑鼠的功能表，按一下 的擷取。  
  
- **SC_MOVE**移動`CWnd`物件。  
  
- **SC_NEXTWINDOW**移到下一個視窗。  
  
- **SC_PREVWINDOW**移到上一個視窗。  
  
- **SC_RESTORE**還原視窗正常位置和大小。  
  
- **SC_SCREENSAVE**執行系統的 [開機] 區段中指定的螢幕保護裝置應用程式。INI 檔案。  
  
- **SC_SIZE**大小`CWnd`物件。  
  
- **SC_TASKLIST** Execute 或啟用 Windows 工作管理員 」 應用程式。  
  
- **SC_VSCROLL**垂直捲動。  
  
 `lParam`  
 如果控制項功能表命令會使用滑鼠選擇`lParam`包含游標座標。 低序位字組包含 x 座標，高序位文字包含的 y 座標。 否則不會使用這個參數。  
  
- **SC_HOTKEY**啟動應用程式指定熱索引鍵相關聯的視窗。 低序位字組的`lParam`識別要啟動的視窗。  
  
- **SC_SCREENSAVE**執行控制台中的桌面區段中指定的螢幕儲存應用程式。  
  
### <a name="remarks"></a>備註  
 根據預設，`OnSysCommand`執行在上表中指定的預先定義動作的控制項功能表要求。  
  
 在`WM_SYSCOMMAND`郵件、 的四個低序位位元`nID`參數由 Windows 在內部使用。 當應用程式測試的值`nID`，它必須結合值 0xFFF0 與`nID`使用位元值-和運算子，以取得正確的結果。  
  
 在控制項功能表的功能表項目可以修改與`GetSystemMenu`， `AppendMenu`， `InsertMenu`，和`ModifyMenu`成員函式。 修改控制項功能表上的應用程式必須處理`WM_SYSCOMMAND`訊息，以及任何`WM_SYSCOMMAND`應用程式所未處理的訊息必須傳遞給`OnSysCommand`。 加入應用程式的任何命令值必須由應用程式處理，並無法傳遞至`OnSysCommand`。  
  
 應用程式可以執行任何系統指令隨時藉由傳遞`WM_SYSCOMMAND`傳送訊息給`OnSysCommand`。  
  
 從 [控制項] 功能表選取項目所定義的快速鍵 （快速鍵） 按鍵輸入會轉譯成`OnSysCommand`呼叫; 所有其他快速鍵的按鍵動作會轉譯成[WM_COMMAND](#oncommand)訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsysdeadchar"></a>CWnd::OnSysDeadChar  
 架構會呼叫此成員函式，如果`CWnd`物件具有輸入焦點時[OnSysKeyUp](#onsyskeyup)或[OnSysKeyDown](#onsyskeydown)呼叫成員函式。  
  
```  
afx_msg void OnSysDeadChar(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定的索引鍵的寄不出的字元值。  
  
 `nRepCnt`  
 指定的重複計數。  
  
 `nFlags`  
 指定的掃描程式碼、 索引鍵轉換程式碼、 索引鍵的先前狀態和內容的程式碼，如下列清單所示︰  
  
|值|意義|  
|-----------|-------------|  
|0–7|掃描代碼 （OEM 相依值）。 高序位字組的低位元組。|  
|8|擴充索引鍵，例如函式的索引鍵或 （1，表示它是一種擴充的金鑰; 否則為 0） 的數字鍵台上的索引鍵。|  
|9–10|未使用。|  
|11–12|Windows 在內部使用。|  
|13|（若按下按鍵時，按住 ALT 鍵為 1; 否則為 0） 的內容程式碼。|  
|14|先前的主要狀態 (1，表示在呼叫之前，0，如果索引鍵是往上已關閉的索引鍵)。|  
|15|轉換狀態 （1，表示被釋放，索引鍵，0，如果要按下按鍵）。|  
  
### <a name="remarks"></a>備註  
 它會指定無作用的索引鍵的字元值。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsyskeydown"></a>CWnd::OnSysKeyDown  
 如果`CWnd`物件具有輸入的焦點，`OnSysKeyDown`使用者按住 ALT 鍵，然後按下另一個索引鍵時由架構呼叫成員函式。  
  
```  
afx_msg void OnSysKeyDown(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定的索引鍵，按下的虛擬按鍵碼。 標準虛擬按鍵碼的清單，請參閱 Winuser.h  
  
 `nRepCnt`  
 指定的重複計數。  
  
 `nFlags`  
 指定的掃描程式碼、 索引鍵轉換程式碼、 索引鍵的先前狀態和內容的程式碼，如下列清單所示︰  
  
|值|意義|  
|-----------|-------------|  
|0–7|掃描代碼 （OEM 相依值）。 高序位字組的低位元組。|  
|8|擴充索引鍵，例如函式的索引鍵或 （1，表示它是一種擴充的金鑰; 否則為 0） 的數字鍵台上的索引鍵。|  
|9–10|未使用。|  
|11–12|Windows 在內部使用。|  
|13|內容程式碼 (1，表示當按下按鍵，0 否則，按住 ALT 鍵)。|  
|14|先前的主要狀態 (1，表示金鑰已關閉訊息傳送之前，0 如果索引鍵是往上)。|  
|15|轉換狀態 （1，表示被釋放，索引鍵，0，如果要按下按鍵）。|  
  
 如`OnSysKeyDown`索引鍵轉換位元 （位元 15） 的呼叫，則為 0。 如果 ALT 鍵時，向下的按鍵; 的內容程式碼位元 （位元 13） 就是 1如果訊息傳送到使用中視窗，因為沒有任何視窗具有輸入的焦點，則為 0。  
  
### <a name="remarks"></a>備註  
 如果沒有任何視窗目前擁有輸入的焦點，作用中視窗的`OnSysKeyDown`呼叫成員函式。 `CWnd`接收訊息的物件可以區別這兩個內容的內容程式碼簽入`nFlags`。  
  
 當內容程式碼為 0，`WM_SYSKEYDOWN`所接收的訊息`OnSysKeyDown`可以傳遞至[translateaccelerator 呼叫](http://msdn.microsoft.com/library/windows/desktop/ms646373)Windows 函式，將會處理其就如同一般的按鍵訊息，而非系統鍵訊息一樣。 這可讓以即使作用中視窗並沒有輸入的焦點用於作用中視窗的快速鍵。  
  
 因為自動重複，超過一個`OnSysKeyDown`呼叫可能會發生之前[WM_SYSKEYUP](#onsyskeyup)接收訊息。 前一個索引鍵的狀態 （位元 14） 可用來判斷是否`OnSysKeyDown`呼叫表示第一個向下轉換或重複向下轉換。  
  
 IBM 增強 101 和 102 鍵鍵盤、 增強的金鑰為右 alt 鍵與右 CTRL 鍵鍵盤; 的主要區段單元、 DEL、 HOME、 END、 PAGE UP、 PAGE DOWN 和箭號左邊的數字鍵台; 在叢集的索引鍵斜線 （/） 和數字鍵台 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元`nFlags`。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onsyskeyup"></a>CWnd::OnSysKeyUp  
 如果`CWnd`物件具有焦點，`OnSysKeyUp`當使用者放開滑鼠時按住 ALT 鍵是已按下按鍵時由架構呼叫成員函式。  
  
```  
afx_msg void OnSysKeyUp(
    UINT nChar,  
    UINT nRepCnt,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `nChar`  
 指定的索引鍵，按下的虛擬按鍵碼。 標準虛擬按鍵碼的清單，請參閱 Winuser.h  
  
 `nRepCnt`  
 指定的重複計數。  
  
 `nFlags`  
 指定的掃描程式碼、 索引鍵轉換程式碼、 索引鍵的先前狀態和內容的程式碼，如下列清單所示︰  
  
|值|意義|  
|-----------|-------------|  
|0–7|掃描代碼 （OEM 相依值）。 高序位字組的低位元組。|  
|8|擴充索引鍵，例如函式的索引鍵或 （1，表示它是一種擴充的金鑰; 否則為 0） 的數字鍵台上的索引鍵。|  
|9–10|未使用。|  
|11–12|Windows 在內部使用。|  
|13|內容程式碼 (1，表示當按下按鍵，0 否則，按住 ALT 鍵)。|  
|14|先前的主要狀態 (1，表示金鑰已關閉訊息傳送之前，0 如果索引鍵是往上)。|  
|15|轉換狀態 （1，表示被釋放，索引鍵，0，如果要按下按鍵）。|  
  
 如`OnSysKeyUp`呼叫，則索引鍵轉換位元 （位元 15） 為 1。 如果 ALT 鍵時，向下的按鍵; 的內容程式碼位元 （位元 13） 就是 1如果訊息傳送到使用中視窗，因為沒有任何視窗具有輸入的焦點，則為 0。  
  
### <a name="remarks"></a>備註  
 如果沒有任何視窗目前擁有輸入的焦點，作用中視窗的`OnSysKeyUp`呼叫成員函式。 `CWnd`接收呼叫的物件可以區別這兩個內容的內容程式碼簽入`nFlags`。  
  
 當內容程式碼為 0，`WM_SYSKEYUP`所接收的訊息`OnSysKeyUp`可以傳遞至[translateaccelerator 呼叫](http://msdn.microsoft.com/library/windows/desktop/ms646373)Windows 函式，將會處理其就如同一般的按鍵訊息，而非系統鍵訊息一樣。 這可讓 accelerator 使用與現用視窗的即使作用中視窗並沒有輸入的焦點 （快顯） 金鑰。  
  
 IBM 增強 101 和 102 鍵鍵盤、 增強的金鑰為右 alt 鍵與右 CTRL 鍵鍵盤; 的主要區段單元、 DEL、 HOME、 END、 PAGE UP、 PAGE DOWN 和箭號左邊的數字鍵台; 在叢集的索引鍵斜線 （/） 和數字鍵台 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元`nFlags`。  
  
 非美國地區增強的 102 鍵的鍵盤，右 ALT 鍵是以 CTRL + ALT 鍵組合來處理。 以下顯示訊息，並會造成當使用者按下並釋放此機碼的呼叫的順序︰  
  
|序列|函式存取|傳遞的訊息|  
|--------------|-----------------------|--------------------|  
|1.|[WM_KEYDOWN](#onkeydown)|**VK_CONTROL**|  
|2.|[WM_KEYDOWN](#onkeydown)|**VK_MENU**|  
|3.|[WM_KEYUP](#onkeyup)|**VK_CONTROL**|  
|4.|[WM_SYSKEYUP](http://msdn.microsoft.com/library/windows/desktop/ms646287)|**VK_MENU**|  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="ontcard"></a>CWnd::OnTCard  
 當使用者按一下可設計的按鈕時，架構會呼叫此成員函式。  
  
```  
afx_msg void OnTCard(
    UINT idAction,  
    DWORD dwActionData);
```  
  
### <a name="parameters"></a>參數  
 `idAction`  
 指出已採取動作的使用者。 這個參數可以是下列值之一︰  
  
- **IDABORT**使用者按一下可設計的 [中止] 按鈕。  
  
- **IDCANCEL**使用者按一下可設計的 [取消] 按鈕。  
  
- **IDCLOSE**使用者關閉訓練卡。  
  
- **IDHELP**使用者按一下可設計的 Windows 說明按鈕。  
  
- **IDIGNORE**使用者按一下可設計的 [忽略] 按鈕。  
  
- **IDCANCEL**使用者按一下可設計的 [確定] 按鈕。  
  
- **IDNO**使用者按一下可設計沒有按鈕。  
  
- **IDRETRY**使用者按一下可設計的 [重試] 按鈕。  
  
- **HELP_TCARD_DATA**使用者按一下可設計的按鈕。 `dwActionData`參數會包含說明作者指定長整數。  
  
- **HELP_TCARD_NEXT**使用者按一下可設計的下一步 按鈕。  
  
- **HELP_TCARD_OTHER_CALLER**另一個應用程式已要求訓練卡。  
  
- **IDYES**使用者按一下可設計的 [是] 按鈕。  
  
 `dwActionData`  
 如果`idAction`指定**HELP_TCARD_DATA**，這個參數是說明作者指定長整數。 否則，此參數為零。  
  
### <a name="remarks"></a>備註  
 僅在應用程式已起始與 Windows 說明的訓練卡時，會呼叫此函數。 應用程式會藉由指定起始訓練卡**HELP_TCARD**命令呼叫[WinHelp](../../mfc/reference/cwinapp-class.md#winhelp)函式。  
  
##  <a name="ontimechange"></a>CWnd::OnTimeChange  
 變更系統時間後，架構會呼叫此成員函式。  
  
```  
afx_msg void OnTimeChange();
```  
  
### <a name="remarks"></a>備註  
 有任何應用程式的變更系統時間傳送此訊息給所有最上層視窗。 傳送`WM_TIMECHANGE`訊息給所有最上層視窗，應用程式可以使用[SendMessage](http://msdn.microsoft.com/library/windows/desktop/ms644950) Windows 函式與它*hwnd*參數設定為**HWND_BROADCAST**。  
  
##  <a name="ontimer"></a>CWnd::OnTimer  
 架構會呼叫此成員函式中指定每個間隔後[SetTimer](#settimer)成員函式用來安裝計時器。  
  
```  
afx_msg void OnTimer(UINT_PTR nIDEvent);
```  
  
### <a name="parameters"></a>參數  
 `nIDEvent`  
 指定計時器的識別項。  
  
### <a name="remarks"></a>備註  
 [DispatchMessage](http://msdn.microsoft.com/library/windows/desktop/ms644934) Windows 函式傳送[WM_TIMER](http://msdn.microsoft.com/library/windows/desktop/ms644902)訊息應用程式的訊息佇列中沒有其他訊息時。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
### <a name="example"></a>範例  
  請參閱中的範例[CWnd::SetTimer](#settimer)。  
  
##  <a name="ontoolhittest"></a>CWnd::OnToolHitTest  
 架構會呼叫此成員函式，判定點是否位於指定工具的周框中。  
  
```  
virtual INT_PTR OnToolHitTest(
    CPoint point,  
    TOOLINFO* pTI) const;  
```  
  
### <a name="parameters"></a>參數  
 `point`  
 指定資料指標 x 和 y 座標。 這些座標是相對於視窗左上角的 alwayson  
  
 `pTI`  
 指標[TOOLINFO](http://msdn.microsoft.com/library/windows/desktop/bb760256)結構。 依預設會設定下列結構的值︰  
  
- *hwnd*  =  `m_hWnd`視窗的控點  
  
- `uId` = **(UINT) hWndChild**子視窗的控點  
  
- `uFlags`| = **TTF_IDISHWND**工具的控制代碼  
  
- `lpszText` = **LPSTR_TEXTCALLBACK**是要在指定的視窗中顯示的字串指標，  
  
### <a name="return-value"></a>傳回值  
 如果找不到工具提示控制項的視窗控制項識別碼。 如果工具提示控制項找不到，-1。  
  
### <a name="remarks"></a>備註  
 如果重點是在矩形中，它會擷取工具的相關資訊。  
  
 如果與工具提示相關聯的區域不是一個按鈕，`OnToolHitTest`結構旗標設定為**TTF_NOTBUTTON**和**TTF_CENTERTIP**。  
  
 覆寫`OnToolHitTest`低於預設所提供，提供不同的資訊。  
  
 請參閱[TOOLINFO](http://msdn.microsoft.com/library/windows/desktop/bb760256)，請在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]，如需有關結構。  
  
##  <a name="ontouchinput"></a>CWnd::OnTouchInput  
 處理來自 Windows 觸控的單一輸入。  
  
```  
virtual BOOL OnTouchInput(
    CPoint pt,  
    int nInputNumber,  
    int nInputsCount,  
    PTOUCHINPUT pInput);
```  
  
### <a name="parameters"></a>參數  
 `pt`  
 螢幕已觸及 （用戶端座標中） 的點。  
  
 `nInputNumber`  
 觸控輸入的數目。  
  
 `nInputsCount`  
 觸控輸入的總數。  
  
 `pInput`  
 TOUCHINPUT 結構指標。  
  
### <a name="return-value"></a>傳回值  
 `TRUE`如果應用程式處理 Windows 觸控輸入。，否則`FALSE`。  
  
### <a name="remarks"></a>備註  
  
##  <a name="ontouchinputs"></a>CWnd::OnTouchInputs  
 處理來自 Windows 觸控的輸入。  
  
```  
virtual BOOL OnTouchInputs(
    UINT nInputsCount,  
    PTOUCHINPUT pInputs);
```  
  
### <a name="parameters"></a>參數  
 `nInputsCount`  
 總數 Windows 觸控輸入。  
  
 `pInputs`  
 TOUCHINPUT 的陣列。  
  
### <a name="return-value"></a>傳回值  
 `TRUE`如果應用程式處理序 Windows 觸控輸入。，否則`FALSE`。  
  
### <a name="remarks"></a>備註  
  
##  <a name="onunichar"></a>CWnd::OnUniChar  
 當按下按鍵時，架構會呼叫此成員函式。 也就是說，目前的視窗擁有鍵盤焦點和[WM_KEYDOWN](http://msdn.microsoft.com/library/windows/desktop/ms646280)訊息轉譯由[TranslateMessage](http://msdn.microsoft.com/library/windows/desktop/ms644955)函式。  
  
```  
afx_msg void OnUniChar(
    UINT nChar,   
    UINT nRepCnt,   
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nChar`|指定的按鍵的字元碼。|  
|[in] `nRepCnt`|指定目前的訊息的重複計數。 值為的按鍵是因為使用者按住鍵 autorepeated 的次數。 如果按鍵會保留時間夠長，傳送多則訊息。 不過，不是累計的重複計數。|  
|[in] `nFlags`|下表所示，指定掃描程式碼、 擴充的索引鍵、 內容程式碼，先前狀態和轉換狀態的旗標︰<br /><br /> **0-7:**指定掃描程式碼。 值取決於原始設備製造商 (OEM)。<br /><br /> **8:**指定擴充的金鑰，例如增強的 101 或 102 鍵鍵盤會出現右 ALT 和 CTRL 鍵。 旗標為 1，如果索引鍵是擴充的索引鍵;否則，它可以是 0。<br /><br /> **9-12:**內部使用的 Windows。<br /><br /> **13:**指定內容的程式碼。 旗標為 1，如果按下按鍵; 時，按住 ALT 鍵否則，值為 0。<br /><br /> **14:**指定前一個索引鍵的狀態。 旗標是如果金鑰已關閉，傳送訊息之前, 的 1 或 0，如果是往上的索引鍵。<br /><br /> **15:**指定轉換狀態。 旗標是放開按鍵時，1 或 0，如果按下索引鍵。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_UNICHAR](http://msdn.microsoft.com/library/windows/desktop/ms646288)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 [WM_UNICHAR](http://msdn.microsoft.com/library/windows/desktop/ms646288)訊息為了傳送或 ANSI windows 張貼 Unicode 字元。 它相當於[WM_CHAR](http://msdn.microsoft.com/library/windows/desktop/ms646276)訊息，但使用 Unicode 轉換格式-32 編碼方式 (utf-32)，而[WM_CHAR](http://msdn.microsoft.com/library/windows/desktop/ms646276)訊息會使用 utf-16。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onuninitmenupopup"></a>CWnd::OnUnInitMenuPopup  
 架構會呼叫此成員函式時下拉式功能表或子功能表被終結。  
  
```  
afx_msg void OnUnInitMenuPopup(
    CMenu* pPopupMenu,   
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `pMenu`|指標[CMenu](../../mfc/reference/cmenu-class.md)物件，表示功能表或子功能表。|  
|[in] `nFlags`|已被終結功能表。 目前，它只能是 [視窗] 功能表中， `MF_SYSMENU`。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_UNINITMENUPOPUP](http://msdn.microsoft.com/library/windows/desktop/ms647614)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onupdateuistate"></a>CWnd::OnUpdateUIState  
 呼叫以變更指定的視窗和其所有子視窗的使用者介面 (UI) 狀態。  
  
```  
afx_msg void OnUpdateUIState(
    UINT nAction,  
    UINT nUIElement);
```  
  
### <a name="parameters"></a>參數  
 `nAction`  
 指定要執行的動作。 可為下列其中一個值：  
  
- **UIS_CLEAR** UI 狀態項目 (所指定`nUIElement`) 應該隱藏。  
  
- **UIS_INITIALIZE** UI 狀態項目 (所指定`nUIElement`) 應該變更為根據的最後一個輸入的事件。 如需詳細資訊，請參閱**註解**區段[WM_UPDATEISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361)。  
  
- **UIS_SET** UI 狀態項目 (所指定`nUIElement`) 應該為可見的。  
  
 `nUIElement`  
 指定受影響的 UI 狀態項目或控制項的樣式。 可為下列其中一個值：  
  
- **UISF_HIDEACCEL**鍵盤快速鍵。  
  
- **UISF_HIDEFOCUS**專注指標。  
  
- **UISF_ACTIVE Windows XP:**控制項應該繪製在使用中控制項所使用的樣式。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬的功能[WM_UPDATEUISTATE](http://msdn.microsoft.com/library/windows/desktop/ms646361)訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="onuserchanged"></a>CWnd::OnUserChanged  
 使用者已登入或登出之後，架構會呼叫這個成員的所有視窗。  
  
```  
afx_msg void OnUserChanged();
```  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_USERCHANGED](http://msdn.microsoft.com/library/windows/desktop/ms632651)通知訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 當使用者登入或登出時，作業系統就會更新使用者特定設定。 系統設定更新後立即傳送此訊息。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onvkeytoitem"></a>CWnd::OnVKeyToItem  
 如果`CWnd`物件會擁有與清單方塊[LBS_WANTKEYBOARDINPUT](../../mfc/reference/list-box-styles.md)樣式，清單方塊將會傳送`WM_VKEYTOITEM`訊息以回應`WM_KEYDOWN`訊息。  
  
```  
afx_msg int OnVKeyToItem(
    UINT nKey,  
    CListBox* pListBox,  
    UINT nIndex);
```  
  
### <a name="parameters"></a>參數  
 `nKey`  
 指定使用者按下按鍵的虛擬按鍵碼。 標準虛擬按鍵碼的清單，請參閱 Winuser.h  
  
 `pListBox`  
 指定清單方塊的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
 `nIndex`  
 指定目前插入號位置。  
  
### <a name="return-value"></a>傳回值  
 指定在回應訊息中的應用程式執行的動作。 – 2 的傳回值會指出應用程式處理所有層面的選取項目，並不需要任何進一步動作的清單方塊。 傳回值-1 表示清單方塊應該執行的預設動作，以回應按鍵。 傳回大於或等於 0 的值清單方塊中指定的項目以零為起始的索引，並指出清單方塊應該對指定的項目上的按鍵動作執行預設動作。  
  
### <a name="remarks"></a>備註  
 僅有的清單方塊的架構會呼叫此成員函式[LBS_HASSTRINGS](../../mfc/reference/list-box-styles.md)樣式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onvscroll"></a>CWnd::OnVScroll  
 當使用者按一下視窗的垂直捲軸，架構會呼叫此成員函式。  
  
```  
afx_msg void OnVScroll(
    UINT nSBCode,  
    UINT nPos,  
    CScrollBar* pScrollBar);
```  
  
### <a name="parameters"></a>參數  
 `nSBCode`  
 指定捲軸程式碼，表示使用者的捲動要求。 這個參數可以是下列其中一項︰  
  
- **SB_BOTTOM**捲動至底部。  
  
- **SB_ENDSCROLL**結束捲軸。  
  
- **SB_LINEDOWN**向下捲動一行。  
  
- **SB_LINEUP**向上捲動一行。  
  
- **SB_PAGEDOWN**向下捲動一頁。  
  
- **SB_PAGEUP**向上捲動一頁。  
  
- **SB_THUMBPOSITION**捲動至絕對位置。 目前的位置所提供的`nPos`。  
  
- **SB_THUMBTRACK**拖曳捲動方塊到指定的位置。 目前的位置所提供的`nPos`。  
  
- **SB_TOP**捲動至頂端。  
  
 `nPos`  
 如果捲軸的程式碼，包含目前捲動方塊位置**SB_THUMBPOSITION**或**SB_THUMBTRACK**; 否則為未使用。 根據初始的捲軸範圍，`nPos`可以是負數，而且應該轉換成`int`如有必要。  
  
 `pScrollBar`  
 如果捲動訊息來自捲軸控制項，包含控制項的指標。 如果使用者按一下視窗的捲軸，這個參數是**NULL**。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
### <a name="remarks"></a>備註  
 `OnVScroll`通常會使用捲動方塊被拖曳的期間，提供一些意見的應用程式。  
  
 如果`OnVScroll`內容捲動`CWnd`物件，它也必須重設的捲動方塊位置[SetScrollPos](#setscrollpos)成員函式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onvscrollclipboard"></a>CWnd::OnVScrollClipboard  
 剪貼簿擁有者的`OnVScrollClipboard`剪貼簿資料時，[剪貼簿檢視器] 便會呼叫成員函式`CF_OWNERDISPLAY`格式化，並在剪貼簿檢視器的垂直捲軸上沒有的事件。  
  
```  
afx_msg void OnVScrollClipboard(
    CWnd* pClipAppWnd,  
    UINT nSBCode,  
    UINT nPos);
```  
  
### <a name="parameters"></a>參數  
 `pClipAppWnd`  
 指定 剪貼簿檢視器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。  
  
 `nSBCode`  
 指定下列的捲軸值的其中一個︰  
  
- **SB_BOTTOM**捲動至底部。  
  
- **SB_ENDSCROLL**結束捲軸。  
  
- **SB_LINEDOWN**向下捲動一行。  
  
- **SB_LINEUP**向上捲動一行。  
  
- **SB_PAGEDOWN**向下捲動一頁。  
  
- **SB_PAGEUP**向上捲動一頁。  
  
- **SB_THUMBPOSITION**捲動至絕對位置。 目前的位置所提供的`nPos`。  
  
- **SB_TOP**捲動至頂端。  
  
 `nPos`  
 如果捲軸的程式碼包含捲動方塊位置**SB_THUMBPOSITION**，否則為`nPos`未使用。  
  
### <a name="remarks"></a>備註  
 擁有者應該捲動剪貼簿影像、 使適當的區段失效，並更新捲軸值。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onwindowmaximizedchanged"></a>CWnd::OnWindowMaximizedChanged  
 當目前視窗最大化，並在視窗由桌面視窗管理員 (DWM) 時，架構會呼叫這個成員。  
  
```  
afx_msg void OnWindowMaximizedChanged(BOOL bIsMaximized);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `bIsMaximized`|`true`如果目前的視窗最大化，並`false`如果不是。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_DWMWINDOWMAXIMIZEDCHANGE](http://msdn.microsoft.com/library/windows/desktop/dd388201)通知訊息中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onwindowposchanged"></a>CWnd::OnWindowPosChanged  
 架構會呼叫此成員函式時呼叫的結果改變了大小、 位置或疊置順序[SetWindowPos](http://msdn.microsoft.com/library/windows/desktop/ms633545)成員函式或另一個視窗管理函式。  
  
```  
afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);
```  
  
### <a name="parameters"></a>參數  
 `lpwndpos`  
 指向[WINDOWPOS](../../mfc/reference/windowpos-structure1.md)包含視窗的新大小和位置的相關資訊的資料結構。  
  
### <a name="remarks"></a>備註  
 預設實作會將傳送[WM_SIZE](http://msdn.microsoft.com/library/windows/desktop/ms632646)和[WM_MOVE](http://msdn.microsoft.com/library/windows/desktop/ms632631)至視窗的訊息。 如果應用程式處理，不會傳送這些訊息`OnWindowPosChanged`而不需要呼叫其基底類別呼叫。 它會執行任何移動或調整大小的呼叫期間變更處理更有效率`OnWindowPosChanged`而不需要呼叫其基底類別。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onwindowposchanging"></a>CWnd::OnWindowPosChanging  
 當大小、 位置或疊置順序即將因呼叫而變更時，架構會呼叫此成員函式[SetWindowPos](http://msdn.microsoft.com/library/windows/desktop/ms633545)成員函式或另一個視窗管理函式。  
  
```  
afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
```  
  
### <a name="parameters"></a>參數  
 `lpwndpos`  
 指向`WINDOWPOS`包含視窗的新大小和位置的相關資訊的資料結構。  
  
### <a name="remarks"></a>備註  
 應用程式可以藉由設定或清除適當的位元，在視窗中防止變更**旗標**隸屬[WINDOWPOS](../../mfc/reference/windowpos-structure1.md)結構。  
  
 與視窗[WS_OVERLAPPED](../../mfc/reference/window-styles.md)或[WS_THICKFRAME](../../mfc/reference/window-styles.md)樣式的預設實作會將傳送[WM_GETMINMAXINFO](http://msdn.microsoft.com/library/windows/desktop/ms632626)至視窗的訊息。 這是要驗證新的大小和視窗的位置，並強制執行**CS_BYTEALIGNCLIENT**和**CS_BYTEALIGN**用戶端的樣式。 應用程式可以透過不會呼叫其基底類別中覆寫這項功能。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onwininichange"></a>CWnd::OnWinIniChange  
 架構會呼叫此成員函式之後已變更 Windows 初始化檔案，WIN。INI。  
  
```  
afx_msg void OnWinIniChange(LPCTSTR lpszSection);
```  
  
### <a name="parameters"></a>參數  
 `lpszSection`  
 指向字串，指定已變更區段的名稱。 （字串不包含方括號括住的區段名稱）。  
  
### <a name="remarks"></a>備註  
 [SystemParametersInfo](http://msdn.microsoft.com/library/windows/desktop/ms724947) Windows 函式呼叫`OnWinIniChange`應用程式使用函式來變更設定，以 win 之後。INI 檔案。  
  
 傳送`WM_WININICHANGE`訊息給所有最上層視窗，應用程式可以使用[SendMessage](http://msdn.microsoft.com/library/windows/desktop/ms644950) Windows 函式與它*hwnd*參數設定為**HWND_BROADCAST**。  
  
 如果應用程式變更許多不同的區段中獲勝。在同一時間 INI，應用程式應該傳送一個`WM_WININICHANGE`訊息`lpszSection`設**NULL**。 否則，應用程式應該傳送`WM_WININICHANGE`每次它進行變更獲勝。INI。  
  
 如果應用程式收到`OnWinIniChange`呼叫`lpszSection`設**NULL**，應用程式應該檢查 WIN 的所有章節。INI 影響應用程式。  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onwndmsg"></a>CWnd::OnWndMsg  
 此成員函式會呼叫`WindowProc`，或訊息反映期間會呼叫。  
  
```  
virtual BOOL OnWndMsg(
    UINT message,  
    WPARAM wParam,  
    LPARAM lParam,  
    LRESULT* pResult);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定要傳送的訊息。  
  
 `wParam`  
 指定訊息相關的其他資訊。  
  
 `lParam`  
 指定訊息相關的其他資訊。  
  
 `pResult`  
 傳回值[WindowProc](#windowproc)。 取決於訊息;可能是**NULL**。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果訊息已處理，否則**FALSE**。  
  
### <a name="remarks"></a>備註  
 `OnWndMsg`判斷訊息類型和呼叫其中一個適當的 framework 函式 (例如， [OnCommand](#oncommand)如**WM_COMMAND**) 或在訊息對應中尋找適當的訊息。  
  
 如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。  
  
##  <a name="onxbuttondblclk"></a>CWnd::OnXButtonDblClk  
 當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區中，架構會呼叫此成員函式。  
  
```  
afx_msg void OnXButtonDblClk(
    UINT nFlags,   
    UINT nButton,   
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nFlags`|的位元組合 (OR) 旗標，表示哪個輔助按鍵按下按鍵。 例如，`MK_CONTROL`旗標表示，按下 CTRL 鍵。|  
|[in] `nButton`|值為`XBUTTON1`，按兩下第一個 Microsoft intellimouse 滑鼠的 X 按鈕時或`XBUTTON2`如果第二個 X 按鈕按兩下時。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於工作區的左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_XBUTTONDBLCLK](http://msdn.microsoft.com/library/windows/desktop/ms646244)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 如果沒有擷取滑鼠，將訊息張貼到視窗下方的資料指標。 否則，將訊息張貼至已捕捉滑鼠的視窗。  
  
 `nFlags`參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱[有關滑鼠輸入](http://msdn.microsoft.com/library/windows/desktop/ms645601)。  
  
|輔助按鍵|描述|  
|------------------|-----------------|  
|MK_CONTROL|已按下 CTRL 鍵。|  
|MK_LBUTTON|已按下滑鼠左的按鈕。|  
|MK_MBUTTON|已按下滑鼠中間鍵。|  
|MK_RBUTTON|已按下滑鼠右按鈕。|  
|MK_SHIFT|已按下 SHIFT 鍵。|  
|MK_XBUTTON1|文件拉的 XBUTTON1 滑鼠按鈕已按下。|  
|MK_XBUTTON2|文件拉 XBUTTON2 滑鼠按鈕已按下。|  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onxbuttondown"></a>CWnd::OnXButtonDown  
 當使用者按 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區中，架構會呼叫此成員函式。  
  
```  
afx_msg void OnXButtonDown(
    UINT nFlags,   
    UINT nButton,   
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nFlags`|的位元組合 (OR) 旗標，表示哪個輔助按鍵按下按鍵。 例如，`MK_CONTROL`旗標表示，按下 CTRL 鍵。|  
|[in] `nButton`|值為`XBUTTON1`如果第一個 Microsoft intellimouse 滑鼠的 X 按鈕已按下，或`XBUTTON2`如果第二個 X 按鈕已按下。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於工作區的左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_XBUTTONDOWN](http://msdn.microsoft.com/library/windows/desktop/ms646245)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 如果沒有擷取滑鼠，將訊息張貼到視窗下方的資料指標。 否則，將訊息張貼至已捕捉滑鼠的視窗。  
  
 `nFlags`參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱[有關滑鼠輸入](http://msdn.microsoft.com/library/windows/desktop/ms645601)。  
  
|輔助按鍵|描述|  
|------------------|-----------------|  
|MK_CONTROL|已按下 CTRL 鍵。|  
|MK_LBUTTON|已按下滑鼠左的按鈕。|  
|MK_MBUTTON|已按下滑鼠中間鍵。|  
|MK_RBUTTON|已按下滑鼠右按鈕。|  
|MK_SHIFT|已按下 SHIFT 鍵。|  
|MK_XBUTTON1|文件拉的 XBUTTON1 滑鼠按鈕已按下。|  
|MK_XBUTTON2|文件拉 XBUTTON2 滑鼠按鈕已按下。|  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="onxbuttonup"></a>CWnd::OnXButtonUp  
 當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區中，架構會呼叫此成員函式。  
  
```  
afx_msg void OnXButtonUp(
    UINT nFlags,   
    UINT nButton,   
    CPoint point);
```  
  
### <a name="parameters"></a>參數  
  
|參數|描述|  
|---------------|-----------------|  
|[in] `nFlags`|的位元組合 (OR) 旗標，表示哪個輔助按鍵按下按鍵。 例如，`MK_CONTROL`旗標表示，按下 CTRL 鍵。|  
|[in] `nButton`|值為`XBUTTON1`如果第一個 Microsoft intellimouse 滑鼠的 X 按鈕被按兩下，或`XBUTTON2`如果第二個 X 按鈕被按兩下。|  
|[in] `point`|A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*和*y*游標相對於工作區的左上角的座標。|  
  
### <a name="remarks"></a>備註  
 這個方法會接收[WM_XBUTTONUP](http://msdn.microsoft.com/library/windows/desktop/ms646246)通知中所述[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。 如果沒有擷取滑鼠，將訊息張貼到視窗下方的資料指標。 否則，將訊息張貼至已捕捉滑鼠的視窗。  
  
 `nFlags`參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱[有關滑鼠輸入](http://msdn.microsoft.com/library/windows/desktop/ms645601)。  
  
|輔助按鍵|描述|  
|------------------|-----------------|  
|MK_CONTROL|已按下 CTRL 鍵。|  
|MK_LBUTTON|已按下滑鼠左的按鈕。|  
|MK_MBUTTON|已按下滑鼠中間鍵。|  
|MK_RBUTTON|已按下滑鼠右按鈕。|  
|MK_SHIFT|已按下 SHIFT 鍵。|  
|MK_XBUTTON1|文件拉的 XBUTTON1 滑鼠按鈕已按下。|  
|MK_XBUTTON2|文件拉 XBUTTON2 滑鼠按鈕已按下。|  
  
> [!NOTE]
>  架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。  
  
##  <a name="openclipboard"></a>CWnd::OpenClipboard  
 開啟剪貼簿。  
  
```  
BOOL OpenClipboard();
```  
  
### <a name="return-value"></a>傳回值  
 如果透過開啟剪貼簿，則為非零`CWnd`，或 0，如果另一個應用程式或視窗有 剪貼簿開啟。  
  
### <a name="remarks"></a>備註  
 其他應用程式不能修改剪貼簿，直到[CloseClipboard](http://msdn.microsoft.com/library/windows/desktop/ms649035)呼叫 Windows 函式。  
  
 目前`CWnd`物件不會成為直到剪貼簿的擁有者[EmptyClipboard](http://msdn.microsoft.com/library/windows/desktop/ms649037)呼叫 Windows 函式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 111](../../mfc/reference/codesnippet/cpp/cwnd-class_52.cpp)]  
  
##  <a name="operator_hwnd"></a>HWND cwnd:: Operator  
 使用此運算子，以取得控制代碼`CWnd`物件。  
  
```  
operator HWND() const;  
```  
  
##  <a name="operator_neq"></a>Cwnd:: Operator ！ =  
 比較兩個`CWnd`物件來判斷是否它們不需要相同[m_hWnd](#m_hwnd)。  
  
```  
BOOL operator!=(const CWnd& wnd) const;  
```  
  
### <a name="parameters"></a>參數  
 `wnd`  
 對 `CWnd` 物件的參考。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果相等。否則便是 0。  
  
##  <a name="operator_eq_eq"></a>Cwnd:: Operator = =  
 比較兩個`CWnd`物件來判斷它們是否相同[m_hWnd](#m_hwnd)。  
  
```  
BOOL operator==(const CWnd& wnd) const;  
```  
  
### <a name="parameters"></a>參數  
 `wnd`  
 對 `CWnd` 物件的參考。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果相等。否則便是 0。  
  
##  <a name="paintwindowlesscontrols"></a>CWnd::PaintWindowlessControls  
 在控制項容器上繪製無視窗控制項。  
  
```  
BOOL PaintWindowlessControls(CDC* pDC);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 在其上繪製無視窗控制項的裝置內容。  
  
### <a name="return-value"></a>傳回值  
 如果控制項容器和無視窗控制項則為 TRUE 會傳回是成功繪製，否則為 FALSE。  
  
##  <a name="postmessage"></a>CWnd::PostMessage  
 將訊息放在視窗的訊息佇列，然後傳回而不需等待處理的訊息對應的視窗。  
  
```  
BOOL PostMessage(
    UINT message,  
    WPARAM wParam = 0,  
    LPARAM lParam = 0);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定要公佈的訊息。  
  
 `wParam`  
 指定額外的訊息資訊。 此參數的內容取決於公佈的訊息。  
  
 `lParam`  
 指定額外的訊息資訊。 此參數的內容取決於公佈的訊息。  
  
### <a name="return-value"></a>傳回值  
 如果張貼的訊息; 非零，否則便是 0。  
  
### <a name="remarks"></a>備註  
 訊息佇列中的訊息藉由呼叫擷取[GetMessage](http://msdn.microsoft.com/library/windows/desktop/ms644936)或[PeekMessage](http://msdn.microsoft.com/library/windows/desktop/ms644943) Windows 函式。  
  
 Windows [PostMessage](http://msdn.microsoft.com/library/windows/desktop/ms644944)函式可以用來存取其他應用程式。  
  
### <a name="example"></a>範例  
  請參閱範例的[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)。  
  
##  <a name="postncdestroy"></a>CWnd::PostNcDestroy  
 預設會呼叫[OnNcDestroy](#onncdestroy)終結視窗後的成員函式。  
  
```  
virtual void PostNcDestroy();
```  
  
### <a name="remarks"></a>備註  
 衍生的類別可以使用此函式，例如刪除自訂清除**這**指標。  
  
##  <a name="precreatewindow"></a>CWnd::PreCreateWindow  
 由架構建立附加到此 Windows 視窗前呼叫`CWnd`物件。  
  
```  
virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
```  
  
### <a name="parameters"></a>參數  
 *cs*  
 A [CREATESTRUCT](../../mfc/reference/createstruct-structure.md)結構。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果應該繼續建立視窗。0，表示建立失敗。  
  
### <a name="remarks"></a>備註  
  
> [!WARNING]
> `CWnd::PreCreateWindow`現在將指派的 hMenu 成員`cs`至`this`指標，如果是`NULL`和樣式包含`WS_CHILD`。 功能正常運作，請確定對話方塊控制項具有 ID 不是`NULL`。  
>   
>  這項變更的 managed/原生 interop 案例中修正損毀。 A`TRACE`陳述式中的`CWnd::Create`警示問題的開發人員。  
  
 永遠不會直接呼叫此函式。  
  
 此函式的預設實作會檢查**NULL**視窗類別名稱並換成適當的預設值。 若要修改此成員函式會覆寫`CREATESTRUCT`結構建立視窗之前。  
  
 每個類別衍生自`CWnd`將自己的功能加入至其覆寫`PreCreateWindow`。 根據設計，這些衍生的`PreCreateWindow`未記載。 若要判斷用於每個類別和樣式之間的相依性的樣式，您可以檢查您的應用程式基底類別的 MFC 原始程式碼。 如果您選擇覆寫**PreCreateWindow，**您可以判斷您的應用程式基底類別中使用的樣式是否提供您需要藉由從 MFC 原始程式碼所收集資訊的功能。  
  
 如需有關如何變更視窗樣式的詳細資訊，請參閱[變更 MFC 所建立的視窗樣式](../../mfc/changing-the-styles-of-a-window-created-by-mfc.md)。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 112](../../mfc/reference/codesnippet/cpp/cwnd-class_53.cpp)]  
  
##  <a name="presubclasswindow"></a>CWnd::PreSubclassWindow  
 此成員函式是由架構以允許其他必要子類別化視窗子類別化之前呼叫。  
  
```  
virtual void PreSubclassWindow();
```  
  
### <a name="remarks"></a>備註  
 覆寫此成員函式可讓您動態子類別化的控制項。 它是進階可覆寫。  
  
##  <a name="pretranslatemessage"></a>Cwnd:: Pretranslatemessage  
 類別所使用[CWinApp](../../mfc/reference/cwinapp-class.md)轉譯分派至之前的視窗訊息[TranslateMessage](http://msdn.microsoft.com/library/windows/desktop/ms644955)和[DispatchMessage](http://msdn.microsoft.com/library/windows/desktop/ms644934) Windows 函式。  
  
```  
virtual BOOL PreTranslateMessage(MSG* pMsg);
```  
  
### <a name="parameters"></a>參數  
 `pMsg`  
 指向[MSG](../../mfc/reference/msg-structure1.md)結構，其中包含要處理的訊息。  
  
### <a name="return-value"></a>傳回值  
 如果訊息已轉譯，而且不應該分派; 非零，如果訊息不翻譯，而且應該分派是 0。  
  
##  <a name="print"></a>CWnd::Print  
 呼叫此成員函式，以繪製在指定的裝置內容中，這是最常在印表機裝置內容中目前的視窗。  
  
```  
void Print(
    CDC* pDC,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 裝置內容的指標。  
  
 `dwFlags`  
 指定的繪圖選項。 這個參數可以是下列其中一個或多個這些旗標︰  
  
- `PRF_CHECKVISIBLE`只有當它會顯示繪製視窗。  
  
- `PRF_CHILDREN`繪製所有可見的子視窗。  
  
- `PRF_CLIENT`繪製視窗工作區。  
  
- `PRF_ERASEBKGND`清除背景繪製視窗之前。  
  
- `PRF_NONCLIENT`繪製視窗中的非工作區。  
  
- `PRF_OWNED`繪製所有已擁有的 windows。  
  
### <a name="remarks"></a>備註  
 [CWnd::DefWindowProc](#defwindowproc)函式會處理此訊息指定哪一個繪圖選項為基礎︰  
  
-   如果`PRF_CHECKVISIBLE`指定視窗為不可見，不執行任何動作。  
  
-   如果`PRF_NONCLIENT`已指定，繪製指定的裝置內容中之非工作區。  
  
-   如果`PRF_ERASEBKGND`已指定，傳送視窗[WM_ERASEBKGND](http://msdn.microsoft.com/library/windows/desktop/ms648055)訊息。  
  
-   如果`PRF_CLIENT`已指定，傳送視窗[wm_printclient 繪製](http://msdn.microsoft.com/library/windows/desktop/dd145217)訊息。  
  
-   如果`PRF_CHILDREN`設定中傳送的每個可見的子視窗[WM_PRINT](http://msdn.microsoft.com/library/windows/desktop/dd145216)訊息。  
  
-   如果`PRF_OWNED`設定中，傳送擁有每個可見視窗`WM_PRINT`訊息。  
  
##  <a name="printclient"></a>CWnd::PrintClient  
 呼叫此成員函式，來繪製指定的裝置內容 （通常是印表機裝置內容） 中的任何視窗。  
  
```  
void PrintClient(
    CDC* pDC,  
    DWORD dwFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 裝置內容的指標。  
  
 `dwFlags`  
 指定繪圖選項。 這個參數可以是下列其中一個或多個這些旗標︰  
  
- `PRF_CHECKVISIBLE`只有當它會顯示繪製視窗。  
  
- `PRF_CHILDREN`繪製所有可見的子視窗。  
  
- `PRF_CLIENT`繪製視窗工作區。  
  
- `PRF_ERASEBKGND`清除背景繪製視窗之前。  
  
- `PRF_NONCLIENT`繪製視窗中的非工作區。  
  
- `PRF_OWNED`繪製所有已擁有的 windows。  
  
##  <a name="printwindow"></a>CWnd::PrintWindow  
 將視覺視窗複製到指定的裝置內容，通常是印表機 DC。  
  
```  
BOOL PrintWindow(
    CDC* pDC,  
    UINT nFlags) const;  
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 若要列印到裝置內容的指標。  
  
 `nFlags`  
 指定的繪圖選項。 如需可能值的清單，請參閱[PrintWindow](http://msdn.microsoft.com/library/windows/desktop/dd162869)。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[PrintWindow](http://msdn.microsoft.com/library/windows/desktop/dd162869)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="redrawwindow"></a>CWnd::RedrawWindow  
 更新指定的矩形或區域在指定的視窗工作區中。  
  
```  
BOOL RedrawWindow(
    LPCRECT lpRectUpdate = NULL,  
    CRgn* prgnUpdate = NULL,  
    UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
```  
  
### <a name="parameters"></a>參數  
 `lpRectUpdate`  
 指向[RECT 結構](../../mfc/reference/rect-structure1.md)包含更新矩形的座標。 這個參數已忽略如果*prgnUpdate*包含有效的區域控制代碼。  
  
 *prgnUpdate*  
 識別更新區域。 如果兩個*prgnUpdate*和`lpRectUpdate`是**NULL**，整個工作區加入到更新區域。  
  
 `flags`  
 下列旗標用來使視窗︰  
  
- **RDW_ERASE**會造成視窗收到[WM_ERASEBKGND](http://msdn.microsoft.com/library/windows/desktop/ms648055)訊息視窗重繪時。 **RDW_INVALIDATE**旗標也必須指定，否則**RDW_ERASE**沒有任何作用。  
  
- **RDW_FRAME**會造成交集要接收的更新區域的視窗中非工作區的任何部分[WM_NCPAINT](http://msdn.microsoft.com/library/windows/desktop/dd145212)訊息。 **RDW_INVALIDATE**旗標也必須指定，否則**RDW_FRAME**沒有任何作用。  
  
- **RDW_INTERNALPAINT**導致[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)訊息張貼到視窗中，不論視窗是否包含無效的區域。  
  
- **RDW_INVALIDATE**失效`lpRectUpdate`或*prgnUpdate* (可能不是只有一個**NULL**)。 如果兩者都**NULL**，整個視窗會失效。  
  
 下列旗標用來驗證視窗︰  
  
- **RDW_NOERASE**隱藏任何暫止`WM_ERASEBKGND`訊息。  
  
- **RDW_NOFRAME**隱藏任何暫止`WM_NCPAINT`訊息。 這個旗標必須搭配**RDW_VALIDATE**和一般會搭配使用**RDW_NOCHILDREN**。 應該小心的情況下，使用這個選項，因為它無法防止正確繪製視窗的組件。  
  
- **RDW_NOINTERNALPAINT**隱藏任何暫止的內部`WM_PAINT`訊息。 這個旗標不會影響`WM_PAINT`訊息所產生的無效區域。  
  
- **RDW_VALIDATE**驗證`lpRectUpdate`或*prgnUpdate* (可能不是只有一個**NULL**)。 如果兩者都**NULL**，整個視窗會進行驗證。 這個旗標不會影響內部`WM_PAINT`訊息。  
  
 下列旗標控制重新繪製時，就會發生。 不由執行繪製`RedrawWindow`作用，除非指定其中一個這些位元。  
  
- **RDW_ERASENOW**會使受影響的視窗 (依照**RDW_ALLCHILDREN**和**RDW_NOCHILDREN**旗標) 接收`WM_NCPAINT`和`WM_ERASEBKGND`訊息，如有必要，函式傳回前。 `WM_PAINT`訊息才會延期。  
  
- **RDW_UPDATENOW**會使受影響的視窗 (依照**RDW_ALLCHILDREN**和**RDW_NOCHILDREN**旗標) 接收`WM_NCPAINT`， `WM_ERASEBKGND`，和`WM_PAINT`訊息，如有必要，函式傳回前。  
  
 根據預設，windows 會受到`RedrawWindow`函式相依於指定的視窗是否有**WS_CLIPCHILDREN**樣式。 子視窗**WS_CLIPCHILDREN** windows 不會受到影響。 不過，這些視窗不是**WS_CLIPCHILDREN** windows 會以遞迴方式進行驗證，或直到失效**WS_CLIPCHILDREN**視窗為止。 下列旗標控制哪些 windows 受到`RedrawWindow`函式︰  
  
- **RDW_ALLCHILDREN**的話，repainting 作業中包含子視窗。  
  
- **RDW_NOCHILDREN**來自 repainting 作業的任何排除子視窗。  
  
### <a name="return-value"></a>傳回值  
 如果已順利啟動。 重新繪製視窗為非零否則便是 0。  
  
### <a name="remarks"></a>備註  
 當`RedrawWindow`成員函式用來使組件的桌面視窗中，該視窗不會收到[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)訊息。 若要重新繪製桌面，應用程式應該使用[CWnd::ValidateRgn](#validatergn)， [CWnd::InvalidateRgn](#invalidatergn)， [CWnd::UpdateWindow](#updatewindow)，或[RedrawWindow](http://msdn.microsoft.com/library/windows/desktop/dd162911)  
  
##  <a name="reflectchildnotify"></a>CWnd::ReflectChildNotify  
 訊息會呼叫此函數由從架構[OnChildNotify](#onchildnotify)。  
  
```  
BOOL ReflectChildNotify(
    UINT message,  
    WPARAM wParam,  
    LPARAM lParam,  
    LRESULT* pResult);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定的訊息才會反映。  
  
 `wParam`  
 指定訊息相關的其他資訊。  
  
 `lParam`  
 指定訊息相關的其他資訊。  
  
 `pResult`  
 要傳回之父視窗的子視窗所產生的結果。 可以是**NULL**。  
  
### <a name="return-value"></a>傳回值  
 **TRUE**如果已反映訊息，否則為**FALSE**。  
  
### <a name="remarks"></a>備註  
 它是協助程式函式會反映`message`至其來源。  
  
 反映會直接傳送訊息[CWnd::OnWndMsg](#onwndmsg)或[CCmdTarget::OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)。  
  
 如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。  
  
##  <a name="reflectlastmsg"></a>CWnd::ReflectLastMsg  
 此成員函式會呼叫架構，以反映最後一個子視窗訊息。  
  
```  
static BOOL PASCAL ReflectLastMsg(
    HWND hWndChild,  
    LRESULT* pResult = NULL);
```  
  
### <a name="parameters"></a>參數  
 `hWndChild`  
 子視窗的控制代碼。  
  
 `pResult`  
 要傳回之父視窗的子視窗所產生的結果。 可以是**NULL**。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果已處理訊息。否則便是 0。  
  
### <a name="remarks"></a>備註  
 此成員函式呼叫[SendChildNotifyLastMsg](#sendchildnotifylastmsg)如果視窗由`hWndChild`OLE 控制項或永久的對應中的視窗。  
  
 如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。  
  
##  <a name="releasedc"></a>Cwnd:: Releasedc  
 釋放裝置內容，釋放它由其他應用程式使用。  
  
```  
int ReleaseDC(CDC* pDC);
```  
  
### <a name="parameters"></a>參數  
 `pDC`  
 識別裝置內容，以釋出。  
  
### <a name="return-value"></a>傳回值  
 如果成功則為非零；否則為 0。  
  
### <a name="remarks"></a>備註  
 效果`ReleaseDC`取決於裝置內容類型的成員函式。  
  
 應用程式必須呼叫`ReleaseDC`每次呼叫成員函式[GetWindowDC](#getwindowdc)成員函式，每次呼叫[GetDC](#getdc)成員函式。  
  
##  <a name="repositionbars"></a>CWnd::RepositionBars  
 呼叫以定位並調整大小之視窗的工作區中的控制列。  
  
```  
void RepositionBars(UINT nIDFirst,
    UINT nIDLast,
    UINT nIDLeftOver,
    UINT nFlag = reposDefault,
    LPRECT lpRectParam = NULL,
    LPCRECT lpRectClient = NULL,
    BOOL bStretch = TRUE) ;  
```  
  
### <a name="parameters"></a>參數  
 `nIDFirst`  
 識別碼的第一個範圍中的控制列來定位並調整大小。  
  
 `nIDLast`  
 重新定位並調整大小的控制列範圍中的最後一個識別碼。  
  
 `nIDLeftOver`  
 指定用來填滿其餘的工作區 窗格的識別碼。  
  
 `nFlag`  
 可以有下列值之一︰  
  
- **CWnd::reposDefault**執行的控制列配置。 `lpRectParam`不使用，而且可以是**NULL**。  
  
- **CWnd::reposQuery**的控制列配置不是; 改用`lpRectParam`一樣有實際執行版面配置使用工作區的大小，來初始化。  
  
- **CWnd::reposExtra**中加入的值`lpRectParam`的用戶端區域`nIDLast`也會執行配置和*。*  
  
 `lpRectParam`  
 指向[RECT 結構](../../mfc/reference/rect-structure1.md); 的使用量取決於值`nFlag`。  
  
 *lpRectClient*  
 指向[RECT 結構](../../mfc/reference/rect-structure1.md)包含可用的用戶端區域。 如果**NULL**，將使用視窗的工作區。  
  
 `bStretch`  
 指出軸是否應該自動縮放以框架的大小。  
  
### <a name="remarks"></a>備註  
 `nIDFirst`和`nIDLast`參數定義的控制列識別碼的工作區中重新定位範圍。 `nIDLeftOver`參數指定的子視窗 （通常檢視） 中重新定位並調整大小以填滿其餘未控制列所填入的工作區的識別碼。  
  
##  <a name="runmodalloop"></a>CWnd::RunModalLoop  
 呼叫此成員函式，來擷取、 轉換、 或之前的訊息分派[ContinueModal](#continuemodal)傳回**FALSE**。  
  
```  
int RunModalLoop(DWORD dwFlags = 0);
```  
  
### <a name="parameters"></a>參數  
 `dwFlags`  
 指定要傳送的 Windows 訊息。 可為下列其中一個值：  
  
- **MLF_NOIDLEMSG**不要傳送[WM_ENTERIDLE](http://msdn.microsoft.com/library/windows/desktop/ms645422)父系的訊息。  
  
- **MLF_NOKICKIDLE**不要傳送**WM_KICKIDLE**至視窗的訊息。  
  
- **MLF_SHOWONIDLE**當訊息佇列變成閒置時顯示視窗。  
  
### <a name="return-value"></a>傳回值  
 指定的值`nResult`參數傳遞至[EndModalLoop](#endmodalloop)成員函式，然後用來結束強制回應迴圈。  
  
### <a name="remarks"></a>備註  
 根據預設，`ContinueModal`傳回**FALSE**之後`EndModalLoop`呼叫。 傳回所提供數值`nResult`至`EndModalLoop`。  
  
##  <a name="screentoclient"></a>CWnd::ScreenToClient  
 將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。  
  
```  
void ScreenToClient(LPPOINT lpPoint) const;  void ScreenToClient(LPRECT lpRect) const;  
```  
  
### <a name="parameters"></a>參數  
 `lpPoint`  
 指向[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[POINT 結構](../../mfc/reference/point-structure1.md)，其中包含要轉換的螢幕座標。  
  
 `lpRect`  
 指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](../../mfc/reference/rect-structure1.md)，其中包含要轉換的螢幕座標。  
  
### <a name="remarks"></a>備註  
 `ScreenToClient`成員函式會取代中的螢幕座標`lpPoint`或`lpRect`用戶端座標。 新的座標是相對於左上角`CWnd`工作區。  
  
### <a name="example"></a>範例  
  請參閱範例的[CListCtrl::GetItemRect](../../mfc/reference/clistctrl-class.md#getitemrect)。  
  
##  <a name="scrollwindow"></a>CWnd::ScrollWindow  
 將目前的工作區的內容捲動`CWnd`物件。  
  
```  
void ScrollWindow(
    int xAmount,  
    int yAmount,  
    LPCRECT lpRect = NULL,  
    LPCRECT lpClipRect = NULL);
```  
  
### <a name="parameters"></a>參數  
 `xAmount`  
 在裝置單位，水平捲動的指定單位的數量。 這個參數必須為負值，向左捲動。  
  
 `yAmount`  
 在裝置單位中，垂直捲動的指定單位的數量。 這個參數必須為負值，向上捲動。  
  
 `lpRect`  
 指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](../../mfc/reference/rect-structure1.md)指定捲動瀏覽工作區的一部分。 如果`lpRect`是**NULL**，捲動整個工作區。 如果資料指標矩形相交捲動矩形，會重新調整位置插入號。  
  
 `lpClipRect`  
 指向`CRect`物件或`RECT`結構，指定要捲動的裁剪方框。 此矩形內的位元將捲動。 即使是在這個矩形的外面的位元不受影響`lpRect`矩形。 如果`lpClipRect`是**NULL**，沒有裁剪部分不會對捲動矩形。  
  
### <a name="remarks"></a>備註  
 如果插入號位於`CWnd`捲動，`ScrollWindow`自動隱藏插入號，以防止它被清除，並在捲軸完成之後，接著還原插入號。 插入號位置會隨之調整。  
  
 區域涵蓋的`ScrollWindow`不繪製成員函式，但會合併到目前`CWnd`物件的更新區域。 最終將會收到應用程式[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)訊息，通知區域需要重新繪製。 若要捲動的同時，重繪未涵蓋範圍的區域，呼叫[UpdateWindow](#updatewindow)後立即呼叫成員函式`ScrollWindow`。  
  
 如果`lpRect`是**NULL**，在視窗中的任何子視窗的位置位移所指定的數量`xAmount`和`yAmount`，和任何無效的 (unpainted) 區域中`CWnd`也位移。 `ScrollWindow`當速度`lpRect`是**NULL**。  
  
 如果`lpRect`不**NULL**，子視窗的位置不是已變更和無效區域`CWnd`不位移。 若要避免的更新問題時`lpRect`不**NULL**，呼叫`UpdateWindow`成員函式來重新繪製`CWnd`之前先呼叫`ScrollWindow`。  
  
##  <a name="scrollwindowex"></a>CWnd::ScrollWindowEx  
 捲動視窗的工作區的內容。  
  
```  
int ScrollWindowEx(
    int dx,  
    int dy,  
    LPCRECT lpRectScroll,  
    LPCRECT lpRectClip,  
    CRgn* prgnUpdate,  
    LPRECT lpRectUpdate,  
    UINT flags);
```  
  
### <a name="parameters"></a>參數  
 `dx`  
 在裝置單位，水平捲動的指定單位的數量。 這個參數必須有負值可向左捲動。  
  
 *dy*  
 在裝置單位中，垂直捲動的指定單位的數量。 這個參數必須為負值，向上捲動。  
  
 `lpRectScroll`  
 指向[RECT 結構](../../mfc/reference/rect-structure1.md)指定捲動瀏覽工作區的一部分。 如果這個參數是**NULL**，捲動整個工作區。  
  
 `lpRectClip`  
 指向`RECT`結構，指定要捲動的裁剪方框。 此結構的優先順序高於所指向的矩形`lpRectScroll`。 此矩形內的位元將捲動。 即使是在這個矩形的外面的位元不受影響`lpRectScroll`矩形。 如果這個參數是**NULL**，沒有裁剪部分不會對捲動矩形。  
  
 *prgnUpdate*  
 識別要修改，以保存捲動失效的區域的區域。 這個參數可以是**NULL**。  
  
 `lpRectUpdate`  
 指向`RECT`結構將會接收捲動失效的矩形界限。 這個參數可以是**NULL**。  
  
 `flags`  
 可以有下列值之一︰  
  
- **SW_ERASE**時指定**SW_INVALIDATE**，藉由傳送清除新失效的區域[WM_ERASEBKGND](http://msdn.microsoft.com/library/windows/desktop/ms648055)至視窗的訊息。  
  
- **SW_INVALIDATE**失效所識別之區域*prgnUpdate*捲動後。  
  
- **SW_SCROLLCHILDREN**捲動交集的矩形所指向的所有子視窗`lpRectScroll`的中指定的像素數目`dx`和*dy*。 Windows 會傳送[WM_MOVE](http://msdn.microsoft.com/library/windows/desktop/ms632631)相交的所有子視窗的訊息`lpRectScroll`，即使它們不會移動。 當子視窗捲動，且資料指標矩形相交捲動矩形重新置放插入號。  
  
### <a name="return-value"></a>傳回值  
 傳回值是**SIMPLEREGION** （矩形失效的區域） 而言**COMPLEXREGION** （非矩形的失效的區域; 重疊矩形），或**NULLREGION** （未處於失效狀態的區域），如果函式成功; 否則傳回值是**錯誤**。  
  
### <a name="remarks"></a>備註  
 此函式是類似於[ScrollWindow](http://msdn.microsoft.com/library/windows/desktop/bb787591)函式，使用一些其他功能。  
  
 如果[SW_INVALIDATE](http://msdn.microsoft.com/library/windows/desktop/bb787593)和[SW_ERASE](http://msdn.microsoft.com/library/windows/desktop/bb787593)未指定，`ScrollWindowEx`成員函式不會使捲動離開的區域。 如果設定為其中一個這些旗標，`ScrollWindowEx`使這個區域。 應用程式會呼叫才會更新區域[UpdateWindow](http://msdn.microsoft.com/library/windows/desktop/dd145167)成員函式，會呼叫[RedrawWindow](http://msdn.microsoft.com/library/windows/desktop/dd162911)成員函式 (指定[RDW_UPDATENOW](http://msdn.microsoft.com/library/windows/desktop/dd162911)或[RDW_ERASENOW](http://msdn.microsoft.com/library/windows/desktop/dd162911))，或擷取[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)從應用程式佇列的訊息。  
  
 如果視窗[WS_CLIPCHILDREN](http://msdn.microsoft.com/library/windows/desktop/ms632679)樣式，傳回所指定的區域*prgnUpdate*和`lpRectUpdate`代表總計必須更新，包括任何區域中需要更新的子視窗捲動視窗的區域。  
  
 如果[SW_SCROLLCHILDREN](http://msdn.microsoft.com/library/windows/desktop/bb787593)指定旗標，Windows 便無法正確更新螢幕捲動子視窗的一部分。 捲動的子視窗，介於來源矩形的外面的部分將不會被清除，且將不會重新繪製正確地在新的目的地。 使用[DeferWindowPos](http://msdn.microsoft.com/library/windows/desktop/ms632681)移動並非位於則完全內的子視窗的 Windows 函式`lpRectScroll`矩形。 如果重新置放游標**SW_SCROLLCHILDREN**旗標設定，以及插入號矩形相交捲動矩形。  
  
 所有的輸入和輸出座標 (如`lpRectScroll`， `lpRectClip`， `lpRectUpdate`，和*prgnUpdate*) 會假設在用戶端座標，不論視窗是否有**CS_OWNDC**或**CS_CLASSDC**類別樣式。 使用[LPtoDP](http://msdn.microsoft.com/library/windows/desktop/dd145042)和[DPtoLP](http://msdn.microsoft.com/library/windows/desktop/dd162474)及轉換從邏輯座標位置，如有必要的 Windows 函式。  
  
##  <a name="sendchildnotifylastmsg"></a>CWnd::SendChildNotifyLastMsg  
 通知訊息給子視窗，從提供的父視窗，讓子視窗可以處理工作，架構會呼叫此成員函式。  
  
```  
BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);
```  
  
### <a name="parameters"></a>參數  
 `pResult`  
 要傳回之父視窗的子視窗所產生的結果。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果子視窗已經處理過訊息傳送給其父代。否則便是 0。  
  
### <a name="remarks"></a>備註  
 `SendChildNotifyLastMsg`目前的訊息傳送至來源，如果它是反映的訊息。  
  
 如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。  
  
##  <a name="senddlgitemmessage"></a>CWnd::SendDlgItemMessage  
 傳送訊息至控制項。  
  
```  
LRESULT SendDlgItemMessage(
    int nID,  
    UINT message,  
    WPARAM wParam = 0,  
    LPARAM lParam = 0);
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 指定將接收的訊息對話方塊控制項的識別碼。  
  
 `message`  
 指定要傳送的訊息。  
  
 `wParam`  
 指定訊息相關的其他資訊。  
  
 `lParam`  
 指定訊息相關的其他資訊。  
  
### <a name="return-value"></a>傳回值  
 指定傳回控制項的視窗程序，或是 0，如果找不到控制項的值。  
  
### <a name="remarks"></a>備註  
 `SendDlgItemMessage`成員函式前不會傳回在處理訊息。  
  
 使用`SendDlgItemMessage`等同於取得`CWnd`* 設為指定的控制項並呼叫[SendMessage](#sendmessage)成員函式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 113](../../mfc/reference/codesnippet/cpp/cwnd-class_54.cpp)]  
  
##  <a name="sendmessage"></a>CWnd::SendMessage  
 將指定的訊息傳送至這個視窗。  
  
```  
LRESULT SendMessage(
    UINT message,  
    WPARAM wParam = 0,  
    LPARAM lParam = 0);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定要傳送的訊息。  
  
 `wParam`  
 指定訊息相關的其他資訊。  
  
 `lParam`  
 指定訊息相關的其他資訊。  
  
### <a name="return-value"></a>傳回值  
 訊息處理的結果。其值取決於傳送的訊息。  
  
### <a name="remarks"></a>備註  
 **SendMessage**成員函式直接呼叫的視窗程序並不會傳回該視窗程序已處理訊息之前。 這是相對於[PostMessage](#postmessage)成員函式，以將訊息放到視窗的訊息佇列，並立即傳回。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]  
  
##  <a name="sendmessagetodescendants"></a>CWnd::SendMessageToDescendants  
 呼叫此成員函式可將指定的 Windows 訊息傳送至所有下階視窗。  
  
```  
void SendMessageToDescendants(
    UINT message,  
    WPARAM wParam = 0,  
    LPARAM lParam = 0,  
    BOOL bDeep = TRUE,  
    BOOL bOnlyPerm = FALSE);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定要傳送的訊息。  
  
 `wParam`  
 指定訊息相關的其他資訊。  
  
 `lParam`  
 指定訊息相關的其他資訊。  
  
 `bDeep`  
 指定要搜尋的層級。 如果**TRUE**，以遞迴方式搜尋所有子系; 如果**FALSE**，搜尋才直屬子系。  
  
 `bOnlyPerm`  
 指定是否將暫存的 windows 所接收訊息。 如果**TRUE**，暫存的 windows 可以接收訊息。 如果**FALSE**，只有永久 windows 接收訊息。 如需有關暫存的 windows，請參閱[技術附註 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。  
  
### <a name="remarks"></a>備註  
 如果`bDeep`是**FALSE**，只是為了在視窗的直接子系傳送訊息; 否則訊息會傳送到所有下階視窗。  
  
 如果`bDeep`和`bOnlyPerm`是**TRUE**，則搜尋會繼續以下暫存的 windows。 在此情況下，只有在搜尋期間發生的永久性 windows 收到的訊息。 如果`bDeep`是**FALSE**，訊息只會傳送到視窗的直接子系。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 114](../../mfc/reference/codesnippet/cpp/cwnd-class_55.cpp)]  
  
##  <a name="sendnotifymessage"></a>CWnd::SendNotifyMessage  
 將指定的訊息傳送至視窗。  
  
```  
BOOL SendNotifyMessage(
    UINT message,  
    WPARAM wParam,  
    LPARAM lParam);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定要傳送的訊息。  
  
 `wParam`  
 指定訊息相關的其他資訊。  
  
 `lParam`  
 指定訊息相關的其他資訊。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 如果呼叫的執行緒，所建立視窗`SendNotifyMessage`呼叫視窗的視窗程序，且沒有傳回之前的視窗程序處理過訊息。 如果視窗由不同的執行緒建立`SendNotifyMessage`將訊息傳遞至視窗程序，並傳回立即; 它不會等待完成處理訊息的視窗程序。  
  
##  <a name="setactivewindow"></a>CWnd::SetActiveWindow  
 可讓`CWnd`作用中視窗。  
  
```  
CWnd* SetActiveWindow();
```  
  
### <a name="return-value"></a>傳回值  
 前一個使用中視窗。  
  
 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 `SetActiveWindow`應小心使用成員函式，因為它可讓任意接管使用中視窗並輸入的焦點的應用程式。 一般來說，Windows 會負責所有啟用。  
  
##  <a name="setcapture"></a>CWnd::SetCapture  
 會導致所有後續滑鼠輸入傳送至目前`CWnd`物件，不論游標的位置。  
  
```  
CWnd* SetCapture();
```  
  
### <a name="return-value"></a>傳回值  
 先前收到所有的滑鼠輸入視窗物件的指標。 它是`NULL`如果沒有這類視窗。 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 當`CWnd`不再需要所有的滑鼠輸入，應用程式應該呼叫[ReleaseCapture](http://msdn.microsoft.com/library/windows/desktop/ms646261)函式，以便在其他視窗可以接收滑鼠輸入。  
  
 擷取滑鼠輸入，而沒有`WM_NCHITTEST`或`WM_SETCURSOR`訊息傳送至作用中視窗。  
  
##  <a name="setcaretpos"></a>CWnd::SetCaretPos  
 將插入號位置設定。  
  
```  
static void PASCAL SetCaretPos(POINT point);
```  
  
### <a name="parameters"></a>參數  
 `point`  
 指定新的 x 和 y 座標 （以用戶端座標表示） 的插入號。  
  
### <a name="remarks"></a>備註  
 `SetCaretPos`成員函式會在它是目前的工作中的視窗時，才將插入號移。 `SetCaretPos`將插入號隱藏插入號移。  
  
 插入號位於共用的資源。 如果未擁有插入號視窗應該不會將插入號。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 115](../../mfc/reference/codesnippet/cpp/cwnd-class_56.cpp)]  
  
##  <a name="setclipboardviewer"></a>CWnd::SetClipboardViewer  
 此視窗將會收到通知的 windows 鏈結 (藉由`WM_DRAWCLIPBOARD`訊息) 的剪貼簿內容已變更時。  
  
```  
HWND SetClipboardViewer();
```  
  
### <a name="return-value"></a>傳回值  
 如果成功的剪貼簿檢視器鏈結中下一個視窗控制代碼。 應用程式應該將此控制代碼 （它可以儲存為成員變數） 儲存至剪貼簿檢視器鏈結訊息回應時使用。  
  
### <a name="remarks"></a>備註  
 視窗的剪貼簿檢視器鏈結的一部分必須回應[WM_DRAWCLIPBOARD](#ondrawclipboard)， [WM_CHANGECBCHAIN](#onchangecbchain)，和[WM_DESTROY](#ondestroy)訊息，並將訊息傳遞給鏈結中下一個視窗。  
  
 此成員函式會將`WM_DRAWCLIPBOARD`至視窗的訊息。 因為未傳回剪貼簿檢視器鏈結中下一個視窗的控制代碼，應用程式應該傳送`WM_DRAWCLIPBOARD`的呼叫期間收到的訊息`SetClipboardViewer`。  
  
 若要從剪貼簿檢視器鏈結中移除本身，應用程式必須呼叫[ChangeClipboardChain](#changeclipboardchain)成員函式。  
  
##  <a name="setdlgctrlid"></a>CWnd::SetDlgCtrlID  
 將視窗識別碼或視窗的控制項 ID 設定新的值。  
  
```  
int SetDlgCtrlID(int nID);
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 要設定控制項的識別項的新值。  
  
### <a name="return-value"></a>傳回值  
 先前的識別項的視窗中，如果登錄成功。否則便是 0。  
  
### <a name="remarks"></a>備註  
 視窗可以是任何子視窗，而不只一個對話方塊中的控制項。 視窗不可以是最上層視窗。  
  
##  <a name="setdlgitemint"></a>CWnd::SetDlgItemInt  
 在對話方塊中指定的整數值的字串表示，設定指定控制項的文字。  
  
```  
void SetDlgItemInt(
    int nID,  
    UINT nValue,  
    BOOL bSigned = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 指定要變更控制項的整數識別碼。  
  
 `nValue`  
 指定用來產生項目文字的整數值。  
  
 `bSigned`  
 指定是否帶正負號或不帶正負號的整數值。 如果這個參數是**TRUE**，`nValue`簽署。 如果這個參數是**TRUE**和`nValue`小於 0，字串中的第一個數字之前放置登減號。 如果這個參數是**FALSE**，`nValue`不帶正負號。  
  
### <a name="remarks"></a>備註  
 `SetDlgItemInt`傳送[WM_SETTEXT](http://msdn.microsoft.com/library/windows/desktop/ms632644)訊息指定的控制項。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::SetDlgItemText](#setdlgitemtext)。  
  
##  <a name="setdlgitemtext"></a>CWnd::SetDlgItemText  
 設定標題或文字的視窗或對話方塊方塊所擁有的控制項。  
  
```  
void SetDlgItemText(
    int nID,  
    LPCTSTR lpszString);
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 識別要設定控制項的文字。  
  
 `lpszString`  
 指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或 null 結束的字串，其中包含要複製到控制項的文字。  
  
### <a name="remarks"></a>備註  
 `SetDlgItemText`傳送[WM_SETTEXT](http://msdn.microsoft.com/library/windows/desktop/ms632644)訊息指定的控制項。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing 116](../../mfc/reference/codesnippet/cpp/cwnd-class_57.cpp)]  
  
##  <a name="setforegroundwindow"></a>CWnd::SetForegroundWindow  
 將建立視窗的執行緒放置到前景並啟動視窗。  
  
```  
BOOL SetForegroundWindow();
```  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 鍵盤輸入會導向至視窗，並變更各種視覺提示使用者。 前景視窗是使用者目前使用的視窗。 前景視窗只適用於最上層視窗 （框架的視窗或對話方塊方塊）。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::FindWindow](#findwindow)。  
  
##  <a name="setfocus"></a>CWnd::SetFocus  
 宣告輸入焦點。  
  
```  
CWnd* SetFocus();
```  
  
### <a name="return-value"></a>傳回值  
 先前擁有輸入的焦點的視窗物件的指標。 它是**NULL**如果沒有這類視窗。 傳回的指標可能是暫時性的不會儲存。  
  
### <a name="remarks"></a>備註  
 輸入的焦點會指示此視窗的所有後續的鍵盤輸入。 任何先前擁有輸入的焦點的視窗會失去它。  
  
 `SetFocus`成員函式會將[WM_KILLFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646282)失去輸入的焦點的視窗訊息和[WM_SETFOCUS](http://msdn.microsoft.com/library/windows/desktop/ms646283)收到輸入的焦點的視窗訊息。 它也會啟動視窗或其父代。  
  
 如果目前的視窗為作用中，但沒有焦點 （也就是沒有視窗具有焦點），按下任何鍵就會產生訊息[WM_SYSCHAR](#onsyschar)， [WM_SYSKEYDOWN](#onsyskeydown)，或[WM_SYSKEYUP](#onsyskeyup)。  
  
##  <a name="setfont"></a>CWnd::SetFont  
 傳送`WM_SETFONT`訊息可使用指定的字型。  
  
```  
void SetFont(
    CFont* pFont,  
    BOOL bRedraw = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `pFont`  
 指向 `CFont` 物件的指標。  
  
 `bRedraw`  
 `TRUE`視窗後立即重繪處理`WM_SETFONT`訊息; 否則`FALSE`。  
  
### <a name="remarks"></a>備註  
 這個方法沒有作用，除非已處理的視窗`WM_SETFONT`訊息。 MFC 類別衍生自`CWnd`處理此訊息，因為它們附加至預先定義的視窗類別，其中包含的訊息處理常式`WM_SETFONT`訊息。 若要使用此方法，衍生自的`CWnd`必須定義方法的處理常式`WM_SETFONT`訊息。  
  
##  <a name="seticon"></a>CWnd::SetIcon  
 呼叫控制代碼設為特定的圖示，此成員函式，所找到`hIcon`。  
  
```  
HICON SetIcon(
    HICON hIcon,  
    BOOL bBigIcon);
```  
  
### <a name="parameters"></a>參數  
 `hIcon`  
 上一個圖示的控制代碼。  
  
 `bBigIcon`  
 指定 32 像素 32 像素圖示，如果**TRUE**; 指定 16 像素 16 像素圖示，如果**FALSE**。  
  
### <a name="return-value"></a>傳回值  
 圖示的控制代碼。  
  
### <a name="remarks"></a>備註  
 視窗類別註冊時，它會選取圖示。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::GetSystemMenu](#getsystemmenu)。  
  
##  <a name="setlayeredwindowattributes"></a>CWnd::SetLayeredWindowAttributes  
 設定分層視窗的不透明和透明色鍵。  
  
```  
BOOL SetLayeredWindowAttributes(
    COLORREF crKey,  
    BYTE bAlpha,  
    DWORD dwFlags);
```  
  
### <a name="parameters"></a>參數  
 `crKey`  
 指標**COLORREF**值，指定撰寫層疊的視窗時使用的透明色彩索引鍵。 以此種色彩視窗所繪製的所有像素會為透明的。 若要產生**COLORREF**，使用 RGB 巨集。  
  
 `bAlpha`  
 用來描述層疊視窗的不透明度的 alpha 值。 如需詳細資訊，請參閱**SourceConstantAlpha**隸屬[BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393)結構。 當`bAlpha`是 0，此視窗會完全透明。 當`bAlpha`為 255，視窗是不透明。  
  
 `dwFlags`  
 指定要採取的動作。 這個參數可以是一或多個下列值。 如需可能值的清單，請參閱[SetLayeredWindowAttributes](http://msdn.microsoft.com/library/windows/desktop/ms633540)。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[SetLayeredWindowAttributes](http://msdn.microsoft.com/library/windows/desktop/ms633540)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="setmenu"></a>CWnd::SetMenu  
 將目前功能表設定為指定的功能表。  
  
```  
BOOL SetMenu(CMenu* pMenu);
```  
  
### <a name="parameters"></a>參數  
 `pMenu`  
 識別新的功能表。 如果這個參數是**NULL**，移除目前的功能表。  
  
### <a name="return-value"></a>傳回值  
 如果功能表會變更，則為非零否則便是 0。  
  
### <a name="remarks"></a>備註  
 會導致重新繪製，以反映功能表變更視窗。  
  
 `SetMenu`並不會終結上一個功能表。 應用程式應該呼叫[CMenu::DestroyMenu](../../mfc/reference/cmenu-class.md#destroymenu)成員函式來完成這項工作。  
  
### <a name="example"></a>範例  
  請參閱範例的[CMenu::LoadMenu](../../mfc/reference/cmenu-class.md#loadmenu)。  
  
##  <a name="setowner"></a>CWnd::SetOwner  
 將目前視窗的擁有者設定為指定的視窗物件。  
  
```  
void SetOwner(CWnd* pOwnerWnd);
```  
  
### <a name="parameters"></a>參數  
 *pOwnerWnd*  
 識別視窗物件的新擁有者。 如果這個參數是**NULL**，視窗物件的擁有者沒有。  
  
### <a name="remarks"></a>備註  
 此擁有者接著可以從目前的視窗物件接收命令訊息。 根據預設，目前視窗的父代是其擁有者。  
  
 通常會很有用來建立不相關的視窗階層架構的視窗物件之間的連接。 例如， [CToolBar](../../mfc/reference/ctoolbar-class.md)傳送通知給其父代而不是其擁有者。 這可讓工具列時傳送通知給另一個視窗 （例如就地框架視窗） 會變成一個視窗 （例如 OLE 容器應用程式視窗） 的子系。 此外，停用或啟用期間就地伺服器視窗時編輯，框架視窗所擁有的任何視窗隱藏或顯示。 此擁有權明確地設定呼叫`SetOwner`。  
  
 此函式的擁有權概念是不同的擁有權概念[GetWindow](http://msdn.microsoft.com/library/windows/desktop/ms633515)。  
  
##  <a name="setparent"></a>CWnd::SetParent  
 變更子視窗的父視窗。  
  
```  
CWnd* SetParent(CWnd* pWndNewParent);
```  
  
### <a name="parameters"></a>參數  
 *pWndNewParent*  
 識別新的父視窗。  
  
### <a name="return-value"></a>傳回值  
 先前的父視窗物件如果成功的指標。 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 如果子視窗為可見，則 Windows 會執行適當的重繪作業並重新繪製。  
  
##  <a name="setproperty"></a>CWnd::SetProperty  
 呼叫此成員函式設定所指定的 OLE 控制項屬性`dwDispID`。  
  
```  
void AFX_CDECL SetProperty(
    DISPID dwDispID,  
    VARTYPE vtProp, ...);
```  
  
### <a name="parameters"></a>參數  
 `dwDispID`  
 識別要設定的屬性。  
  
 `vtProp`  
 指定要設定的屬性類型。 可能的值，請參閱 < 備註 > 一節[coledispatchdriver:: Invokehelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)。  
  
 *...*  
 `vtProp`指定的類型單一參數。  
  
### <a name="remarks"></a>備註  
  
> [!NOTE]
>  應該只有在呼叫此函式`CWnd`物件，表示 OLE 控制項。  
  
 如需 OLE 控制項容器中使用此成員函式的詳細資訊，請參閱文章[ActiveX 控制項容器︰ 在 ActiveX 控制項容器中程式設計 ActiveX 控制項](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。  
  
##  <a name="setredraw"></a>CWnd::SetRedraw  
 應用程式呼叫`SetRedraw`允許重新繪製，或防止重繪變更的變更。  
  
```  
void SetRedraw(BOOL bRedraw = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bRedraw`  
 指定重新繪製旗標的狀態。 如果這個參數是**TRUE**，重繪旗標設定; 如果**FALSE**，會清除旗標。  
  
### <a name="remarks"></a>備註  
 此成員函式設定或清除重繪旗標。 清除重繪旗標，而內容將不會更新每個變更之後，且會重新繪製旗標設定時，才不繪製。 例如，應用程式需要數個項目加入至清單方塊可以清除重繪旗標，加入項目，，然後設定重新繪製旗標。 最後，應用程式可以呼叫[失效](#invalidate)或[InvalidateRect](#invalidaterect)成員函式會導致重新繪製該清單方塊。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 117](../../mfc/reference/codesnippet/cpp/cwnd-class_58.cpp)]  
  
##  <a name="setscrollinfo"></a>CWnd::SetScrollInfo  
 呼叫此成員函式可設定的資訊`SCROLLINFO`結構維護的捲軸相關。  
  
```  
BOOL SetScrollInfo(
    int nBar,  
    LPSCROLLINFO lpScrollInfo,  
    BOOL bRedraw = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定捲軸控制項或視窗之非工作區的一部分。 如果它是之非工作區的一部分時，nBar 也會指出是否捲軸置於水平、 垂直或兩者。 它必須是下列其中一項︰  
  
- **SB_CTL**包含捲軸控制項的參數。 `m_hWnd`資料僝磟饡瑢捲軸控制項的控制代碼。  
  
- **SB_HORZ**指定視窗是水平捲軸。  
  
- **SB_VERT**指定視窗是垂直捲軸。  
  
 `lpScrollInfo`  
 指標[SCROLLINFO](http://msdn.microsoft.com/library/windows/desktop/bb787537)結構。 請參閱[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需有關這個結構。  
  
 `bRedraw`  
 指定捲軸是否應該重新繪製以反映新的位置。 如果`bRedraw`是**TRUE**，會重新繪製捲軸。 如果是**FALSE**，不會重新繪製。 根據預設重新繪製捲軸時。  
  
### <a name="return-value"></a>傳回值  
 如果成功，傳回是**TRUE**。 否則，它是**FALSE**。  
  
### <a name="remarks"></a>備註  
 [SCROLLINFO](http://msdn.microsoft.com/library/windows/desktop/bb787537)結構包含捲軸，包括最小值和最大值捲動位置、 頁面大小和捲軸方塊 （捲動方塊） 的位置的相關資訊。 請參閱`SCROLLINFO`結構中的主題[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]如需有關變更結構的預設值。  
  
 MFC 視窗訊息處理常式，以指出捲軸位置[CWnd::OnHScroll](#onhscroll)和[CWnd::OnVScroll](#onvscroll)，提供只有 16 位元的位置資料。 [GetScrollInfo](#getscrollinfo)和`SetScrollInfo`提供 32 位元的捲軸位置資料。 因此，應用程式可以呼叫`GetScrollInfo`處理其中時`CWnd::OnHScroll`或`CWnd::OnVScroll`取得 32 位元的捲軸位置資料。  
  
> [!NOTE]
> [CWnd::GetScrollInfo](#getscrollinfo)讓應用程式使用 32 位元的捲軸位置。  
  
##  <a name="setscrollpos"></a>CWnd::SetScrollPos  
 設定捲動方塊目前的位置，如果要求，會重新繪製捲軸以反映新的捲動方塊的位置。  
  
```  
int SetScrollPos(
    int nBar,  
    int nPos,  
    BOOL bRedraw = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定要設定捲軸。 這個參數可以是下列其中一項︰  
  
- **SB_HORZ**設定中的視窗水平捲軸的捲動方塊位置。  
  
- **SB_VERT**設定視窗的垂直捲軸中捲動方塊的位置。  
  
 `nPos`  
 指定捲動方塊的新位置。 它必須位於捲動的範圍內。  
  
 `bRedraw`  
 指定捲軸是否應該重新繪製以反映新的捲動方塊位置。 如果這個參數是**TRUE**，繪製捲軸; 如果**FALSE**，不會重新繪製捲軸。  
  
### <a name="return-value"></a>傳回值  
 捲動方塊的上一個位置。  
  
### <a name="remarks"></a>備註  
 設定`bRedraw`至**FALSE**時另一個函式的後續呼叫將會重新繪製捲軸會很實用。  
  
##  <a name="setscrollrange"></a>CWnd::SetScrollRange  
 設定給定捲軸的最小和最大位置值。  
  
```  
void SetScrollRange(
    int nBar,  
    int nMinPos,  
    int nMaxPos,  
    BOOL bRedraw = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定要設定捲軸。 這個參數可以是下列值之一︰  
  
- **SB_HORZ**設定視窗的水平捲軸的範圍。  
  
- **SB_VERT**設定視窗的垂直捲軸的範圍。  
  
 `nMinPos`  
 指定捲動位置的最小。  
  
 `nMaxPos`  
 指定捲動位置的最大值。  
  
 `bRedraw`  
 指定捲軸是否應該重新繪製以反映變更。 如果`bRedraw`是**TRUE**，繪製捲軸; 如果**FALSE**，不會重新繪製捲軸。  
  
### <a name="remarks"></a>備註  
 它也可以用來隱藏或顯示標準的捲軸。  
  
 應用程式不應該呼叫此函式可處理的捲軸的通知訊息時隱藏捲軸。  
  
 如果呼叫`SetScrollRange`緊接著呼叫[SetScrollPos](#setscrollpos)成員函式，`bRedraw`中的參數`SetScrollPos`成員函式應該是 0，以防止捲軸繪製兩次。  
  
 標準的捲軸的預設範圍是 0 到 100 之間。 捲軸控制項的預設範圍是空的 (同時`nMinPos`和`nMaxPos`的值為 0)。 所指定的值之間的差異`nMinPos`和`nMaxPos`不能大於**INT_MAX**。  
  
##  <a name="settimer"></a>CWnd::SetTimer  
 安裝系統計時器。  
  
```  
UINT_PTR SetTimer(
    UINT_PTR nIDEvent,  
    UINT nElapse,  
    void (CALLBACK* lpfnTimer)(HWND,  
    UINT, 
    UINT_PTR, 
    DWORD));
```  
  
### <a name="parameters"></a>參數  
 `nIDEvent`  
 指定非零的計時器識別碼。 如果計時器識別碼是唯一的這個值由`SetTimer`。 否則，`SetTimer`判斷新的唯一值，並會傳回。 視窗計時器 （其中有 NULL 的回呼函式） 的值必須是唯一只會針對與目前的視窗相關聯的其他 windows 計時器。 回呼計時器的值必須是唯一的所有處理序中所有的計時器。 因此，當您建立的回呼計時器，它是更有可能傳回的值可能不同於您指定的值。  
  
 `nElapse`  
 指定的逾時值間隔，以毫秒為單位。  
  
 `lpfnTimer`  
 指定應用程式所提供的位址`TimerProc`處理的回呼函式[WM_TIMER](http://msdn.microsoft.com/library/windows/desktop/ms644902)訊息。 如果這個參數是`NULL`、`WM_TIMER`訊息會放在訊息佇列應用程式和由`CWnd`物件。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，新的計時器計時器識別項。 此值可能會或可能不是透過傳入的值等於`nIDEvent`參數。 應用程式應該永遠傳回值傳遞至[KillTimer](#killtimer)成員函式來刪除計時器。 如果成功，則為非零否則為 0。  
  
### <a name="remarks"></a>備註  
 指定的間隔值，且每次間隔耗盡時，系統會張貼`WM_TIMER`安裝應用程式的安裝訊息佇列的訊息或傳遞訊息至應用程式定義`TimerProc`回呼函式。  
  
 `lpfnTimer`回呼函式需要未命名`TimerProc`，但是它必須宣告為靜態，且已定義，如下所示。  
  
```  
void CALLBACK TimerProc(
    HWND hWnd,   // handle of CWnd that called SetTimer  
    UINT nMsg,   // WM_TIMER  
    UINT_PTR nIDEvent,   // timer identification  
    DWORD dwTime    // system time);
```  
  
### <a name="example"></a>範例  
 這個範例會使用`CWnd::SetTimer`， `CWnd::OnTimer`，和`CWnd::KillTimer`處理`WM_TIMER`訊息。 第一個計時器設定為傳送`WM_TIMER`訊息至主框架視窗中每 2 秒`OnStartTimer`。 `OnTimer`事件處理常式的控制代碼`WM_TIMER`主框架視窗的訊息。 這個方法會讓電腦喇叭，每 2 秒發出嗶聲。 第二個計時器傳送訊息至回呼函式每隔 3.75 秒。 `OnStopTimer`會藉由呼叫停止這兩個計時器`CWnd::KillTimer`每個計時器的識別碼。  
  
 [!code-cpp[NVC_MFCWindowing # 118](../../mfc/reference/codesnippet/cpp/cwnd-class_59.cpp)]  
  
##  <a name="setwindowcontexthelpid"></a>CWnd::SetWindowContextHelpId  
 呼叫此成員函式將說明內容識別碼與指定的視窗產生關聯。  
  
```  
BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
```  
  
### <a name="parameters"></a>參數  
 `dwContextHelpId`  
 說明內容識別碼。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 如果子視窗並沒有說明內容識別碼，它會繼承其父視窗的識別項。 同樣地，如果擁有的視窗並沒有說明內容識別碼，它會繼承其擁有者視窗的識別項。 此繼承的說明內容識別碼可讓應用程式設定 對話方塊的單一識別項和所有控制項。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 119](../../mfc/reference/codesnippet/cpp/cwnd-class_60.cpp)]  
  
##  <a name="setwindowplacement"></a>CWnd::SetWindowPlacement  
 設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。  
  
```  
BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);
```  
  
### <a name="parameters"></a>參數  
 `lpwndpl`  
 指向[WINDOWPLACEMENT](../../mfc/reference/windowplacement-structure.md)結構，指定新的顯示狀態和位置。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
##  <a name="setwindowpos"></a>CWnd::SetWindowPos  
 變更大小、 位置及疊置順序的子系，快顯視窗，和最上層視窗。  
  
```  
BOOL SetWindowPos(
    const CWnd* pWndInsertAfter,  
    int x,  
    int y,  
    int cx,  
    int cy,  
    UINT nFlags);
```  
  
### <a name="parameters"></a>參數  
 `pWndInsertAfter`  
 識別`CWnd`將前面的物件 （會高於） 這`CWnd`疊置順序的物件。 這個參數可以是指向`CWnd`或**指標**至下列值之一︰  
  
- **wndBottom**讓此視窗底部的疊置順序。 如果這個`CWnd`是最上層視窗，視窗會失去其最上層的狀態，則系統將視窗放在所有其他視窗的底部。  
  
- **wndTop**讓此視窗頂端的疊置順序。  
  
- **wndTopMost**將優先於所有非最上層視窗的視窗。 即使停用時，視窗會維護其最上層的位置。  
  
- **wndNoTopMost**重新定位到所有非最上層視窗頂端視窗 (也就是所有的最上層視窗後面)。 如果該視窗的非最上層視窗，此旗標會有任何作用。  
  
 如需有關如何使用這個參數的規則，請參閱本主題的 「 備註 」 一節。  
  
 *x*  
 指定視窗的左半部的新位置。  
  
 *y*  
 指定視窗頂端的新位置。  
  
 `cx`  
 指定新視窗的寬度。  
  
 `cy`  
 指定新視窗的高度。  
  
 `nFlags`  
 指定調整大小和位置選項。 這個參數可以是下列旗標的組合︰  
  
- **SWP_DRAWFRAME**視窗周圍繪製 （[] 視窗建立時定義） 的框架。  
  
- **SWP_FRAMECHANGED**傳送`WM_NCCALCSIZE`訊息視窗中，即使不變更視窗的大小。 如果未指定這個旗標，`WM_NCCALCSIZE`視窗的大小已經變更時，才會傳送。  
  
- **SWP_HIDEWINDOW**隱藏視窗。  
  
- `SWP_NOACTIVATE`不會啟動視窗。 如果未設定此旗標，視窗啟動並移到最上層或非最上層群組的頂端 (視設定而定`pWndInsertAfter`參數)。  
  
- **SWP_NOCOPYBITS**捨棄工作區的整個內容。 如果未指定這個旗標，用戶端區域的有效內容所儲存且之後視窗大小或重新調整位置複製到工作區。  
  
- `SWP_NOMOVE`保留目前的位置 (會忽略*x*和*y*參數)。  
  
- **SWP_NOOWNERZORDER**不會變更圖層順序中的主控視窗的位置。  
  
- **SWP_NOREDRAW**不會重新繪製的變更。 如果設定此旗標，任何種類的不重新繪製時發生。 這適用於用戶端區域、 非工作區 （包括標題和捲軸） 和未涵蓋範圍結果已移動的視窗的父任何的視窗部分。 當設定這個旗標時，應用程式必須明確地失效，或重繪其視窗和父視窗，必須重新繪製的任何組件。  
  
- **SWP_NOREPOSITION**相同**SWP_NOOWNERZORDER**。  
  
- **SWP_NOSENDCHANGING**防止接收視窗`WM_WINDOWPOSCHANGING`訊息。  
  
- `SWP_NOSIZE`會保留目前的大小 (會忽略`cx`和`cy`參數)。  
  
- `SWP_NOZORDER`會保留目前的順序 (會忽略`pWndInsertAfter`)。  
  
- **SWP_SHOWWINDOW**顯示視窗。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，則為非零否則為 0。  
  
### <a name="remarks"></a>備註  
 Windows 會根據他們的疊置順序; 在螢幕上排序視窗頂端的疊置順序出現在順序中的所有其他視窗的最上層。  
  
 子視窗的所有座標都是工作區座標 （相對於父視窗工作區的左上角）。  
  
 視窗可以移到疊置順序的頂端設定`pWndInsertAfter`參數**& wndTopMost**並確保`SWP_NOZORDER`旗標是不設定，或藉由設定視窗的疊置順序，所以其值高於任何現有的最上層視窗。 當非最上層的視窗由最上層時，其擁有的 windows 也會有最上層。 不會變更其擁有者。  
  
 最上層的視窗不會再為最上層，如果它重新定位到下 ( **& wndBottom**) 或後任何非最上層視窗的疊置順序。 當最上層的視窗由非最上層時，所有其擁有者和其擁有的 windows 也會有非最上層視窗。  
  
 如果沒有`SWP_NOACTIVATE`也`SWP_NOZORDER`（也就是應用程式要求視窗可同時啟動，並放在指定的疊置順序） 時指定中, 指定的值`pWndInsertAfter`只適用於下列情況︰  
  
-   既不**& wndTopMost**也**& wndNoTopMost**中指定`pWndInsertAfter`參數。  
  
-   這個視窗不是作用中視窗。  
  
 應用程式無法啟動非作用中視窗，而不將其帶到疊置順序頂端。 應用程式可以變更視窗而沒有任何限制疊置順序。  
  
 非最上層視窗可能擁有最上層的視窗中，但不是反之亦然。 最上層的視窗所擁有的任何視窗 （例如對話方塊） 是本身所做的最上層的視窗，以確保所有擁有 windows 保持其擁有者。  
  
 使用 Windows 3.1 和更新版本的版本，windows 可以是移到疊置順序的頂端，鎖定那里藉由設定其**WS_EX_TOPMOST**樣式。 這類最上層的視窗會維護其最上層的位置，即使停用。 比方說，選取 WinHelp 最上層命令可讓 [說明] 視窗最上方，且它，然後當您回到您的應用程式仍會顯示。  
  
 若要建立最上層視窗，呼叫`SetWindowPos`與`pWndInsertAfter`參數等於**& wndTopMost**，或設定**WS_EX_TOPMOST**樣式時建立視窗。  
  
 如果圖層順序包含與任何 windows **WS_EX_TOPMOST**樣式，以移動視窗**& wndTopMost**值會放在最上方的所有非最上層視窗，但低於任何最上層視窗。 當應用程式會啟動非作用中的視窗，而不用**WS_EX_TOPMOST**位元，視窗移上述所有非最上層視窗，但低於任何最上層視窗。  
  
 如果`SetWindowPos`時，會呼叫`pWndInsertAfter`參數是**& wndBottom**和`CWnd`是最上層視窗，視窗會失去其最上層的狀態 ( **WS_EX_TOPMOST**清除)，以及系統讓此視窗底部的疊置順序。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 120](../../mfc/reference/codesnippet/cpp/cwnd-class_61.cpp)]  
  
##  <a name="setwindowrgn"></a>CWnd::SetWindowRgn  
 呼叫此成員函式可設定的視窗區域。  
  
```  
int SetWindowRgn(
    HRGN hRgn,  
    BOOL bRedraw);
```  
  
### <a name="parameters"></a>參數  
 `hRgn`  
 區域控制代碼。  
  
 `bRedraw`  
 如果**TRUE**、 作業系統設定區域之後會重新繪製視窗; 否則它並不會。 一般而言，設定`bRedraw`至**TRUE**視窗是否可見。 如果設定為**TRUE**，系統會傳送`WM_WINDOWPOSCHANGING`和`WM_WINDOWPOSCHANGED`至視窗的訊息。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功，傳回的值不是零。 如果此函式失敗，則傳回值為零。  
  
### <a name="remarks"></a>備註  
 視窗的視窗區域的座標是相對於視窗，而非工作區視窗的左上角。  
  
 在成功呼叫之後`SetWindowRgn`，作業系統擁有區域控制代碼所指定的區域`hRgn`。 作業系統不會在區域的複本，因此不會進行任何進一步函式呼叫與這個區域控制代碼，但不要關閉這個區域控制代碼。  
  
##  <a name="setwindowtext"></a>CWnd::SetWindowText  
 設定視窗的標題，以指定的文字。  
  
```  
void SetWindowText(LPCTSTR lpszString);
```  
  
### <a name="parameters"></a>參數  
 `lpszString`  
 指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或 null 結束要做為新的標題或控制項文字的字串。  
  
### <a name="remarks"></a>備註  
 如果視窗是一個控制項，會設定控制項內的文字。  
  
 這個函式導致[WM_SETTEXT](http://msdn.microsoft.com/library/windows/desktop/ms632644)訊息傳送到這個視窗。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 121](../../mfc/reference/codesnippet/cpp/cwnd-class_62.cpp)]  
  
##  <a name="showcaret"></a>CWnd::ShowCaret  
 在插入號的目前位置在螢幕上顯示插入號。  
  
```  
void ShowCaret();
```  
  
### <a name="remarks"></a>備註  
 顯示後，插入號會開始自動閃爍。  
  
 `ShowCaret`成員函式會顯示只插入號，是否它具有目前的圖形，並不已隱藏兩個以上的時間連續。 如果插入號不屬於此視窗，將插入號不會顯示。  
  
 隱藏該插入號是累計的。 如果[HideCaret](#hidecaret)成員函式呼叫五次連續，`ShowCaret`必須呼叫五次時，才能顯示插入號。  
  
 插入號位於共用的資源。 只有在具有輸入的焦點或作用中時，視窗應該會顯示插入號。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::CreateCaret](#createcaret)。  
  
##  <a name="showownedpopups"></a>CWnd::ShowOwnedPopups  
 顯示或隱藏此視窗所擁有的所有快顯視窗。  
  
```  
void ShowOwnedPopups(BOOL bShow = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bShow`  
 指定是否要顯示或隱藏的快顯視窗。 如果這個參數是**TRUE**，會顯示所有隱藏的快顯視窗。 如果這個參數是**FALSE**，隱藏所有可見的快顯視窗。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::SetWindowPos](#setwindowpos)。  
  
##  <a name="showscrollbar"></a>CWnd::ShowScrollBar  
 顯示或隱藏捲軸。  
  
```  
void ShowScrollBar(
    UINT nBar,  
    BOOL bShow = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `nBar`  
 指定捲軸控制項或視窗之非工作區的一部分。 如果是中, 非工作區的一部分`nBar`也會指出是否捲軸置於水平、 垂直或兩者。 它必須是下列其中一項︰  
  
- **SB_BOTH**指定視窗的水平和垂直捲軸。  
  
- **SB_HORZ**指定視窗是水平捲軸。  
  
- **SB_VERT**指定視窗是垂直捲軸。  
  
 `bShow`  
 指定 Windows 是否顯示或隱藏捲軸。 如果這個參數是**TRUE**，捲軸會顯示; 否則在捲軸會隱藏。  
  
### <a name="remarks"></a>備註  
 應用程式不應該呼叫`ShowScrollBar`處理捲軸的通知訊息時隱藏捲軸。  
  
##  <a name="showwindow"></a>CWnd::ShowWindow  
 設定視窗的可見性狀態。  
  
```  
BOOL ShowWindow(int nCmdShow);
```  
  
### <a name="parameters"></a>參數  
 `nCmdShow`  
 指定如何`CWnd`顯示。 它必須是下列值之一︰  
  
- **SW_HIDE**會隱藏此視窗，並將啟用傳遞給另一個視窗。  
  
- **SW_MINIMIZE**視窗最小化，並啟動系統的清單中的最上層視窗。  
  
- **SW_RESTORE**啟動並顯示視窗。 如果視窗是最小化或最大化，則 Windows 會將它還原至其原始大小和位置。  
  
- **SW_SHOW**啟動視窗並顯示在其目前大小和位置。  
  
- **Sw_showmaximized 其中一個**啟動視窗，顯示最大化視窗。  
  
- **SW_SHOWMINIMIZED**啟動視窗並將它顯示為圖示。  
  
- **SW_SHOWMINNOACTIVE**會顯示為圖示。 目前正在使用中視窗會保持有效。  
  
- **SW_SHOWNA**處於目前狀態會顯示視窗。 目前正在使用中視窗會保持有效。  
  
- **SW_SHOWNOACTIVATE**顯示視窗中的最新的大小和位置。 目前正在使用中視窗會保持有效。  
  
- **SW_SHOWNORMAL**啟動並顯示視窗。 如果視窗是最小化或最大化，則 Windows 會將它還原至其原始大小和位置。  
  
### <a name="return-value"></a>傳回值  
 為非零，如果視窗是先前可見的。0 代表`CWnd`之前隱藏。  
  
### <a name="remarks"></a>備註  
 `ShowWindow`必須一次呼叫每個應用程式的主視窗的[CWinApp::m_nCmdShow](../../mfc/reference/cwinapp-class.md#m_ncmdshow)。 後續呼叫`ShowWindow`必須使用其中一個值，而不是所指定的一個以上所列`CWinApp::m_nCmdShow`。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::CalcWindowRect](#calcwindowrect)。  
  
##  <a name="subclassdlgitem"></a>CWnd::SubclassDlgItem  
 呼叫此成員函式，「 動態子類別化 」 從對話方塊範本建立的控制項，並將它附加至這個`CWnd`物件。  
  
```  
BOOL SubclassDlgItem(
    UINT nID,  
    CWnd* pParent);
```  
  
### <a name="parameters"></a>參數  
 `nID`  
 控制項的 id。  
  
 `pParent`  
 控制項的父代 （通常為對話方塊）。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 動態子類別化控制項時，windows 訊息會路由傳送透過`CWnd`的訊息對應，並呼叫訊息處理常式`CWnd`第一次的類別。 傳遞至基底類別的訊息會傳遞給控制項中的預設訊息處理常式中。  
  
 此成員函式會將附加至 Windows 控制項`CWnd`物件，並取代的元件**WndProc**和**AfxWndProc**函式。 此函式會儲存舊**WndProc**所傳回的位置中`GetSuperWndProcAddr`成員函式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 122](../../mfc/reference/codesnippet/cpp/cwnd-class_63.cpp)]  
  
##  <a name="subclasswindow"></a>CWnd::SubclassWindow  
 呼叫此成員函式，「 動態子類別化 」 視窗，並將它附加至這個`CWnd`物件。  
  
```  
BOOL SubclassWindow(HWND hWnd);
```  
  
### <a name="parameters"></a>參數  
 `hWnd`  
 視窗控制代碼。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零，否則為 0。  
  
### <a name="remarks"></a>備註  
 動態子類別化一個視窗時，windows 訊息會路由傳送透過`CWnd`的訊息對應，並呼叫訊息處理常式`CWnd`第一次的類別。 傳遞至基底類別的訊息會傳遞至視窗中的預設訊息處理常式。  
  
 此成員函式會將附加至 Windows 控制項`CWnd`物件，並會取代視窗**WndProc**和**AfxWndProc**函式。 此函式會儲存指向舊的**WndProc**中`CWnd`物件。  
  
> [!NOTE]
>  視窗必須已附加 MFC 物件時呼叫此函式。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 123](../../mfc/reference/codesnippet/cpp/cwnd-class_64.cpp)]  
  
##  <a name="unlockwindowupdate"></a>CWnd::UnlockWindowUpdate  
 呼叫此成員函式，才可解除鎖定的鎖定已使用的視窗`CWnd::LockWindowUpdate`。  
  
```  
void UnlockWindowUpdate();
```  
  
### <a name="remarks"></a>備註  
 一次只有一個視窗可以使用鎖定`LockWindowUpdate`。 請參閱[CWnd::LockWindowUpdate](#lockwindowupdate)或 Win32 函式[LockWindowUpdate](http://msdn.microsoft.com/library/windows/desktop/dd145034)如需有關鎖定 windows。  
  
##  <a name="unsubclasswindow"></a>CWnd::UnsubclassWindow  
 呼叫此成員函式設定**WndProc**回其原始值，並卸離所識別的視窗`HWND`從**CWnd**物件。  
  
```  
HWND UnsubclassWindow();
```  
  
### <a name="return-value"></a>傳回值  
 Unsubclassed 視窗的控制代碼。  
  
### <a name="example"></a>範例  
  請參閱範例的[CWnd::SubclassWindow](#subclasswindow)。  
  
##  <a name="updatedata"></a>CWnd::UpdateData  
 呼叫此成員函式來初始化資料，在對話方塊中，或擷取和驗證對話方塊資料。  
  
```  
BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
```  
  
### <a name="parameters"></a>參數  
 `bSaveAndValidate`  
 旗標，指出對話方塊是否正在初始化 ( **FALSE**) 或擷取資料 ( **TRUE**)。  
  
### <a name="return-value"></a>傳回值  
 如果作業成功，則為非零否則便是 0。 如果*bSaveAndValidat*e 是**TRUE**，則傳回值為非零，表示資料成功通過驗證。  
  
### <a name="remarks"></a>備註  
 架構會自動呼叫`UpdateData`與`bSaveAndValidate`設**FALSE**的預設實作中建立強制回應對話方塊時[CDialog::OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)。 呼叫發生才看到的對話方塊。 預設實作[CDialog::OnOK](../../mfc/reference/cdialog-class.md#onok)呼叫此成員函式`bSaveAndValidate`設**TRUE**來擷取資料，如果成功的話，會關閉對話方塊。 （如果在對話方塊中按一下 [取消] 按鈕時，對話方塊會關閉而不所擷取的資料。）  
  
##  <a name="updatedialogcontrols"></a>CWnd::UpdateDialogControls  
 呼叫此成員函式，以更新對話方塊按鈕和其他控制項在對話方塊或視窗中，使用中的狀態[ON_UPDATE_COMMAND_UI](http://msdn.microsoft.com/library/c4de3c21-2d2e-4b89-a4ce-d0c0e2d9edc4)回呼機制。  
  
```  
void UpdateDialogControls(
    CCmdTarget* pTarget,  
    BOOL bDisableIfNoHndler);
```  
  
### <a name="parameters"></a>參數  
 `pTarget`  
 指向主框架視窗的應用程式，並用它來更新訊息的路由*。*  
  
 `bDisableIfNoHndler`  
 旗標，指出是否應該為已停用自動顯示沒有更新處理常式的控制項。  
  
### <a name="remarks"></a>備註  
 如果子控制項沒有處理常式和`bDisableIfNoHndler`是**TRUE**，子控制項將會停用。  
  
 架構會呼叫此成員函式的對話方塊列或工具列中的控制項的應用程式的一部分閒置處理。  
  
##  <a name="updatelayeredwindow"></a>CWnd::UpdateLayeredWindow  
 更新分層視窗的位置、大小、形狀、內容和透明度。  
  
```  
BOOL UpdateLayeredWindow(
    CDC* pDCDst,  
    POINT* pptDst,  
    SIZE* psize,  
    CDC* pDCSrc,  
    POINT* pptSrc,  
    COLORREF crKey,  
    BLENDFUNCTION* pblend,  
    DWORD dwFlags);
```  
  
### <a name="parameters"></a>參數  
 `pDCDst`  
 螢幕裝置內容的指標。 它用於調色盤色彩比對視窗內容更新時。 如果`pDCDst`是**NULL**，將使用預設調色盤。  
  
 If `pDCSrc` is **NULL**, `pDCDst` must be **NULL**.  
  
 `pptDst`  
 指標**點**結構，指定新層疊視窗的螢幕位置。 如果不要變更目前的位置，`pptDst`可以**NULL**。  
  
 *psize*  
 指標**大小**結構，指定新層疊視窗的大小。 如果不要變更視窗的大小， *psize*可以**NULL**。  
  
 If `pDCSrc` is **NULL**, *psize* must be **NULL**.  
  
 `pDCSrc`  
 DC，定義層疊的視窗的介面指標。 如果不要變更形狀和視覺化內容的視窗，`pDCSrc`可以**NULL**。  
  
 `pptSrc`  
 指標**點**結構，在裝置內容中指定的圖層的位置。  
  
 If `pDCSrc` is **NULL**, `pptSrc` should be **NULL**.  
  
 `crKey`  
 指標**COLORREF**值，指定撰寫層疊的視窗時使用的透明色彩索引鍵。 以此種色彩視窗所繪製的所有像素會為透明的。 若要產生**COLORREF**，使用 RGB 巨集。  
  
 *pblend*  
 指標[BLENDFUNCTION](http://msdn.microsoft.com/library/windows/desktop/dd183393)結構，指定要撰寫層疊的視窗時使用的透明度值。  
  
 `dwFlags`  
 指定要採取的動作。 這個參數可以是一或多個下列值。 如需可能值的清單，請參閱[UpdateLayeredWindow](http://msdn.microsoft.com/library/windows/desktop/ms633556)。  
  
### <a name="return-value"></a>傳回值  
 如果函式成功則為非零值，否則為 0。  
  
### <a name="remarks"></a>備註  
 此成員函式模擬函式的功能[UpdateLayeredWindow](http://msdn.microsoft.com/library/windows/desktop/ms633556)中所述， [!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
##  <a name="updatewindow"></a>CWnd::UpdateWindow  
 更新工作區，藉由傳送[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)訊息若不是空的更新區域。  
  
```  
void UpdateWindow();
```  
  
### <a name="remarks"></a>備註  
 `UpdateWindow`成員函式會將`WM_PAINT`訊息直接，略過應用程式佇列。 如果更新區域是空的`WM_PAINT`不會傳送。  
  
### <a name="example"></a>範例  
 [!code-cpp[NVC_MFCWindowing # 124](../../mfc/reference/codesnippet/cpp/cwnd-class_65.cpp)]  
  
##  <a name="validaterect"></a>CWnd::ValidateRect  
 從視窗的更新區域中移除矩形，會驗證給定矩形內的工作區。  
  
```  
void ValidateRect(LPCRECT lpRect);
```  
  
### <a name="parameters"></a>參數  
 `lpRect`  
 指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](../../mfc/reference/rect-structure1.md)，其中包含從更新區域中移除矩形的用戶端座標。 如果`lpRect`是**NULL**，整個視窗會進行驗證。  
  
### <a name="remarks"></a>備註  
 [BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 既不`ValidateRect`和[ValidateRgn](#validatergn)應該呼叫成員函式，如果之前先驗證需要更新區域的一部分[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)下次產生。  
  
 Windows 會繼續產生`WM_PAINT`訊息之前會驗證目前的更新區域。  
  
##  <a name="validatergn"></a>CWnd::ValidateRgn  
 驗證給定區域內的用戶端區域的區域移除目前的更新區域的視窗。  
  
```  
void ValidateRgn(CRgn* pRgn);
```  
  
### <a name="parameters"></a>參數  
 `pRgn`  
 指標[CRgn](../../mfc/reference/crgn-class.md)物件，識別定義要移除的更新區域的區域的區域。 如果這個參數是**NULL**，整個工作區移除。  
  
### <a name="remarks"></a>備註  
 指定的區域必須事先建立區域函式。 區域座標會假設用戶端座標。  
  
 [BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 既不[ValidateRect](#validaterect)和`ValidateRgn`應該呼叫成員函式，如果必須在下一步 之前進行驗證的更新區域一部分[WM_PAINT](http://msdn.microsoft.com/library/windows/desktop/dd145213)會產生訊息。  
  
##  <a name="windowfrompoint"></a>CWnd::WindowFromPoint  
 擷取包含指定的點; 的視窗`point`必須在螢幕上指定點的螢幕座標。  
  
```  
static CWnd* PASCAL WindowFromPoint(POINT point);
```  
  
### <a name="parameters"></a>參數  
 `point`  
 指定[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[點](../../mfc/reference/point-structure1.md)資料結構，定義要檢查點。  
  
### <a name="return-value"></a>傳回值  
 重點在於視窗物件的指標。 它是**NULL**沒有視窗有指定的點。 傳回的指標可能是暫時性的不會儲存供稍後使用。  
  
### <a name="remarks"></a>備註  
 `WindowFromPoint`不會擷取隱藏或停用視窗中，即使是在視窗內的點。 應用程式應該使用[ChildWindowFromPoint](#childwindowfrompoint)限制性搜尋的成員函式。  
  
##  <a name="windowproc"></a>CWnd::WindowProc  
 提供 Windows 程序 ( `WindowProc`) 的`CWnd`物件。  
  
```  
virtual LRESULT WindowProc(
    UINT message,  
    WPARAM wParam,  
    LPARAM lParam);
```  
  
### <a name="parameters"></a>參數  
 `message`  
 指定要處理的 Windows 訊息。  
  
 `wParam`  
 提供用於處理訊息的其他資訊。 參數值取決於訊息。  
  
 `lParam`  
 提供用於處理訊息的其他資訊。 參數值取決於訊息。  
  
### <a name="return-value"></a>傳回值  
 傳回的值取決於訊息。  
  
### <a name="remarks"></a>備註  
 它會分派視窗的訊息對應的訊息。  
  
##  <a name="winhelp"></a>CWnd::WinHelp  
 呼叫以初始化 WinHelp 應用程式。  
  
```  
virtual void WinHelp(
    DWORD_PTR dwData,  
    UINT nCmd = HELP_CONTEXT);
```  
  
### <a name="parameters"></a>參數  
 `dwData`  
 指定其他資料。 所使用的值取決於值`nCmd`參數。  
  
 `nCmd`  
 指定要求的說明類型。 如需可能的值，以及它們如何影響`dwData`參數，請參閱[WinHelp](http://msdn.microsoft.com/library/windows/desktop/bb762267) Windows 函式在[!INCLUDE[winSDK](../../atl/includes/winsdk_md.md)]。  
  
### <a name="remarks"></a>備註  
 請參閱[CWinApp::WinHelp](../../mfc/reference/cwinapp-class.md#winhelp)如需詳細資訊。  
  
##  <a name="registertouchwindow"></a>CWnd::RegisterTouchWindow  
 註冊或取消註冊 Windows 觸控支援。  
  
```  
BOOL RegisterTouchWindow(
    BOOL bRegister = TRUE,  
    ULONG ulFlags = 0);
```  
  
### <a name="parameters"></a>參數  
 `bRegister`  
 `TRUE`表示暫存 Windows 觸控支援。`FALSE`否則。  
  
 `ulFlags`  
 一組的位元旗標，指定選擇性的修改。 此欄位可能包含 0 或下列值之一︰ TWF_FINETOUCH、 TWF_WANTPALM。  
  
### <a name="return-value"></a>傳回值  
 如果成功，則為 `TRUE`，否則為 `FALSE`。  
  
### <a name="remarks"></a>備註  
  
##  <a name="resizedynamiclayout"></a>CWnd::ResizeDynamicLayout  
 如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。  
  
```  
virtual void ResizeDynamicLayout();
```  
  
### <a name="remarks"></a>備註  
  
## <a name="see-also"></a>另請參閱  
 [CCmdTarget 類別](../../mfc/reference/ccmdtarget-class.md)   
 [階層架構圖表](../../mfc/hierarchy-chart.md)   
 [CFrameWnd 類別](../../mfc/reference/cframewnd-class.md)   
 [CView 類別](../../mfc/reference/cview-class.md)

