---
title: CWnd 類別
ms.date: 11/19/2018
f1_keywords:
- CWnd
- AFXWIN/CWnd
- AFXWIN/CWnd::CWnd
- AFXWIN/CWnd::accDoDefaultAction
- AFXWIN/CWnd::accHitTest
- AFXWIN/CWnd::accLocation
- AFXWIN/CWnd::accNavigate
- AFXWIN/CWnd::accSelect
- AFXWIN/CWnd::AnimateWindow
- AFXWIN/CWnd::ArrangeIconicWindows
- AFXWIN/CWnd::Attach
- AFXWIN/CWnd::BeginModalState
- AFXWIN/CWnd::BeginPaint
- AFXWIN/CWnd::BindDefaultProperty
- AFXWIN/CWnd::BindProperty
- AFXWIN/CWnd::BringWindowToTop
- AFXWIN/CWnd::CalcWindowRect
- AFXWIN/CWnd::CancelToolTips
- AFXWIN/CWnd::CenterWindow
- AFXWIN/CWnd::ChangeClipboardChain
- AFXWIN/CWnd::CheckDlgButton
- AFXWIN/CWnd::CheckRadioButton
- AFXWIN/CWnd::ChildWindowFromPoint
- AFXWIN/CWnd::ClientToScreen
- AFXWIN/CWnd::CloseWindow
- AFXWIN/CWnd::ContinueModal
- AFXWIN/CWnd::Create
- AFXWIN/CWnd::CreateAccessibleProxy
- AFXWIN/CWnd::CreateCaret
- AFXWIN/CWnd::CreateControl
- AFXWIN/CWnd::CreateEx
- AFXWIN/CWnd::CreateGrayCaret
- AFXWIN/CWnd::CreateSolidCaret
- AFXWIN/CWnd::DeleteTempMap
- AFXWIN/CWnd::DestroyWindow
- AFXWIN/CWnd::Detach
- AFXWIN/CWnd::DlgDirList
- AFXWIN/CWnd::DlgDirListComboBox
- AFXWIN/CWnd::DlgDirSelect
- AFXWIN/CWnd::DlgDirSelectComboBox
- AFXWIN/CWnd::DragAcceptFiles
- AFXWIN/CWnd::DragDetect
- AFXWIN/CWnd::DrawAnimatedRects
- AFXWIN/CWnd::DrawCaption
- AFXWIN/CWnd::DrawMenuBar
- AFXWIN/CWnd::EnableActiveAccessibility
- AFXWIN/CWnd::EnableDynamicLayout
- AFXWIN/CWnd::EnableD2DSupport
- AFXWIN/CWnd::EnableScrollBar
- AFXWIN/CWnd::EnableScrollBarCtrl
- AFXWIN/CWnd::EnableToolTips
- AFXWIN/CWnd::EnableTrackingToolTips
- AFXWIN/CWnd::EnableWindow
- AFXWIN/CWnd::EndModalLoop
- AFXWIN/CWnd::EndModalState
- AFXWIN/CWnd::EndPaint
- AFXWIN/CWnd::ExecuteDlgInit
- AFXWIN/CWnd::FilterToolTipMessage
- AFXWIN/CWnd::FindWindow
- AFXWIN/CWnd::FindWindowEx
- AFXWIN/CWnd::FlashWindow
- AFXWIN/CWnd::FlashWindowEx
- AFXWIN/CWnd::FromHandle
- AFXWIN/CWnd::FromHandlePermanent
- AFXWIN/CWnd::get_accChild
- AFXWIN/CWnd::get_accChildCount
- AFXWIN/CWnd::get_accDefaultAction
- AFXWIN/CWnd::get_accDescription
- AFXWIN/CWnd::get_accFocus
- AFXWIN/CWnd::get_accHelp
- AFXWIN/CWnd::get_accHelpTopic
- AFXWIN/CWnd::get_accKeyboardShortcut
- AFXWIN/CWnd::get_accName
- AFXWIN/CWnd::get_accParent
- AFXWIN/CWnd::get_accRole
- AFXWIN/CWnd::get_accSelection
- AFXWIN/CWnd::get_accState
- AFXWIN/CWnd::get_accValue
- AFXWIN/CWnd::GetActiveWindow
- AFXWIN/CWnd::GetAncestor
- AFXWIN/CWnd::GetCapture
- AFXWIN/CWnd::GetCaretPos
- AFXWIN/CWnd::GetCheckedRadioButton
- AFXWIN/CWnd::GetClientRect
- AFXWIN/CWnd::GetClipboardOwner
- AFXWIN/CWnd::GetClipboardViewer
- AFXWIN/CWnd::GetControlUnknown
- AFXWIN/CWnd::GetDC
- AFXWIN/CWnd::GetDCEx
- AFXWIN/CWnd::GetDCRenderTarget
- AFXWIN/CWnd::GetDescendantWindow
- AFXWIN/CWnd::GetDesktopWindow
- AFXWIN/CWnd::GetDlgCtrlID
- AFXWIN/CWnd::GetDlgItem
- AFXWIN/CWnd::GetDlgItemInt
- AFXWIN/CWnd::GetDlgItemText
- AFXWIN/CWnd::GetDSCCursor
- AFXWIN/CWnd::GetDynamicLayout
- AFXWIN/CWnd::GetExStyle
- AFXWIN/CWnd::GetFocus
- AFXWIN/CWnd::GetFont
- AFXWIN/CWnd::GetForegroundWindow
- AFXWIN/CWnd::GetIcon
- AFXWIN/CWnd::GetLastActivePopup
- AFXWIN/CWnd::GetLayeredWindowAttributes
- AFXWIN/CWnd::GetMenu
- AFXWIN/CWnd::GetNextDlgGroupItem
- AFXWIN/CWnd::GetNextDlgTabItem
- AFXWIN/CWnd::GetNextWindow
- AFXWIN/CWnd::GetOleControlSite
- AFXWIN/CWnd::GetOpenClipboardWindow
- AFXWIN/CWnd::GetOwner
- AFXWIN/CWnd::GetParent
- AFXWIN/CWnd::GetParentFrame
- AFXWIN/CWnd::GetParentOwner
- AFXWIN/CWnd::GetProperty
- AFXWIN/CWnd::GetRenderTarget
- AFXWIN/CWnd::GetSafeHwnd
- AFXWIN/CWnd::GetSafeOwner
- AFXWIN/CWnd::GetScrollBarCtrl
- AFXWIN/CWnd::GetScrollBarInfo
- AFXWIN/CWnd::GetScrollInfo
- AFXWIN/CWnd::GetScrollLimit
- AFXWIN/CWnd::GetScrollPos
- AFXWIN/CWnd::GetScrollRange
- AFXWIN/CWnd::GetStyle
- AFXWIN/CWnd::GetSystemMenu
- AFXWIN/CWnd::GetTitleBarInfo
- AFXWIN/CWnd::GetTopLevelFrame
- AFXWIN/CWnd::GetTopLevelOwner
- AFXWIN/CWnd::GetTopLevelParent
- AFXWIN/CWnd::GetTopWindow
- AFXWIN/CWnd::GetUpdateRect
- AFXWIN/CWnd::GetUpdateRgn
- AFXWIN/CWnd::GetWindow
- AFXWIN/CWnd::GetWindowContextHelpId
- AFXWIN/CWnd::GetWindowDC
- AFXWIN/CWnd::GetWindowedChildCount
- AFXWIN/CWnd::GetWindowInfo
- AFXWIN/CWnd::GetWindowlessChildCount
- AFXWIN/CWnd::GetWindowPlacement
- AFXWIN/CWnd::GetWindowRect
- AFXWIN/CWnd::GetWindowRgn
- AFXWIN/CWnd::GetWindowText
- AFXWIN/CWnd::GetWindowTextLength
- AFXWIN/CWnd::HideCaret
- AFXWIN/CWnd::HiliteMenuItem
- AFXWIN/CWnd::HtmlHelp
- AFXWIN/CWnd::Invalidate
- AFXWIN/CWnd::InvalidateRect
- AFXWIN/CWnd::InvalidateRgn
- AFXWIN/CWnd::InvokeHelper
- AFXWIN/CWnd::IsChild
- AFXWIN/CWnd::IsD2DSupportEnabled
- AFXWIN/CWnd::IsDialogMessage
- AFXWIN/CWnd::IsDlgButtonChecked
- AFXWIN/CWnd::IsDynamicLayoutEnabled
- AFXWIN/CWnd::IsIconic
- AFXWIN/CWnd::IsTouchWindow
- AFXWIN/CWnd::IsWindowEnabled
- AFXWIN/CWnd::IsWindowVisible
- AFXWIN/CWnd::IsZoomed
- AFXWIN/CWnd::KillTimer
- AFXWIN/CWnd::LockWindowUpdate
- AFXWIN/CWnd::MapWindowPoints
- AFXWIN/CWnd::MessageBox
- AFXWIN/CWnd::ModifyStyle
- AFXWIN/CWnd::ModifyStyleEx
- AFXWIN/CWnd::MoveWindow
- AFXWIN/CWnd::NotifyWinEvent
- AFXWIN/CWnd::OnAmbientProperty
- AFXWIN/CWnd::OnDrawIconicThumbnailOrLivePreview
- AFXWIN/CWnd::OnHelp
- AFXWIN/CWnd::OnHelpFinder
- AFXWIN/CWnd::OnHelpIndex
- AFXWIN/CWnd::OnHelpUsing
- AFXWIN/CWnd::OnToolHitTest
- AFXWIN/CWnd::OpenClipboard
- AFXWIN/CWnd::PaintWindowlessControls
- AFXWIN/CWnd::PostMessage
- AFXWIN/CWnd::PreCreateWindow
- AFXWIN/CWnd::PreSubclassWindow
- AFXWIN/CWnd::PreTranslateMessage
- AFXWIN/CWnd::Print
- AFXWIN/CWnd::PrintClient
- AFXWIN/CWnd::PrintWindow
- AFXWIN/CWnd::RedrawWindow
- AFXWIN/CWnd::RegisterTouchWindow
- AFXWIN/CWnd::ReleaseDC
- AFXWIN/CWnd::RepositionBars
- AFXWIN/CWnd::RunModalLoop
- AFXWIN/CWnd::ScreenToClient
- AFXWIN/CWnd::ScrollWindow
- AFXWIN/CWnd::ScrollWindowEx
- AFXWIN/CWnd::SendChildNotifyLastMsg
- AFXWIN/CWnd::SendDlgItemMessage
- AFXWIN/CWnd::SendMessage
- AFXWIN/CWnd::SendMessageToDescendants
- AFXWIN/CWnd::SendNotifyMessage
- AFXWIN/CWnd::SetActiveWindow
- AFXWIN/CWnd::SetCapture
- AFXWIN/CWnd::SetCaretPos
- AFXWIN/CWnd::SetClipboardViewer
- AFXWIN/CWnd::SetDlgCtrlID
- AFXWIN/CWnd::SetDlgItemInt
- AFXWIN/CWnd::SetDlgItemText
- AFXWIN/CWnd::SetFocus
- AFXWIN/CWnd::SetFont
- AFXWIN/CWnd::SetForegroundWindow
- AFXWIN/CWnd::SetIcon
- AFXWIN/CWnd::SetLayeredWindowAttributes
- AFXWIN/CWnd::SetMenu
- AFXWIN/CWnd::SetOwner
- AFXWIN/CWnd::SetParent
- AFXWIN/CWnd::SetProperty
- AFXWIN/CWnd::SetRedraw
- AFXWIN/CWnd::SetScrollInfo
- AFXWIN/CWnd::SetScrollPos
- AFXWIN/CWnd::SetScrollRange
- AFXWIN/CWnd::SetTimer
- AFXWIN/CWnd::SetWindowContextHelpId
- AFXWIN/CWnd::SetWindowPlacement
- AFXWIN/CWnd::SetWindowPos
- AFXWIN/CWnd::SetWindowRgn
- AFXWIN/CWnd::SetWindowText
- AFXWIN/CWnd::ShowCaret
- AFXWIN/CWnd::ShowOwnedPopups
- AFXWIN/CWnd::ShowScrollBar
- AFXWIN/CWnd::ShowWindow
- AFXWIN/CWnd::SubclassDlgItem
- AFXWIN/CWnd::SubclassWindow
- AFXWIN/CWnd::UnlockWindowUpdate
- AFXWIN/CWnd::UnsubclassWindow
- AFXWIN/CWnd::UpdateData
- AFXWIN/CWnd::UpdateDialogControls
- AFXWIN/CWnd::UpdateLayeredWindow
- AFXWIN/CWnd::UpdateWindow
- AFXWIN/CWnd::ValidateRect
- AFXWIN/CWnd::ValidateRgn
- AFXWIN/CWnd::WindowFromPoint
- AFXWIN/CWnd::WinHelp
- AFXWIN/CWnd::Default
- AFXWIN/CWnd::DefWindowProc
- AFXWIN/CWnd::DoDataExchange
- AFXWIN/CWnd::GetCurrentMessage
- AFXWIN/CWnd::InitDynamicLayout
- AFXWIN/CWnd::LoadDynamicLayoutResource
- AFXWIN/CWnd::OnActivate
- AFXWIN/CWnd::OnActivateApp
- AFXWIN/CWnd::OnAppCommand
- AFXWIN/CWnd::OnAskCbFormatName
- AFXWIN/CWnd::OnCancelMode
- AFXWIN/CWnd::OnCaptureChanged
- AFXWIN/CWnd::OnChangeCbChain
- AFXWIN/CWnd::OnChangeUIState
- AFXWIN/CWnd::OnChar
- AFXWIN/CWnd::OnCharToItem
- AFXWIN/CWnd::OnChildActivate
- AFXWIN/CWnd::OnChildNotify
- AFXWIN/CWnd::OnClipboardUpdate
- AFXWIN/CWnd::OnClose
- AFXWIN/CWnd::OnColorizationColorChanged
- AFXWIN/CWnd::OnCommand
- AFXWIN/CWnd::OnCompacting
- AFXWIN/CWnd::OnCompareItem
- AFXWIN/CWnd::OnCompositionChanged
- AFXWIN/CWnd::OnContextMenu
- AFXWIN/CWnd::OnCopyData
- AFXWIN/CWnd::OnCreate
- AFXWIN/CWnd::OnCtlColor
- AFXWIN/CWnd::OnDeadChar
- AFXWIN/CWnd::OnDeleteItem
- AFXWIN/CWnd::OnDestroy
- AFXWIN/CWnd::OnDestroyClipboard
- AFXWIN/CWnd::OnDeviceChange
- AFXWIN/CWnd::OnDevModeChange
- AFXWIN/CWnd::OnDrawClipboard
- AFXWIN/CWnd::OnDrawItem
- AFXWIN/CWnd::OnDropFiles
- AFXWIN/CWnd::OnEnable
- AFXWIN/CWnd::OnEndSession
- AFXWIN/CWnd::OnEnterIdle
- AFXWIN/CWnd::OnEnterMenuLoop
- AFXWIN/CWnd::OnEnterSizeMove
- AFXWIN/CWnd::OnEraseBkgnd
- AFXWIN/CWnd::OnExitMenuLoop
- AFXWIN/CWnd::OnExitSizeMove
- AFXWIN/CWnd::OnFontChange
- AFXWIN/CWnd::OnGetDlgCode
- AFXWIN/CWnd::OnGetMinMaxInfo
- AFXWIN/CWnd::OnHelpInfo
- AFXWIN/CWnd::OnHotKey
- AFXWIN/CWnd::OnHScroll
- AFXWIN/CWnd::OnHScrollClipboard
- AFXWIN/CWnd::OnIconEraseBkgnd
- AFXWIN/CWnd::OnInitMenu
- AFXWIN/CWnd::OnInitMenuPopup
- AFXWIN/CWnd::OnInputDeviceChange
- AFXWIN/CWnd::OnInputLangChange
- AFXWIN/CWnd::OnInputLangChangeRequest
- AFXWIN/CWnd::OnKeyDown
- AFXWIN/CWnd::OnKeyUp
- AFXWIN/CWnd::OnKillFocus
- AFXWIN/CWnd::OnLButtonDblClk
- AFXWIN/CWnd::OnLButtonDown
- AFXWIN/CWnd::OnLButtonUp
- AFXWIN/CWnd::OnMButtonDblClk
- AFXWIN/CWnd::OnMButtonDown
- AFXWIN/CWnd::OnMButtonUp
- AFXWIN/CWnd::OnMDIActivate
- AFXWIN/CWnd::OnMeasureItem
- AFXWIN/CWnd::OnMenuChar
- AFXWIN/CWnd::OnMenuDrag
- AFXWIN/CWnd::OnMenuGetObject
- AFXWIN/CWnd::OnMenuRButtonUp
- AFXWIN/CWnd::OnMenuSelect
- AFXWIN/CWnd::OnMouseActivate
- AFXWIN/CWnd::OnMouseHover
- AFXWIN/CWnd::OnMouseHWheel
- AFXWIN/CWnd::OnMouseLeave
- AFXWIN/CWnd::OnMouseMove
- AFXWIN/CWnd::OnMouseWheel
- AFXWIN/CWnd::OnMove
- AFXWIN/CWnd::OnMoving
- AFXWIN/CWnd::OnNcActivate
- AFXWIN/CWnd::OnNcCalcSize
- AFXWIN/CWnd::OnNcCreate
- AFXWIN/CWnd::OnNcDestroy
- AFXWIN/CWnd::OnNcHitTest
- AFXWIN/CWnd::OnNcLButtonDblClk
- AFXWIN/CWnd::OnNcLButtonDown
- AFXWIN/CWnd::OnNcLButtonUp
- AFXWIN/CWnd::OnNcMButtonDblClk
- AFXWIN/CWnd::OnNcMButtonDown
- AFXWIN/CWnd::OnNcMButtonUp
- AFXWIN/CWnd::OnNcMouseHover
- AFXWIN/CWnd::OnNcMouseLeave
- AFXWIN/CWnd::OnNcMouseMove
- AFXWIN/CWnd::OnNcPaint
- AFXWIN/CWnd::OnNcRButtonDblClk
- AFXWIN/CWnd::OnNcRButtonDown
- AFXWIN/CWnd::OnNcRButtonUp
- AFXWIN/CWnd::OnNcRenderingChanged
- AFXWIN/CWnd::OnNcXButtonDblClk
- AFXWIN/CWnd::OnNcXButtonDown
- AFXWIN/CWnd::OnNcXButtonUp
- AFXWIN/CWnd::OnNextMenu
- AFXWIN/CWnd::OnNotify
- AFXWIN/CWnd::OnNotifyFormat
- AFXWIN/CWnd::OnPaint
- AFXWIN/CWnd::OnPaintClipboard
- AFXWIN/CWnd::OnPaletteChanged
- AFXWIN/CWnd::OnPaletteIsChanging
- AFXWIN/CWnd::OnParentNotify
- AFXWIN/CWnd::OnPowerBroadcast
- AFXWIN/CWnd::OnQueryDragIcon
- AFXWIN/CWnd::OnQueryEndSession
- AFXWIN/CWnd::OnQueryNewPalette
- AFXWIN/CWnd::OnQueryOpen
- AFXWIN/CWnd::OnQueryUIState
- AFXWIN/CWnd::OnRawInput
- AFXWIN/CWnd::OnRButtonDblClk
- AFXWIN/CWnd::OnRButtonDown
- AFXWIN/CWnd::OnRButtonUp
- AFXWIN/CWnd::OnRenderAllFormats
- AFXWIN/CWnd::OnRenderFormat
- AFXWIN/CWnd::OnSessionChange
- AFXWIN/CWnd::OnSetCursor
- AFXWIN/CWnd::OnSetFocus
- AFXWIN/CWnd::OnSettingChange
- AFXWIN/CWnd::OnShowWindow
- AFXWIN/CWnd::OnSize
- AFXWIN/CWnd::OnSizeClipboard
- AFXWIN/CWnd::OnSizing
- AFXWIN/CWnd::OnSpoolerStatus
- AFXWIN/CWnd::OnStyleChanged
- AFXWIN/CWnd::OnStyleChanging
- AFXWIN/CWnd::OnSysChar
- AFXWIN/CWnd::OnSysColorChange
- AFXWIN/CWnd::OnSysCommand
- AFXWIN/CWnd::OnSysDeadChar
- AFXWIN/CWnd::OnSysKeyDown
- AFXWIN/CWnd::OnSysKeyUp
- AFXWIN/CWnd::OnTCard
- AFXWIN/CWnd::OnTimeChange
- AFXWIN/CWnd::OnTimer
- AFXWIN/CWnd::OnTouchInput
- AFXWIN/CWnd::OnTouchInputs
- AFXWIN/CWnd::OnUniChar
- AFXWIN/CWnd::OnUnInitMenuPopup
- AFXWIN/CWnd::OnUpdateUIState
- AFXWIN/CWnd::OnUserChanged
- AFXWIN/CWnd::OnVKeyToItem
- AFXWIN/CWnd::OnVScroll
- AFXWIN/CWnd::OnVScrollClipboard
- AFXWIN/CWnd::OnWindowPosChanged
- AFXWIN/CWnd::OnWindowPosChanging
- AFXWIN/CWnd::OnWinIniChange
- AFXWIN/CWnd::OnWndMsg
- AFXWIN/CWnd::OnXButtonDblClk
- AFXWIN/CWnd::OnXButtonDown
- AFXWIN/CWnd::OnXButtonUp
- AFXWIN/CWnd::PostNcDestroy
- AFXWIN/CWnd::ReflectChildNotify
- AFXWIN/CWnd::ReflectLastMsg
- AFXWIN/CWnd::ResizeDynamicLayout
- AFXWIN/CWnd::WindowProc
- AFXWIN/CWnd::m_hWnd
helpviewer_keywords:
- CWnd [MFC], CWnd
- CWnd [MFC], accDoDefaultAction
- CWnd [MFC], accHitTest
- CWnd [MFC], accLocation
- CWnd [MFC], accNavigate
- CWnd [MFC], accSelect
- CWnd [MFC], AnimateWindow
- CWnd [MFC], ArrangeIconicWindows
- CWnd [MFC], Attach
- CWnd [MFC], BeginModalState
- CWnd [MFC], BeginPaint
- CWnd [MFC], BindDefaultProperty
- CWnd [MFC], BindProperty
- CWnd [MFC], BringWindowToTop
- CWnd [MFC], CalcWindowRect
- CWnd [MFC], CancelToolTips
- CWnd [MFC], CenterWindow
- CWnd [MFC], ChangeClipboardChain
- CWnd [MFC], CheckDlgButton
- CWnd [MFC], CheckRadioButton
- CWnd [MFC], ChildWindowFromPoint
- CWnd [MFC], ClientToScreen
- CWnd [MFC], CloseWindow
- CWnd [MFC], ContinueModal
- CWnd [MFC], Create
- CWnd [MFC], CreateAccessibleProxy
- CWnd [MFC], CreateCaret
- CWnd [MFC], CreateControl
- CWnd [MFC], CreateEx
- CWnd [MFC], CreateGrayCaret
- CWnd [MFC], CreateSolidCaret
- CWnd [MFC], DeleteTempMap
- CWnd [MFC], DestroyWindow
- CWnd [MFC], Detach
- CWnd [MFC], DlgDirList
- CWnd [MFC], DlgDirListComboBox
- CWnd [MFC], DlgDirSelect
- CWnd [MFC], DlgDirSelectComboBox
- CWnd [MFC], DragAcceptFiles
- CWnd [MFC], DragDetect
- CWnd [MFC], DrawAnimatedRects
- CWnd [MFC], DrawCaption
- CWnd [MFC], DrawMenuBar
- CWnd [MFC], EnableActiveAccessibility
- CWnd [MFC], EnableDynamicLayout
- CWnd [MFC], EnableD2DSupport
- CWnd [MFC], EnableScrollBar
- CWnd [MFC], EnableScrollBarCtrl
- CWnd [MFC], EnableToolTips
- CWnd [MFC], EnableTrackingToolTips
- CWnd [MFC], EnableWindow
- CWnd [MFC], EndModalLoop
- CWnd [MFC], EndModalState
- CWnd [MFC], EndPaint
- CWnd [MFC], ExecuteDlgInit
- CWnd [MFC], FilterToolTipMessage
- CWnd [MFC], FindWindow
- CWnd [MFC], FindWindowEx
- CWnd [MFC], FlashWindow
- CWnd [MFC], FlashWindowEx
- CWnd [MFC], FromHandle
- CWnd [MFC], FromHandlePermanent
- CWnd [MFC], get_accChild
- CWnd [MFC], get_accChildCount
- CWnd [MFC], get_accDefaultAction
- CWnd [MFC], get_accDescription
- CWnd [MFC], get_accFocus
- CWnd [MFC], get_accHelp
- CWnd [MFC], get_accHelpTopic
- CWnd [MFC], get_accKeyboardShortcut
- CWnd [MFC], get_accName
- CWnd [MFC], get_accParent
- CWnd [MFC], get_accRole
- CWnd [MFC], get_accSelection
- CWnd [MFC], get_accState
- CWnd [MFC], get_accValue
- CWnd [MFC], GetActiveWindow
- CWnd [MFC], GetAncestor
- CWnd [MFC], GetCapture
- CWnd [MFC], GetCaretPos
- CWnd [MFC], GetCheckedRadioButton
- CWnd [MFC], GetClientRect
- CWnd [MFC], GetClipboardOwner
- CWnd [MFC], GetClipboardViewer
- CWnd [MFC], GetControlUnknown
- CWnd [MFC], GetDC
- CWnd [MFC], GetDCEx
- CWnd [MFC], GetDCRenderTarget
- CWnd [MFC], GetDescendantWindow
- CWnd [MFC], GetDesktopWindow
- CWnd [MFC], GetDlgCtrlID
- CWnd [MFC], GetDlgItem
- CWnd [MFC], GetDlgItemInt
- CWnd [MFC], GetDlgItemText
- CWnd [MFC], GetDSCCursor
- CWnd [MFC], GetDynamicLayout
- CWnd [MFC], GetExStyle
- CWnd [MFC], GetFocus
- CWnd [MFC], GetFont
- CWnd [MFC], GetForegroundWindow
- CWnd [MFC], GetIcon
- CWnd [MFC], GetLastActivePopup
- CWnd [MFC], GetLayeredWindowAttributes
- CWnd [MFC], GetMenu
- CWnd [MFC], GetNextDlgGroupItem
- CWnd [MFC], GetNextDlgTabItem
- CWnd [MFC], GetNextWindow
- CWnd [MFC], GetOleControlSite
- CWnd [MFC], GetOpenClipboardWindow
- CWnd [MFC], GetOwner
- CWnd [MFC], GetParent
- CWnd [MFC], GetParentFrame
- CWnd [MFC], GetParentOwner
- CWnd [MFC], GetProperty
- CWnd [MFC], GetRenderTarget
- CWnd [MFC], GetSafeHwnd
- CWnd [MFC], GetSafeOwner
- CWnd [MFC], GetScrollBarCtrl
- CWnd [MFC], GetScrollBarInfo
- CWnd [MFC], GetScrollInfo
- CWnd [MFC], GetScrollLimit
- CWnd [MFC], GetScrollPos
- CWnd [MFC], GetScrollRange
- CWnd [MFC], GetStyle
- CWnd [MFC], GetSystemMenu
- CWnd [MFC], GetTitleBarInfo
- CWnd [MFC], GetTopLevelFrame
- CWnd [MFC], GetTopLevelOwner
- CWnd [MFC], GetTopLevelParent
- CWnd [MFC], GetTopWindow
- CWnd [MFC], GetUpdateRect
- CWnd [MFC], GetUpdateRgn
- CWnd [MFC], GetWindow
- CWnd [MFC], GetWindowContextHelpId
- CWnd [MFC], GetWindowDC
- CWnd [MFC], GetWindowedChildCount
- CWnd [MFC], GetWindowInfo
- CWnd [MFC], GetWindowlessChildCount
- CWnd [MFC], GetWindowPlacement
- CWnd [MFC], GetWindowRect
- CWnd [MFC], GetWindowRgn
- CWnd [MFC], GetWindowText
- CWnd [MFC], GetWindowTextLength
- CWnd [MFC], HideCaret
- CWnd [MFC], HiliteMenuItem
- CWnd [MFC], HtmlHelp
- CWnd [MFC], Invalidate
- CWnd [MFC], InvalidateRect
- CWnd [MFC], InvalidateRgn
- CWnd [MFC], InvokeHelper
- CWnd [MFC], IsChild
- CWnd [MFC], IsD2DSupportEnabled
- CWnd [MFC], IsDialogMessage
- CWnd [MFC], IsDlgButtonChecked
- CWnd [MFC], IsDynamicLayoutEnabled
- CWnd [MFC], IsIconic
- CWnd [MFC], IsTouchWindow
- CWnd [MFC], IsWindowEnabled
- CWnd [MFC], IsWindowVisible
- CWnd [MFC], IsZoomed
- CWnd [MFC], KillTimer
- CWnd [MFC], LockWindowUpdate
- CWnd [MFC], MapWindowPoints
- CWnd [MFC], MessageBox
- CWnd [MFC], ModifyStyle
- CWnd [MFC], ModifyStyleEx
- CWnd [MFC], MoveWindow
- CWnd [MFC], NotifyWinEvent
- CWnd [MFC], OnAmbientProperty
- CWnd [MFC], OnDrawIconicThumbnailOrLivePreview
- CWnd [MFC], OnHelp
- CWnd [MFC], OnHelpFinder
- CWnd [MFC], OnHelpIndex
- CWnd [MFC], OnHelpUsing
- CWnd [MFC], OnToolHitTest
- CWnd [MFC], OpenClipboard
- CWnd [MFC], PaintWindowlessControls
- CWnd [MFC], PostMessage
- CWnd [MFC], PreCreateWindow
- CWnd [MFC], PreSubclassWindow
- CWnd [MFC], PreTranslateMessage
- CWnd [MFC], Print
- CWnd [MFC], PrintClient
- CWnd [MFC], PrintWindow
- CWnd [MFC], RedrawWindow
- CWnd [MFC], RegisterTouchWindow
- CWnd [MFC], ReleaseDC
- CWnd [MFC], RepositionBars
- CWnd [MFC], RunModalLoop
- CWnd [MFC], ScreenToClient
- CWnd [MFC], ScrollWindow
- CWnd [MFC], ScrollWindowEx
- CWnd [MFC], SendChildNotifyLastMsg
- CWnd [MFC], SendDlgItemMessage
- CWnd [MFC], SendMessage
- CWnd [MFC], SendMessageToDescendants
- CWnd [MFC], SendNotifyMessage
- CWnd [MFC], SetActiveWindow
- CWnd [MFC], SetCapture
- CWnd [MFC], SetCaretPos
- CWnd [MFC], SetClipboardViewer
- CWnd [MFC], SetDlgCtrlID
- CWnd [MFC], SetDlgItemInt
- CWnd [MFC], SetDlgItemText
- CWnd [MFC], SetFocus
- CWnd [MFC], SetFont
- CWnd [MFC], SetForegroundWindow
- CWnd [MFC], SetIcon
- CWnd [MFC], SetLayeredWindowAttributes
- CWnd [MFC], SetMenu
- CWnd [MFC], SetOwner
- CWnd [MFC], SetParent
- CWnd [MFC], SetProperty
- CWnd [MFC], SetRedraw
- CWnd [MFC], SetScrollInfo
- CWnd [MFC], SetScrollPos
- CWnd [MFC], SetScrollRange
- CWnd [MFC], SetTimer
- CWnd [MFC], SetWindowContextHelpId
- CWnd [MFC], SetWindowPlacement
- CWnd [MFC], SetWindowPos
- CWnd [MFC], SetWindowRgn
- CWnd [MFC], SetWindowText
- CWnd [MFC], ShowCaret
- CWnd [MFC], ShowOwnedPopups
- CWnd [MFC], ShowScrollBar
- CWnd [MFC], ShowWindow
- CWnd [MFC], SubclassDlgItem
- CWnd [MFC], SubclassWindow
- CWnd [MFC], UnlockWindowUpdate
- CWnd [MFC], UnsubclassWindow
- CWnd [MFC], UpdateData
- CWnd [MFC], UpdateDialogControls
- CWnd [MFC], UpdateLayeredWindow
- CWnd [MFC], UpdateWindow
- CWnd [MFC], ValidateRect
- CWnd [MFC], ValidateRgn
- CWnd [MFC], WindowFromPoint
- CWnd [MFC], WinHelp
- CWnd [MFC], Default
- CWnd [MFC], DefWindowProc
- CWnd [MFC], DoDataExchange
- CWnd [MFC], GetCurrentMessage
- CWnd [MFC], InitDynamicLayout
- CWnd [MFC], LoadDynamicLayoutResource
- CWnd [MFC], OnActivate
- CWnd [MFC], OnActivateApp
- CWnd [MFC], OnAppCommand
- CWnd [MFC], OnAskCbFormatName
- CWnd [MFC], OnCancelMode
- CWnd [MFC], OnCaptureChanged
- CWnd [MFC], OnChangeCbChain
- CWnd [MFC], OnChangeUIState
- CWnd [MFC], OnChar
- CWnd [MFC], OnCharToItem
- CWnd [MFC], OnChildActivate
- CWnd [MFC], OnChildNotify
- CWnd [MFC], OnClipboardUpdate
- CWnd [MFC], OnClose
- CWnd [MFC], OnColorizationColorChanged
- CWnd [MFC], OnCommand
- CWnd [MFC], OnCompacting
- CWnd [MFC], OnCompareItem
- CWnd [MFC], OnCompositionChanged
- CWnd [MFC], OnContextMenu
- CWnd [MFC], OnCopyData
- CWnd [MFC], OnCreate
- CWnd [MFC], OnCtlColor
- CWnd [MFC], OnDeadChar
- CWnd [MFC], OnDeleteItem
- CWnd [MFC], OnDestroy
- CWnd [MFC], OnDestroyClipboard
- CWnd [MFC], OnDeviceChange
- CWnd [MFC], OnDevModeChange
- CWnd [MFC], OnDrawClipboard
- CWnd [MFC], OnDrawItem
- CWnd [MFC], OnDropFiles
- CWnd [MFC], OnEnable
- CWnd [MFC], OnEndSession
- CWnd [MFC], OnEnterIdle
- CWnd [MFC], OnEnterMenuLoop
- CWnd [MFC], OnEnterSizeMove
- CWnd [MFC], OnEraseBkgnd
- CWnd [MFC], OnExitMenuLoop
- CWnd [MFC], OnExitSizeMove
- CWnd [MFC], OnFontChange
- CWnd [MFC], OnGetDlgCode
- CWnd [MFC], OnGetMinMaxInfo
- CWnd [MFC], OnHelpInfo
- CWnd [MFC], OnHotKey
- CWnd [MFC], OnHScroll
- CWnd [MFC], OnHScrollClipboard
- CWnd [MFC], OnIconEraseBkgnd
- CWnd [MFC], OnInitMenu
- CWnd [MFC], OnInitMenuPopup
- CWnd [MFC], OnInputDeviceChange
- CWnd [MFC], OnInputLangChange
- CWnd [MFC], OnInputLangChangeRequest
- CWnd [MFC], OnKeyDown
- CWnd [MFC], OnKeyUp
- CWnd [MFC], OnKillFocus
- CWnd [MFC], OnLButtonDblClk
- CWnd [MFC], OnLButtonDown
- CWnd [MFC], OnLButtonUp
- CWnd [MFC], OnMButtonDblClk
- CWnd [MFC], OnMButtonDown
- CWnd [MFC], OnMButtonUp
- CWnd [MFC], OnMDIActivate
- CWnd [MFC], OnMeasureItem
- CWnd [MFC], OnMenuChar
- CWnd [MFC], OnMenuDrag
- CWnd [MFC], OnMenuGetObject
- CWnd [MFC], OnMenuRButtonUp
- CWnd [MFC], OnMenuSelect
- CWnd [MFC], OnMouseActivate
- CWnd [MFC], OnMouseHover
- CWnd [MFC], OnMouseHWheel
- CWnd [MFC], OnMouseLeave
- CWnd [MFC], OnMouseMove
- CWnd [MFC], OnMouseWheel
- CWnd [MFC], OnMove
- CWnd [MFC], OnMoving
- CWnd [MFC], OnNcActivate
- CWnd [MFC], OnNcCalcSize
- CWnd [MFC], OnNcCreate
- CWnd [MFC], OnNcDestroy
- CWnd [MFC], OnNcHitTest
- CWnd [MFC], OnNcLButtonDblClk
- CWnd [MFC], OnNcLButtonDown
- CWnd [MFC], OnNcLButtonUp
- CWnd [MFC], OnNcMButtonDblClk
- CWnd [MFC], OnNcMButtonDown
- CWnd [MFC], OnNcMButtonUp
- CWnd [MFC], OnNcMouseHover
- CWnd [MFC], OnNcMouseLeave
- CWnd [MFC], OnNcMouseMove
- CWnd [MFC], OnNcPaint
- CWnd [MFC], OnNcRButtonDblClk
- CWnd [MFC], OnNcRButtonDown
- CWnd [MFC], OnNcRButtonUp
- CWnd [MFC], OnNcRenderingChanged
- CWnd [MFC], OnNcXButtonDblClk
- CWnd [MFC], OnNcXButtonDown
- CWnd [MFC], OnNcXButtonUp
- CWnd [MFC], OnNextMenu
- CWnd [MFC], OnNotify
- CWnd [MFC], OnNotifyFormat
- CWnd [MFC], OnPaint
- CWnd [MFC], OnPaintClipboard
- CWnd [MFC], OnPaletteChanged
- CWnd [MFC], OnPaletteIsChanging
- CWnd [MFC], OnParentNotify
- CWnd [MFC], OnPowerBroadcast
- CWnd [MFC], OnQueryDragIcon
- CWnd [MFC], OnQueryEndSession
- CWnd [MFC], OnQueryNewPalette
- CWnd [MFC], OnQueryOpen
- CWnd [MFC], OnQueryUIState
- CWnd [MFC], OnRawInput
- CWnd [MFC], OnRButtonDblClk
- CWnd [MFC], OnRButtonDown
- CWnd [MFC], OnRButtonUp
- CWnd [MFC], OnRenderAllFormats
- CWnd [MFC], OnRenderFormat
- CWnd [MFC], OnSessionChange
- CWnd [MFC], OnSetCursor
- CWnd [MFC], OnSetFocus
- CWnd [MFC], OnSettingChange
- CWnd [MFC], OnShowWindow
- CWnd [MFC], OnSize
- CWnd [MFC], OnSizeClipboard
- CWnd [MFC], OnSizing
- CWnd [MFC], OnSpoolerStatus
- CWnd [MFC], OnStyleChanged
- CWnd [MFC], OnStyleChanging
- CWnd [MFC], OnSysChar
- CWnd [MFC], OnSysColorChange
- CWnd [MFC], OnSysCommand
- CWnd [MFC], OnSysDeadChar
- CWnd [MFC], OnSysKeyDown
- CWnd [MFC], OnSysKeyUp
- CWnd [MFC], OnTCard
- CWnd [MFC], OnTimeChange
- CWnd [MFC], OnTimer
- CWnd [MFC], OnTouchInput
- CWnd [MFC], OnTouchInputs
- CWnd [MFC], OnUniChar
- CWnd [MFC], OnUnInitMenuPopup
- CWnd [MFC], OnUpdateUIState
- CWnd [MFC], OnUserChanged
- CWnd [MFC], OnVKeyToItem
- CWnd [MFC], OnVScroll
- CWnd [MFC], OnVScrollClipboard
- CWnd [MFC], OnWindowPosChanged
- CWnd [MFC], OnWindowPosChanging
- CWnd [MFC], OnWinIniChange
- CWnd [MFC], OnWndMsg
- CWnd [MFC], OnXButtonDblClk
- CWnd [MFC], OnXButtonDown
- CWnd [MFC], OnXButtonUp
- CWnd [MFC], PostNcDestroy
- CWnd [MFC], ReflectChildNotify
- CWnd [MFC], ReflectLastMsg
- CWnd [MFC], ResizeDynamicLayout
- CWnd [MFC], WindowProc
- CWnd [MFC], m_hWnd
ms.assetid: 49a832ee-bc34-4126-88b3-bc1d9974f6c4
ms.openlocfilehash: b846a065b02a73bfca8f548097101f73008b33d3
ms.sourcegitcommit: 0e3da5cea44437c132b5c2ea522bd229ea000a10
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/12/2019
ms.locfileid: "67861055"
---
# <a name="cwnd-class"></a>CWnd 類別

提供 MFC 程式庫中所有視窗類別的基本功能。

## <a name="syntax"></a>語法

```
class CWnd : public CCmdTarget
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CWnd::CWnd](#cwnd)|建構 `CWnd` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CWnd::accDoDefaultAction](#accdodefaultaction)|由架構呼叫以執行物件的預設動作。|
|[CWnd::accHitTest](#acchittest)|由架構呼叫以擷取畫面中給定點的子項目或子物件。|
|[CWnd::accLocation](#acclocation)|由架構呼叫以擷取指定物件目前畫面的位置。|
|[CWnd::accNavigate](#accnavigate)|由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。|
|[CWnd::accSelect](#accselect)|由架構呼叫以修改選取或移動指定物件的鍵盤焦點。|
|[CWnd::AnimateWindow](#animatewindow)|建立相關聯的視窗物件的動畫。|
|[CWnd::ArrangeIconicWindows](#arrangeiconicwindows)|排列所有最小化 (圖示) 子視窗。|
|[CWnd::Attach](#attach)|將 Windows 控制代碼附加至 `CWnd` 物件。|
|[CWnd::BeginModalState](#beginmodalstate)|呼叫此成員函式以製作框架視窗強制回應。|
|[CWnd::BeginPaint](#beginpaint)|準備 `CWnd` 進行繪製。|
|[CWnd::BindDefaultProperty](#binddefaultproperty)|將呼叫物件的預設簡單繫結屬性 (在類型程式庫中標示)，繫結至資料來源控制項相關聯的游標。|
|[CWnd::BindProperty](#bindproperty)|將資料繫結控制項上的游標繫結屬性繫結至資料來源控制項，並註冊該關聯性與 MFC 繫結管理員。|
|[CWnd::BringWindowToTop](#bringwindowtotop)|將 `CWnd` 帶到重疊視窗堆疊的最上層。|
|[CWnd::CalcWindowRect](#calcwindowrect)|呼叫可從用戶端矩形計算視窗矩形。|
|[CWnd::CancelToolTips](#canceltooltips)|停用工具提示控制項。|
|[CWnd::CenterWindow](#centerwindow)|將相對於其父系的視窗置中。|
|[CWnd::ChangeClipboardChain](#changeclipboardchain)|從剪貼簿檢視器的鏈結中移除 `CWnd`。|
|[CWnd::CheckDlgButton](#checkdlgbutton)|在按鈕控制項旁放置核取記號，或從中移除核取記號。|
|[CWnd::CheckRadioButton](#checkradiobutton)|檢查指定的選項按鈕，及移除指定的按鈕群組中所有其他選項按鈕的核取記號。|
|[CWnd::ChildWindowFromPoint](#childwindowfrompoint)|判斷 (如果有的話) 是否有子視窗包含指定的點。|
|[CWnd::ClientToScreen](#clienttoscreen)|將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。|
|[CWnd::CloseWindow](#closewindow)|將視窗最小化。|
|[CWnd::ContinueModal](#continuemodal)|繼續視窗的強制回應狀態。|
|[CWnd::Create](#create)|建立並初始化 `CWnd` 物件相關聯的子視窗。|
|[CWnd::CreateAccessibleProxy](#createaccessibleproxy)|建立指定物件的 Active Accessibility Proxy。|
|[CWnd::CreateCaret](#createcaret)|建立系統游標的新形狀，並取得插入號的擁有權。|
|[CWnd::CreateControl](#createcontrol)|建立將由 `CWnd` 物件在 MFC 程式中表示的 ActiveX 控制項。|
|[CWnd::CreateEx](#createex)|建立 Windows 重疊、快顯視窗或子視窗，並將其附加至 `CWnd` 物件。|
|[CWnd::CreateGrayCaret](#creategraycaret)|建立系統游標的灰色區塊，並取得插入號的擁有權。|
|[CWnd::CreateSolidCaret](#createsolidcaret)|建立系統游標的實心區塊，並取得插入號的擁有權。|
|[CWnd::DeleteTempMap](#deletetempmap)|由 `CWinApp` 閒置時間處理常式自動呼叫，並刪除 `FromHandle` 建立的任何暫存 `CWnd` 物件。|
|[CWnd::DestroyWindow](#destroywindow)|終結附加的 Windowd 視窗。|
|[CWnd::Detach](#detach)|從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。|
|[CWnd::DlgDirList](#dlgdirlist)|使用檔案或目錄清單填入清單方塊。|
|[CWnd::DlgDirListComboBox](#dlgdirlistcombobox)|使用檔案或目錄清單來填入下拉式方塊的清單方塊。|
|[CWnd::DlgDirSelect](#dlgdirselect)|從清單方塊擷取目前的選取範圍。|
|[CWnd::DlgDirSelectComboBox](#dlgdirselectcombobox)|從下拉式方塊的清單方塊中擷取目前的選取範圍。|
|[CWnd::DragAcceptFiles](#dragacceptfiles)|指出視窗將接受拖曳的檔案。|
|[CWnd::DragDetect](#dragdetect)|擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。|
|[CWnd::DrawAnimatedRects](#drawanimatedrects)|繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。|
|[CWnd::DrawCaption](#drawcaption)|繪製標題。|
|[CWnd::DrawMenuBar](#drawmenubar)|重新繪製功能表列。|
|[CWnd::EnableActiveAccessibility](#enableactiveaccessibility)|啟用使用者定義的 `Active Accessibility` 函式。|
|[CWnd::EnableDynamicLayout](#enabledynamiclayout)|可在使用者調整視窗大小時，動態調整子視窗的位置與大小。|
|[CWnd::EnableD2DSupport](#enabled2dsupport)|啟用或停用視窗 `D2D` 支援。 初始化主視窗之前先呼叫這個方法。|
|[CWnd::EnableScrollBar](#enablescrollbar)|啟用或停用一個捲軸的一或兩個箭號。|
|[CWnd::EnableScrollBarCtrl](#enablescrollbarctrl)|啟用或停用同層級捲軸控制項。|
|[CWnd::EnableToolTips](#enabletooltips)|啟用工具提示控制項。|
|[CWnd::EnableTrackingToolTips](#enabletrackingtooltips)|啟用追蹤模式中的工具提示控制項。|
|[CWnd::EnableWindow](#enablewindow)|啟用或停用滑鼠和鍵盤輸入。|
|[CWnd::EndModalLoop](#endmodalloop)|結束視窗的強制回應狀態。|
|[CWnd::EndModalState](#endmodalstate)|呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。|
|[CWnd::EndPaint](#endpaint)|標記繪製的結束。|
|[CWnd::ExecuteDlgInit](#executedlginit)|初始化對話方塊資源。|
|[CWnd::FilterToolTipMessage](#filtertooltipmessage)|擷取對話方塊中控制項相關聯的標題或文字。|
|[CWnd::FindWindow](#findwindow)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FindWindowEx](#findwindowex)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FlashWindow](#flashwindow)|閃爍視窗一次。|
|[CWnd::FlashWindowEx](#flashwindowex)|閃爍視窗與其他功能。|
|[CWnd::FromHandle](#fromhandle)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|
|[CWnd::FromHandlePermanent](#fromhandlepermanent)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|
|[CWnd::get_accChild](#get_accchild)|由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。|
|[CWnd::get_accChildCount](#get_accchildcount)|由架構呼叫以擷取屬於此物件的子物件數目。|
|[CWnd::get_accDefaultAction](#get_accdefaultaction)|由架構呼叫以擷取具有物件預設動作描述的字串。|
|[CWnd::get_accDescription](#get_accdescription)|由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。|
|[CWnd::get_accFocus](#get_accfocus)|由架構呼叫以擷取具有鍵盤焦點的物件。|
|[CWnd::get_accHelp](#get_acchelp)|由架構呼叫以擷取物件**協助**屬性字串。|
|[CWnd::get_accHelpTopic](#get_acchelptopic)|由架構呼叫以擷取 `WinHelp` 檔 (與指定物件和該檔案中適切主題的識別項關聯) 的完整路徑。|
|[CWnd::get_accKeyboardShortcut](#get_acckeyboardshortcut)|由架構呼叫以擷取指定物件的快速鍵或便捷鍵。|
|[CWnd::get_accName](#get_accname)|由架構呼叫以擷取指定物件的名稱。|
|[CWnd::get_accParent](#get_accparent)|由架構呼叫以擷取物件之父代的 `IDispatch` 介面。|
|[CWnd::get_accRole](#get_accrole)|由架構呼叫以擷取含有指定物件的角色描述資訊。|
|[CWnd::get_accSelection](#get_accselection)|由架構呼叫以擷取此物件的選取子物件。|
|[CWnd::get_accState](#get_accstate)|由架構呼叫以擷取指定物件的目前狀態。|
|[CWnd::get_accValue](#get_accvalue)|由架構呼叫以擷取指定物件的值。|
|[CWnd::GetActiveWindow](#getactivewindow)|擷取使用中視窗。|
|[CWnd::GetAncestor](#getancestor)|擷取指定視窗的上階視窗物件。|
|[CWnd::GetCapture](#getcapture)|擷取具有滑鼠捕捉的 `CWnd`。|
|[CWnd::GetCaretPos](#getcaretpos)|擷取插入號之目前位置的用戶端座標。|
|[CWnd::GetCheckedRadioButton](#getcheckedradiobutton)|傳回按鈕群組中目前核取的選項按鈕的識別碼。|
|[CWnd::GetClientRect](#getclientrect)|取得 `CWnd` 工作區的維度。|
|[CWnd::GetClipboardOwner](#getclipboardowner)|擷取剪貼簿的目前擁有者的指標。|
|[CWnd::GetClipboardViewer](#getclipboardviewer)|擷取剪貼簿檢視器鏈結中的第一個視窗的指標。|
|[CWnd::GetControlUnknown](#getcontrolunknown)|擷取至未知 ActiveX 控制項的指標。|
|[CWnd::GetDC](#getdc)|擷取工作區的顯示內容。|
|[CWnd::GetDCEx](#getdcex)|擷取工作區的顯示內容，並在繪製時啟用裁剪。|
|[CWnd::GetDCRenderTarget](#getdcrendertarget)|擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。|
|[CWnd::GetDescendantWindow](#getdescendantwindow)|搜尋所有下階視窗，並傳回具有指定識別碼的視窗。|
|[CWnd::GetDesktopWindow](#getdesktopwindow)|擷取 Windows 桌面視窗。|
|[CWnd::GetDlgCtrlID](#getdlgctrlid)|如果 `CWnd` 是子視窗，呼叫這個函式會傳回它的識別碼值。|
|[CWnd::GetDlgItem](#getdlgitem)|從指定的對話方塊中擷取具有指定識別碼的控制項。|
|[CWnd::GetDlgItemInt](#getdlgitemint)|將指定對話方塊中的控制項文字轉譯成整數值。|
|[CWnd::GetDlgItemText](#getdlgitemtext)|擷取與控制項相關聯的標題或文字。|
|[CWnd::GetDSCCursor](#getdsccursor)|擷取料來源控制項的 DataSource、UserName、Password 和 SQL 屬性所定義之基礎游標的指標。|
|[CWnd::GetDynamicLayout](#getdynamiclayout)|擷取動態配置管理員物件的指標。|
|[CWnd::GetExStyle](#getexstyle)|傳回視窗的延伸樣式。|
|[CWnd::GetFocus](#getfocus)|擷取目前具有輸入焦點的 `CWnd`。|
|[CWnd::GetFont](#getfont)|擷取目前的字型。|
|[CWnd::GetForegroundWindow](#getforegroundwindow)|讓指標回到前景視窗 (使用者目前使用的最上層視窗)。|
|[CWnd::GetIcon](#geticon)|擷取圖示的控制代碼。|
|[CWnd::GetLastActivePopup](#getlastactivepopup)|判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。|
|[CWnd::GetLayeredWindowAttributes](#getlayeredwindowattributes)|擷取分層視窗的不透明和透明色鍵。|
|[CWnd::GetMenu](#getmenu)|擷取指定功能表的指標。|
|[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)|搜尋控制項群組內的下一個 (或上一個) 控制項。|
|[CWnd::GetNextDlgTabItem](#getnextdlgtabitem)|擷取第一個控制項[WS_TABSTOP](styles-used-by-mfc.md#window-styles) （或） 指定的控制項的樣式。|
|[CWnd::GetNextWindow](#getnextwindow)|傳回視窗管理員清單中的下一個 (或上一個) 視窗。|
|[CWnd::GetOleControlSite](#getolecontrolsite)|擷取指定的 ActiveX 控制項的自訂網站。|
|[CWnd::GetOpenClipboardWindow](#getopenclipboardwindow)|擷取目前已開啟剪貼簿的視窗指標。|
|[CWnd::GetOwner](#getowner)|擷取 `CWnd` 擁有者的指標。|
|[CWnd::GetParent](#getparent)|擷取 `CWnd` 的父視窗 (如果有的話)。|
|[CWnd::GetParentFrame](#getparentframe)|擷取 `CWnd` 物件的父框架視窗。|
|[CWnd::GetParentOwner](#getparentowner)|傳回子視窗的父視窗指標。|
|[CWnd::GetProperty](#getproperty)|擷取 ActiveX 控制項屬性。|
|[CWnd::GetRenderTarget](#getrendertarget)|取得與此視窗相關聯的呈現目標。|
|[CWnd::GetSafeHwnd](#getsafehwnd)|傳回`m_hWnd`，則為 NULL 如果**這**指標為 NULL。|
|[CWnd::GetSafeOwner](#getsafeowner)|擷取給定視窗的安全擁有者。|
|[CWnd::GetScrollBarCtrl](#getscrollbarctrl)|傳回一個同層級捲軸控制項。|
|[CWnd::GetScrollBarInfo](#getscrollbarinfo)|擷取所指定之捲軸的相關資訊。|
|[CWnd::GetScrollInfo](#getscrollinfo)|擷取 `SCROLLINFO` 結構維護的捲軸相關資訊。|
|[CWnd::GetScrollLimit](#getscrolllimit)|擷取捲軸的限制。|
|[CWnd::GetScrollPos](#getscrollpos)|擷取捲動方塊的目前位置。|
|[CWnd::GetScrollRange](#getscrollrange)|複製給定捲軸目前的最小和最大捲軸位置。|
|[CWnd::GetStyle](#getstyle)|傳回目前的視窗樣式。|
|[CWnd::GetSystemMenu](#getsystemmenu)|可讓應用程式存取控制功能表以進行複製和修改。|
|[CWnd::GetTitleBarInfo](#gettitlebarinfo)|擷取指定之標題列的相關資訊。|
|[CWnd::GetTopLevelFrame](#gettoplevelframe)|擷取視窗的最上層框架視窗。|
|[CWnd::GetTopLevelOwner](#gettoplevelowner)|擷取最上層視窗。|
|[CWnd::GetTopLevelParent](#gettoplevelparent)|擷取視窗的最上層父代。|
|[CWnd::GetTopWindow](#gettopwindow)|傳回屬於 `CWnd` 的第一個子視窗。|
|[CWnd::GetUpdateRect](#getupdaterect)|擷取完全圍住 `CWnd` 更新區域的最小矩形座標。|
|[CWnd::GetUpdateRgn](#getupdatergn)|擷取 `CWnd` 更新區域。|
|[CWnd::GetWindow](#getwindow)|傳回與此視窗具有指定關聯性的視窗。|
|[CWnd::GetWindowContextHelpId](#getwindowcontexthelpid)|擷取說明內容識別碼。|
|[CWnd::GetWindowDC](#getwindowdc)|擷取整個視窗的顯示內容，包括標題列、功能表和捲軸。|
|[CWnd::GetWindowedChildCount](#getwindowedchildcount)|傳回相關聯子視窗的數目。|
|[CWnd::GetWindowInfo](#getwindowinfo)|傳回視窗的相關資訊。|
|[CWnd::GetWindowlessChildCount](#getwindowlesschildcount)|傳回相關聯的無視窗子視窗數目。|
|[CWnd::GetWindowPlacement](#getwindowplacement)|擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::GetWindowRect](#getwindowrect)|取得 `CWnd` 的螢幕座標。|
|[CWnd::GetWindowRgn](#getwindowrgn)|擷取視窗的視窗區域複本。|
|[CWnd::GetWindowText](#getwindowtext)|傳回視窗文字或標題 (如果有的話)。|
|[CWnd::GetWindowTextLength](#getwindowtextlength)|傳回視窗的文字或標題的長度。|
|[CWnd::HideCaret](#hidecaret)|藉由從顯示畫面移除插入號來隱藏該插入號。|
|[CWnd::HiliteMenuItem](#hilitemenuitem)|反白顯示或從最上層 (功能表列) 的功能表項目中移除反白顯示。|
|[CWnd::HtmlHelp](#htmlhelp)|呼叫以初始化 HTMLHelp 應用程式。|
|[CWnd::Invalidate](#invalidate)|使整個工作區失效。|
|[CWnd::InvalidateRect](#invalidaterect)|將矩形加入至目前的更新區域，使給定矩形內的工作區失效。|
|[CWnd::InvalidateRgn](#invalidatergn)|將區域加入至目前的更新區域，使給定區域內的工作區失效。|
|[CWnd::InvokeHelper](#invokehelper)|叫用 ActiveX 控制項方法或屬性。|
|[CWnd::IsChild](#ischild)|指出 `CWnd` 是子視窗，還是指定視窗的其他直屬下階。|
|[CWnd::IsD2DSupportEnabled](#isd2dsupportenabled)|決定是否啟用 D2D 支援。|
|[CWnd::IsDialogMessage](#isdialogmessage)|判斷指定的訊息是否適用於非強制回應對話方塊，若是則處理它。|
|[CWnd::IsDlgButtonChecked](#isdlgbuttonchecked)|決定是否核取按鈕控制項。|
|[CWnd::IsDynamicLayoutEnabled](#isdynamiclayoutenabled)|決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。|
|[CWnd::IsIconic](#isiconic)|決定是否將 `CWnd` 降到最低 (圖示)。|
|[CWnd::IsTouchWindow](#istouchwindow)|指定 `CWnd` 是否有觸控支援。|
|[CWnd::IsWindowEnabled](#iswindowenabled)|決定是否為滑鼠和鍵盤輸入啟用視窗。|
|[CWnd::IsWindowVisible](#iswindowvisible)|決定視窗是否可見。|
|[CWnd::IsZoomed](#iszoomed)|決定是否將 `CWnd` 最大化。|
|[CWnd::KillTimer](#killtimer)|刪除系統計時器。|
|[CWnd::LockWindowUpdate](#lockwindowupdate)|停用或重新啟用在給定視窗中繪製。|
|[CWnd::MapWindowPoints](#mapwindowpoints)|將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。|
|[CWnd::MessageBox](#messagebox)|建立並顯示視窗，其中包含應用程式提供的訊息和標題。|
|[CWnd::ModifyStyle](#modifystyle)|修改目前的視窗樣式。|
|[CWnd::ModifyStyleEx](#modifystyleex)|修改視窗的延伸樣式。|
|[CWnd::MoveWindow](#movewindow)|變更 `CWnd` 的位置和維度。|
|[CWnd::NotifyWinEvent](#notifywinevent)|表示發生預先定義之事件的系統。|
|[CWnd::OnAmbientProperty](#onambientproperty)|實作環境屬性值。|
|[CWnd::OnDrawIconicThumbnailOrLivePreview](#ondrawiconicthumbnailorlivepreview)|需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。|
|[CWnd::OnHelp](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|
|[CWnd::OnHelpFinder](#onhelpfinder)|處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。|
|[CWnd::OnHelpIndex](#onhelpindex)|處理 ID_HELP_INDEX 命令，並提供預設的說明主題。|
|[CWnd::OnHelpUsing](#onhelpusing)|處理 ID_HELP_USING 命令。|
|[CWnd::OnToolHitTest](#ontoolhittest)|決定一個點是否位於指定工具的週框中並擷取工具的相關資訊。|
|[CWnd::OpenClipboard](#openclipboard)|開啟剪貼簿。 其他應用程式不能修改剪貼簿，直到 Windows [CloseClipboard](/windows/desktop/api/winuser/nf-winuser-closeclipboard)呼叫函式。|
|[CWnd::PaintWindowlessControls](#paintwindowlesscontrols)|在控制項容器上繪製無視窗控制項。|
|[CWnd::PostMessage](#postmessage)|在應用程式佇列中放置訊息，然後傳回，而不需等待視窗處理訊息。|
|[CWnd::PreCreateWindow](#precreatewindow)|在建立附加至此 `CWnd` 物件的 Windows 視窗前呼叫。|
|[CWnd::PreSubclassWindow](#presubclasswindow)|可讓其他必要的子類別發生後再[SubclassWindow](#subclasswindow)呼叫。|
|[CWnd::PreTranslateMessage](#pretranslatemessage)|由 `CWinApp` 使用，可先篩選視窗訊息，再將它們分派至 `TranslateMessage` 和 `DispatchMessage` Windows 函式。|
|[CWnd::Print](#print)|在指定的裝置內容中繪製目前的視窗。|
|[CWnd::PrintClient](#printclient)|在指定的裝置內容中繪製任何視窗 (通常是印表機裝置內容)。|
|[CWnd::PrintWindow](#printwindow)|將視覺視窗複製到指定的裝置內容，通常是印表機 DC。|
|[CWnd::RedrawWindow](#redrawwindow)|更新工作區中指定的矩形或區域。|
|[CWnd::RegisterTouchWindow](#registertouchwindow)|註冊/取消註冊視窗 Windows 觸控支援。|
|[CWnd::ReleaseDC](#releasedc)|釋放用戶端和視窗裝置內容，釋放這些內容供其他應用程式使用。|
|[CWnd::RepositionBars](#repositionbars)|工作區中的重新置放控制列。|
|[CWnd::RunModalLoop](#runmodalloop)|擷取、轉換或分派處於強制回應狀態之視窗的訊息。|
|[CWnd::ScreenToClient](#screentoclient)|將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。|
|[CWnd::ScrollWindow](#scrollwindow)|捲動工作區的內容。|
|[CWnd::ScrollWindowEx](#scrollwindowex)|捲動工作區的內容。 類似於 `ScrollWindow`，但具有額外的功能。|
|[CWnd::SendChildNotifyLastMsg](#sendchildnotifylastmsg)|從父視窗中將通知訊息提供給子視窗，讓子視窗可以處理工作。|
|[CWnd::SendDlgItemMessage](#senddlgitemmessage)|將訊息傳送至指定的控制項。|
|[CWnd::SendMessage](#sendmessage)|傳送訊息給 `CWnd` 物件，在處理訊息後才會傳回。|
|[CWnd::SendMessageToDescendants](#sendmessagetodescendants)|傳送訊息給視窗的所有下階視窗。|
|[CWnd::SendNotifyMessage](#sendnotifymessage)|將指定的訊息傳送至視窗並儘速傳回，視呼叫執行緒是否建立視窗而定。|
|[CWnd::SetActiveWindow](#setactivewindow)|啟用視窗。|
|[CWnd::SetCapture](#setcapture)|導致所有後續滑鼠輸入傳送至 `CWnd`。|
|[CWnd::SetCaretPos](#setcaretpos)|將插入號移動到指定的位置。|
|[CWnd::SetClipboardViewer](#setclipboardviewer)|將 `CWnd` 新增到視窗的鏈結，每當剪貼簿的內容變更時就會通知這些視窗。|
|[CWnd::SetDlgCtrlID](#setdlgctrlid)|設定視窗或視窗的控制項識別碼 (這可以是任何子視窗，而不只是對話方塊中的控制項)。|
|[CWnd::SetDlgItemInt](#setdlgitemint)|將控制項的文字設為表示整數值的字串。|
|[CWnd::SetDlgItemText](#setdlgitemtext)|在指定的對話方塊中設定控制項的標題或文字。|
|[CWnd::SetFocus](#setfocus)|宣告輸入焦點。|
|[CWnd::SetFont](#setfont)|設定目前的字型。|
|[CWnd::SetForegroundWindow](#setforegroundwindow)|將建立視窗的執行緒放置到前景並啟動視窗。|
|[CWnd::SetIcon](#seticon)|將控制代碼設為特定的圖示。|
|[CWnd::SetLayeredWindowAttributes](#setlayeredwindowattributes)|設定分層視窗的不透明和透明色鍵。|
|[CWnd::SetMenu](#setmenu)|將功能表設定為指定的功能表。|
|[CWnd::SetOwner](#setowner)|變更 `CWnd` 的擁有者。|
|[CWnd::SetParent](#setparent)|變更父視窗。|
|[CWnd::SetProperty](#setproperty)|設定 ActiveX 控制項屬性。|
|[CWnd::SetRedraw](#setredraw)|允許重新繪製 `CWnd` 中的變更，或防止重新繪製進行變更。|
|[CWnd::SetScrollInfo](#setscrollinfo)|設定捲軸的相關資訊。|
|[CWnd::SetScrollPos](#setscrollpos)|設定捲動方塊的目前位置，而且如果指定，會重新繪製捲軸以反映新位置。|
|[CWnd::SetScrollRange](#setscrollrange)|設定給定捲軸的最小和最大位置值。|
|[CWnd::SetTimer](#settimer)|安裝系統計時器傳送[WM_TIMER](#ontimer)訊息時觸發。|
|[CWnd::SetWindowContextHelpId](#setwindowcontexthelpid)|設定說明內容識別碼。|
|[CWnd::SetWindowPlacement](#setwindowplacement)|設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::SetWindowPos](#setwindowpos)|變更大小、位置和子系順序、快顯視窗，和最上層視窗。|
|[CWnd::SetWindowRgn](#setwindowrgn)|設定視窗的區域。|
|[CWnd::SetWindowText](#setwindowtext)|將視窗文字或標題 (如果有的話) 設為指定的文字。|
|[CWnd::ShowCaret](#showcaret)|在畫面上插入號的目前位置上顯示插入號。 顯示後，插入號會開始自動閃爍。|
|[CWnd::ShowOwnedPopups](#showownedpopups)|顯示或隱藏視窗擁有的所有快顯視窗。|
|[CWnd::ShowScrollBar](#showscrollbar)|顯示或隱藏捲軸。|
|[CWnd::ShowWindow](#showwindow)|顯示或隱藏視窗。|
|[CWnd::SubclassDlgItem](#subclassdlgitem)|將 Windows 控制項附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::SubclassWindow](#subclasswindow)|將視窗附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::UnlockWindowUpdate](#unlockwindowupdate)|解除鎖定已使用 `CWnd::LockWindowUpdate` 鎖定的視窗。|
|[CWnd::UnsubclassWindow](#unsubclasswindow)|卸離視窗從`CWnd`物件|
|[CWnd::UpdateData](#updatedata)|從對話方塊中初始化或擷取資料。|
|[CWnd::UpdateDialogControls](#updatedialogcontrols)|呼叫以更新對話方塊按鈕和其他控制項的狀態。|
|[CWnd::UpdateLayeredWindow](#updatelayeredwindow)|更新分層視窗的位置、大小、形狀、內容和透明度。|
|[CWnd::UpdateWindow](#updatewindow)|更新工作區。|
|[CWnd::ValidateRect](#validaterect)|從目前的更新區域中移除矩形，驗證給定矩形內的工作區。|
|[CWnd::ValidateRgn](#validatergn)|從目前的更新區域中移除區域，驗證給定區域內的工作區。|
|[CWnd::WindowFromPoint](#windowfrompoint)|識別包含指定點的視窗。|
|[CWnd::WinHelp](#winhelp)|呼叫以初始化 WinHelp 應用程式。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[CWnd::Default](#default)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DefWindowProc](#defwindowproc)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DoDataExchange](#dodataexchange)|適用於對話方塊資料交換和驗證。 由 `UpdateData` 呼叫。|
|[CWnd::GetCurrentMessage](#getcurrentmessage)|傳回此視窗目前正在處理的訊息指標。 應該只呼叫時`On`*訊息*訊息處理常式成員函式。|
|[CWnd::InitDynamicLayout](#initdynamiclayout)|由架構呼叫以初始化視窗的動態配置。|
|[CWnd::LoadDynamicLayoutResource](#loaddynamiclayoutresource)|從資源檔載入動態配置資訊。|
|[CWnd::OnActivate](#onactivate)|當 `CWnd` 啟動或停用時呼叫。|
|[CWnd::OnActivateApp](#onactivateapp)|當應用程式即將啟動或停用時呼叫。|
|[CWnd::OnAppCommand](#onappcommand)|當使用者產生應用程式命令事件時呼叫。|
|[CWnd::OnAskCbFormatName](#onaskcbformatname)|當剪貼簿擁有者將顯示剪貼簿內容時，由剪貼簿檢視器應用程式呼叫。|
|[CWnd::OnCancelMode](#oncancelmode)|呼叫以讓 `CWnd` 取消任何內部的模式，例如滑鼠捕捉。|
|[CWnd::OnCaptureChanged](#oncapturechanged)|將訊息傳送至正失去滑鼠捕捉的視窗。|
|[CWnd::OnChangeCbChain](#onchangecbchain)|通知正在從鏈結中移除指定的視窗。|
|[CWnd::OnChangeUIState](#onchangeuistate)|應變更使用者介面 (UI) 狀態時呼叫。|
|[CWnd::OnChar](#onchar)|按鍵轉譯為非系統字元時呼叫。|
|[CWnd::OnCharToItem](#onchartoitem)|呼叫具有的子清單方塊[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式，以回應[WM_CHAR](#onchar)訊息。|
|[CWnd::OnChildActivate](#onchildactivate)|每當 `CWnd` 的大小或位置變更，或 `CWnd` 已啟動時，針對多重文件介面 (MDI) 子視窗呼叫。|
|[CWnd::OnChildNotify](#onchildnotify)|由父視窗呼叫，讓通知控制項有機會回應控制項通知。|
|[CWnd::OnClipboardUpdate](#onclipboardupdate)|於剪貼簿內容已變更時呼叫。|
|[CWnd::OnClose](#onclose)|呼叫以表示 `CWnd` 應該關閉。|
|[CWnd::OnColorizationColorChanged](#oncolorizationcolorchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnCommand](#oncommand)|當使用者選取命令時呼叫。|
|[CWnd::OnCompacting](#oncompacting)|當 Windows 偵測到系統記憶體過低時呼叫。|
|[CWnd::OnCompareItem](#oncompareitem)|呼叫以判斷子排序之主控描繪的下拉式方塊或清單方塊中新項目的相對位置。|
|[CWnd::OnCompositionChanged](#oncompositionchanged)|當桌面視窗管理員 (DWM) 組合啟用或停用時，為所有最上層視窗呼叫。|
|[CWnd::OnContextMenu](#oncontextmenu)|當使用者在視窗中按一下滑鼠右鍵時呼叫。|
|[CWnd::OnCopyData](#oncopydata)|在應用程式之間複製資料。|
|[CWnd::OnCreate](#oncreate)|在視窗建立過程中呼叫。|
|[CWnd::OnCtlColor](#onctlcolor)|即將繪製控制項時，如果`CWnd` 是控制項的父代則呼叫。|
|[CWnd::OnDeadChar](#ondeadchar)|當按鍵轉譯為非系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnDeleteItem](#ondeleteitem)|當主控描繪子清單方塊或下拉式方塊損毀，或從控制項移除項目時呼叫。|
|[CWnd::OnDestroy](#ondestroy)|          `CWnd` 正在損毀時呼叫。|
|[CWnd::OnDestroyClipboard](#ondestroyclipboard)|當透過呼叫 Windows 清空剪貼簿時，呼叫[EmptyClipboard](/windows/desktop/api/winuser/nf-winuser-emptyclipboard)函式。|
|[CWnd::OnDeviceChange](#ondevicechange)|將裝置或電腦的硬體組態變更通知應用程式或裝置驅動程式。|
|[CWnd::OnDevModeChange](#ondevmodechange)|當使用者變更裝置模式設定時，針對所有最上層視窗呼叫。|
|[CWnd::OnDrawClipboard](#ondrawclipboard)|於剪貼簿內容變更時呼叫。|
|[CWnd::OnDrawItem](#ondrawitem)|主控描繪子按鈕控制項、下拉式方塊控制項、清單方塊控制項或功能表的視覺外觀必須繪製時呼叫。|
|[CWnd::OnDropFiles](#ondropfiles)|當使用者在視窗 (已本身註冊為捨棄檔案的收件者) 上放開滑鼠按鈕時呼叫。|
|[CWnd::OnEnable](#onenable)|啟用或停用 `CWnd` 時呼叫。|
|[CWnd::OnEndSession](#onendsession)|當工作階段正在結束時呼叫。|
|[CWnd::OnEnterIdle](#onenteridle)|呼叫此函式，可將強制回應對話方塊或功能表正在進入閒置狀態的訊息，通知應用程式的主視窗程序。|
|[CWnd::OnEnterMenuLoop](#onentermenuloop)|已進入功能表強制回應迴圈時呼叫。|
|[CWnd::OnEnterSizeMove](#onentersizemove)|在受影響的視窗進入移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnEraseBkgnd](#onerasebkgnd)|視窗背景需要清除時呼叫。|
|[CWnd::OnExitMenuLoop](#onexitmenuloop)|已結束功能表強制回應迴圈時呼叫。|
|[CWnd::OnExitSizeMove](#onexitsizemove)|在受影響的視窗結束移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnFontChange](#onfontchange)|字型資源的集區變更時呼叫。|
|[CWnd::OnGetDlgCode](#ongetdlgcode)|呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。|
|[CWnd::OnGetMinMaxInfo](#ongetminmaxinfo)|每當 Windows 必須知道最大化的位置或維度，或最小或最大的追蹤大小時呼叫。|
|[CWnd::OnHelpInfo](#onhelpinfo)|當使用者按下 F1 鍵時，由架構呼叫。|
|[CWnd::OnHotKey](#onhotkey)|當使用者按下全系統的便捷鍵時呼叫。|
|[CWnd::OnHScroll](#onhscroll)|當使用者按一下 `CWnd` 的水平捲軸時呼叫。|
|[CWnd::OnHScrollClipboard](#onhscrollclipboard)|當剪貼簿擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnIconEraseBkgnd](#oniconerasebkgnd)|當 `CWnd` 減到最小 (圖示)，且必須先填入圖示的背景再繪製圖示時呼叫。|
|[CWnd::OnInitMenu](#oninitmenu)|當功能表即將變成現用時呼叫。|
|[CWnd::OnInitMenuPopup](#oninitmenupopup)|當快顯功能表即將變成現用時呼叫。|
|[CWnd::OnInputDeviceChange](#oninputdevicechange)|從系統中新增或移除 I/O 裝置時呼叫。|
|[CWnd::OnInputLangChange](#oninputlangchange)|在應用程式的輸入語言變更後呼叫。|
|[CWnd::OnInputLangChangeRequest](#oninputlangchangerequest)|當使用者選擇新的輸入語言時呼叫。|
|[CWnd::OnKeyDown](#onkeydown)|按下非系統鍵時呼叫。|
|[CWnd::OnKeyUp](#onkeyup)|放開非系統鍵時呼叫。|
|[CWnd::OnKillFocus](#onkillfocus)|在 `CWnd` 遺失輸入焦點前立即呼叫。|
|[CWnd::OnLButtonDblClk](#onlbuttondblclk)|當使用者按兩下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonDown](#onlbuttondown)|當使用者按下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonUp](#onlbuttonup)|當使用者放開滑鼠左鍵時呼叫。|
|[CWnd::OnMButtonDblClk](#onmbuttondblclk)|當使用者按兩下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonDown](#onmbuttondown)|當使用者按下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonUp](#onmbuttonup)|當使用者放開滑鼠中鍵時呼叫。|
|[CWnd::OnMDIActivate](#onmdiactivate)|當 MDI 子視窗啟用或停用時呼叫。|
|[CWnd::OnMeasureItem](#onmeasureitem)|建立控制項時，針對主控描繪子下拉式方塊、清單方塊或功能表項目呼叫。 `CWnd` 會將控制項維度通知 Windows。|
|[CWnd::OnMenuChar](#onmenuchar)|當使用者按下功能表的助憶鍵字元，且該字元不符合目前功能表中任何預先定義的助憶鍵時呼叫。|
|[CWnd::OnMenuDrag](#onmenudrag)|當使用者開始拖曳功能表項目時呼叫。|
|[CWnd::OnMenuGetObject](#onmenugetobject)|當滑鼠游標進入功能表項目，或從項目中央移到項目上方或下方時呼叫。|
|[CWnd::OnMenuRButtonUp](#onmenurbuttonup)|當游標位於功能表項目上，而使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnMenuSelect](#onmenuselect)|當使用者選取功能表項目時呼叫。|
|[CWnd::OnMouseActivate](#onmouseactivate)|當游標處於非使用中視窗，且使用者按下滑鼠按鈕時呼叫。|
|[CWnd::OnMouseHover](#onmousehover)|當游標停留在先前呼叫中指定的時間週期 視窗的工作區時呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。|
|[CWnd::OnMouseHWheel](#onmousehwheel)|當目前的視窗由桌面視窗管理員 (DWM) 組成，且該視窗最大化時呼叫。|
|[CWnd::OnMouseLeave](#onmouseleave)|當游標離開之前的呼叫中所指定視窗的工作區時呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。|
|[CWnd::OnMouseMove](#onmousemove)|當滑鼠游標移動時呼叫。|
|[CWnd::OnMouseWheel](#onmousewheel)|當使用者旋轉滑鼠滾輪時呼叫。 使用 Windows NT 4.0 訊息處理。|
|[CWnd::OnMove](#onmove)|在 `CWnd` 的位置變更後呼叫。|
|[CWnd::OnMoving](#onmoving)|指出使用者正在移動 `CWnd` 物件。|
|[CWnd::OnNcActivate](#onncactivate)|當非工作區需要變更以表示作用中或非作用中狀態時呼叫。|
|[CWnd::OnNcCalcSize](#onnccalcsize)|需要計算工作區的大小和位置時呼叫。|
|[CWnd::OnNcCreate](#onnccreate)|之前呼叫[OnCreate](#oncreate)建立非工作區時。|
|[CWnd::OnNcDestroy](#onncdestroy)|當非工作區正在損毀時呼叫。|
|[CWnd::OnNcHitTest](#onnchittest)|每次移動滑鼠時，如果 `CWnd` 包含游標，或已使用 `SetCapture` 擷取滑鼠輸入時呼叫。|
|[CWnd::OnNcLButtonDblClk](#onnclbuttondblclk)|當使用者按兩下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonDown](#onnclbuttondown)|當使用者按下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonUp](#onnclbuttonup)|當使用者放開滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDblClk](#onncmbuttondblclk)|當使用者按兩下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDown](#onncmbuttondown)|當使用者按下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonUp](#onncmbuttonup)|當使用者放開滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMouseHover](#onncmousehover)|當游標停留在先前呼叫中指定的時間週期 視窗的非工作區時呼叫[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。|
|[CWnd::OnNcMouseLeave](#onncmouseleave)|當游標離開之前的呼叫中所指定視窗的非工作區時，架構會呼叫此成員函式[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。|
|[CWnd::OnNcMouseMove](#onncmousemove)|當游標在 `CWnd` 的非工作區內移動時呼叫。|
|[CWnd::OnNcPaint](#onncpaint)|當非工作區需要繪製時呼叫。|
|[CWnd::OnNcRButtonDblClk](#onncrbuttondblclk)|當使用者按兩下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonDown](#onncrbuttondown)|當使用者按下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonUp](#onncrbuttonup)|當使用者放開滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRenderingChanged](#onncrenderingchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnNcXButtonDblClk](#onncxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonDown](#onncxbuttondown)|當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonUp](#onncxbuttonup)|當使用者放開滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNextMenu](#onnextmenu)|當使用向右鍵或向左鍵切換功能表列和系統功能表時呼叫。|
|[CWnd::OnNotify](#onnotify)|由架構呼叫，將其中一個控制項已發生的事件，或控制項需要資訊等狀況通知父視窗。|
|[CWnd::OnNotifyFormat](#onnotifyformat)|呼叫以決定目前視窗的 WM_NOTIFY 通知訊息中是否接受 ANSI 或 Unicode 結構。|
|[CWnd::OnPaint](#onpaint)|呼叫以重新繪製視窗的一部份。|
|[CWnd::OnPaintClipboard](#onpaintclipboard)|當需要重新繪製剪貼簿檢視器的工作區時呼叫。|
|[CWnd::OnPaletteChanged](#onpalettechanged)|呼叫以允許使用調色盤的視窗調整其邏輯色板的大小，並更新其工作區。|
|[CWnd::OnPaletteIsChanging](#onpaletteischanging)|當應用程式即將實現其邏輯色板時通知其他應用程式。|
|[CWnd::OnParentNotify](#onparentnotify)|建立或終結子視窗時，或當使用者按一下滑鼠按鈕，而游標移至子視窗上方時，進行呼叫。|
|[CWnd::OnPowerBroadcast](#onpowerbroadcast)|電源管理事件發生時呼叫。|
|[CWnd::OnQueryDragIcon](#onquerydragicon)|最小化 (圖示化) `CWnd` 即將由使用者拖曳時呼叫。|
|[CWnd::OnQueryEndSession](#onqueryendsession)|當使用者選擇結束 Windows 工作階段時呼叫。|
|[CWnd::OnQueryNewPalette](#onquerynewpalette)|通知 `CWnd` 即將接收輸入焦點。|
|[CWnd::OnQueryOpen](#onqueryopen)|當 `CWnd` 是圖示，且使用者要求開啟圖示時呼叫。|
|[CWnd::OnQueryUIState](#onqueryuistate)|呼叫以擷取視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnRawInput](#onrawinput)|當目前視窗取得原始輸入時呼叫。|
|[CWnd::OnRButtonDblClk](#onrbuttondblclk)|當使用者按兩下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonDown](#onrbuttondown)|當使用者按下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonUp](#onrbuttonup)|當使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnRenderAllFormats](#onrenderallformats)|當擁有者應用程式正在被破壞，而且需要呈現其所有格式時呼叫。|
|[CWnd::OnRenderFormat](#onrenderformat)|需要呈現具有延遲轉譯需求的特定格式時，針對剪貼簿擁有者呼叫。|
|[CWnd::OnSessionChange](#onsessionchange)|呼叫以將工作階段狀態的變更通知應用程式。|
|[CWnd::OnSetCursor](#onsetcursor)|如果不擷取滑鼠輸入，而且滑鼠導致游標在視窗內移動，則呼叫。|
|[CWnd::OnSetFocus](#onsetfocus)|在 `CWnd` 取得輸入焦點後呼叫。|
|[CWnd::OnSettingChange](#onsettingchange)|當 Win32 `SystemParametersInfo` 函式變更整個系統的設定時呼叫。|
|[CWnd::OnShowWindow](#onshowwindow)|當 `CWnd` 要隱藏或顯示時呼叫。|
|[CWnd::OnSize](#onsize)|在 `CWnd` 大小變更後呼叫。|
|[CWnd::OnSizeClipboard](#onsizeclipboard)|當剪貼簿檢視器視窗中的工作區大小變更後呼叫。|
|[CWnd::OnSizing](#onsizing)|表示使用者正在重新調整矩形的大小。|
|[CWnd::OnSpoolerStatus](#onspoolerstatus)|每當加入工作或從列印管理員佇列中移除工作時，從列印管理員呼叫。|
|[CWnd::OnStyleChanged](#onstylechanged)|指出[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) Windows 函式已變更一或多個視窗的樣式。|
|[CWnd::OnStyleChanging](#onstylechanging)|指出[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) Windows 函式即將變更一或多個視窗的樣式。|
|[CWnd::OnSysChar](#onsyschar)|按鍵轉譯為系統字元時呼叫。|
|[CWnd::OnSysColorChange](#onsyscolorchange)|當系統色彩設定中進行變更時，為所有最上層視窗呼叫。|
|[CWnd::OnSysCommand](#onsyscommand)|當使用者從 [控制] 功能表中選取命令時，或在使用者選取 [最大化] 或 [最小化] 按鈕時呼叫。|
|[CWnd::OnSysDeadChar](#onsysdeadchar)|當按鍵轉譯為系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnSysKeyDown](#onsyskeydown)|當使用者按住 ALT 鍵，然後按下另一個按鍵時呼叫。|
|[CWnd::OnSysKeyUp](#onsyskeyup)|當使用者在按住 ALT 鍵時放開按下的按鍵時呼叫。|
|[CWnd::OnTCard](#ontcard)|使用者按一下可設計的按鈕時呼叫。|
|[CWnd::OnTimeChange](#ontimechange)|在系統時間變更後，針對所有最上層視窗呼叫。|
|[CWnd::OnTimer](#ontimer)|指定在每個間隔之後呼叫[SetTimer](#settimer)。|
|[CWnd::OnTouchInput](#ontouchinput)|處理來自 Windows 觸控的單一輸入。|
|[CWnd::OnTouchInputs](#ontouchinputs)|處理來自 Windows 觸控的輸入。|
|[CWnd::OnUniChar](#onunichar)|按下按鍵時呼叫。 也就是目前的視窗擁有鍵盤焦點和[WM_KEYDOWN](/windows/desktop/inputdev/wm-keydown)訊息轉譯[TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage)函式。|
|[CWnd::OnUnInitMenuPopup](#onuninitmenupopup)|於下拉式功能表或子功能表被終結時呼叫。|
|[CWnd::OnUpdateUIState](#onupdateuistate)|呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnUserChanged](#onuserchanged)|在使用者登入或登出後呼叫。|
|[CWnd::OnVKeyToItem](#onvkeytoitem)|呼叫所擁有的清單方塊`CWnd`來回[WM_KEYDOWN](#onkeydown)訊息。|
|[CWnd::OnVScroll](#onvscroll)|當使用者按一下視窗的垂直捲軸時呼叫。|
|[CWnd::OnVScrollClipboard](#onvscrollclipboard)|當擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnWindowPosChanged](#onwindowposchanged)|呼叫時呼叫的結果改變大小、 位置或疊置順序[SetWindowPos](#setwindowpos)或另一個視窗管理函式。|
|[CWnd::OnWindowPosChanging](#onwindowposchanging)|當大小、 位置或疊置順序即將因呼叫而變更時呼叫[SetWindowPos](#setwindowpos)或另一個視窗管理函式。|
|[CWnd::OnWinIniChange](#onwininichange)|在 Windows 初始化檔案 (WIN.INI) 變更後，針所有最上層視窗呼叫。|
|[CWnd::OnWndMsg](#onwndmsg)|指出是否已處理視窗訊息。|
|[CWnd::OnXButtonDblClk](#onxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonDown](#onxbuttondown)|當使用者按下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonUp](#onxbuttonup)|當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::PostNcDestroy](#postncdestroy)|預設會呼叫此虛擬函式[OnNcDestroy](#onncdestroy)函式之後終結視窗。|
|[CWnd::ReflectChildNotify](#reflectchildnotify)|將訊息反映至其來源的 Helper 函式。|
|[CWnd::ReflectLastMsg](#reflectlastmsg)|將最後一個訊息反映到子視窗。|
|[CWnd::ResizeDynamicLayout](#resizedynamiclayout)|如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。|
|[CWnd::WindowProc](#windowproc)|提供 `CWnd` 的視窗程序。 透過訊息對應的預設分派訊息。|

### <a name="public-operators"></a>公用運算子

|名稱|描述|
|----------|-----------------|
|[HWND cwnd:: Operator](#operator_hwnd)|呼叫以取得視窗的控制代碼。|
|[CWnd::operator !=](#operator_neq)|判斷視窗是否不相同的視窗控制代碼[m_hWnd](#m_hwnd)。|
|[CWnd::operator ==](#operator_eq_eq)|判斷視窗是否與視窗控制代碼是相同[m_hWnd](#m_hwnd)。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CWnd::m_hWnd](#m_hwnd)|表示附加至這個 HWND `CWnd`。|

## <a name="remarks"></a>備註

          `CWnd` 物件不同於 Windows 視窗，但兩者緊密連結。           `CWnd` 物件是由 `CWnd` 建構函式和解構函式所建立或終結。 [Windows] 視窗中，相反地，是 Windows 所建立的內部資料結構`Create`成員函式和終結`CWnd`虛擬解構函式。 [DestroyWindow](#destroywindow)函式會終結 Windows 視窗而不會終結物件。

`CWnd`類別和訊息對應機制會隱藏`WndProc`函式。 透過適當的訊息對應會自動路由傳送連入的 Windows 通知訊息**上**<em>訊息</em>`CWnd`成員函式。 您覆寫**上**<em>訊息</em>成員函式，以處理成員的衍生類別中的特定訊息。

          `CWnd` 類別也可讓您建立應用程式的 Windows 子視窗。 自 `CWnd` 衍生類別，然後將成員變數加入至衍生類別以儲存應用程式的特定資料。 實作訊息處理常式成員函式，和衍生類別中對應的訊息，以指定訊息被導向至視窗時會發生什麼事。

您在兩個步驟中建立子視窗。 首先，呼叫建構函式`CWnd`來建構`CWnd`物件，然後呼叫[建立](#create)成員函式，來建立子視窗，並將其附加至`CWnd`物件。

當使用者終止子視窗時，摧毀 `CWnd` 物件，或呼叫 `DestroyWindow` 成員函式來移除視窗並摧毀其資料結構。

在 Microsoft Foundation 類別庫中，會自 `CWnd` 衍生進一步類別以提供特定的視窗類型。 其中許多類別，包括[CFrameWnd](../../mfc/reference/cframewnd-class.md)， [CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)， [CMDIChildWnd](../../mfc/reference/cmdichildwnd-class.md)， [CView](../../mfc/reference/cview-class.md)，和[CDialog](../../mfc/reference/cdialog-class.md)，專為進一步衍生。 控制項類別衍生自`CWnd`，這類[CButton](../../mfc/reference/cbutton-class.md)、 可以直接使用或用於進一步衍生的類別。

如需有關使用`CWnd`，請參閱 <<c2> [ 框架 Windows](../../mfc/frame-windows.md)並[視窗物件](../../mfc/window-objects.md)。

## <a name="inheritance-hierarchy"></a>繼承階層

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

`CWnd`

## <a name="requirements"></a>需求

**標題:** afxwin.h

##  <a name="accdodefaultaction"></a>  CWnd::accDoDefaultAction

由架構呼叫以執行物件的預設動作。

```
virtual HRESULT accDoDefaultAction(VARIANT varChild);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要叫用的預設動作為物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （於執行物件的預設動作） 或子系 ID （若要執行的其中一個物件的子元素的預設動作）。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::accDoDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生的類別，以執行您的物件預設動作。 如需詳細資訊，請參閱 < [IAccessible::accDoDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction) Windows SDK 中。

##  <a name="acchittest"></a>  CWnd::accHitTest

由架構呼叫以擷取畫面中給定點的子項目或子物件。

```
virtual HRESULT accHitTest(
    long xLeft,
    long yTop,
    VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*xLeft*<br/>
X 座標的點来進行點擊測試 （以螢幕為單位）。

*yTop*<br/>
Y 座標的點来進行點擊測試 （以螢幕為單位）。

*pvarChild*<br/>
接收到的資訊識別所指定的點物件*xLeft*並*yTop*。 請參閱*pvarID*中[IAccessible::accHitTest](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-acchittest) Windows SDK 中。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::accHitTest`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::accHitTest](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-acchittest) Windows SDK 中。

##  <a name="acclocation"></a>  CWnd::accLocation

由架構呼叫以擷取指定物件目前畫面的位置。

```
virtual HRESULT accLocation(
    long* pxLeft,
    long* pyTop,
    long* pcxWidth,
    long* pcyHeight,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*pxLeft*<br/>
接收的物件 （以螢幕為單位） 的左上角的 x 座標。

*pyTop*<br/>
接收的物件 （以螢幕為單位） 的左上角的 y 座標。

*pcxWidth*<br/>
接收物件 （以螢幕為單位） 的寬度。

*pcyHeight*<br/>
接收物件 （以螢幕為單位） 的高度。

*varChild*<br/>
指定是否要擷取的位置是物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::accLocation`Windows SDK 中。

### <a name="remarks"></a>備註

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱`IAccessible::accLocation`Windows SDK 中。

##  <a name="accnavigate"></a>  CWnd::accNavigate

由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。

```
virtual HRESULT accNavigate(
    long navDir,
    VARIANT varStart,
    VARIANT* pvarEndUpAt);
```

### <a name="parameters"></a>參數

*navDir*<br/>
指定要巡覽的方向。 請參閱*navDir*中[IAccessible::accNavigate](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accnavigate) Windows SDK 中。

*varStart*<br/>
指定在開始物件。 請參閱*varStart*在`IAccessible::accNavigate`Windows SDK 中。

*pvarEndUpAt*<br/>
收到目的地使用者介面物件的相關資訊。 請參閱*pvarEnd*在`IAccessible::accNavigate`Windows SDK 中。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::accNavigate`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::accNavigate](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accnavigate) Windows SDK 中。

##  <a name="accselect"></a>  CWnd::accSelect

由架構呼叫以修改選取或移動指定物件的鍵盤焦點。

```
virtual HRESULT accSelect(
    long flagsSelect,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*flagsSelect*<br/>
指定如何變更目前的選取範圍或焦點。 請參閱*flagsSelect*中[IAccessible::accSelect](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accselect) Windows SDK 中。

*varChild*<br/>
指定要選取的物件。 這個參數可以是 CHILDID_SELF （若要選取的物件本身） 或 （若要選取其中一個物件的子系） 的子系識別碼。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::accSelect`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::accSelect](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-accselect) Windows SDK 中。

##  <a name="animatewindow"></a>  CWnd::AnimateWindow

會產生特殊效果時顯示或隱藏視窗。

```
BOOL AnimateWindow(
    DWORD dwTime,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*dwTime*<br/>
指定會播放動畫，以毫秒為單位的時間長度。 一般而言，動畫會需要 200 毫秒就能播放。

*dwFlags*<br/>
指定動畫的類型。 如需可能值的完整清單，請參閱 < [AnimateWindow](/windows/desktop/api/winuser/nf-winuser-animatewindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[AnimateWindow](/windows/desktop/api/winuser/nf-winuser-animatewindow)、 Windows SDK 中所述。

##  <a name="arrangeiconicwindows"></a>  CWnd::ArrangeIconicWindows

排列所有最小化 (圖示) 子視窗。

```
UINT ArrangeIconicWindows();
```

### <a name="return-value"></a>傳回值

如果成功，函式的圖示的一個資料列的高度否則為 0。

### <a name="remarks"></a>備註

此成員函式也會排列在桌面的視窗中，涵蓋整個畫面的圖示。 [GetDesktopWindow](#getdesktopwindow)成員函式會擷取桌面視窗物件的指標。

若要排列在 MDI 用戶端視窗圖示的 MDI 子視窗，呼叫[CMDIFrameWnd::MDIIconArrange](../../mfc/reference/cmdiframewnd-class.md#mdiiconarrange)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#66](../../mfc/reference/codesnippet/cpp/cwnd-class_1.cpp)]

##  <a name="attach"></a>  CWnd::Attach

將 Windows 視窗來附加`CWnd`物件。

```
BOOL Attach(HWND hWndNew);
```

### <a name="parameters"></a>參數

*hWndNew*<br/>
指定 Windows 視窗的控制代碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

此範例示範如何使用附加和中斷連結對應到 MDI 用戶端視窗。

[!code-cpp[NVC_MFCWindowing#67](../../mfc/reference/codesnippet/cpp/cwnd-class_2.h)]

[!code-cpp[NVC_MFCWindowing#68](../../mfc/reference/codesnippet/cpp/cwnd-class_3.cpp)]

[!code-cpp[NVC_MFCWindowing#69](../../mfc/reference/codesnippet/cpp/cwnd-class_4.cpp)]

##  <a name="beginmodalstate"></a>  CWnd::BeginModalState

呼叫此成員函式以製作框架視窗強制回應。

```
virtual void BeginModalState();
```

##  <a name="beginpaint"></a>  CWnd::BeginPaint

準備`CWnd`繪製的填滿`PAINTSTRUCT`繪製的相關資訊的資料結構。

```
CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向[PAINTSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagpaintstruct)接收繪製資訊的結構。

### <a name="return-value"></a>傳回值

識別的裝置內容`CWnd`。 指標可能是暫時性的不應超出的範圍儲存[EndPaint](#endpaint)。

### <a name="remarks"></a>備註

[小畫家] 結構會包含具有最小的矩形完全圍住更新區域和旗標，指定是否已清除的背景的矩形資料結構。

更新區域由設定[Invalidate](#invalidate)， [InvalidateRect](#invalidaterect)，或[InvalidateRgn](#invalidatergn)成員函式，並由系統調整它的大小之後，移動、 建立、 捲動時，或執行會影響用戶端區域的任何其他作業。 如果更新區域已標示為要清除`BeginPaint`傳送[WM_ONERASEBKGND](#onerasebkgnd)訊息。

請勿呼叫`BeginPaint`成員函式除了以回應[WM_PAINT](#onpaint)訊息。 每次呼叫`BeginPaint`成員函式必須呼叫[EndPaint](#endpaint)成員函式。 如果插入號位於要繪製的區域`BeginPaint`成員函式，自動隱藏插入號，以防止它被清除。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#70](../../mfc/reference/codesnippet/cpp/cwnd-class_5.cpp)]

##  <a name="binddefaultproperty"></a>  CWnd::BindDefaultProperty

將呼叫物件的預設簡單繫結的屬性 （例如編輯控制項），做為標記類型程式庫中的繫結至基礎資料來源控制項的資料來源、 使用者名稱、 密碼和 SQL 屬性所定義的資料指標。

```
void BindDefaultProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    LPCTSTR szFieldName,
    CWnd* pDSCWnd);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
指定要繫結至資料來源控制項的資料繫結控制項屬性的 DISPID。

*vtProp*<br/>
指定要繫結屬性的型別 — 比方說，VT_BSTR、 VT_VARIANT、 等等。

*szFieldName*<br/>
指定資料來源控制項，此屬性會繫結所提供的資料指標中的資料行的名稱。

*pDSCWnd*<br/>
指向視窗屬性會繫結該主機資料來源控制項。 呼叫`GetDlgItem`網域控制站的主視窗的資源識別碼，擷取這個指標。

### <a name="remarks"></a>備註

`CWnd`呼叫此函式的物件必須是資料繫結控制項。

### <a name="example"></a>範例

`BindDefaultProperty` 可能用於下列內容：

[!code-cpp[NVC_MFC_AxDataBinding#2](../../mfc/reference/codesnippet/cpp/cwnd-class_7.cpp)]

##  <a name="bindproperty"></a>  CWnd::BindProperty

將資料繫結控制項 （例如方格控制項） 上的游標繫結屬性繫結至資料來源控制項，並註冊該關聯性與 MFC 繫結管理員。

```
void BindProperty(
    DISPID dwDispId,
    CWnd* pWndDSC);
```

### <a name="parameters"></a>參數

*dwDispId*<br/>
指定要繫結至資料來源控制項的資料繫結控制項屬性的 DISPID。

*pWndDSC*<br/>
指向視窗屬性會繫結該主機資料來源控制項。 呼叫`GetDlgItem`網域控制站的主視窗的資源識別碼，擷取這個指標。

### <a name="remarks"></a>備註

`CWnd`呼叫此函式的物件必須是資料繫結控制項。

### <a name="example"></a>範例

`BindProperty` 可能用於下列內容：

[!code-cpp[NVC_MFC_AxDataBinding#4](../../mfc/reference/codesnippet/cpp/cwnd-class_9.cpp)]

##  <a name="bringwindowtotop"></a>  CWnd::BringWindowToTop

將 `CWnd` 帶到重疊視窗堆疊的最上層。

```
void BringWindowToTop();
```

### <a name="remarks"></a>備註

此外，`BringWindowToTop` 會啟用快顯、最上層和 MDI 子視窗。 需使用 `BringWindowToTop` 成員函式，才能顯示出重疊視窗部分或完全遮住的視窗。

此函式只會呼叫 Win32 [BringWindowToTop](/windows/desktop/api/winuser/nf-winuser-bringwindowtotop)函式。 呼叫[SetWindowPos](#setwindowpos)函式來變更視窗的疊置順序位置。           `BringWindowToTop` 函式不會將視窗樣式變更為最上層視窗。 如需詳細資訊，請參閱[between HWND_TOP 和 hwnd_topmost 有何不同的差異為何](https://devblogs.microsoft.com/oldnewthing/?p=33263)

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#71](../../mfc/reference/codesnippet/cpp/cwnd-class_10.cpp)]

##  <a name="calcwindowrect"></a>  CWnd::CalcWindowRect

計算視窗矩形可以包含指定的用戶端矩形。

```
virtual void CalcWindowRect(
    LPRECT lpClientRect,
    UINT nAdjustType = adjustBorder);
```

### <a name="parameters"></a>參數

*lpClientRect*<br/>
[in、 out]矩形結構的指標。 輸入時，此結構會包含用戶端矩形。 方法完成之後，此結構會包含可包含指定的用戶端矩形視窗矩形。

*nAdjustType*<br/>
[in]使用 `CWnd::adjustBorder`來計算視窗座標，而不需要 WS_EX_CLIENTEDGE 樣式; 否則，請使用`CWnd::adjustOutside`。

### <a name="remarks"></a>備註

計算的視窗矩形的大小不包括功能表列的空間。

如需詳細的使用限制，請參閱 < [AdjustWindowRectEx](/windows/desktop/api/winuser/nf-winuser-adjustwindowrectex)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#72](../../mfc/reference/codesnippet/cpp/cwnd-class_11.cpp)]

##  <a name="canceltooltips"></a>  CWnd::CancelToolTips

呼叫此成員函式，若要從螢幕移除工具提示，如果目前顯示工具提示。

```
static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
```

### <a name="parameters"></a>參數

*bKeys*<br/>
TRUE 表示取消工具提示時按下按鍵且設為預設值; 的狀態列文字否則為 FALSE。

### <a name="remarks"></a>備註

> [!NOTE]
> 使用此成員函式有不受您的程式碼的工具提示會影響。 它只會影響所管理的工具提示控制項[CWnd::EnableToolTips](#enabletooltips)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#73](../../mfc/reference/codesnippet/cpp/cwnd-class_12.cpp)]

##  <a name="centerwindow"></a>  CWnd::CenterWindow

將相對於其父系的視窗置中。

```
void CenterWindow(CWnd* pAlternateOwner = NULL);
```

### <a name="parameters"></a>參數

*pAlternateOwner*<br/>
指標相對於它將會替代視窗置中 （除了父視窗）。

### <a name="remarks"></a>備註

通常從呼叫[CDialog::OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog) center 對話方塊相對於主要視窗的 應用程式。 根據預設，函式會將相對於其父視窗和相對於其擁有者的快顯視窗的子視窗置中。 如果不屬於快顯視窗中，它會置中相對於畫面。 相對於特定的視窗不是擁有者或父視窗的中央*pAlternateOwner*參數可能會設定為有效的視窗。 若要強制將相對於畫面置中，傳遞所傳回的值[CWnd::GetDesktopWindow](#getdesktopwindow)作為*pAlternateOwner*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#74](../../mfc/reference/codesnippet/cpp/cwnd-class_13.cpp)]

##  <a name="changeclipboardchain"></a>  CWnd::ChangeClipboardChain

移除`CWnd`從所指定視窗的剪貼簿檢視器並使鏈結*hWndNext*階`CWnd`鏈結中的上階。

```
BOOL ChangeClipboardChain(HWND hWndNext);
```

### <a name="parameters"></a>參數

*hWndNext*<br/>
識別視窗後面`CWnd`剪貼簿檢視器鏈結中。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

##  <a name="checkdlgbutton"></a>  CWnd::CheckDlgButton

選取 （放置一個旁的核取記號） 或取消 （移除從的核取記號） 按鈕，或它的三態按鈕狀態變更。

```
void CheckDlgButton(
    int nIDButton,
    UINT nCheck);
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定要修改的按鈕。

*nCheck*<br/>
指定要採取的動作。 如果*n*為非零值，`CheckDlgButton`成員函式會放置之按鈕旁邊的核取記號; 如果為 0，會移除核取記號。 三種狀態的按鈕，如果*n*為 2，按鈕狀態尚未確定。

### <a name="remarks"></a>備註

`CheckDlgButton`函式傳送[BM_SETCHECK](/windows/desktop/Controls/bm-setcheck)訊息至指定的按鈕。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#75](../../mfc/reference/codesnippet/cpp/cwnd-class_14.cpp)]

##  <a name="checkradiobutton"></a>  CWnd::CheckRadioButton

選取 （加上核取記號，以） 指定的選項按鈕群組中，清除 （移除核取記號） 所有其他選項 群組中的按鈕。

```
void CheckRadioButton(
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);
```

### <a name="parameters"></a>參數

*nIDFirstButton*<br/>
指定群組中的第一個選項按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中的最後一個選項按鈕的整數識別碼。

*nIDCheckButton*<br/>
指定要檢查的選項按鈕的整數識別碼。

### <a name="remarks"></a>備註

`CheckRadioButton`函式傳送[BM_SETCHECK](/windows/desktop/Controls/bm-setcheck)訊息至指定的選項按鈕。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#76](../../mfc/reference/codesnippet/cpp/cwnd-class_15.cpp)]

##  <a name="childwindowfrompoint"></a>  CWnd::ChildWindowFromPoint

決定哪一個，如果有的話，屬於子視窗的`CWnd`包含指定的點。

```
CWnd* ChildWindowFromPoint(POINT point) const;

CWnd* ChildWindowFromPoint(
    POINT point,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*point*<br/>
指定要測試之點的用戶端座標。

*nflags*<br/>
指定要略過的子視窗。 這個參數可以是下列值的組合：

|值|意義|
|-----------|-------------|
|CWP_ALL|請勿略過任何子視窗|
|CWP_SKIPINVISIBLE|略過不可見的子視窗|
|CWP_SKIPDISABLED|略過已停用的子視窗|
|CWP_SKIPTRANSPARENT|略過透明子視窗|

### <a name="return-value"></a>傳回值

識別包含點的子視窗。 如果指定的點落在用戶端區域外部，它就會是 NULL。 如果用戶端區域內的點，它未包含任何子視窗，在`CWnd`會傳回。

此成員函式會傳回包含指定的點的隱藏或停用的子視窗。

多個視窗可能包含指定的時間點。 不過，此函式只會傳回`CWnd`* 發生之包含點的第一個視窗。

`CWnd`* 傳回可能是暫時性的不應該儲存供稍後使用。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#77](../../mfc/reference/codesnippet/cpp/cwnd-class_16.cpp)]

##  <a name="clienttoscreen"></a>  CWnd::ClientToScreen

將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。

```
void ClientToScreen(LPPOINT lpPoint) const;  void ClientToScreen(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向[POINT 結構](/windows/desktop/api/windef/ns-windef-tagpoint)或`CPoint`来轉換的物件，包含用戶端座標。

*lpRect*<br/>
指向[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)或`CRect`来轉換的物件，包含用戶端座標。

### <a name="remarks"></a>備註

`ClientToScreen`成員函式使用中的用戶端座標`POINT`或`RECT`結構或`CPoint`或是`CRect`指向物件*lpPoint*或*lpRect*來計算新的螢幕座標。然後會使用這個新座標取代結構中的座標。 新的螢幕座標是相對於系統顯示的左上角。

`ClientToScreen`成員函式會假設指定的點或矩形是在用戶端座標。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#78](../../mfc/reference/codesnippet/cpp/cwnd-class_17.cpp)]

##  <a name="closewindow"></a>  CWnd::CloseWindow

將視窗最小化。

```
void CloseWindow();
```

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[Closewindowsg](/windows/desktop/api/winuser/nf-winuser-closewindow)、 Windows SDK 中所述。

##  <a name="continuemodal"></a>  CWnd::ContinueModal

此成員函式會呼叫[runmodalloop 呼叫](#runmodalloop)判斷強制回應狀態應已結束。

```
virtual BOOL ContinueModal();
```

### <a name="return-value"></a>傳回值

若要繼續，強制回應迴圈時，非零值。0 [EndModalLoop](#endmodalloop)呼叫。

### <a name="remarks"></a>備註

根據預設，它會傳回非零直到`EndModalLoop`呼叫。

##  <a name="create"></a>  Cwnd:: Create

建立指定的子視窗，並將它附加至[CWnd](../../mfc/reference/cwnd-class.md)物件。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    Const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>參數

*lpszClassName*<br/>
[in]以 null 終止的字串，其中包含已註冊的系統視窗類別名稱的指標或預先定義的系統視窗類別名稱。

*lpszWindowName*<br/>
[in]以 null 終止的字串，包含視窗的指標會顯示欄位名稱。否則為 NULL 的任何視窗的顯示名稱。

*dwStyle*<br/>
[in]位元組合 (OR)[的視窗樣式](styles-used-by-mfc.md#window-styles)。 WS_POPUP 選項不是有效的樣式。

*rect*<br/>
[in]大小和位置，相對於父視窗的左上角的視窗。

*pParentWnd*<br/>
[in]父視窗的指標。

*nID*<br/>
[in]視窗的識別碼。

*pContext*<br/>
[in]指標[CCreateContext](../../mfc/reference/ccreatecontext-structure.md)用來自訂應用程式的文件檢視架構的結構。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow` 現在將指派的 hMenu 成員及其`CREATESTRUCT`參數來**這**如果功能表是 NULL，而且樣式包含 WS_CHILD 的指標。 功能正常運作，請確定您的對話方塊控制項都有識別碼，不是 NULL。
>
> 這項變更會修正損毀 managed/原生 interop 案例中。 中的追蹤陳述式`CWnd::Create`警示問題的開發人員。

使用[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函式，註冊視窗類別。 使用者定義 視窗的模組中的類別可註冊的位置。

[CWnd::OnCreate](#oncreate)方法之前呼叫`Create`方法傳回時，以及之前的視窗成為可見。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#79](../../mfc/reference/codesnippet/cpp/cwnd-class_18.cpp)]

##  <a name="createaccessibleproxy"></a>  CWnd::CreateAccessibleProxy

建立指定物件的 Active Accessibility Proxy。

```
virtual HRESULT CreateAccessibleProxy(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
識別 Active Accessibility proxy 所存取的物件。 可以是下列值之一

|值|意義|
|-----------|-------------|
|OBJID_CLIENT|指的是視窗的工作區。|

*lParam*<br/>
提供訊息相關的其他資訊。

*pResult*<br/>
儲存的結果碼 LRESULT 指標。

### <a name="remarks"></a>備註

建立指定物件的 Active Accessibility Proxy。

##  <a name="createcaret"></a>  CWnd::CreateCaret

建立系統游標的新形狀，並宣告插入號的擁有權。

```
void CreateCaret(CBitmap* pBitmap);
```

### <a name="parameters"></a>參數

*pBitmap*<br/>
識別定義插入號圖形的點陣圖。

### <a name="remarks"></a>備註

點陣圖必須先前已建立的[CBitmap::CreateBitmap](../../mfc/reference/cbitmap-class.md#createbitmap)成員函式[CreateDIBitmap](/windows/desktop/api/wingdi/nf-wingdi-createdibitmap) Windows 函式，或有[cbitmap:: Loadbitmap](../../mfc/reference/cbitmap-class.md#loadbitmap)成員函式。

`CreateCaret` 如果任何，不論哪一個視窗擁有插入號，則會自動終結先前的插入號圖形。 建立之後，插入號一開始會隱藏起來。 若要顯示插入號[ShowCaret](#showcaret)必須呼叫成員函式。

系統游標是共用的資源。 `CWnd` 具有輸入的焦點或作用中時，只應該建立插入號。 失去輸入的焦點或變成非作用中之前，它應該將插入號損毀。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#80](../../mfc/reference/codesnippet/cpp/cwnd-class_19.cpp)]

##  <a name="createcontrol"></a>  CWnd::CreateControl

若要建立將表示的 ActiveX 控制項的 MFC 程式中使用此成員函式`CWnd`物件。

```
BOOL CreateControl(
    LPCTSTR pszClass,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const POINT* ppt,
    const SIZE* psize,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);
```

### <a name="parameters"></a>參數

*pszClass*<br/>
此字串可能包含 OLE 「 簡短名稱 」 (ProgID) 類別，例如，"CIRC3。Circ3Ctrl.1"。 名稱必須符合註冊控制項的相同名稱。 或者，字串可能包含 CLSID、 包含括號括住，例如，"{9DBAFCCF-592F-101B-85CE-00608CEC297B}"的字串形式。 在任一情況下，`CreateControl`將字串轉換成對應的類別識別碼。

*pszWindowName*<br/>
要在控制項中顯示的文字指標。 （如果有的話），請設定控制項的標題或文字屬性的值。 如果是 NULL，不會變更控制項的標題或文字屬性。

*dwStyle*<br/>
視窗樣式。 < 備註 > 底下列出的可用樣式。

*rect*<br/>
指定控制項的大小和位置。 它可以是[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)。

*ppt*<br/>
指向[POINT 結構](/windows/desktop/api/windef/ns-windef-tagpoint)或`CPoint`物件，包含控制項的左上的角。

*pSize*<br/>
指向[大小](/windows/desktop/api/windef/ns-windef-tagsize)結構或`CSize`物件，包含控制項的大小

*pParentWnd*<br/>
指定控制項的父視窗。 它必須不是 NULL。

*nID*<br/>
指定控制項的識別碼。

*pPersist*<br/>
指標[CFile](../../mfc/reference/cfile-class.md)包含控制項的永續性狀態。 預設值是 NULL，表示控制項，而不還原其狀態從任何持續性儲存體初始化本身。 如果不是 NULL，它應該是一個指向`CFile`-衍生物件，其中包含控制項的永續性資料，資料流或儲存體的形式。 這項資料可以儲存在用戶端上啟用。 `CFile`可以包含其他資料，但必須設定為永續性資料的第一個位元組時呼叫它讀寫指標`CreateControl`。

*bStorage*<br/>
指出是否在資料*pPersist*應解譯為 IStorage 或 IStream 資料。 如果中的資料*pPersist*是儲存體*bStorage*應該是 TRUE。 如果中的資料*pPersist*是資料流*bStorage*應該是 FALSE。 預設值為 FALSE。

*bstrLicKey*<br/>
選擇性的授權金鑰資料。 這項資料只能在建立需要的執行階段授權金鑰的控制項。 如果此控制項支援授權，您必須提供授權金鑰建立的控制項才會成功。 預設值是 NULL。

*clsid*<br/>
控制項的唯一類別 ID。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`CreateControl` 是的直接類似物[cwnd:: Create](#create)函式，這會建立視窗`CWnd`。 `CreateControl` 建立 ActiveX 控制項，而不是一般的視窗。

只是 Windows 的子集*cheaderctrl:: Create*旗標受到支援`CreateControl`:

- WS_VISIBLE 會建立一開始即可見的視窗。 如果您想看見立即，像一般的 windows 控制項的必要項。

- WS_DISABLED 會建立一開始會停用的視窗。 停用的視窗無法接收來自使用者的輸入。 如果控制項具有已啟用屬性，可以設定。

- WS_BORDER 會建立具有精簡列框線的視窗。 如果控制項的框線樣式屬性，可以設定。

- WS_GROUP 指定控制項群組的第一個控制項。 使用者可以變更鍵盤焦點從群組中的一個控制項到下一個使用方向鍵。 之後的第一個控制項屬於相同的群組，以 WS_GROUP 樣式定義的所有控制項。 WS_GROUP 樣式的下一個控制項結束該群組，並開始下一步 群組。

- WS_TABSTOP 指定當使用者按下 TAB 鍵時，可以接收鍵盤焦點的控制項。 按下 TAB 鍵若 WS_TABSTOP 樣式的下一個控制項来變更鍵盤焦點。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#81](../../mfc/reference/codesnippet/cpp/cwnd-class_20.h)]

##  <a name="createex"></a>  CWnd::CreateEx

建立指定的視窗，並將它附加至`CWnd`物件。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU nIDorHMenu,
    LPVOID lpParam = NULL);

virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    LPVOID lpParam = NULL);
```

### <a name="parameters"></a>參數

*dwExStyle*<br/>
位元組合 (OR)[延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)，否則為 NULL 延伸視窗樣式的預設值。

*lpszClassName*<br/>
以 null 終止的字串，其中包含已註冊的系統視窗類別名稱的指標或預先定義的系統視窗類別名稱。

*lpszWindowName*<br/>
以 null 終止的字串，包含視窗的指標會顯示欄位名稱。否則為 NULL 的任何視窗的顯示名稱。

*dwStyle*<br/>
位元組合 (OR)[的視窗樣式](styles-used-by-mfc.md#window-styles)，否則為 NULL 的預設視窗樣式。

*x*<br/>
從畫面的左側視窗或父視窗的初始的水平距離。

*y*<br/>
從畫面頂端的視窗或父視窗的初始的垂直距離。

*nWidth*<br/>
寬度，單位為像素的視窗。

*nHeight*<br/>
高度，單位為像素的視窗。

*hwndParent*<br/>
子視窗，父視窗控制代碼;否則，如果視窗有擁有者中的 [擁有者] 視窗的控制代碼。

*nIDorHMenu*<br/>
子視窗的視窗識別碼;否則，視窗功能表的識別碼。

*lpParam*<br/>
傳遞至的使用者資料指標[CWnd::OnCreate](#oncreate)方法中的*lpCreateParams*欄位。

*rect*<br/>
大小和位置，相對於畫面視窗的父視窗。

*pParentWnd*<br/>
為子視窗，請指向父視窗;如果視窗有擁有者中的 [擁有者] 視窗的指標，否則為。

*nID*<br/>
子視窗的視窗識別碼;否則，視窗功能表的識別碼。

### <a name="return-value"></a>傳回值

如果方法成功，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow` 現在將指派的 hMenu 成員及其`CREATESTRUCT`參數來**這**如果功能表是 NULL，而且樣式包含 WS_CHILD 的指標。 功能正常運作，請確定您的對話方塊控制項都有識別碼，不是 NULL。
>
> 這項變更會修正損毀 managed/原生 interop 案例中。 A`TRACE`中的陳述式`CWnd::Create`警示問題的開發人員。

延伸視窗樣式預設為 WS_EX_LEFT。 預設視窗樣式是 WS_OVERLAPPED。

使用[AfxRegisterWndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函式，註冊視窗類別。 使用者定義 視窗的模組中的類別可註冊的位置。

子視窗尺寸為相對於父視窗的工作區的左上角。 最上層視窗尺寸為相對於螢幕左上角。

[CWnd::OnCreate](#oncreate)方法之前呼叫`CreateEx`方法傳回時，以及之前的視窗成為可見。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#82](../../mfc/reference/codesnippet/cpp/cwnd-class_21.cpp)]

##  <a name="creategraycaret"></a>  CWnd::CreateGrayCaret

建立系統游標的灰色矩形，以及宣告的插入號的擁有權。

```
void CreateGrayCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定的寬度 （以邏輯單位表示） 插入號。 如果此參數為 0，會將寬度設的系統定義的視窗框線寬度。

*nHeight*<br/>
指定的高度 （以邏輯單位表示） 插入號。 如果此參數為 0，會將高度設的系統定義的視窗框線的高度。

### <a name="remarks"></a>備註

插入號圖案可以是一條線或區塊。

參數*nWidth*並*nHeight*指定插入號的寬度和高度 （以邏輯單位表示），確切的寬度和高度 （以像素為單位） 相依於此對應模式。

可以藉由擷取系統的視窗框線的寬度或高度[GetSystemMetrics](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics)具有 SM_CXBORDER 和 SM_CYBORDER 索引的 Windows 函式。 使用視窗框線的寬度或高度，以確保插入號，將會顯示高解析度的顯示器上。

`CreateGrayCaret`成員函式會自動終結先前的插入號圖形中，如果任何，不論哪一個視窗擁有插入號。 建立之後，插入號一開始會隱藏起來。 若要顯示插入號[ShowCaret](#showcaret)必須呼叫成員函式。

系統游標是共用的資源。 `CWnd` 具有輸入的焦點或作用中時，只應該建立插入號。 失去輸入的焦點或變成非作用中之前，它應該將插入號損毀。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#83](../../mfc/reference/codesnippet/cpp/cwnd-class_22.cpp)]

##  <a name="createsolidcaret"></a>  CWnd::CreateSolidCaret

建立系統游標的實心矩形，以及宣告的插入號的擁有權。

```
void CreateSolidCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*nWidth*<br/>
指定的寬度 （以邏輯單位表示） 插入號。 如果此參數為 0，會將寬度設的系統定義的視窗框線寬度。

*nHeight*<br/>
指定的高度 （以邏輯單位表示） 插入號。 如果此參數為 0，會將高度設的系統定義的視窗框線的高度。

### <a name="remarks"></a>備註

插入號圖案可以是線條或區塊。

參數*nWidth*並*nHeight*指定插入號的寬度和高度 （以邏輯單位表示），確切的寬度和高度 （以像素為單位） 相依於此對應模式。

可以藉由擷取系統的視窗框線的寬度或高度[GetSystemMetrics](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics)具有 SM_CXBORDER 和 SM_CYBORDER 索引的 Windows 函式。 使用視窗框線的寬度或高度，以確保插入號，將會顯示高解析度的顯示器上。

`CreateSolidCaret`成員函式會自動終結先前的插入號圖形中，如果任何，不論哪一個視窗擁有插入號。 建立之後，插入號一開始會隱藏起來。 若要顯示插入號[ShowCaret](#showcaret)必須呼叫成員函式。

系統游標是共用的資源。 `CWnd` 具有輸入的焦點或作用中時，只應該建立插入號。 失去輸入的焦點或變成非作用中之前，它應該將插入號損毀。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#84](../../mfc/reference/codesnippet/cpp/cwnd-class_23.cpp)]

##  <a name="cwnd"></a>  CWnd::CWnd

建構 `CWnd` 物件。

```
CWnd();
```

### <a name="remarks"></a>備註

Windows 視窗在不建立並連接到[CreateEx](#createex)或是[建立](#create)呼叫成員函式。

##  <a name="default"></a>  CWnd::Default

呼叫預設視窗程序。

```
LRESULT Default();
```

### <a name="return-value"></a>傳回值

取決於傳送的訊息。

### <a name="remarks"></a>備註

預設視窗程序提供的預設應用程式不會處理任何視窗訊息處理。 此成員函式可確保每則訊息處理。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#85](../../mfc/reference/codesnippet/cpp/cwnd-class_24.cpp)]

##  <a name="defwindowproc"></a>  CWnd::DefWindowProc

呼叫預設視窗程序，其會提供應用程式不會處理任何視窗訊息的預設處理。

```
virtual LRESULT DefWindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理 Windows 訊息。

*wParam*<br/>
指定訊息相關的其他資訊。

*lParam*<br/>
指定訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

取決於傳送的訊息。

### <a name="remarks"></a>備註

此成員函式可確保每則訊息處理。 它應該使用相同的參數，所收到的視窗程序呼叫。

##  <a name="deletetempmap"></a>  CWnd::DeleteTempMap

會自動呼叫的閒置時間處理常式`CWinApp`物件。

```
static void PASCAL DeleteTempMap();
```

### <a name="remarks"></a>備註

刪除暫時`CWnd`所建立的物件`FromHandle`成員函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#86](../../mfc/reference/codesnippet/cpp/cwnd-class_25.cpp)]

##  <a name="destroywindow"></a>  CWnd::DestroyWindow

終結 Windows 視窗附加至`CWnd`物件。

```
virtual BOOL DestroyWindow();
```

### <a name="return-value"></a>傳回值

終結視窗; 如果為非零否則為 0。

### <a name="remarks"></a>備註

`DestroyWindow`成員函式會將適當的訊息傳送至視窗，以停用它，並移除輸入的焦點。 它也會終結視窗的功能表、 排清應用程式佇列、 終結未完成的計時器，會移除剪貼簿的擁有權，並會中斷剪貼簿檢視器鏈結，如果`CWnd`位於檢視器鏈結的最上層。 它會傳送[WM_DESTROY](#ondestroy)並[控制](#onncdestroy)至視窗的訊息。 它不會終結`CWnd`物件。

`DestroyWindow` 是預留位置執行清除。 因為`DestroyWindow`是虛擬函式，它會顯示在任何`CWnd`-衍生的類別檢視 中的類別。 不過，即使您覆寫這個函式，在您`CWnd`-衍生的類別，`DestroyWindow`一定不會呼叫。 如果`DestroyWindow`不會呼叫在 MFC 程式碼中，則您必須明確呼叫它自己的程式碼中如果您想要呼叫它。

例如，假設，您已覆寫`DestroyWindow`在`CView`-衍生的類別。 因為 MFC 原始碼不會呼叫`DestroyWindow`中的任何其`CFrameWnd`-衍生的類別，覆寫的`DestroyWindow`將不會呼叫除非您明確地呼叫它。

如果視窗是任何視窗的父代，這些子視窗會自動終結時終結父視窗。 `DestroyWindow`成員函式會終結子視窗，然後視窗本身。

`DestroyWindow`成員函式也會終結所建立的非強制回應對話方塊[CDialog::Create](../../mfc/reference/cdialog-class.md#create)。

如果`CWnd`終結子視窗，而且沒有[WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)樣式集，則[WM_PARENTNOTIFY](/previous-versions/windows/desktop/inputmsg/wm-parentnotify)訊息傳送至父代。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#87](../../mfc/reference/codesnippet/cpp/cwnd-class_26.cpp)]

##  <a name="detach"></a>  CWnd::Detach

從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。

```
HWND Detach();
```

### <a name="return-value"></a>傳回值

Windows 物件的 HWND。

### <a name="example"></a>範例

  範例，請參閱[CWnd::Attach](#attach)。

##  <a name="dlgdirlist"></a>  CWnd::DlgDirList

使用檔案或目錄清單填入清單方塊。

```
int DlgDirList(
    LPTSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
指向以 null 終止的字串，包含路徑或檔名。 `DlgDirList` 修改此字串應該是長時間足以包含所做的修改。 如需詳細資訊，請參閱下的 < 備註 > 一節。

*nIDListBox*<br/>
指定清單方塊的識別碼。 如果*nIDListBox*為 0，`DlgDirList`假設沒有清單方塊存在，而且不會嘗試填入其中。

*nIDStaticPath*<br/>
指定用來顯示目前的磁碟機和目錄的靜態文字控制項的識別項。 如果*nIDStaticPath*為 0，`DlgDirList`假設這些文字控制項都存在。

*nFileType*<br/>
指定要顯示之檔案的屬性。 它可以是下列值的任何組合：

- DDL_READWRITE 讀寫資料檔案不含任何額外的屬性。

- DDL_READONLY 唯讀檔案。

- DDL_HIDDEN 隱藏的檔案。

- DDL_SYSTEM 系統檔案。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE 封存。

- DDL_POSTMSGS LB_DIR 旗標。 如果設定 LB_DIR 旗標，Windows 會將所產生的訊息`DlgDirList`在應用程式的佇列，否則它們會直接傳送到對話方塊程序。

- DDL_DRIVES 磁碟機。 如果設定 DDL_DRIVES 旗標，則會自動設定 DDL_EXCLUSIVE 旗標。 因此，若要建立包含磁碟機和檔案的目錄清單，您必須呼叫`DlgDirList`兩次： 一次具有 DDL_DRIVES 旗標集，另一次使用的清單上的其他旗標。

- DDL_EXCLUSIVE 獨佔位元。 如果設定的獨佔位元，只指定型別的會列出檔案;否則會列出一般的檔案和檔案指定的類型。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

`DlgDirList` 傳送[LB_RESETCONTENT](/windows/desktop/Controls/lb-resetcontent)並[LB_DIR](/windows/desktop/Controls/lb-dir)訊息至清單方塊。 填入清單方塊中所指定*nIDListBox*符合所指定的路徑的所有檔案的名稱*lpPathSpec*。

*LpPathSpec*參數具有下列格式：

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中，*磁碟機*磁碟機代號，*目錄*是有效的目錄名稱，並*filename*是有效的檔名必須包含至少一個萬用字元。 萬用字元是問號 ( **？** )，這表示比對任何字元，並以星號 (<strong>\*</strong>)，這表示比對任何數目的字元。

如果您指定的 0 長度字串*lpPathSpec*，或如果您指定目錄名稱，但不是包含任何檔案規格時，會將字串變更為 「\*。\*"。

如果*lpPathSpec*包含磁碟機及/或目錄的名稱、 目前的磁碟機和目錄都會變更為指定的磁碟機和目錄之前會填入清單方塊。 所識別的文字控制項*nIDStaticPath*也會更新為新的磁碟機及/或目錄名稱。

填入清單方塊之後， *lpPathSpec*會藉由移除磁碟機及/或目錄路徑的部分更新。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#88](../../mfc/reference/codesnippet/cpp/cwnd-class_27.cpp)]

##  <a name="dlgdirlistcombobox"></a>  CWnd::DlgDirListComboBox

使用檔案或目錄清單來填入下拉式方塊的清單方塊。

```
int DlgDirListComboBox(
    LPTSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
指向以 null 終止的字串，包含路徑或檔名。 `DlgDirListComboBox` 修改這個字串，因此這項資料不應該是字串常值的形式。 請參閱下列 < 備註 > 一節。

*nIDComboBox*<br/>
在對話方塊中指定下拉式方塊的識別碼。 如果*nIDComboBox*為 0，`DlgDirListComboBox`假設沒有下拉式方塊存在，而且不會嘗試填入其中。

*nIDStaticPath*<br/>
指定用來顯示目前的磁碟機和目錄的靜態文字控制項的識別項。 如果*nIDStaticPath*為 0，`DlgDirListComboBox`假設這些文字控制項都存在。

*nFileType*<br/>
指定要顯示之檔案的 DOS 檔案屬性。 它可以是下列值的任何組合：

- DDL_READWRITE 讀寫資料檔案不含任何額外的屬性。

- DDL_READONLY 唯讀檔案。

- DDL_HIDDEN 隱藏的檔案。

- DDL_SYSTEM 系統檔案。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE 封存。

- DDL_POSTMSGS CB_DIR 旗標。 如果設定 CB_DIR 旗標，Windows 會將所產生的訊息`DlgDirListComboBox`在應用程式的佇列，否則它們會直接傳送到對話方塊程序。

- DDL_DRIVES 磁碟機。 如果設定 DDL_DRIVES 旗標，則會自動設定 DDL_EXCLUSIVE 旗標。 因此，若要建立包含磁碟機和檔案的目錄清單，您必須呼叫`DlgDirListComboBox`兩次： 一次具有 DDL_DRIVES 旗標集，另一次使用的清單上的其他旗標。

- DDL_EXCLUSIVE 獨佔位元。 如果設定的獨佔位元，只指定型別的會列出檔案;否則會列出一般的檔案和檔案指定的類型。

### <a name="return-value"></a>傳回值

指定函式的結果。 如果清單已進行的甚至是空的清單，其為非零值。 0 的傳回值，表示輸入的字串未包含有效的搜尋路徑。

### <a name="remarks"></a>備註

`DlgDirListComboBox` 傳送[CB_RESETCONTENT](/windows/desktop/Controls/cb-resetcontent)並[CB_DIR](/windows/desktop/Controls/cb-dir)下拉式方塊的訊息。 清單方塊中所指定的下拉式方塊的填滿*nIDComboBox*符合所指定的路徑的所有檔案的名稱*lpPathSpec*。

*LpPathSpec*參數具有下列格式：

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中，*磁碟機*磁碟機代號，*目錄*是有效的目錄名稱，並*filename*是有效的檔名必須包含至少一個萬用字元。 萬用字元是問號 ( **？** )，這表示比對任何字元，並以星號 (<strong>\*</strong>)，這表示比對任何數目的字元。

如果您指定的長度為零的字串*lpPathSpec*，將會使用目前的目錄並*lpPathSpec*將不會修改。 如果您指定目錄名稱，但不是包含任何檔案規格時，將字串變更為 「\*"。

如果*lpPathSpec*包含磁碟機及/或目錄的名稱、 目前的磁碟機和目錄都會變更為指定的磁碟機和目錄之前會填入清單方塊。 所識別的文字控制項*nIDStaticPath*也會更新為新的磁碟機及/或目錄名稱。

下拉式方塊清單方塊會填滿之後， *lpPathSpec*會藉由移除磁碟機及/或目錄路徑的部分更新。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#89](../../mfc/reference/codesnippet/cpp/cwnd-class_28.cpp)]

##  <a name="dlgdirselect"></a>  CWnd::DlgDirSelect

從清單方塊擷取目前的選取範圍。

```
BOOL DlgDirSelect(
    LPTSTR lpString,
    int nIDListBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
指向接收目前的選取範圍的清單方塊中的緩衝區。

*nIDListBox*<br/>
在對話方塊中，指定清單方塊的整數識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它會採用清單方塊中，已填滿所[DlgDirList](#dlgdirlist)成員函式，並選取項目是磁碟機代號、 檔案或目錄名稱。

`DlgDirSelect`成員函式會將選取範圍複製到所指定的緩衝區*lpString*。 如果沒有選取範圍中， *lpString*不會變更。

`DlgDirSelect` 傳送[LB_GETCURSEL](/windows/desktop/Controls/lb-getcursel)並[LB_GETTEXT](/windows/desktop/Controls/lb-gettext)訊息至清單方塊。

它不允許一個以上的檔案名稱，以便傳回從清單方塊。 清單方塊不能複選清單方塊。

##  <a name="dlgdirselectcombobox"></a>  CWnd::DlgDirSelectComboBox

從下拉式方塊的清單方塊中擷取目前的選取範圍。

```
BOOL DlgDirSelectComboBox(
    LPTSTR lpString,
    int nIDComboBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
要接收所選的路徑之緩衝區的點。

*nIDComboBox*<br/>
在對話方塊中指定下拉式方塊的整數識別碼。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它會採用清單方塊中，已填滿所[DlgDirListComboBox](#dlgdirlistcombobox)成員函式，並選取項目是磁碟機代號、 檔案或目錄名稱。

`DlgDirSelectComboBox`成員函式會將選取範圍複製到指定的緩衝區。 如果沒有選取範圍，都不會變更緩衝區的內容。

`DlgDirSelectComboBox` 傳送[CB_GETCURSEL](/windows/desktop/Controls/cb-getcursel)並[CB_GETLBTEXT](/windows/desktop/Controls/cb-getlbtext)下拉式方塊的訊息。

它不允許一個以上的檔案名稱，傳回將下拉式方塊中。

##  <a name="dodataexchange"></a>  CWnd::DoDataExchange

由架構呼叫以交換和驗證對話方塊資料。

```
virtual void DoDataExchange(CDataExchange* pDX);
```

### <a name="parameters"></a>參數

*pDX*<br/>
          `CDataExchange` 物件的指標。

### <a name="remarks"></a>備註

永遠不會直接呼叫此函式。 它由呼叫[UpdateData](#updatedata)成員函式。 呼叫`UpdateData`初始化對話方塊的控制項，或從對話方塊中擷取資料。

當您衍生特定應用程式的對話方塊類別從[CDialog](../../mfc/reference/cdialog-class.md)，您需要覆寫此成員函式，如果您想要利用架構的自動資料交換和驗證。 加入變數 精靈會為您包含所需撰寫覆寫的版本，此成員函式的 「 資料對應 」 的對話方塊資料交換 (DDX) 和驗證 (DDV) 全域函式呼叫。

若要自動產生覆寫此成員函式版本，請先使用對話方塊編輯器中，建立對話方塊資源，然後衍生特定應用程式的對話方塊類別。 變數、 資料和驗證範圍與新的對話方塊中的各種控制項，然後使用 加入變數的精靈。 精靈接著會將覆寫`DoDataExchange`，其中包含資料地圖。 以下是加入變數 精靈所產生的範例 DDX/DDV 程式碼區塊：

[!code-cpp[NVC_MFCWindowing#90](../../mfc/reference/codesnippet/cpp/cwnd-class_29.cpp)]

`DoDataExchange`覆寫的成員函式必須在原始程式檔中之前的巨集陳述式。

如需有關對話資料交換和驗證的詳細資訊，請參閱[顯示和操作表單中的資料](../../data/odbc/displaying-and-manipulating-data-in-a-form.md)並[對話資料交換和驗證](../../mfc/dialog-data-exchange-and-validation.md)。 如需加入變數 精靈所產生的 DDX_ 和 DDV_ 巨集的說明，請參閱[技術提示 26](../../mfc/tn026-ddx-and-ddv-routines.md)。

##  <a name="dragacceptfiles"></a>  CWnd::DragAcceptFiles

在視窗中，呼叫此成員函式，從使用`CWnd`指標，在您的應用程式中[Afxenablecontrolcontainer](../../mfc/reference/cwinapp-class.md#initinstance)函式來表示視窗接受從 Windows 檔案管理員 或 [檔案總管] 中卸除檔案.

```
void DragAcceptFiles(BOOL bAccept = TRUE);
```

### <a name="parameters"></a>參數

*BAccept*<br/>
旗標，指出是否接受拖曳的檔案。

### <a name="remarks"></a>備註

呼叫的視窗`DragAcceptFiles`具有*bAccept*參數設定為 TRUE 」 已識別本身為能夠處理 Windows 訊息 WM_DROPFILES。 例如，在 MDI 應用程式時，如果`CMDIFrameWnd`視窗的指標會在`DragAcceptFiles`函式呼叫，只有`CMDIFrameWnd`視窗取得 WM_DROPFILES 訊息。 此訊息不會傳送給所有開放`CMDIChildWnd`windows。 針對`CMDIChildWnd`視窗來接收此訊息中，您必須呼叫`DragAcceptFiles`與`CMDIChildWnd`視窗指標。

若要停止接收拖曳的檔案，呼叫成員函式與*bAccept*設為 FALSE。

##  <a name="dragdetect"></a>  CWnd::DragDetect

擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。

```
BOOL DragDetect(POINT pt) const;
```

### <a name="parameters"></a>參數

*pt*<br/>
螢幕座標中滑鼠的初始位置。 函式會使用此點，以判斷拖曳矩形的座標。

### <a name="return-value"></a>傳回值

如果使用者按住左鍵同時移動滑鼠拖曳矩形之外，傳回的值為非零值。

如果使用者未按住左鍵同時移動滑鼠拖曳矩形之外，傳回的值為零。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[DragDetect](/windows/desktop/api/winuser/nf-winuser-dragdetect)、 Windows SDK 中所述。

##  <a name="drawanimatedrects"></a>  CWnd::DrawAnimatedRects

繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。

```
BOOL DrawAnimatedRects(
    int idAni,
    CONST RECT* lprcFrom,
    CONST RECT* lprcTo);
```

### <a name="parameters"></a>參數

*idAni*<br/>
指定動畫的類型。 如果您指定 IDANI_CAPTION，視窗標題會從所指定的位置建立動畫*lprcFrom*所指定的位置來*lprcTo*。 效果就類似於最小化或最大化視窗。

*lprcFrom*<br/>
指標[RECT](/previous-versions/dd162897\(v=vs.85\))結構，指定最小化的視窗之圖示的大小與位置。

*lprcTo*<br/>
指標[RECT](/previous-versions/dd162897\(v=vs.85\))結構，指定已還原視窗的大小與位置

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[DrawAnimatedRects](/windows/desktop/api/winuser/nf-winuser-drawanimatedrects)、 Windows SDK 中所述。

##  <a name="drawcaption"></a>  CWnd::DrawCaption

繪製視窗標題。

```
BOOL DrawCaption(
    CDC* pDC,
    LPCRECT lprc,
    UINT uFlags);
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。 函式會繪製至這個裝置內容的視窗標題。

*lprc*<br/>
指定視窗標題的周框矩形結構的指標。

*uFlags*<br/>
指定繪圖選項。 值的完整清單，請參閱 < [DrawCaption](/windows/desktop/api/winuser/nf-winuser-drawcaption)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[DrawCaption](/windows/desktop/api/winuser/nf-winuser-drawcaption)、 Windows SDK 中所述。

##  <a name="drawmenubar"></a>  CWnd::DrawMenuBar

重新繪製功能表列。

```
void DrawMenuBar();
```

### <a name="remarks"></a>備註

如果 Windows 建立視窗之後，即可變更功能表列，，呼叫此函式可繪製已變更的功能表列。

### <a name="example"></a>範例

  範例，請參閱[CWnd::GetMenu](#getmenu)。

##  <a name="enableactiveaccessibility"></a>  CWnd::EnableActiveAccessibility

可讓使用者定義 Active Accessibility 函式。

```
void EnableActiveAccessibility();
```

### <a name="remarks"></a>備註

MFC 的預設 Active Accessibility 支援不足的標準 windows 和控制項，包括 ActiveX 控制項;不過，如果您`CWnd`-衍生的類別包含 nonwindowed 使用者介面項目，MFC 具有無從得知其相關。 在此情況下，您必須覆寫的適當[Active Accessibility 成員函式](/windows/desktop/winauto/sdk-components)在類別中，您必須呼叫`EnableActiveAccessibility`類別的建構函式中。

##  <a name="enabledynamiclayout"></a>  CWnd::EnableDynamicLayout

啟用或停用動態配置管理員。 啟用動態配置時，會在使用者調整視窗大小時動態調整子視窗的位置與大小。

```
void EnableDynamicLayout(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
TRUE 表示啟用動態配置；FALSE 則停用動態配置。

### <a name="remarks"></a>備註

如果您想要啟用動態配置，除了呼叫這個方法之外，還必須執行其他作業。 您還必須提供動態配置資訊，該資訊指定視窗中的控制項如何回應大小變更。 您可以在資源編輯器中或以程式設計方式，為每個控制項指定這項資訊。 請參閱[動態配置](../../mfc/dynamic-layout.md)。

##  <a name="enabled2dsupport"></a>  CWnd::EnableD2DSupport

啟用或停用視窗 D2D 支援。 初始化主視窗之前先呼叫這個方法。

```
void EnableD2DSupport(
    BOOL bEnable = TRUE,
    BOOL bUseDCRenderTarget = FALSE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否開啟或關閉 D2D 支援。

*bUseDCRenderTarget*<br/>
指定是否要使用裝置內容 (DC) 呈現目標 CDCRenderTarget。 如果為 FALSE，則會使用 CHwndRenderTarget。

##  <a name="enablescrollbar"></a>  CWnd::EnableScrollBar

啟用或停用一個捲軸的一或兩個箭號。

```
BOOL EnableScrollBar(
    int nSBFlags,
    UINT nArrowFlags = ESB_ENABLE_BOTH);
```

### <a name="parameters"></a>參數

*nSBFlags*<br/>
指定捲軸類型。 可以有下列值之一：

- SB_BOTH 啟用或停用的水平和垂直捲軸箭號，相關聯的視窗。

- SB_HORZ 啟用或停用的水平捲軸箭號，相關聯的視窗。

- SB_VERT 啟用或停用的垂直捲軸箭號，相關聯的視窗。

*nArrowFlags*<br/>
指定捲軸箭號是否已啟用或停用和啟用或停用的箭號。 可以有下列值之一：

- ESB_ENABLE_BOTH 可讓這兩個箭號的捲軸列 （預設值）。

- 水平捲軸向左箭號或垂直捲軸向上箭號，會停用 ESB_DISABLE_LTUP。

- 水平捲軸向右箭頭或向下的箭號，在垂直捲軸上，會停用 ESB_DISABLE_RTDN。

- ESB_DISABLE_BOTH 停用這兩個捲軸的箭號。

### <a name="return-value"></a>傳回值

如果啟用或停用指定的箭號，非零值。 否則，它會是 0，表示箭號已要求的狀態，或發生錯誤。

##  <a name="enablescrollbarctrl"></a>  CWnd::EnableScrollBarCtrl

啟用或停用此視窗的捲軸。

```
void EnableScrollBarCtrl(
    int nBar,
    BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
捲軸的識別項。

*bEnable*<br/>
指定捲軸是否已啟用或停用。

### <a name="remarks"></a>備註

如果視窗有同層級捲軸控制項，則使用捲軸否則，系統會使用視窗的捲軸。

##  <a name="enabletooltips"></a>  CWnd::EnableToolTips

可讓指定的視窗工具提示。

```
BOOL EnableToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否啟用或停用工具提示控制項。 TRUE 可讓控制項;FALSE 會停用控制項。

### <a name="return-value"></a>傳回值

如果已啟用工具提示;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

覆寫[OnToolHitTest](#ontoolhittest)提供[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa)結構或結構的視窗。

> [!NOTE]
> 某些視窗中，這類[CToolBar](../../mfc/reference/ctoolbar-class.md)，提供的內建實作[OnToolHitTest](#ontoolhittest)。

請參閱[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa) Windows SDK，如需有關此結構中。

只要呼叫`EnableToolTips`不足以顯示工具提示，針對您的子控制項，除非父視窗衍生自`CFrameWnd`。 這是因為`CFrameWnd`TTN_NEEDTEXT 通知會提供預設處理常式。 如果父視窗不衍生自`CFrameWnd`，這就是，如果它是在對話方塊或表單檢視時，工具提示控制項將無法正確顯示除非您提供的處理常式 TTN_NEEDTEXT 工具提示告知您子系。 請參閱[工具提示](../../mfc/tool-tips-in-windows-not-derived-from-cframewnd.md)。

針對您的 windows 所提供的預設工具提示`EnableToolTips`沒有與其相關聯的文字。 若要擷取要顯示的工具提示文字，TTN_NEEDTEXT 通知會傳送至工具提示控制項的父視窗，在顯示工具提示視窗之前。 如果沒有將一些值指派給這個訊息處理常式*pszText*隸屬`TOOLTIPTEXT`結構，會有任何工具提示所顯示的文字。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#91](../../mfc/reference/codesnippet/cpp/cwnd-class_30.cpp)]

[!code-cpp[NVC_MFCWindowing#92](../../mfc/reference/codesnippet/cpp/cwnd-class_31.cpp)]

##  <a name="enabletrackingtooltips"></a>  CWnd::EnableTrackingToolTips

啟用或停用追蹤工具提示。

```
BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否追蹤的工具提示已啟用或停用。 如果此參數為 TRUE，提示將會啟用此追蹤工具。 如果此參數為 FALSE 時，提示將會停用追蹤工具。

### <a name="return-value"></a>傳回值

表示之前的狀態`EnableWindow`呼叫成員函式。 如果之前已停用視窗為非零傳回值。 如果之前已啟用視窗，或發生錯誤，則傳回的值為 0。

### <a name="remarks"></a>備註

追蹤工具提示是您可以動態地放置在螢幕的工具提示視窗。 藉由快速更新的位置，工具提示視窗出現地移動，或 「 追蹤 」。 此功能會很有用，如果您需要遵循指標的位置，當它移動時的工具提示文字。

##  <a name="enablewindow"></a>  CWnd::EnableWindow

啟用或停用滑鼠和鍵盤輸入。

```
BOOL EnableWindow(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否啟用或停用指定的視窗。 如果此參數為 TRUE，將會啟用視窗。 如果此參數為 FALSE 時，視窗將會停用。

### <a name="return-value"></a>傳回值

表示之前的狀態`EnableWindow`呼叫成員函式。 如果之前已停用視窗為非零傳回值。 如果之前已啟用視窗，或發生錯誤，則傳回的值為 0。

### <a name="remarks"></a>備註

停用輸入時，輸入，例如滑鼠點按和按鍵輸入會被忽略。 啟用輸入時，視窗就會處理所有的輸入。

如果已啟用的狀態會變更，請[WM_ENABLE](#onenable)此函式傳回之前，會傳送訊息。

如果停用，所有的子視窗會隱含停用，雖然它們不會傳送 WM_ENABLE 訊息。

視窗必須先啟用，才可以將它啟用。 比方說，如果應用程式會顯示非強制回應對話方塊，並已停用其主視窗，在主視窗必須啟用之前的對話方塊時終結。 否則，另一個視窗會收到輸入的焦點，並啟用。 如果為子視窗已停用，則會忽略 Windows 會嘗試判斷哪一個視窗應該會看到滑鼠訊息時。

根據預設，會在建立時，會啟用視窗。 應用程式可以指定在 WS_DISABLED 樣式[Create](#create)或是[CreateEx](#createex)成員函式來建立一開始會停用的視窗。 建立視窗之後，也可以使用應用程式`EnableWindow`來啟用或停用視窗的成員函式。

若要啟用或停用的控制項在對話方塊中，應用程式可以使用此函式。 停用的控制項無法接收輸入的焦點，也不在使用者可以存取它。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#93](../../mfc/reference/codesnippet/cpp/cwnd-class_32.cpp)]

##  <a name="endmodalloop"></a>  CWnd::EndModalLoop

終止呼叫`RunModalLoop`。

```
virtual void EndModalLoop(int nResult);
```

### <a name="parameters"></a>參數

*nResult*<br/>
包含要傳回給呼叫端的值[runmodalloop 呼叫](#runmodalloop)。

### <a name="remarks"></a>備註

*n 結果*參數會傳播到傳回的值從`RunModalLoop`。

##  <a name="endmodalstate"></a>  CWnd::EndModalState

呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。

```
virtual void EndModalState();
```

##  <a name="endpaint"></a>  CWnd::EndPaint

將標記在指定的視窗中繪製的結束。

```
void EndPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向[PAINTSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagpaintstruct)結構，其中包含所擷取之繪製資訊[BeginPaint](#beginpaint)成員函式。

### <a name="remarks"></a>備註

`EndPaint`成員函式是為了對每個呼叫`BeginPaint`成員函式，但前提是繪製已完成。

如果已隱藏插入號`BeginPaint`成員函式，`EndPaint`還原至畫面的插入號。

### <a name="example"></a>範例

  範例，請參閱[cwnd:: Beginpaint](#beginpaint)。

##  <a name="executedlginit"></a>  CWnd::ExecuteDlgInit

初始化對話方塊資源。

```
BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
BOOL ExecuteDlgInit(LPVOID lpResource);
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
以 null 終止的字串，指定的資源名稱的指標。

*lpResource*<br/>
資源的指標。

### <a name="return-value"></a>傳回值

如果執行對話方塊資源，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

`ExecuteDlgInit` 將從其他來源使用繫結至執行模組中，資源。 若要這麼做，`ExecuteDlgInit`尋找資源控制代碼藉由呼叫`AfxFindResourceHandle`。 如果您的 MFC 應用程式不會使用共用的 DLL (MFCx0 [U] [D]。DLL)，`AfxFindResourceHandle`呼叫[AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle)，它會傳回目前的資源控制代碼，可執行檔。 如果您使用 MFCx0 的 MFC 應用程式 [U] [D]。DLL`AfxFindResourceHandle`周遊`CDynLinkLibrary`共用的物件清單和 MFC 擴充 Dll 尋找正確的資源的處理。

##  <a name="filtertooltipmessage"></a>  CWnd::FilterToolTipMessage

由架構呼叫以顯示工具提示訊息。

```
void FilterToolTipMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
工具提示訊息指標。

### <a name="remarks"></a>備註

從 framework 大多數 MFC 應用程式中呼叫這個方法[PreTranslateMessage](#pretranslatemessage)並[; enabletooltips&lt; 2](#enabletooltips)，而且您不需要自行呼叫。

不過，在某些應用程式，例如某些 ActiveX 控制項，這些方法可能不會叫用，framework，您必須自行呼叫 FilterToolTipMessage。 如需詳細資訊，請參閱 <<c0> [ 方法的建立工具提示](../../mfc/methods-of-creating-tool-tips.md)。

##  <a name="findwindow"></a>  CWnd::FindWindow

傳回最上層`CWnd`所指定的視窗類別*lpszClassName*和其視窗名稱或標題，會根據*lpszWindowName*。

```
static CWnd* PASCAL FindWindow(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName);
```

### <a name="parameters"></a>參數

*lpszClassName*<br/>
指向以 null 終止的字串，指定視窗的類別名稱 (`WNDCLASS`結構)。 如果*lpClassName*是 NULL，所有的類別名稱相符。

*lpszWindowName*<br/>
指向以 null 終止的字串，指定視窗名稱 （該視窗的標題）。 如果*lpWindowName*是 NULL，所有的視窗名稱相符。

### <a name="return-value"></a>傳回值

識別具有指定的類別名稱和視窗名稱的視窗。 如果不找到任何這類視窗，它就會是 NULL。

`CWnd`* 可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

此函式不會搜尋子視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#94](../../mfc/reference/codesnippet/cpp/cwnd-class_33.cpp)]

##  <a name="findwindowex"></a>  CWnd::FindWindowEx

擷取視窗物件的類別名稱和視窗名稱符合指定的字串。

```
static CWnd* FindWindowEx(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCTSTR lpszClass,
    LPCTSTR lpszWindow);
```

### <a name="parameters"></a>參數

*hwndParent*<br/>
搜尋要的子視窗的父視窗控制代碼。

*hwndChildAfter*<br/>
子視窗的控制代碼。 使用下一個子視窗的疊置順序中開始搜尋。 子視窗必須是直接子視窗*hwndParent*，不只是一個子系的視窗。

*lpszClass*<br/>
以 null 終止的字串，指定類別名稱或由先前呼叫建立類別元素的指標[RegisterClass](/windows/desktop/api/winuser/nf-winuser-registerclassa)或是[RegisterClassEx](/windows/desktop/api/winuser/nf-winuser-registerclassexa)。

*lpszWindow*<br/>
以 null 終止的字串，指定視窗名稱 （該視窗的標題） 的指標。 如果此參數為 NULL，則比對所有的視窗名稱。

### <a name="return-value"></a>傳回值

如果函式成功，則傳回的值會是具有指定之類別和視窗名稱的視窗物件的指標。 如果函式失敗，傳回的值會是 NULL。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[FindWindowEx](/windows/desktop/api/winuser/nf-winuser-findwindowexa)、 Windows SDK 中所述。

##  <a name="flashwindow"></a>  CWnd::FlashWindow

指定的視窗 閃爍一次。

```
BOOL FlashWindow(BOOL bInvert);
```

### <a name="parameters"></a>參數

*bInvert*<br/>
指定是否`CWnd`快閃記憶體或回到其原始狀態。 `CWnd`其他如果從某個狀態快閃記憶體*bInvert*為 TRUE。 如果*bInvert*為 FALSE 時，視窗會傳回到其原始狀態 （作用中或非使用中）。

### <a name="return-value"></a>傳回值

非零值，如果視窗是作用的呼叫之前`FlashWindow`成員函式; 否則為 0。

### <a name="remarks"></a>備註

對於後續的閃爍，請在建立系統計時器，然後重複呼叫`FlashWindow`。 閃爍`CWnd`表示變更其標題列的外觀如同`CWnd`已變更為 作用中的非作用中狀態，從，反之亦然。 （非使用中的標題列會變成作用中的標題列，使用中的標題列會變為非作用中的標題列）。

一般而言，視窗是快閃，通知使用者，它需要注意但，它目前沒有輸入的焦點。

*BInvert*參數應該是 FALSE，僅當視窗已取得輸入的焦點，而且將不再會閃爍; 它應該是 TRUE 在等候取得輸入的焦點時的後續呼叫。

此函式一律會傳回非零值的最小化視窗項目。 如果視窗最小化，`FlashWindow`只會顯示閃爍視窗的圖示*bInvert*忽略的最小化視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#95](../../mfc/reference/codesnippet/cpp/cwnd-class_34.cpp)]

##  <a name="flashwindowex"></a>  CWnd::FlashWindowEx

指定的視窗 閃爍。

```
BOOL FlashWindowEx(
    DWORD dwFlags,
    UINT uCount,
    DWORD dwTimeout);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定的快閃的狀態。 值的完整清單，請參閱 < [FLASHWINFO](/windows/desktop/api/winuser/ns-winuser-flashwinfo)結構。

*uCount*<br/>
指定的次數閃爍的視窗。

*dwTimeout*<br/>
指定的速率，以毫秒為單位，將的快閃記憶體視窗。 如果*dwTimeout*為零，此函數會使用預設游標閃爍頻率。

### <a name="return-value"></a>傳回值

傳回的值指定視窗的狀態，再呼叫`FlashWindowEx`函式。 如果為作用中的呼叫之前，已繪製視窗標題，則傳回的值為非零值。 否則，傳回的值為零。

### <a name="remarks"></a>備註

這個方法的函式會模擬[FlashWindowEx](/windows/desktop/api/winuser/nf-winuser-flashwindowex)、 Windows SDK 中所述。

##  <a name="fromhandle"></a>  CWnd::FromHandle

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

```
static CWnd* PASCAL FromHandle(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
Windows 視窗的 HWND。

### <a name="return-value"></a>傳回值

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

該指標可能是暫時性的，因此不應該儲存供日後使用。

##  <a name="fromhandlepermanent"></a>  CWnd::FromHandlePermanent

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。

```
static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
Windows 視窗的 HWND。

### <a name="return-value"></a>傳回值

          `CWnd` 物件的指標。

### <a name="remarks"></a>備註

如果`CWnd`物件沒有附加至控制代碼，則會傳回 NULL。

此函式不同的是[FromHandle](#fromhandle)，不會建立暫存物件。

##  <a name="get_accchild"></a>  CWnd::get_accChild

由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。

```
virtual HRESULT get_accChild(
    VARIANT varChild,
    IDispatch** ppdispChild);
```

### <a name="parameters"></a>參數

*varChild*<br/>
識別的子系的`IDispatch`介面是要擷取。

*ppdispChild*<br/>
接收的子物件的位址`IDispatch`介面。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accChild](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchild) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::get_accChild](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchild) Windows SDK 中。

##  <a name="get_accchildcount"></a>  CWnd::get_accChildCount

由架構呼叫以擷取屬於此物件的子物件數目。

```
virtual HRESULT get_accChildCount(long* pcountChildren);
```

### <a name="parameters"></a>參數

*pcountChildren*<br/>
接收子系的數目。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accChildCount](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchildcount) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。 呼叫基底類別版本，然後再加入 nonwindowed 子項目。

如需詳細資訊，請參閱 < [IAccessible::get_accChildCount](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accchildcount) Windows SDK 中。

##  <a name="get_accdefaultaction"></a>  CWnd::get_accDefaultAction

由架構呼叫以擷取具有物件預設動作描述的字串。

```
virtual HRESULT get_accDefaultAction(
    VARIANT varChild,
    BSTR* pszDefaultAction);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取的預設動作為物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pszDefaultAction*<br/>
接收的當地語系化的字串。 如果此物件沒有預設動作描述的預設動作為指定的物件，則為 NULL 的 BSTR 的位址。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生的類別來描述物件的預設動作。

如需詳細資訊，請參閱 < [IAccessible::get_accDefaultAction](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction) Windows SDK 中。

##  <a name="get_accdescription"></a>  CWnd::get_accDescription

由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。

```
virtual HRESULT get_accDescription(
    VARIANT varChild,
    BSTR* pszDescription);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取的描述是物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pszDescription*<br/>
接收的當地語系化的字串，描述指定的物件，BSTR 的位址，或如果沒有描述可供此物件為 NULL。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accDescription](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdescription) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生的類別來描述您的物件。 呼叫基底類別版本，並加入您的描述。

如需詳細資訊，請參閱 < [IAccessible::get_accDescription](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accdescription) Windows SDK 中。

##  <a name="get_accfocus"></a>  CWnd::get_accFocus

由架構呼叫以擷取具有鍵盤焦點的物件。

```
virtual HRESULT get_accFocus(VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*pvarChild*<br/>
收到具有焦點之物件的相關資訊。 請參閱*pvarID*中[IAccessible::get_accFocus](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accfocus) Windows SDK 中。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::get_accFocus`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::get_accFocus](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accfocus) Windows SDK 中。

##  <a name="get_acchelp"></a>  CWnd::get_accHelp

由架構呼叫以擷取物件**協助**屬性字串。

```
virtual HRESULT get_accHelp(
    VARIANT varChild,
    BSTR* pszHelp);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取的 [說明] 資訊的物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pszHelp*<br/>
接收的當地語系化的字串，包含指定的物件，則為 NULL 的說明資訊，如果不未提供任何說明資訊的 BSTR 的位址。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accHelp](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelp) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生的類別物件提供說明文字。

如需詳細資訊，請參閱 < [IAccessible::get_accHelp](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelp) Windows SDK 中。

##  <a name="get_acchelptopic"></a>  CWnd::get_accHelpTopic

由架構呼叫以擷取的完整路徑**WinHelp**與指定的物件和該檔案中適切主題的識別項相關聯的檔案。

```
virtual HRESULT get_accHelpTopic(
    BSTR* pszHelpFile,
    VARIANT varChild,
    long* pidTopic);
```

### <a name="parameters"></a>參數

*pszHelpFile*<br/>
接收的完整路徑的 BSTR 的位址`WinHelp`如果有的話，與指定的物件相關聯的檔案。

*varChild*<br/>
指定是否要擷取的 [說明] 主題的物件或物件的子元素之一。 這個參數可以是子的 CHILDID_SELF （若要取得說明 主題的物件） 或 （若要取得說明主題的其中一個物件元素） 的子識別碼。

*pidTopic*<br/>
識別指定的物件相關聯的說明檔主題。 請參閱*pidTopic*中[IAccessible::get_accHelpTopic](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic) Windows SDK 中。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::get_accHelpTopic`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，以提供您物件的說明資訊。

如需詳細資訊，請參閱 < [IAccessible::get_accHelpTopic](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic) Windows SDK 中。

##  <a name="get_acckeyboardshortcut"></a>  CWnd::get_accKeyboardShortcut

由架構呼叫以擷取指定物件的快速鍵或便捷鍵。

```
virtual HRESULT get_accKeyboardShortcut(
    VARIANT varChild,
    BSTR* pszKeyboardShortcut);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取的鍵盤快速鍵是物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pszKeyboardShortcut*<br/>
BSTR，接收識別鍵盤快速鍵的當地語系化的字串的位址，或如果沒有鍵盤快速鍵是以指定的物件相關聯，則為 NULL。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accKeyboardShortcut](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生的類別來識別物件的鍵盤快速鍵。

如需詳細資訊，請參閱 < [IAccessible::get_accKeyboardShortcut](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut) Windows SDK 中。

##  <a name="get_accname"></a>  CWnd::get_accName

由架構呼叫以擷取指定物件的名稱。

```
virtual HRESULT get_accName(
    VARIANT varChild,
    BSTR* pszName);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取的名稱是物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pszName*<br/>
接收字串，包含指定的物件名稱的 BSTR 的位址。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accName](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accname) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，以傳回您物件的名稱。

如需詳細資訊，請參閱 < [IAccessible::get_accName](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accname) Windows SDK 中。

##  <a name="get_accparent"></a>  CWnd::get_accParent

由架構呼叫以擷取物件之父代的 `IDispatch` 介面。

```
virtual HRESULT get_accParent(IDispatch** ppdispParent);
```

### <a name="parameters"></a>參數

*ppdispParent*<br/>
接收的父物件的位址`IDispatch`介面。 如果父代不存在，或如果子系無法存取其父代，變數會設為 NULL。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accParent](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accparent) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在大部分情況下，您不必覆寫這個函式。

如需詳細資訊，請參閱 < [IAccessible::get_accParent](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accparent) Windows SDK 中。

##  <a name="get_accrole"></a>  CWnd::get_accRole

由架構呼叫以擷取含有指定物件的角色描述資訊。

```
virtual HRESULT get_accRole(
    VARIANT varChild,
    VARIANT* pvarRole);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取角色資訊的物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pvarRole*<br/>
接收角色資訊。 請參閱*pvarRole*中[IAccessible::get_accRole](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accrole) Windows SDK 中。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::get_accRole`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::get_accRole](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accrole) Windows SDK 中。

##  <a name="get_accselection"></a>  CWnd::get_accSelection

由架構呼叫以擷取此物件的選取子物件。

```
virtual HRESULT get_accSelection(VARIANT* pvarChildren);
```

### <a name="parameters"></a>參數

*pvarChildren*<br/>
會接收子系會選取相關的資訊。 請參閱*pvarChildren*中[IAccessible::get_accSelection](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accselection) Windows SDK 中。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::get_accSelection`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::get_accSelection](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accselection) Windows SDK 中。

##  <a name="get_accstate"></a>  CWnd::get_accState

由架構呼叫以擷取指定物件的目前狀態。

```
virtual HRESULT get_accState(
    VARIANT varChild,
    VARIANT* pvarState);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取的狀態資訊的物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pvarState*<br/>
接收物件的狀態資訊。 請參閱*pvarState*中[IAccessible::get_accState](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accstate) Windows SDK 中。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**在`IAccessible::get_accState`Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::get_accState](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accstate) Windows SDK 中。

##  <a name="get_accvalue"></a>  CWnd::get_accValue

由架構呼叫以擷取指定物件的值。

```
virtual HRESULT get_accValue(
    VARIANT varChild,
    BSTR* pszValue);
```

### <a name="parameters"></a>參數

*varChild*<br/>
指定是否要擷取的值資訊的物件或物件的子元素之一。 這個參數可以是 CHILDID_SELF （若要取得物件的相關資訊） 或子系 ID （若要取得物件的子元素的相關資訊）。

*pszValue*<br/>
接收包含物件的目前值的當地語系化的字串的 BSTR 的位址。

### <a name="return-value"></a>傳回值

成功時，COM 錯誤碼失敗，會傳回 S_OK。 請參閱**傳回值**中[IAccessible::get_accValue](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accvalue) Windows SDK 中。

### <a name="remarks"></a>備註

此函式是 MFC 的一部分[Active Accessibility](/windows/desktop/WinAuto/microsoft-active-accessibility)支援。

在此函式會覆寫您`CWnd`-衍生類別，如果您有 nonwindowed 使用者介面項目 （以外無視窗 ActiveX 控制項，MFC 處理）。

如需詳細資訊，請參閱 < [IAccessible::get_accValue](/windows/desktop/api/oleacc/nf-oleacc-iaccessible-get_accvalue) Windows SDK 中。

##  <a name="getactivewindow"></a>  CWnd::GetActiveWindow

擷取使用中視窗的指標。

```
static CWnd* PASCAL GetActiveWindow();
```

### <a name="return-value"></a>傳回值

作用中視窗或 NULL，如果沒有任何視窗是作用中時呼叫。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

使用中的視窗是具有目前的輸入的焦點的視窗或明確設為作用中的視窗[SetActiveWindow](#setactivewindow)成員函式。

##  <a name="getancestor"></a>  CWnd::GetAncestor

擷取指定視窗的上階視窗物件。

```
CWnd* GetAncestor(UINT gaFlags) const;
```

### <a name="parameters"></a>參數

*gaFlags*<br/>
指定要擷取的祖系。 如需可能值的完整清單，請參閱 < [GetAncestor](/windows/desktop/api/winuser/nf-winuser-getancestor)。

### <a name="return-value"></a>傳回值

如果此函數成功，則傳回的值會是上階視窗物件的指標。 如果函式失敗，傳回的值會是 NULL。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetAncestor](/windows/desktop/api/winuser/nf-winuser-getancestor)、 Windows SDK 中所述。

##  <a name="getcapture"></a>  CWnd::GetCapture

擷取具有滑鼠捕捉的視窗。

```
static CWnd* PASCAL GetCapture();
```

### <a name="return-value"></a>傳回值

識別具有滑鼠捕捉的視窗。 如果沒有任何視窗具有滑鼠捕捉，它就會是 NULL。

傳回的值可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

只有一個視窗具有滑鼠捕捉任何給定的時間。 在視窗接收滑鼠擷取時[SetCapture](#setcapture)呼叫成員函式。 此視窗會收到滑鼠輸入，或有資料指標位於其框線。

##  <a name="getcaretpos"></a>  CWnd::GetCaretPos

擷取插入號的目前位置的用戶端座標，並傳回其作為`CPoint`。

```
static CPoint PASCAL GetCaretPos();
```

### <a name="return-value"></a>傳回值

[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，包含插入號位置的座標。

### <a name="remarks"></a>備註

插入號位置的用戶端座標中指定`CWnd`視窗。

##  <a name="getcheckedradiobutton"></a>  CWnd::GetCheckedRadioButton

擷取指定的群組中的目前選取的選項按鈕的識別碼。

```
int GetCheckedRadioButton(
    int nIDFirstButton,
    int nIDLastButton);
```

### <a name="parameters"></a>參數

*nIDFirstButton*<br/>
指定群組中的第一個選項按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中的最後一個選項按鈕的整數識別碼。

### <a name="return-value"></a>傳回值

已檢查的選項按鈕或 0，如果未選取的識別碼。

##  <a name="getclientrect"></a>  CWnd::GetClientRect

將複製的用戶端座標`CWnd`到結構的工作區所指*lpRect*。

```
void GetClientRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)或`CRect`物件，以接收的用戶端座標。 `left`和`top`成員將會是 0。 `right`和`bottom`成員將包含視窗的高度與寬度。

### <a name="remarks"></a>備註

工作區座標中指定的工作區的左上角和右下角邊角。 因為用戶端座標是相對於的左上角邊角`CWnd`工作區，左上角的座標為 (0，0)。

### <a name="example"></a>範例

  範例，請參閱[CWnd::IsIconic](#isiconic)。

##  <a name="getclipboardowner"></a>  CWnd::GetClipboardOwner

擷取剪貼簿的目前擁有者。

```
static CWnd* PASCAL GetClipboardOwner();
```

### <a name="return-value"></a>傳回值

識別擁有剪貼簿，此函式成功時的視窗。 否則，它可以是 NULL。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

即使目前並未擁有剪貼簿可以仍會包含資料。

##  <a name="getclipboardviewer"></a>  CWnd::GetClipboardViewer

擷取剪貼簿檢視器鏈結中的第一個視窗。

```
static CWnd* PASCAL GetClipboardViewer();
```

### <a name="return-value"></a>傳回值

識別目前負責顯示剪貼簿成功; 如果視窗（例如，如果沒有任何檢視器），否則為 NULL。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

##  <a name="getcontrolunknown"></a>  CWnd::GetControlUnknown

呼叫此成員函式可擷取至未知的 OLE 控制項的指標。

```
LPUNKNOWN GetControlUnknown();
```

### <a name="return-value"></a>傳回值

指標[IUnknown](/windows/desktop/api/unknwn/nn-unknwn-iunknown)介面所表示的 OLE 控制項`CWnd`物件。 如果此物件不代表 OLE 控制項，則傳回的值會是 NULL。

### <a name="remarks"></a>備註

您應該不會釋放這`IUnknown`指標。 一般而言，您會使用以取得特定介面的控制項。

所傳回的介面指標`GetControlUnknown`不參考計數。 請勿呼叫[iunknown:: Release](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release)指標除非您先前稱為[iunknown:: Addref](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref)在其上。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#96](../../mfc/reference/codesnippet/cpp/cwnd-class_35.cpp)]

##  <a name="getcurrentmessage"></a>  CWnd::GetCurrentMessage

傳回此視窗目前正在處理的訊息指標。 應該只呼叫時**上**<em>訊息</em>訊息處理常式成員函式。

```
static const MSG* PASCAL GetCurrentMessage();
```

### <a name="return-value"></a>傳回值

將指標傳回至[MSG](/windows/desktop/api/winuser/ns-winuser-tagmsg)目前正在處理結構，其中包含訊息的視窗。 應該只呼叫時**上**<em>訊息</em>處理常式。

### <a name="example"></a>範例

  範例，請參閱[CMDIFrameWnd::MDICascade](../../mfc/reference/cmdiframewnd-class.md#mdicascade)。

##  <a name="getdc"></a>  CWnd::GetDC

擷取以一般的指標、 類別或根據指定的類別樣式的工作區的私用的裝置內容`CWnd`。

```
CDC* GetDC();
```

### <a name="return-value"></a>傳回值

識別的裝置內容`CWnd`工作區如果成功，否則傳回值是 NULL。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

針對常見的裝置內容、`GetDC`擷取每次將預設屬性指派至內容。 類別和私用的內容，`GetDC`離開之前指派的屬性不變。 裝置內容可以用於後續的圖形裝置介面 (GDI) 函式，若要繪製工作區中。

裝置內容屬於視窗類別，除非[ReleaseDC](#releasedc)成員函式必須呼叫以繪製後釋出內容。

裝置內容屬於`CWnd`類別由`GetDC`成員函式如果 CS_CLASSDC、 CS_OWNDC 或 CS_PARENTDC 指定中的樣式為`WNDCLASS`結構註冊類別時。

##  <a name="getdcex"></a>  CWnd::GetDCEx

擷取的裝置內容控制代碼`CWnd`視窗。

```
CDC* GetDCEx(
    CRgn* prgnClip,
    DWORD flags);
```

### <a name="parameters"></a>參數

*prgnClip*<br/>
識別可能會結合用戶端視窗的可見區域的裁剪區域。

*flags*<br/>
可以有下列的預設值的其中一個：

- DCX_CACHE 傳回快取，而不是 OWNDC 或 CLASSDC 視窗裝置內容。 覆寫 CS_OWNDC 和 CS_CLASSDC。

- DCX_CLIPCHILDREN 排除所有的子視窗下方可見區域`CWnd`視窗。

- DCX_CLIPSIBLINGS 排除上述的所有同層級視窗的可見區域`CWnd`視窗。

- DCX_EXCLUDERGN 排除所識別的裁剪區域*prgnClip*從傳回的裝置內容的可見區域。

- 所識別的裁剪區域的 DCX_INTERSECTRGN 相交*prgnClip*內傳回的裝置內容的可見區域。

- DCX_LOCKWINDOWUPDATE 允許繪製即使沒有`LockWindowUpdate`呼叫，否則會排除此視窗的作用中。 這個值用於追蹤期間的繪圖。

- DCX_PARENTCLIP 會使用父視窗的可見區域，並忽略父視窗的 WS_CLIPCHILDREN 和 WS_PARENTDC 樣式的位元。 此值會設定裝置內容的原點的左上角`CWnd`視窗。

- DCX_WINDOW 視窗矩形，而不是用戶端矩形傳回對應的裝置內容。

### <a name="return-value"></a>傳回值

在指定的時段，如果函式成功，裝置內容否則為 NULL。

### <a name="remarks"></a>備註

裝置內容可以用於後續的 GDI 函式，若要繪製工作區中。

此函式，也就是延伸模組來[GetDC](/windows/desktop/api/winuser/nf-winuser-getdc)函式中，為應用程式提供更充分掌控如何及是否裁剪的裝置內容 視窗。

裝置內容所屬的視窗類別，除非[ReleaseDC](/windows/desktop/api/winuser/nf-winuser-releasedc)呼叫函式必須在 繪圖之後釋出內容。 因為只有五個常見的裝置內容可在任何指定時間，使其無法存取的裝置內容的其他應用程式頁面時，可能無法釋放裝置內容失敗。

若要取得的快取的裝置內容，應用程式必須指定[DCX_CACHE](/windows/desktop/api/winuser/nf-winuser-getdcex)。 如果未指定 DCX_CACHE 而視窗都不 CS_OWNDC 也[CS_CLASSDC](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)，此函數會傳回 NULL。

裝置內容中具有特殊的特性由[GetDCEx](/windows/desktop/api/winuser/nf-winuser-getdcex)函式的 CS_CLASSDC [CS_OWNDC](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)，或[CS_PARENTDC](/windows/desktop/api/winuser/ns-winuser-tagwndclassa) 中所指定的樣式[WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)結構註冊類別時。

如需有關這些特性的詳細資訊，請參閱說明`WNDCLASS`Windows SDK 中的結構。

##  <a name="getdcrendertarget"></a>  CWnd::GetDCRenderTarget

擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。

```
CDCRenderTarget* GetDCRenderTarget();
```

### <a name="return-value"></a>傳回值

裝置內容呈現在指定的視窗的目標，如果成功，函式否則為 NULL。

### <a name="remarks"></a>備註

##  <a name="getdescendantwindow"></a>  CWnd::GetDescendantWindow

呼叫此成員函式，以尋找子系所指定的識別碼。 指定的視窗

```
CWnd* GetDescendantWindow(
    int nID,
    BOOL bOnlyPerm = FALSE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要擷取的控制項或子視窗的識別碼。

*bOnlyPerm*<br/>
指定是否要傳回視窗可以是暫時的。 如果為 TRUE，可傳回只有一個永久的視窗;如果為 FALSE，此函數可以傳回暫時的視窗。 如需有關暫存的 windows，請參閱[技術的附註 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="return-value"></a>傳回值

指標`CWnd`物件，或如果不找到任何子視窗，則為 NULL。

### <a name="remarks"></a>備註

此成員函式會搜尋整個樹狀結構的子視窗，而不只是直接子系的視窗。

##  <a name="getdesktopwindow"></a>  CWnd::GetDesktopWindow

傳回的 Windows 桌面視窗。

```
static CWnd* PASCAL GetDesktopWindow();
```

### <a name="return-value"></a>傳回值

識別 Windows 桌面視窗。 這個指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

桌面視窗涵蓋整個畫面，並會在其頂端所有圖示和其他視窗繪製的區域。

##  <a name="getdlgctrlid"></a>  CWnd::GetDlgCtrlID

傳回任何子視窗的視窗或控制項 ID 值不只是，在對話方塊中的控制項。

```
int GetDlgCtrlID() const;
```

### <a name="return-value"></a>傳回值

數值識別碼`CWnd`子視窗，如果函式成功，否則為 0。

### <a name="remarks"></a>備註

由於最上層視窗不會有的識別碼值，這個函式的傳回值是無效如果`CWnd`成為最上層視窗。

### <a name="example"></a>範例

  範例，請參閱[CWnd::OnCtlColor](#onctlcolor)。

##  <a name="getdlgitem"></a>  CWnd::GetDlgItem

擷取在對話方塊中指定的控制項或子視窗或其他視窗的指標。

```
CWnd* GetDlgItem(int nID) const;

void GetDlgItem(
    int nID,
    HWND* phWnd) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要擷取的控制項或子視窗的識別碼。

*phWnd*<br/>
子視窗的指標。

### <a name="return-value"></a>傳回值

指定的控制項或子視窗的指標。 如果沒有任何控制項具有所指定的整數識別碼*nID*參數存在，則值為 NULL。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

通常會轉換成所識別的控制項型別時，傳回的指標*nID*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#97](../../mfc/reference/codesnippet/cpp/cwnd-class_36.cpp)]

##  <a name="getdlgitemint"></a>  CWnd::GetDlgItemInt

擷取所識別之控制項的文字*nID*。

```
UINT GetDlgItemInt(
    int nID,
    BOOL* lpTrans = NULL,
    BOOL bSigned = TRUE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要轉譯的對話方塊控制項的整數識別碼。

*lpTrans*<br/>
接收轉譯的旗標的布林值變數指向。

*bSigned*<br/>
指定是否要簽署要擷取的值。

### <a name="return-value"></a>傳回值

指定對話方塊中的項目文字的已翻譯的值。 0 是有效的傳回值，因為*lpTrans*必須用來偵測錯誤。 如果需要帶正負號的傳回值，則將它轉換成**int**型別。

函式會傳回 0，表示已轉換的數字大於 INT_MAX （適用於帶正負號的數字） 或 UINT_MAX （適用於不帶正負號）。

發生錯誤時，遇到非數字字元及超過上述的最大值，例如`GetDlgItemInt`會將 0 複製到所指向的位置*lpTrans*。 如果沒有任何錯誤， *lpTrans*接收非零值。 如果*lpTrans*是 NULL，`GetDlgItemInt`不會在錯誤的相關警告。

### <a name="remarks"></a>備註

就會在指定的對話方塊中指定的控制項文字轉譯成整數值，移除任何多餘的空格開頭的文字，並將轉換的十進位數字。 當它到達文字末端，或遇到任何非數字的字元時，它會停止轉譯。

如果*bSigned*為 TRUE，`GetDlgItemInt`會檢查是否有減號 （-） 開頭的文字，並將文字轉譯成帶正負號的數字。 否則，它會建立不帶正負號的值。

它會傳送[WM_GETTEXT](/windows/desktop/winmsg/wm-gettext)至控制項的訊息。

##  <a name="getdlgitemtext"></a>  CWnd::GetDlgItemText

呼叫此成員函式可擷取的標題或在對話方塊中控制項相關聯的文字。

```
int GetDlgItemText(
    int nID,
    LPTSTR lpStr,
    int nMaxCount) const;

int GetDlgItemText(
    int nID,
    CString& rString) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要擷取其標題之控制項的整數識別碼。

*lpStr*<br/>
接收控制項的標題或文字的緩衝區指標。

*nMaxCount*<br/>
指定要複製到字串的長度上限 （以字元為單位） *lpStr*。 如果字串的長度超過*nMaxCount*，則會遭到截斷。

*rString*<br/>
參考[CString](../../atl-mfc-shared/reference/cstringt-class.md)。

### <a name="return-value"></a>傳回值

指定實際的複製到緩衝區，不包括結束的 null 字元的字元數。 如果文字不會複製，則值為 0。

### <a name="remarks"></a>備註

`GetDlgItemText`成員函式會將文字複製到所指向的位置*lpStr* ，並傳回它會將複製的位元組數目的計數。

##  <a name="getdsccursor"></a>  CWnd::GetDSCCursor

呼叫此成員函式，來擷取基礎資料來源控制項的資料來源、 使用者名稱、 密碼和 SQL 屬性所定義的資料指標的指標。

```
IUnknown* GetDSCCursor();
```

### <a name="return-value"></a>傳回值

定義資料來源控制項的資料指標的指標。 MFC 會負責呼叫`AddRef`指標。

### <a name="remarks"></a>備註

若要設定的複雜資料繫結控制項，例如資料繫結方格控制項 ICursor 屬性中使用傳回的指標。 資料來源控制項不會變成作用直到第一個繫結的控制項要求其資料指標。 這種情形是明確地呼叫`GetDSCCursor`或以隱含方式由 MFC 繫結管理員。 在任一情況下，您可以強制藉由呼叫變成作用中的資料來源控制項`GetDSCCursor`然後呼叫`Release`若要傳回的指標上`IUnknown`。 啟用會嘗試連接到基礎資料來源的資料來源控制項。 傳回的指標可能用於下列內容：

### <a name="example"></a>範例

[!code-cpp[NVC_MFC_AxDataBinding#5](../../mfc/reference/codesnippet/cpp/cwnd-class_37.cpp)]

##  <a name="getdynamiclayout"></a>  CWnd::GetDynamicLayout

擷取動態配置管理員物件的指標。

```
CMFCDynamicLayout* GetDynamicLayout();
```

### <a name="return-value"></a>傳回值

動態配置管理員物件的指標，或是如果未啟用動態配置，則為 NULL。

### <a name="remarks"></a>備註

視窗物件擁有及管理傳回的指標存留期，因此它只應該用來存取物件；請勿永久刪除指標或儲存指標。

##  <a name="getexstyle"></a>  CWnd::GetExStyle

傳回視窗的延伸樣式。

```
DWORD GetExStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的延伸樣式。 如需在 MFC 中使用延伸的視窗樣式的詳細資訊，請參閱[延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

##  <a name="getfocus"></a>  CWnd::GetFocus

擷取的指標`CWnd`目前具有輸入的焦點。

```
static CWnd* PASCAL GetFocus();
```

### <a name="return-value"></a>傳回值

具有目前焦點，則為 NULL，如果沒有焦點視窗的視窗的指標。

該指標可能是暫時性的，因此不應該儲存供日後使用。

##  <a name="getfont"></a>  CWnd::GetFont

將 WM_GETFONT 訊息傳送至視窗，以擷取目前的字型。

```
CFont* GetFont() const;
```

### <a name="return-value"></a>傳回值

指標[CFont](../../mfc/reference/cfont-class.md)附加到視窗的目前字型的物件。

### <a name="remarks"></a>備註

這個方法沒有任何作用，除非視窗處理 WM_GETFONT 的訊息。 MFC 類別衍生自`CWnd`處理此訊息，因為它們會附加至包含 WM_GETFONT 訊息的訊息處理常式的預先定義的視窗類別。 若要使用此方法中，您可以從衍生的類別`CWnd`必須定義 WM_GETFONT 訊息的方法處理常式。

##  <a name="getforegroundwindow"></a>  CWnd::GetForegroundWindow

讓指標回到前景視窗 （使用者目前使用的視窗）。

```
static CWnd* PASCAL GetForegroundWindow();
```

### <a name="return-value"></a>傳回值

前景視窗的指標。 這可能是暫存`CWnd`物件。

### <a name="remarks"></a>備註

前景視窗只適用於最上層視窗 （框架視窗或對話方塊）。

##  <a name="geticon"></a>  CWnd::GetIcon

呼叫此成員函式，以取得可能是大 (32 x 32) 的控制代碼或小型 (16 x 16) 圖示，控制代碼，如所示*bBigIcon*。

```
HICON GetIcon(BOOL bBigIcon) const;
```

### <a name="parameters"></a>參數

*bBigIcon*<br/>
指定 32 像素 32 像素圖示，如果為 TRUE;指定的 16 像素 16 像素圖示，如果為 FALSE。

### <a name="return-value"></a>傳回值

圖示控制代碼。 如果不成功，會傳回 NULL。

##  <a name="getlastactivepopup"></a>  CWnd::GetLastActivePopup

判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。

```
CWnd* GetLastActivePopup() const;
```

### <a name="return-value"></a>傳回值

識別最活躍的快顯視窗。 傳回的值將是視窗本身，如果下列任一條件成立：

- 視窗本身是最近的作用。

- 視窗並未擁有任何快顯視窗。

- 視窗不是最上層的視窗，或屬於另一個視窗。

該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="example"></a>範例

  範例，請參閱[CWnd::FindWindow](#findwindow)。

##  <a name="getlayeredwindowattributes"></a>  CWnd::GetLayeredWindowAttributes

擷取分層視窗的不透明和透明色鍵。

```
BOOL GetLayeredWindowAttributes(
    COLORREF* pcrKey,
    BYTE* pbAlpha,
    DWORD* pdwFlags) const;
```

### <a name="parameters"></a>參數

*pcrKey*<br/>
接收撰寫分層的視窗時要使用的透明色彩索引鍵為 COLORREF 值的指標。 以此種色彩視窗所繪製的所有像素會是透明的。 如果不需要引數，這可以是 NULL。

*pbAlpha*<br/>
接收用來描述層疊視窗的不透明度的 Alpha 值的位元組指標。 當變數所參考*pbAlpha*是 0，則是完全透明的視窗。 當變數所參考*pbAlpha*為 255，視窗是不透明。 如果不需要引數，這可以是 NULL。

*pdwFlags*<br/>
Dword 接收分層旗標的指標。 如果不需要引數，這可以是 NULL。 如需可能值的完整清單，請參閱 < [GetLayeredWindowAttributes](/windows/desktop/api/winuser/nf-winuser-getlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetLayeredWindowAttributes](/windows/desktop/api/winuser/nf-winuser-getlayeredwindowattributes)、 Windows SDK 中所述。

##  <a name="getmenu"></a>  CWnd::GetMenu

擷取變數的指標，此視窗的功能表。

```
CMenu* GetMenu() const;
```

### <a name="return-value"></a>傳回值

識別功能表。 此值為 NULL，如果`CWnd`有沒有功能表。 如果未定義傳回的值，為`CWnd`是子視窗。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

此函式不應為子視窗因為它們不會有功能表。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#98](../../mfc/reference/codesnippet/cpp/cwnd-class_38.cpp)]

##  <a name="getmenubarinfo"></a>  CWnd::GetMenuBarInfo

擷取指定的功能表列的相關資訊。

```
BOOL GetMenuBarInfo(
    LONG idObject,
    LONG idItem,
    PMENUBARINFO pmbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 如需可能值的清單，請參閱 < [GetMenuBarInfo](/windows/desktop/api/winuser/nf-winuser-getmenubarinfo)。

*idItem*<br/>
指定要擷取資訊的項目。 如果此參數為零，則函式會擷取功能表本身的相關資訊。 如果這個參數是 1，函式擷取相關資訊的第一個項目 功能表等等。

*pmbi*<br/>
指標[MENUBARINFO](/windows/desktop/api/winuser/ns-winuser-tagmenubarinfo)接收資訊的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetMenuBarInfo](/windows/desktop/api/winuser/nf-winuser-getmenubarinfo)、 Windows SDK 中所述。

##  <a name="getnextdlggroupitem"></a>  CWnd::GetNextDlgGroupItem

搜尋上一個或下一個控制項 對話方塊中的控制項群組內。

```
CWnd* GetNextDlgGroupItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgGroupItem(
    COleControlSiteOrWnd* pCurSiteOrWnd = NULL) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
識別要用做為起點，來搜尋的控制項。

*bPrevious*<br/>
指定要搜尋控制項群組，在對話方塊中的函式的方式。 如果為 TRUE，函式會搜尋上一個控制項中群組;如果為 FALSE，它會搜尋在群組中的下一個控制項。

*pCurSiteOrWnd*<br/>
識別`COleControlSiteOrWnd`控制項。 如需詳細資訊`COleControlSiteOrWnd`，請參閱 <<c2>  **備註**。

### <a name="return-value"></a>傳回值

上一個或下一個控制項中群組的成員函式成功時的指標。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

控制項群組的開頭所建立的控制項[WS_GROUP](styles-used-by-mfc.md#window-styles)樣式和結尾不以 WS_GROUP 樣式建立的最後一個控制項。

根據預設，`GetNextDlgGroupItem`成員函式會傳回群組中的下一個控制項的指標。 如果*pWndCtl*識別群組中的第一個控制項並*bPrevious*為 TRUE，`GetNextDlgGroupItem`傳回群組中的最後一個控制項的指標。

> [!NOTE]
> 因為 MFC 支援無視窗的 ActiveX 控制項、 標準 ActiveX 控制項和 windows，所以不會再參考控制項的 HWND 只就夠了。 `COleControlSiteOrWnd`物件包含物件識別的視窗型 ActiveX 控制項、 無視窗的 ActiveX 控制項或視窗，如下所示的資訊：

|控制項或視窗型別|識別資訊|
|----------------------------|-----------------------------|
|視窗型 ActiveX 控制項|包含 HWND，並將相關聯[COleControlSite](../../mfc/reference/colecontrolsite-class.md)與它的物件。 `m_hWnd`隸屬`COleControlSiteOrWnd`設定為控制項的 HWND 和`m_pSite`成員指向控制項的`COleControlSite`。|
|無視窗的 ActiveX 控制項|不包含任何 HWND。 `m_pSite`隸屬`COleControlSiteOrWnd`指向控制項的`COleControlSite`，和`m_hWnd`成員會是 NULL。|
|標準的視窗|包含只 HWND。 `m_hWnd`隸屬`COleControlSiteOrWnd`設定為視窗的 HWND 和`m_pSite`成員會是 NULL。|

##  <a name="getnextdlgtabitem"></a>  CWnd::GetNextDlgTabItem

擷取使用所建立的第一個控制項指標[WS_TABSTOP](styles-used-by-mfc.md#window-styles)樣式，前面或後面指定的控制項。

```
CWnd* GetNextDlgTabItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgTabItem(
    COleControlSiteOrWnd* pCurSiteOrWnd,
    BOOL bPrevious) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
識別要用做為起點，來搜尋的控制項。

*pCurSiteOrWnd*<br/>
識別`COleControlSiteOrWnd`控制項。 如需詳細資訊`COleControlSiteOrWnd`，請參閱 < [CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)。

*bPrevious*<br/>
指定要搜尋對話方塊中的函式的方式。 如果為 TRUE，函式會搜尋對話方塊中，在上一個控制項如果為 FALSE，它會搜尋下一個控制項。

### <a name="return-value"></a>傳回值

成員函式成功時，具有 WS_TABSTOP 樣式的上一個或下一步 控制項的指標。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

如需詳細資訊`COleControlSiteOrWnd`，請參閱 < [CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)。

##  <a name="getnextwindow"></a>  CWnd::GetNextWindow

搜尋的視窗管理員清單中的 下一步 （或先前） 視窗。

```
CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
```

### <a name="parameters"></a>參數

*nFlag*<br/>
指定的函式是否傳回下一個視窗或上一個視窗的指標。 它可以是任一 GW_HWNDNEXT，傳回接下來的視窗`CWnd`視窗管理員清單中，或 GW_HWNDPREV，傳回上一個視窗的視窗管理員清單的物件。

### <a name="return-value"></a>傳回值

識別下一個 （或先前） 視窗的視窗管理員清單成員函式是否成功。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

視窗管理員清單包含所有最上層視窗、 其相關聯的子視窗和任何子視窗的子視窗的項目。

如果`CWnd`是最上層的視窗時，函式搜尋下一個 （或先前） 最上層的視窗; 如果`CWnd`是子視窗，函式搜尋下一個 （或先前） 子視窗。

##  <a name="getolecontrolsite"></a>  CWnd::GetOleControlSite

擷取指定的 ActiveX 控制項的自訂網站。

```
COleControlSite* GetOleControlSite(UINT idControl) const;
```

### <a name="parameters"></a>參數

*idControl*<br/>
ActiveX 控制項的 ID。

##  <a name="getopenclipboardwindow"></a>  CWnd::GetOpenClipboardWindow

擷取目前已開啟剪貼簿的視窗控制代碼。

```
static CWnd* PASCAL GetOpenClipboardWindow();
```

### <a name="return-value"></a>傳回值

如果函式成功，目前已開啟剪貼簿的視窗控制代碼否則為 NULL。

##  <a name="getowner"></a>  CWnd::GetOwner

擷取視窗的擁有者的指標。

```
CWnd* GetOwner() const;
```

### <a name="return-value"></a>傳回值

          `CWnd` 物件的指標。

### <a name="remarks"></a>備註

如果視窗有沒有擁有者，則會傳回預設的父視窗物件的指標。 請注意從父子式方面，在幾個重要層面，不同的擁有者和擁有之間的關聯性。 例如，使用父視窗會侷限於它的父視窗工作區。 擁有的 windows 可以在任何位置中繪製，在桌面上。

此函式擁有權證明是不同的擁有權證明[GetWindow](/windows/desktop/api/winuser/nf-winuser-getwindow)。

##  <a name="getparent"></a>  CWnd::GetParent

呼叫此函式來取得子視窗的父視窗 （如果有的話） 的指標。

```
CWnd* GetParent() const;
```

### <a name="return-value"></a>傳回值

請參閱中的傳回值 」 一節[GetParent](/windows/desktop/api/winuser/nf-winuser-getparent) Windows SDK 中。

### <a name="remarks"></a>備註

`GetParent`函式會傳回指標的直接父系 （若有的話）。 相反地， [GetParentOwner](#getparentowner)函式傳回不是子視窗 （不一定 WS_CHILD 樣式） 的最直接父系或擁有者視窗的指標。 如果您有子視窗內的子視窗`GetParent`和`GetParentOwner`傳回不同的結果。

##  <a name="getparentframe"></a>  CWnd::GetParentFrame

呼叫此成員函式可擷取父框架視窗。

```
CFrameWnd* GetParentFrame() const;
```

### <a name="return-value"></a>傳回值

如果成功，框架視窗的指標否則為 NULL。

### <a name="remarks"></a>備註

此成員函式會搜尋父鏈結，直到[CFrameWnd](../../mfc/reference/cframewnd-class.md) （或衍生類別中） 找到物件。

##  <a name="getparentowner"></a>  CWnd::GetParentOwner

呼叫此成員函式，以取得子視窗的父視窗或主控視窗的指標。

```
CWnd* GetParentOwner() const;
```

### <a name="return-value"></a>傳回值

          `CWnd` 物件的指標。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`GetParentOwner` 傳回不是子視窗 （不一定 WS_CHILD 樣式） 的最直接父系或擁有者視窗的指標。 目前視窗中，擁有者可以將與[出現了 SetOwner](#setowner)。 根據預設，視窗的父代是其擁有者。

相反地， [GetParent](#getparent)函式會傳回指標的直接父系，不論是否為子視窗。 如果您有子視窗內的子視窗`GetParent`和`GetParentOwner`傳回不同的結果。

##  <a name="getproperty"></a>  CWnd::GetProperty

呼叫此成員函式，以取得所指定的 ActiveX 控制項屬性*dwDispID*。

```
void GetProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    void* pvProp)const;
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
識別要擷取的屬性。

*vtProp*<br/>
指定要擷取屬性的型別。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvProp*<br/>
將這個變數的位址會接收屬性的值。 它必須符合所指定的型別*vtProp*。

### <a name="remarks"></a>備註

`GetProperty` 傳回值，透過*pvProp*。

> [!NOTE]
> 此函式應該只在呼叫`CWnd`物件，表示 ActiveX 控制項。

如需這個成員函式使用 ActiveX 控制項容器的詳細資訊，請參閱文章[ActiveX 控制項容器：程式設計 ActiveX 控制項容器中的 ActiveX 控制項](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

##  <a name="getrendertarget"></a>  CWnd::GetRenderTarget

取得與此視窗相關聯的呈現目標。

```
CHwndRenderTarget* GetRenderTarget();
```

### <a name="return-value"></a>傳回值

呈現目標或 NULL 指標。

##  <a name="getsafehwnd"></a>  CWnd::GetSafeHwnd

傳回`m_hWnd`，則為 NULL 如果**這**指標為 NULL。

```
HWND GetSafeHwnd() const;
```

### <a name="return-value"></a>傳回值

傳回視窗的視窗控制代碼。 如果傳回 NULL`CWnd`不會附加到視窗或如果它搭配 NULL`CWnd`指標。

### <a name="example"></a>範例

  範例，請參閱[CWnd::SubclassWindow](#subclasswindow)。

##  <a name="getsafeowner"></a>  CWnd::GetSafeOwner

呼叫此成員函式，以擷取應用於對話方塊的 [擁有者] 視窗或其他的強制回應視窗。

```
static CWnd* GetSafeOwner(
    CWnd* pParent = NULL,
    HWND* pWndTop = NULL);
```

### <a name="parameters"></a>參數

*pParent*<br/>
父代指標`CWnd`視窗。 可以是 NULL。

*pWndTop*<br/>
目前位於最上方視窗的指標。 可以是 NULL。

### <a name="return-value"></a>傳回值

指定視窗的安全擁有者指標。

### <a name="remarks"></a>備註

安全的擁有者是第一個非子系的父視窗的*pParent*。 如果*pParent*是 NULL，執行緒的主視窗 (透過擷取[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)) 用來尋找擁有者。

> [!NOTE]
> 架構本身會使用此函式，來決定正確的主控視窗的對話方塊和屬性工作表，不指定擁有者。

##  <a name="getscrollbarctrl"></a>  CWnd::GetScrollBarCtrl

呼叫此成員函式，來取得指向指定的同層級捲軸或分隔器視窗。

```
virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸類型。 參數可以採用下列值之一：

- SB_HORZ 擷取水平捲軸的位置。

- SB_VERT 擷取的垂直捲軸的位置。

### <a name="return-value"></a>傳回值

同層級捲軸控制項或若無則為 NULL。

### <a name="remarks"></a>備註

此成員函式無法運作時的 WS_HSCROLL 或 WS_VSCROLL 位元會設定在視窗的建立期間建立的捲軸上。 `CWnd`此函式的實作只會傳回 NULL。 衍生類別，例如`CView`，實作所述的功能。

##  <a name="getscrollbarinfo"></a>  CWnd::GetScrollBarInfo

擷取所指定之捲軸的相關資訊。

```
BOOL GetScrollBarInfo(
    LONG idObject,
    PSCROLLBARINFO psbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 如需可能值的清單，請參閱 < [GetScrollBarInfo](/windows/desktop/api/winuser/nf-winuser-getscrollbarinfo)。

*psbi*<br/>
指標[SCROLLBARINFO](/windows/desktop/api/winuser/ns-winuser-tagscrollbarinfo)接收資訊的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetScrollBarInfo](/windows/desktop/api/winuser/nf-winuser-getscrollbarinfo)、 Windows SDK 中所述。

##  <a name="getscrollinfo"></a>  CWnd::GetScrollInfo

呼叫此成員函式，來擷取資訊的`SCROLLINFO`結構維護的捲軸相關。

```
BOOL GetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    UINT nMask = SIF_ALL);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果是中, 非工作區的一部分*nBar*也會指出是否捲軸置於水平、 垂直或兩者。 它必須是下列其中一項：

- SB_CTL 擷取捲軸控制項的參數。 `m_hWnd`資料成員必須是捲軸控制項的控制代碼。

- SB_HORZ 擷取視窗的標準的水平捲軸的參數。

- SB_VERT 擷取視窗的標準的垂直捲軸的參數。

*lpScrollInfo*<br/>
指標[SCROLLINFO](/windows/desktop/api/winuser/ns-winuser-tagscrollinfo)結構。 請參閱 Windows SDK，如需有關這個結構。

*nMask*<br/>
指定要擷取的捲軸列參數。 預設值會指定 SIF_PAGE、 SIF_POS、 SIF_TRACKPOS 和 SIF_RANGE 的組合。 請參閱`SCROLLINFO`如需詳細資訊*nMask*值。

### <a name="return-value"></a>傳回值

如果訊息中擷取的任何值，傳回為 TRUE。 否則，它就是 FALSE。

### <a name="remarks"></a>備註

`GetScrollInfo` 可讓應用程式使用 32 位元捲動位置。

[SCROLLINFO](/windows/desktop/api/winuser/ns-winuser-tagscrollinfo)結構包含捲軸，包括最小值和最大捲動位置、 頁面大小和捲軸方塊 （捲動方塊） 的位置的相關資訊。 請參閱`SCROLLINFO`結構變更結構的預設值的詳細資訊的 Windows SDK 中的主題。

MFC Windows 訊息，表示捲軸位置的處理常式[CWnd::OnHScroll](#onhscroll)並[CWnd::OnVScroll](#onvscroll)，提供僅 16 位元的位置資料。 `GetScrollInfo` 和`SetScrollInfo`提供 32 位元的捲軸位置資料。 因此，應用程式可以呼叫`GetScrollInfo`同時處理`CWnd::OnHScroll`或`CWnd::OnVScroll`取得 32 位元的捲軸位置資料。

##  <a name="getscrolllimit"></a>  CWnd::GetScrollLimit

呼叫此成員函式可擷取捲軸的最大捲動位置。

```
int GetScrollLimit(int nBar);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸類型。 參數可以採用下列值之一：

- SB_HORZ 擷取水平捲軸的捲動限制。

- SB_VERT 擷取垂直捲軸的捲動的限制。

### <a name="return-value"></a>傳回值

指定如果成功則為捲軸的最大值的位置否則為 0。

##  <a name="getscrollpos"></a>  CWnd::GetScrollPos

擷取捲軸的捲動方塊的目前位置。

```
int GetScrollPos(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的捲軸。 參數可以採用下列值之一：

- SB_HORZ 擷取水平捲軸的位置。

- SB_VERT 擷取的垂直捲軸的位置。

### <a name="return-value"></a>傳回值

指定捲動方塊的目前位置中的捲軸，如果成功，否則為 0。

### <a name="remarks"></a>備註

目前的位置會取決於目前的捲動範圍的相對值。 比方說，如果捲動的範圍是 50 到 100 之間，捲軸方塊位於中間列目前位置會是 75。

##  <a name="getscrollrange"></a>  CWnd::GetScrollRange

將給定的捲軸的目前最小和最大捲軸位置複製到指定的位置*lpMinPos*並*lpMaxPos*。

```
void GetScrollRange(
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的捲軸。 參數可以採用下列值之一：

- SB_HORZ 擷取水平捲軸的位置。

- SB_VERT 擷取的垂直捲軸的位置。

*lpMinPos*<br/>
指向要接收的最小位置的整數變數。

*lpMaxPos*<br/>
指向要接收的最大位置的整數變數。

### <a name="remarks"></a>備註

如果`CWnd`沒有捲軸，則`GetScrollRange`成員函式會複製到 0 *lpMinPos*並*lpMaxPos*。

標準的捲軸的預設範圍是 0 到 100 之間。 捲軸控制項的預設範圍是空的 （這兩個值是 0）。

##  <a name="getstyle"></a>  CWnd::GetStyle

傳回目前的視窗樣式。

```
DWORD GetStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的樣式。 如需在 MFC 中使用的視窗樣式的詳細資訊，請參閱[的視窗樣式](styles-used-by-mfc.md#window-styles)。

##  <a name="getsystemmenu"></a>  CWnd::GetSystemMenu

可讓應用程式存取控制功能表以進行複製和修改。

```
CMenu* GetSystemMenu(BOOL bRevert) const;
```

### <a name="parameters"></a>參數

*bRevert*<br/>
指定要採取的動作。 如果*bRevert*為 FALSE，`GetSystemMenu`傳回一份目前正在使用中的 [控制] 功能表的控制代碼。 此複本一開始等同於 [控制] 功能表，但是可以修改。 如果*bRevert*為 TRUE，`GetSystemMenu`重設回預設狀態的 [控制] 功能表。 先前，可能已經過修改，來控制 功能表中，如果的話損毀。 在此情況下未傳回的值。

### <a name="return-value"></a>傳回值

識別控制項功能表中的複本，如果*bRevert*為 FALSE。 如果*bRevert*為 TRUE，傳回的值會是未定義。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

不使用任何視窗`GetSystemMenu`製作自己的複本，控制項的功能表接收標準的 [控制] 功能表。

所傳回的指標`GetSystemMenu`成員函式可以搭配[CMenu::AppendMenu](../../mfc/reference/cmenu-class.md#appendmenu)， [CMenu::InsertMenu](../../mfc/reference/cmenu-class.md#insertmenu)，或[CMenu::ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu)函式變更 [控制] 功能表。

[控制] 功能表一開始會包含使用 SC_CLOSE、 SC_MOVE，等 SC_SIZE 各種識別碼值識別的項目。 在 [控制] 功能表上的項目產生[WM_SYSCOMMAND](#onsyscommand)訊息。 所有預先定義的控制項功能表項目有大於 0xF000 的 ID 編號。 如果應用程式會將項目新增至 [控制] 功能表中，它應該使用小於 F000 識別碼數字。

Windows 可能會自動使項目無法使用標準的 [控制] 功能表上。 `CWnd` 可以自己選取項目或無法使用藉由完成回應[WM_INITMENU](#oninitmenu)顯示任何功能表之前傳送的訊息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#99](../../mfc/reference/codesnippet/cpp/cwnd-class_39.cpp)]

##  <a name="gettitlebarinfo"></a>  CWnd::GetTitleBarInfo

擷取指定之標題列的相關資訊。

```
BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;
```

### <a name="parameters"></a>參數

*pti*<br/>
指標[TITLEBARINFO](/windows/desktop/api/winuser/ns-winuser-tagtitlebarinfo)接收資訊的結構。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetTitleBarInfo](/windows/desktop/api/winuser/nf-winuser-gettitlebarinfo)、 Windows SDK 中所述。

##  <a name="gettoplevelframe"></a>  CWnd::GetTopLevelFrame

呼叫此成員函式，以擷取視窗的上層框架視窗中，如果有的話。

```
CFrameWnd* GetTopLevelFrame() const;
```

### <a name="return-value"></a>傳回值

識別視窗的最上層框架視窗。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

如果`CWnd`沒有附加的視窗，或不是其最上層的父代[CFrameWnd](../../mfc/reference/cframewnd-class.md)-衍生物件，此函式會傳回 NULL。

##  <a name="gettoplevelowner"></a>  CWnd::GetTopLevelOwner

呼叫此成員函式可擷取的最上層視窗。

```
CWnd* GetTopLevelOwner() const;
```

### <a name="return-value"></a>傳回值

識別的最上層視窗。 傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

最上層的視窗是視窗，是在桌面的子系。 如果`CWnd`沒有附加的視窗中，此函數會傳回 NULL。

##  <a name="gettoplevelparent"></a>  CWnd::GetTopLevelParent

呼叫此成員函式，以擷取視窗的最上層的父代。

```
CWnd* GetTopLevelParent() const;
```

### <a name="return-value"></a>傳回值

識別視窗的最上層的父視窗。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

`GetTopLevelParent` 類似於[GetTopLevelFrame](#gettoplevelframe)並[GetTopLevelOwner](#gettoplevelowner); 不過，它會忽略目前的擁有者視窗設定的值。

##  <a name="gettopwindow"></a>  CWnd::GetTopWindow

所屬的最上層的子視窗的搜尋`CWnd`。

```
CWnd* GetTopWindow() const;
```

### <a name="return-value"></a>傳回值

識別在最上層的子視窗`CWnd`子視窗的連結的清單。 如果沒有子視窗存在，則值會是 NULL。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

如果`CWnd`沒有子系，此函數會傳回 NULL。

##  <a name="getupdaterect"></a>  CWnd::GetUpdateRect

擷取完全圍住更新區域的最小矩形座標。

```
BOOL GetUpdateRect(
    LPRECT lpRect,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向`CRect`物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)將要接收的更新，包含更新區域的用戶端座標。

將此參數設定為 NULL 則判斷更新區域是否存在於`CWnd`。 如果*lpRect*是 NULL，`GetUpdateRect`成員函式傳回非零值，如果更新區域存在，而且如果有一個 0 並不會。 這會提供一個方式來判斷是否 WM_PAINT 訊息產生無效的區域。 沒有設定此參數為 NULL Windows 3.0 版和更早版本。

*bErase*<br/>
指定是否要清除的背景更新區域中。

### <a name="return-value"></a>傳回值

指定的更新區域的狀態。 值為非零值，如果更新區域不是空的。否則為 0。

如果*lpRect*參數設為 NULL，則傳回值是可更新區域有非零，否則為 0。

### <a name="remarks"></a>備註

如果`CWnd`建立 CS_OWNDC 樣式與對應模式不是 MM_TEXT，`GetUpdateRect`成員函式會讓矩形的邏輯座標。 否則，`GetUpdateRect`提供在用戶端矩形座標。 如果沒有任何更新區域，`GetUpdateRect`設定為空白 （將所有座標為 0） 的矩形。

*BErase*參數會指定是否`GetUpdateRect`應該清除更新區域的背景。 如果*bErase*為 TRUE，且更新區域不是空的會清除的背景。 若要清除的背景`GetUpdateRect`傳送[WM_ERASEBKGND](#onerasebkgnd)訊息。

擷取更新矩形[BeginPaint](#beginpaint)成員函式等同於擷取`GetUpdateRect`成員函式。

`BeginPaint`成員函式會自動驗證更新區域中，因此先呼叫`GetUpdateRect`的呼叫之後立即進行`BeginPaint`擷取空的更新區域。

##  <a name="getupdatergn"></a>  CWnd::GetUpdateRgn

會更新區域擷取到所識別的區域*pRgn*。

```
int GetUpdateRgn(
    CRgn* pRgn,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
識別更新區域。

*bErase*<br/>
指定是否將清除的背景，並將繪製子視窗的非工作區。 如果值為 FALSE，會不完成任何繪圖。

### <a name="return-value"></a>傳回值

指定短整數旗標，指出產生的區域類型。 值可以採取下列其中一項動作：

- SIMPLEREGION 區域沒有任何重疊的框線。

- COMPLEXREGION 區域具有重疊的框線。

- NULLREGION 區域是空的。

- 沒有任何區域所建立的錯誤。

### <a name="remarks"></a>備註

此區域的座標是相對於左上角 （在 工作區座標中）。

[BeginPaint](#beginpaint)成員函式會自動驗證更新區域中，因此對`GetUpdateRgn`的呼叫之後立即進行`BeginPaint`擷取空的更新區域。

##  <a name="getwindow"></a>  CWnd::GetWindow

讓指標回到視窗，要求或若無則為 NULL。

```
CWnd* GetWindow(UINT nCmd) const;
```

### <a name="parameters"></a>參數

*nCmd*<br/>
指定之間的關聯性`CWnd`和傳回的視窗。 它可以採取下列值之一：

- GW_CHILD 識別`CWnd`第一個子視窗。

- GW_HWNDFIRST 如果`CWnd`為子視窗，會傳回第一個同層級視窗。 否則會傳回第一個最上層的視窗清單中。

- GW_HWNDLAST 如果`CWnd`為子視窗，會傳回最後一個同層級視窗。 否則會傳回最後一個最上層的視窗清單中。

- GW_HWNDNEXT 傳回視窗管理員清單上的下一個視窗。

- GW_HWNDPREV 視窗管理員清單上，傳回上一個視窗。

- GW_OWNER 識別`CWnd`擁有者。

### <a name="return-value"></a>傳回值

傳回的指標可能是暫時性的不應該儲存供稍後使用。

##  <a name="getwindowcontexthelpid"></a>  CWnd::GetWindowContextHelpId

如果任何項目，與視窗產生關聯，請呼叫來擷取說明內容識別碼，此成員函式。

```
DWORD GetWindowContextHelpId() const;
```

### <a name="return-value"></a>傳回值

說明內容識別碼。 如果視窗有 none，則會傳回 0。

##  <a name="getwindowedchildcount"></a>  CWnd::GetWindowedChildCount

呼叫此成員函式，以擷取相關聯的子視窗的數目。

```
long GetWindowedChildCount();
```

### <a name="return-value"></a>傳回值

與相關聯的子視窗數目`CWnd`物件。

##  <a name="getwindowdc"></a>  CWnd::GetWindowDC

擷取整個視窗中，包括標題列、 功能表和捲軸的顯示內容。

```
CDC* GetWindowDC();
```

### <a name="return-value"></a>傳回值

識別指定的視窗顯示內容，如果成功，函式否則為 NULL。

傳回的指標可能是暫時性的不應該儲存供稍後使用。 [ReleaseDC](#releasedc)應該每次成功呼叫一次呼叫`GetWindowDC`。

### <a name="remarks"></a>備註

視窗顯示內容允許在任何地方繪製`CWnd`，因為內容的原點的左上角`CWnd`而不是工作區。

每次它擷取內容時，會顯示內容指派預設屬性。 先前的屬性都會遺失。

`GetWindowDC` 適用於在特殊的繪製效果`CWnd`非工作區。 不建議在任何視窗非工作區域的繪製。

[GetSystemMetrics](/windows/desktop/api/winuser/nf-winuser-getsystemmetrics) Windows 函式可以用來擷取非工作區，例如標題列、 功能表和捲軸的各個部分的維度。

繪製完成後[ReleaseDC](#releasedc)成員函式必須呼叫以釋出顯示內容。 釋放的顯示內容失敗會嚴重影響繪製由應用程式，因為可以同時開啟的裝置內容的數目限制。

##  <a name="getwindowinfo"></a>  CWnd::GetWindowInfo

擷取視窗的相關資訊。

```
BOOL GetWindowInfo(PWINDOWINFO pwi) const;
```

### <a name="parameters"></a>參數

*pwi*<br/>
指標[WINDOWINFO](/windows/desktop/api/winuser/ns-winuser-tagwindowinfo)結構。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[GetWindowInfo](/windows/desktop/api/winuser/nf-winuser-getwindowinfo)、 Windows SDK 中所述。

##  <a name="getwindowlesschildcount"></a>  CWnd::GetWindowlessChildCount

擷取相關聯的無視窗子視窗的數目。

```
long GetWindowlessChildCount();
```

### <a name="return-value"></a>傳回值

與相關聯的無視窗子視窗數目`CWnd`物件。

##  <a name="getwindowplacement"></a>  CWnd::GetWindowPlacement

擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
```

### <a name="parameters"></a>參數

*lpwndpl*<br/>
指向`WINDOWPLACEMENT`接收到的顯示狀態和位置資訊的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

`flags`隸屬[WINDOWPLACEMENT](/windows/desktop/api/winuser/ns-winuser-tagwindowplacement)擷取由此函式的結構一定是 0。 如果`CWnd`最大化`showCmd`隸屬`WINDOWPLACEMENT`是 sw_showmaximized 其中一個。 如果視窗最小化，它會是 SW_SHOWMINIMIZED。 否則，它是 SW_SHOWNORMAL。

##  <a name="getwindowrect"></a>  CWnd::GetWindowRect

將複製的週框矩形的尺寸`CWnd`指向的物件結構*lpRect*。

```
void GetWindowRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向`CRect`物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，將會收到的左上角和右下角的螢幕座標。

### <a name="remarks"></a>備註

維度是相對於顯示畫面的左上角的螢幕座標中指定。 維度的標題、 上框線和捲軸，如果有的話，會包含。

##  <a name="getwindowrgn"></a>  CWnd::GetWindowRgn

呼叫此成員函式，若要取得之視窗的視窗區域。

```
int GetWindowRgn(HRGN hRgn)const;
```

### <a name="parameters"></a>參數

*hRgn*<br/>
視窗區域控制代碼。

### <a name="return-value"></a>傳回值

傳回的值指定函式會取得區域的類型。 它可以是下列值之一：

- NULLREGION 區域是空的。

- SIMPLEREGION 區域是一個單一的矩形。

- COMPLEXREGION 區域是一個以上的矩形。

- 發生錯誤的錯誤區域不會受到影響。

### <a name="remarks"></a>備註

視窗區域判斷作業系統，允許的繪圖視窗內的區域。 作業系統不會顯示視窗位於視窗區域以外的任何部分。

視窗的視窗區域的座標是相對於視窗中，非工作區視窗的左上角。

若要設定之視窗的視窗區域，請呼叫[CWnd::SetWindowRgn](#setwindowrgn)。

##  <a name="getwindowtext"></a>  CWnd::GetWindowText

複本`CWnd`所指向緩衝區的標題 （如果有的話） 標題*lpszStringBuf*或是目的字串*rString*。

```
int GetWindowText(
    LPTSTR lpszStringBuf,
    int nMaxCount) const;

void GetWindowText(
    CString& rString) const;
```

### <a name="parameters"></a>參數

*lpszStringBuf*<br/>
指向接收視窗的標題複製的字串的緩衝區。

*nMaxCount*<br/>
指定要複製到緩衝區，包括結束的 null 字元的字元數目上限。 如果字串長度中指定的字元數超過*nMaxCount*，則會遭到截斷。

*rString*<br/>
A [CString](../../atl-mfc-shared/reference/cstringt-class.md)接收視窗的標題複製的字串的物件。

### <a name="return-value"></a>傳回值

指定長度，以複製的字串，不包括結束的 null 字元的字元為單位。 如果為 0`CWnd`沒有標題或標題是空的。

### <a name="remarks"></a>備註

如果`CWnd`物件是控制項，`GetWindowText`成員函式會複製而不要複製標題控制項內的文字。

此成員函式會導致[WM_GETTEXT](/windows/desktop/winmsg/wm-gettext)訊息傳送至`CWnd`物件。

### <a name="example"></a>範例

  範例，請參閱[CWnd::SetWindowText](#setwindowtext)。

##  <a name="getwindowtextlength"></a>  CWnd::GetWindowTextLength

傳回的長度`CWnd`物件標題的標題。

```
int GetWindowTextLength() const;
```

### <a name="return-value"></a>傳回值

指定的文字長度，以字元為單位，不包括任何 null 結束字元。 如果沒有這類文字存在，則值為 0。

### <a name="remarks"></a>備註

如果`CWnd`是一個控制項，`GetWindowTextLength`成員函式會傳回而不是標題控制項中文字的長度。

此成員函式會導致[WM_GETTEXTLENGTH](/windows/desktop/winmsg/wm-gettextlength)訊息傳送至`CWnd`物件。

### <a name="example"></a>範例

  範例，請參閱[CWnd::SetWindowText](#setwindowtext)。

##  <a name="hidecaret"></a>  CWnd::HideCaret

藉由從顯示畫面移除插入號來隱藏該插入號。

```
void HideCaret();
```

### <a name="remarks"></a>備註

雖然插入號不再是可見的但不會顯示一次使用[ShowCaret](#showcaret)成員函式。 隱藏插入號不會終結其目前的圖形。

隱藏是累計的。 如果`HideCaret`已呼叫五次的資料列中`ShowCaret`成員函式之前，必須呼叫五次會顯示插入號。

##  <a name="hilitemenuitem"></a>  CWnd::HiliteMenuItem

反白顯示，或從最上層 （功能表列） 的功能表項目中移除反白顯示。

```
BOOL HiliteMenuItem(
    CMenu* pMenu,
    UINT nIDHiliteItem,
    UINT nHilite);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
識別最上層的功能表，其中包含要反白顯示的項目。

*nIDHiliteItem*<br/>
指定功能表項目，會反白顯示，視值而定*nHilite*參數。

*nHilite*<br/>
指定功能表項目會反白顯示或反白顯示的已移除。 它可以是 MF_HILITE 或 MF_BYCOMMAND 或 MF_BYPOSITION MF_UNHILITE 的組合。 值，可以使用位元的 OR 運算子加以結合。 這些值具有下列意義：

- MF_BYCOMMAND 解譯*nIDHiliteItem*為功能表項目 ID （預設解譯）。

- MF_BYPOSITION 解譯*nIDHiliteItem*功能表項目的以零為起始的位移。

- MF_HILITE 反白顯示的項目。 如果未指定此值，反白顯示，會移除從項目。

- MF_UNHILITE 移除反白顯示的項目。

### <a name="return-value"></a>傳回值

指定功能表項目是否已反白顯示。 非零值，如果項目已反白顯示;否則為 0。

### <a name="remarks"></a>備註

MF_HILITE 和 MF_UNHILITE 旗標只能搭配此成員函式;它們無法搭配[CMenu::ModifyMenu](../../mfc/reference/cmenu-class.md#modifymenu)成員函式。

##  <a name="htmlhelp"></a>  CWnd::HtmlHelp

呼叫此成員函式來叫用 HTMLHelp 應用程式。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 所使用的值而定的值*nCmd*參數。

*nCmd*<br/>
指定要求的說明類型。 如需可能的值，以及它們如何影響*dwData*參數，請參閱*uCommand* HTML 說明 API 參考中的 Windows SDK 中所述的參數。

### <a name="remarks"></a>備註

請參閱[CWinApp::HtmlHelp](../../mfc/reference/cwinapp-class.md#htmlhelp)如需詳細資訊。

##  <a name="initdynamiclayout"></a>  CWnd::InitDynamicLayout

由架構呼叫以初始化視窗的動態配置。

```
void InitDynamicLayout();
```

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

##  <a name="invalidate"></a>  CWnd::Invalidate

失效的整個工作區`CWnd`。

```
void Invalidate(BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*bErase*<br/>
指定是否要清除的背景更新區域內。

### <a name="remarks"></a>備註

工作區已標示為繪製時的下一步 [WM_PAINT](#onpaint)就會出現訊息。 區域也驗證，WM_PAINT 訊息發生的前[ValidateRect](#validaterect)或是[ValidateRgn](#validatergn)成員函式。

*BErase*參數會指定是否要處理的更新區域時清除的背景更新區域內。 如果*bErase*為 TRUE 時，背景當清除[BeginPaint](#beginpaint)呼叫成員函式; 如果*bErase*為 FALSE 時，背景會保持不變。 如果*bErase*的更新區域，在整個區域中，不只是在特定的組件，任何的背景部分都會清除，則為 TRUE。

Windows 會傳送[WM_PAINT](#onpaint)每當訊息`CWnd`更新區域不是空白，且該視窗的應用程式佇列中沒有其他訊息。

### <a name="example"></a>範例

  範例，請參閱[CWnd::UpdateWindow](#updatewindow)。

##  <a name="invalidaterect"></a>  CWnd::InvalidateRect

使給定矩形內的工作區失效加到該矩形`CWnd`更新區域。

```
void InvalidateRect(
    LPCRECT lpRect,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向`CRect`物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，其中包含要新增到更新區域的矩形 （在工作區座標中）。 如果*lpRect*為 NULL，就是整個工作區加入到區域中。

*bErase*<br/>
指定是否要清除的背景更新區域內。

### <a name="remarks"></a>備註

失效的矩形，以及所有的其他區域中更新區域中，標示為進行繪製時的下一步 [WM_PAINT](#onpaint)傳送訊息。 失效的區域會在更新區域中累積，直到下一個 WM_PAINT 呼叫時，處理區域或區域所驗證的[ValidateRect](#validaterect)或是[ValidateRgn](#validatergn)成員函式。

*BErase*參數會指定是否要處理的更新區域時清除的背景更新區域內。 如果*bErase*為 TRUE 時，背景當清除[BeginPaint](#beginpaint)呼叫成員函式; 如果*bErase*為 FALSE 時，背景會保持不變。 如果*bErase*清除更新區域，在整個區域背景的任何部分，不只是在特定的組件為 TRUE。

Windows 會傳送[WM_PAINT](#onpaint)每當訊息`CWnd`更新區域不是空白，且該視窗的應用程式佇列中沒有其他訊息。

##  <a name="invalidatergn"></a>  CWnd::InvalidateRgn

藉由將目前的更新區域，使給定區域內用戶端區失效`CWnd`。

```
void InvalidateRgn(
    CRgn* pRgn,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
指標[CRgn](../../mfc/reference/crgn-class.md)物件，識別要新增到更新區域的區域。 區域會假設用戶端座標。 如果此參數為 NULL，整個工作區會加入到更新區域中。

*bErase*<br/>
指定是否要清除的背景更新區域內。

### <a name="remarks"></a>備註

失效的區域，以及所有其他區域中更新區域中，已標示為要繪製的時機[WM_PAINT](#onpaint)接下來會傳送訊息。 失效的區域會累積在更新區域，直到處理 WM_PAINT 訊息接下來傳送時，區域或區域經過[ValidateRect](#validaterect)或是[ValidateRgn](#validatergn)成員函式。

*BErase*參數會指定是否要處理的更新區域時清除的背景更新區域內。 如果*bErase*為 TRUE 時，背景當清除[BeginPaint](#beginpaint)呼叫成員函式; 如果*bErase*為 FALSE 時，背景會保持不變。 如果*bErase*的更新區域，在整個區域中，不只是在特定的組件，任何的背景部分都會清除，則為 TRUE。

Windows 會傳送[WM_PAINT](#onpaint)每當訊息`CWnd`更新區域不是空白，且該視窗的應用程式佇列中沒有其他訊息。

指定的區域必須先前建立的其中一個區域函式。

##  <a name="invokehelper"></a>  CWnd::InvokeHelper

呼叫此成員函式，來叫用的 ActiveX 控制項方法或屬性所指定*dwDispID*，在所指定的內容中*wFlags*。

```
void AFX_CDECL InvokeHelper(
    DISPID dwDispID,
    WORD wFlags,
    VARTYPE vtRet,
    void* pvRet,
    const BYTE* pbParamInfo,
    ... );
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
指定所要叫用的屬性或方法。

*wFlags*<br/>
描述要呼叫的內容旗標`IDispatch::Invoke`。

*vtRet*<br/>
指定傳回值的類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvRet*<br/>
將這個變數的位址將會接收屬性值，或傳回值。 它必須符合所指定的型別*vtRet*。

*pbParamInfo*<br/>
以 null 終止的字串的指定類型的下列參數的位元組指標*pbParamInfo*。 如需可能的值，請參閱 < 備註 > 一節`COleDispatchDriver::InvokeHelper`。

*...*<br/>
變數清單的參數，在指定的型別*pbParamInfo*。

### <a name="remarks"></a>備註

*PbParamInfo*參數會指定傳遞至方法或屬性的參數類型。 引數的變數清單會以 *...* 語法宣告代表。

此函式會將參數轉換為 VARIANTARG 值，然後再叫用`IDispatch::Invoke`ActiveX 控制項上的方法。 若呼叫 `IDispatch::Invoke` 失敗，此函式會擲回例外狀況。 如果所傳回的 SCODE （狀態碼）`IDispatch::Invoke`是 DISP_E_EXCEPTION，此函式會擲回[COleException](../../mfc/reference/coleexception-class.md)物件，否則就會擲回[COleDispatchException](../../mfc/reference/coledispatchexception-class.md)。

> [!NOTE]
> 此函式應該只在呼叫`CWnd`物件，表示 ActiveX 控制項。

如需這個成員函式使用 ActiveX 控制項容器的詳細資訊，請參閱文章[ActiveX 控制項容器：程式設計 ActiveX 控制項容器中的 ActiveX 控制項](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

##  <a name="ischild"></a>  CWnd::IsChild

指出所指定視窗是否*pWnd*是子視窗或其他直接子代`CWnd`。

```
BOOL IsChild(const CWnd* pWnd) const;
```

### <a name="parameters"></a>參數

*pWnd*<br/>
識別要測試視窗。

### <a name="return-value"></a>傳回值

指定函式的結果。 值為非零值，如果所識別的視窗*pWnd*是子視窗的`CWnd`，否則為 0。

### <a name="remarks"></a>備註

子視窗是直接下的階`CWnd`如果`CWnd`物件是在父視窗的鏈結中，會導致從原始的快顯視窗的子視窗。

##  <a name="isd2dsupportenabled"></a>  CWnd::IsD2DSupportEnabled

決定是否啟用 D2D 支援。

```
BOOL IsD2DSupportEnabled();
```

### <a name="return-value"></a>傳回值

如果已啟用此功能，則為 TRUE。否則為 FALSE。

##  <a name="isdialogmessage"></a>  CWnd::IsDialogMessage

呼叫以判斷給定的訊息是否適用於非強制回應對話方塊; 此成員函式如果是，此函式會處理訊息。

```
BOOL IsDialogMessage(LPMSG lpMsg);
```

### <a name="parameters"></a>參數

*lpMsg*<br/>
指向[MSG](/windows/desktop/api/winuser/ns-winuser-tagmsg)結構，其中包含要檢查的訊息。

### <a name="return-value"></a>傳回值

指定此成員函式是否已處理指定的訊息。 如果已處理訊息，其為非零值否則為 0。 如果傳回為 0，呼叫[cwnd:: Pretranslatemessage](#pretranslatemessage)來處理訊息的基底類別成員函式。 中的覆寫`CWnd::PreTranslateMessage`成員函式程式碼看起來像這樣：

[!code-cpp[NVC_MFCWindowing#100](../../mfc/reference/codesnippet/cpp/cwnd-class_40.cpp)]

### <a name="remarks"></a>備註

當`IsDialogMessage`函式會處理一則訊息，它會檢查鍵盤訊息，並將它們轉換成對應的對話方塊中選擇命令。 比方說，TAB 鍵選取 [下一步] 的控制項或控制項群組，並向下鍵選取群組中的下一個控制項。

您必須傳遞所處理的訊息`IsDialogMessage`要[TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage)或是[DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函式，因為它已處理。

##  <a name="isdlgbuttonchecked"></a>  CWnd::IsDlgButtonChecked

決定按鈕控制項是否具有它旁邊的核取記號。

```
UINT IsDlgButtonChecked(int nIDButton) const;
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定按鈕控制項的整數識別碼。

### <a name="return-value"></a>傳回值

如果已指定的控制項，為非零 0，如果未核取。 只有選項按鈕，可以勾選核取方塊。 三種狀態的按鈕，傳回的值可以是 2，如果不確定 按鈕。 此成員函式會傳回 0 的按鈕。

### <a name="remarks"></a>備註

如果按鈕是三種狀態控制項，此成員函式會決定是否就會呈暗灰色，核取，或兩者都關閉。

##  <a name="isdynamiclayoutenabled"></a>  CWnd::IsDynamicLayoutEnabled

決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。

```
BOOL IsDynamicLayoutEnabled() const;
```

### <a name="return-value"></a>傳回值

如果啟用動態配置則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="isiconic"></a>  CWnd::IsIconic

指定是否`CWnd`降到最低 （圖示）。

```
BOOL IsIconic() const;
```

### <a name="return-value"></a>傳回值

非零`CWnd`降到最低; 否則為 0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

##  <a name="istouchwindow"></a>  CWnd::IsTouchWindow

指定 `CWnd` 是否有觸控支援。

```
BOOL IsTouchWindow() const;
```

### <a name="return-value"></a>傳回值

則為 TRUE`CWnd`有觸控支援，否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="iswindowenabled"></a>  CWnd::IsWindowEnabled

指定是否`CWnd`都可使用滑鼠和鍵盤輸入。

```
BOOL IsWindowEnabled() const;
```

### <a name="return-value"></a>傳回值

非零`CWnd`已啟用; 否則為 0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#102](../../mfc/reference/codesnippet/cpp/cwnd-class_42.cpp)]

##  <a name="iswindowvisible"></a>  CWnd::IsWindowVisible

判斷指定的視窗的可見性狀態。

```
BOOL IsWindowVisible() const;
```

### <a name="return-value"></a>傳回值

非零`CWnd`可見 (有[WS_VISIBLE](styles-used-by-mfc.md#window-styles)樣式位元集，和父視窗會顯示)。 傳回值會反映 WS_VISIBLE 樣式位元的狀態，因為傳回的值可能為非零即使`CWnd`完全遮住其他視窗。

### <a name="remarks"></a>備註

視窗擁有由 WS_VISIBLE 樣式位元的可見性狀態。 當呼叫設定此樣式位元[ShowWindow](#showwindow)成員函式，顯示視窗和後續的繪圖視窗隨即出現，只要視窗有樣式位元組。

如果視窗都會受到其他視窗，或由其父視窗會裁剪，不會顯示任何繪圖 WS_VISIBLE 樣式的視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#103](../../mfc/reference/codesnippet/cpp/cwnd-class_43.cpp)]

##  <a name="iszoomed"></a>  CWnd::IsZoomed

決定是否`CWnd`已經最大化。

```
BOOL IsZoomed() const;
```

### <a name="return-value"></a>傳回值

非零`CWnd`最大化; 否則為 0。

##  <a name="killtimer"></a>  CWnd::KillTimer

刪除所識別的計時器事件*nIDEvent*從  苺巃`SetTimer`。

```
BOOL KillTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
計時器事件的值傳遞給[SetTimer](#settimer)。

### <a name="return-value"></a>傳回值

指定函式的結果。 值為非零值，如果已清除的事件。 如果為 0`KillTimer`成員函式找不到指定的計時器事件。

### <a name="remarks"></a>備註

暫止[WM_TIMER](#ontimer)與計時器相關聯的訊息不會從訊息佇列中移除。

### <a name="example"></a>範例

  範例，請參閱[CWnd::SetTimer](#settimer)。

##  <a name="loaddynamiclayoutresource"></a>  CWnd::LoadDynamicLayoutResource

由架構呼叫以從資源檔載入動態配置資訊。

```
BOOL LoadDynamicLayoutResource(LPCTSTR lpszResourceName);
```

### <a name="parameters"></a>參數

*lpszResourceName*<br/>
包含此視窗所需之動態配置資訊的資源名稱。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 如果發生失敗，則為 0。

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

##  <a name="lockwindowupdate"></a>  CWnd::LockWindowUpdate

在指定的視窗中繪製停用。

```
BOOL LockWindowUpdate();
```

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 它會是 0，如果發生失敗，或如果`LockWindowUpdate`函式已用來鎖定另一個視窗。

### <a name="remarks"></a>備註

無法移動已鎖定的視窗。 只有一個視窗可以鎖定一次。 若要解除鎖定與鎖定的視窗`LockWindowUpdate`，呼叫[UnlockWindowUpdate](#unlockwindowupdate)。

如果鎖定的視窗 （或任何鎖定的子視窗） 的應用程式會呼叫[GetDC，](/windows/desktop/api/winuser/nf-winuser-getdc) [GetDCEx，](/windows/desktop/api/winuser/nf-winuser-getdcex)或是[BeginPaint](/windows/desktop/api/winuser/nf-winuser-beginpaint) Windows 函式，呼叫的函式會傳回裝置其可見的區域是空的內容。 藉由呼叫應用程式解除鎖定的視窗之前，會發生此情況`UnlockWindowUpdate`成員函式。

視窗將會更新鎖定後，系統會追蹤的任何繪製作業，以鎖定視窗相關聯的裝置內容的週框矩形。 時重新繪圖，這個週框矩形無效 [鎖定] 視窗和其子視窗強制最終[WM_PAINT](/windows/desktop/gdi/wm-paint)更新螢幕的訊息。 如果不發生任何繪圖視窗將會更新已鎖定時，不含區域將會失效。

`LockWindowUpdate`成員函式不會讓指定的視窗變成不可見，並不會清除[WS_VISIBLE](styles-used-by-mfc.md#window-styles)樣式位元。

##  <a name="m_hwnd"></a>  CWnd::m_hWnd

Windows 視窗的控制代碼附加至此`CWnd`。

```
HWND m_hWnd;
```

### <a name="remarks"></a>備註

`m_hWnd`資料成員是型別 HWND 的公用變數。

##  <a name="mapwindowpoints"></a>  CWnd::MapWindowPoints

將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。

```
void MapWindowPoints(
    CWnd* pwndTo,
    LPRECT lpRect) const;

void MapWindowPoints(
    CWnd* pwndTo,
    LPPOINT lpPoint,
    UINT nCount) const;
```

### <a name="parameters"></a>參數

*pwndTo*<br/>
識別點轉換成的視窗。 如果此參數為 NULL，點轉換成螢幕座標。

*lpRect*<br/>
指定的點是要轉換的矩形。 只有 Windows 3.1 和更新版本，可使用此函式的第一個版本。

*lpPoint*<br/>
陣列的指標[POINT 結構](/windows/desktop/api/windef/ns-windef-tagpoint)包含一組要轉換的點。

*nCount*<br/>
指定的數目`POINT`結構陣列中的所指*lpPoint*。

##  <a name="messagebox"></a>  CWnd::MessageBox

建立並顯示視窗，其中包含應用程式所提供的訊息和標題，再加上預先定義的圖示和按鈕中所述的組合[訊息方塊樣式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)清單。

```
int MessageBox(
    LPCTSTR lpszText,
    LPCTSTR lpszCaption = NULL,
    UINT nType = MB_OK);
```

### <a name="parameters"></a>參數

*lpszText*<br/>
指向`CString`物件或 null 結尾的字串，包含要顯示的訊息。

*lpszCaption*<br/>
指向`CString`物件或 null 結束的字串，用於訊息方塊標題。 如果*lpszCaption*是 NULL，在使用 「 錯誤 」 的預設標題。

*nType*<br/>
指定的內容和訊息方塊的行為。

### <a name="return-value"></a>傳回值

這個方法會利用[MessageBox](/windows/desktop/api/winuser/nf-winuser-messagebox)做為 Windows SDK 中定義。 這個方法會傳回呼叫此函式的結果。

### <a name="remarks"></a>備註

使用全域函式[AfxMessageBox](../../mfc/reference/cstring-formatting-and-message-box-display.md#afxmessagebox)而不是此成員函式，在您的應用程式中實作的訊息方塊。

下圖顯示可用在訊息方塊中的各種系統圖示：

|||
|-|-|
|![停止&#40;x&#41;圖示](../../mfc/reference/media/vc364f1.gif "停止&#40;x&#41;圖示")|MB_ICONHAND、 MB_ICONSTOP 和 MB_ICONERROR|
|![說明&#40;嗎？&#41;圖示](../../mfc/reference/media/vc364f2.gif "說明&#40;？&#41;圖示")|MB_ICONQUESTION|
|![重要&#40; &#33; &#41;圖示](../../mfc/reference/media/vc364f3.gif "重要&#40; &#33; &#41;圖示")|MB_ICONEXCLAMATION 和 MB_ICONWARNING|
|![資訊&#40;i&#41;圖示](../../mfc/reference/media/vc364f4.gif "資訊&#40;i&#41;圖示")|MB_ICONASTERISK 和 MB_ICONINFORMATION|

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#104](../../mfc/reference/codesnippet/cpp/cwnd-class_44.cpp)]

##  <a name="modifystyle"></a>  CWnd::ModifyStyle

呼叫此成員函式來修改視窗的樣式。

```
BOOL ModifyStyle(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定要移除樣式修改期間的視窗樣式。

*dwAdd*<br/>
指定要加入樣式修改期間的視窗樣式。

*nFlags*<br/>
旗標傳遞給[SetWindowPos](#setwindowpos)，或零，如果`SetWindowPos`不應該呼叫。 預設值是零。 請參閱 < 備註 > 一節清單預設旗標。

### <a name="return-value"></a>傳回值

已成功修改樣式; 如果為非零否則就是 0。

### <a name="remarks"></a>備註

要加入或移除的樣式可以結合使用的位元 OR (&#124;) 運算子。 請參閱主題[的視窗樣式](/windows/desktop/winmsg/window-styles)並[CreateWindow](/windows/desktop/api/winuser/nf-winuser-createwindowa)可用的視窗樣式的相關資訊的 Windows SDK 中。

如果*nFlags*為非零值，`ModifyStyle`呼叫 Windows API 函式[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos)並重新繪製視窗，結合*nFlags*具有下列四個預設值旗標：

- SWP_NOSIZE 會保留目前的大小。

- SWP_NOMOVE 會保留目前的位置。

- SWP_NOZORDER 會保留目前的 Z 順序。

- SWP_NOACTIVATE 不會啟動視窗。

若要修改視窗的延伸樣式，請參閱 < [ModifyStyleEx](#modifystyleex)。

> [!NOTE]
> 在某些控制項 （在編輯控制項中，例如 ES_READONLY 樣式），某些樣式`ModifyStyle`可能不正確地變更樣式因為控制項可能需要執行特殊的內部處理。 在這些情況下，變更樣式對應的訊息會提供 (EM_SETREADONLY 中所述的範例)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#105](../../mfc/reference/codesnippet/cpp/cwnd-class_45.cpp)]

##  <a name="modifystyleex"></a>  CWnd::ModifyStyleEx

呼叫此成員函式來修改視窗的延伸的樣式。

```
BOOL ModifyStyleEx(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定要移除樣式修改期間的延伸的樣式。

*dwAdd*<br/>
指定要加入樣式修改期間的延伸的樣式。

*nFlags*<br/>
旗標傳遞給[SetWindowPos](#setwindowpos)，或零，如果`SetWindowPos`不應該呼叫。 預設值是零。 請參閱 < 備註 > 一節清單預設旗標。

### <a name="return-value"></a>傳回值

已成功修改樣式; 如果為非零否則就是 0。

### <a name="remarks"></a>備註

要加入或移除的樣式可以結合使用的位元 OR (&#124;) 運算子。 請參閱主題[延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)在本書中並[CreateWindowEx](/windows/desktop/api/winuser/nf-winuser-createwindowexa)擴充可用的相關資訊的 Windows SDK 中的 樣式

如果*nFlags*為非零值，`ModifyStyleEx`呼叫 Windows API 函式[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos)並重新繪製視窗，結合*nFlags*具有下列四個預設值旗標：

- SWP_NOSIZE 會保留目前的大小。

- SWP_NOMOVE 會保留目前的位置。

- SWP_NOZORDER 會保留目前的 Z 順序。

- SWP_NOACTIVATE 不會啟動視窗。

若要修改使用一般的視窗樣式的 windows，請參閱[ModifyStyle](#modifystyle)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#106](../../mfc/reference/codesnippet/cpp/cwnd-class_46.cpp)]

##  <a name="movewindow"></a>  CWnd::MoveWindow

變更的位置和維度。

```
void MoveWindow(
    int x,
    int y,
    int nWidth,
    int nHeight,
    BOOL bRepaint = TRUE);

void MoveWindow(
    LPCRECT lpRect,
    BOOL bRepaint = TRUE);
```

### <a name="parameters"></a>參數

*x*<br/>
指定新位置的左側`CWnd`。

*y*<br/>
指定新位置上方的`CWnd`。

*nWidth*<br/>
指定的新寬度`CWnd`。

*nHeight*<br/>
指定新的高度`CWnd`。

*bRepaint*<br/>
指定是否`CWnd`會重新繪製。 如果為 TRUE，`CWnd`接收[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息中其[OnPaint](#onpaint)如往常般訊息處理常式。 如果此參數為 FALSE，未重新繪製任何種類的就會發生。 這適用於工作區、 非工作區 （包括標題和捲軸），以及未涵蓋範圍的父任何的視窗部分`CWnd`的移動。 當此參數為 FALSE 時，應用程式必須明確失效或重新繪製的任何部分`CWnd`和父視窗，必須重新繪製。

*lpRect*<br/>
[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，指定新的大小和位置。

### <a name="remarks"></a>備註

針對最上層`CWnd`物件， *x*並*y*參數都是相對於螢幕左上角。 子`CWnd`物件，它們會相對於父視窗工作區的左上角。

`MoveWindow`函式傳送[WM_GETMINMAXINFO](#ongetminmaxinfo)訊息。 處理此訊息提供`CWnd`有機會修改最大和最小可能 windows 的預設值。 如果參數`MoveWindow`成員函式超過這些值，可由 WM_GETMINMAXINFO 處理常式中的最小或最大值取代這些值。

### <a name="example"></a>範例

  範例，請參閱[CWnd::ClientToScreen](#clienttoscreen)。

##  <a name="notifywinevent"></a>  CWnd::NotifyWinEvent

表示發生預先定義之事件的系統。 如果任何用戶端應用程式註冊事件的攔截函式，系統就會呼叫用戶端的攔截函式。

```
void NotifyWinEvent(
    DWORD event,
    LONG idObjectType,
    LONG idObject);
```

### <a name="parameters"></a>參數

*event*<br/>
指定發生的事件。 此值必須是其中一個[事件常數](/windows/desktop/WinAuto/event-constants)。

*idObjectType*<br/>
識別產生事件的物件的類型。 此值是其中一個預先定義[物件識別項](/windows/desktop/WinAuto/object-identifiers)或自訂物件的識別碼值。

*idObject*<br/>
識別產生事件的物件或物件的子元素。 如果此值為 CHILDID_SELF，物件本身產生的事件。 如果沒有，此值是產生事件的項目子系識別碼。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[NotifyWinEvent](/windows/desktop/api/winuser/nf-winuser-notifywinevent)、 Windows SDK 中所述。

##  <a name="onactivate"></a>  CWnd::OnActivate

架構會呼叫此成員函式時`CWnd`物件正被啟用或停用。

```
afx_msg void OnActivate(
    UINT nState,
    CWnd* pWndOther,
    BOOL bMinimized);
```

### <a name="parameters"></a>參數

*nState*<br/>
指定是否`CWnd`是要啟用或停用。 它可以是下列值之一：

- 正在停用 WA_INACTIVE 視窗。

- （例如，藉由使用的鍵盤介面，以選取的視窗），按一下的 WA_ACTIVE 透過滑鼠以外的某種方法正在啟動視窗。

- 正在啟動 WA_CLICKACTIVE 視窗中按一下滑鼠。

*pWndOther*<br/>
指標`CWnd`正在啟用或停用。 指標可以是 NULL，而且可能是暫時性。

*bMinimized*<br/>
指定的最小化的狀態`CWnd`正在啟用或停用。 如果為 true 值表示視窗最小化。

如果為 TRUE，`CWnd`正在啟動; 否則為停用。

### <a name="remarks"></a>備註

如果`CWnd`滑鼠按一下啟動物件，它也會收到[OnMouseActivate](#onmouseactivate)成員函式呼叫。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onactivateapp"></a>  CWnd::OnActivateApp

架構會呼叫此成員函式，以啟動工作與工作在已停用的所有最上層視窗的所有最上層視窗。

```
afx_msg void OnActivateApp(
    BOOL bActive,
    DWORD dwThreadID);
```

### <a name="parameters"></a>參數

*bActive*<br/>
指定是否`CWnd`是要啟用或停用。 TRUE 表示`CWnd`正在啟動。 FALSE 表示`CWnd`正在停用。

*dwThreadID*<br/>
指定之值的執行緒 id。 如果*bActive*為 TRUE 時， *dwThreadID*識別擁有的執行緒`CWnd`在已停用。 如果*bActive*為 FALSE 時， *dwThreadID*識別擁有的執行緒`CWnd`使其無法啟動。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onambientproperty"></a>  CWnd::OnAmbientProperty

架構會呼叫此成員函式，從包含 OLE 控制項的視窗取得環境屬性值。

```
virtual BOOL OnAmbientProperty(
    COleControlSite* pSite,
    DISPID dispid,
    VARIANT* pvar);
```

### <a name="parameters"></a>參數

*pSite*<br/>
要求環境的屬性之控制項的站台的指標。

*dispid*<br/>
要求的環境屬性的分派識別碼。

*pvar*<br/>
呼叫端配置的指標`VARIANT`結構，透過將傳回環境屬性的值。

### <a name="return-value"></a>傳回值

支援的環境屬性; 如果為 TRUE如果沒有，則為 FALSE。

### <a name="remarks"></a>備註

覆寫這個函式來變更預設值給它的控制項，所傳回的 OLE 控制項容器的環境屬性值。 任何未處理的覆寫的函式的環境屬性要求應該轉送至基底類別實作。

##  <a name="onappcommand"></a>  CWnd::OnAppCommand

使用者產生的應用程式命令事件時，架構會呼叫此成員函式。 當使用者按一下應用程式的命令按鈕或類型的應用程式命令按鍵，就會發生這種情況。

```
afx_msg void OnAppCommand(
    CWnd* pWnd,
    UINT nCmd,
    UINT nDevice,
    UINT nKey);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*pWnd*|[in]指標`CWnd`物件，表示的視窗中，使用者已按下命令按鈕或按 command 機碼的位置。 這個視窗可以是子視窗的視窗接收訊息。|
|*nCmd*|[in]表示應用程式的命令。 如需可能值的清單，請參閱底下的命令*cmd*一節*lParam*參數[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)。|
|*nDevice*|[in]產生的輸入的事件的輸入的裝置。 如需可能值的清單，請參閱下的裝置*uDevice*一節*lParam*參數[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)。|
|*nKey*|[in]表示會關閉，例如 CTRL 鍵或滑鼠左的按鈕的任何虛擬按鍵。 如需可能值的清單，請參閱下的索引鍵*dwKeys*一節*lParam*參數[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)。 如需詳細資訊，請參閱中的 < 訊息參數 > 子標題[有關滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。|

### <a name="remarks"></a>備註

這個方法會接收[WM_APPCOMMAND](/windows/desktop/inputdev/wm-appcommand)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onaskcbformatname"></a>  CWnd::OnAskCbFormatName

這個架構會呼叫剪貼簿包含資料時，此成員函式處理 CF_OWNERDISPLAY 格式 （也就是當剪貼簿擁有者將顯示剪貼簿內容）。

```
afx_msg void OnAskCbFormatName(
    UINT nMaxCount,
    LPTSTR lpszString);
```

### <a name="parameters"></a>參數

*nMaxCount*<br/>
指定要複製位元組的數目上限。

*lpszString*<br/>
要儲存副本的格式名稱緩衝區的指標。

### <a name="remarks"></a>備註

剪貼簿擁有者應該提供它的格式名稱。

覆寫此成員函式，並將 CF_OWNERDISPLAY 格式的名稱複製到指定的緩衝區，不超過指定的位元組數目上限。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncancelmode"></a>  CWnd::OnCancelMode

架構會呼叫此成員函式，以通知`CWnd`取消任何內部的模式。

```
afx_msg void OnCancelMode();
```

### <a name="remarks"></a>備註

如果`CWnd`物件有焦點，其`OnCancelMode`顯示對話方塊或訊息方塊時，呼叫成員函式。 這可讓`CWnd`取消模式，例如滑鼠捕捉的機會。

預設實作會藉由呼叫回應[ReleaseCapture](/windows/desktop/api/winuser/nf-winuser-releasecapture) Windows 函式。 覆寫此成員函式，在您處理其他模式的衍生類別中。

##  <a name="oncapturechanged"></a>  CWnd::OnCaptureChanged

架構會呼叫此成員函式，以通知正失去滑鼠捕捉的視窗。

```
afx_msg void OnCaptureChanged(CWnd* pWnd);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
若要獲得滑鼠擷取視窗的指標

### <a name="remarks"></a>備註

視窗收到這個訊息，即使它會呼叫[ReleaseCapture](/windows/desktop/api/winuser/nf-winuser-releasecapture)本身。 應用程式不應該嘗試設定這個訊息的回應中的滑鼠捕捉。 當它收到這則訊息時，視窗應該重繪其本身，如有必要，以反映新的滑鼠捕捉狀態。

請參閱 Windows SDK 的資訊上`ReleaseCapture`Windows 函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchangecbchain"></a>  CWnd::OnChangeCbChain

架構會呼叫此成員函式，以通知它，正在從鏈結中移除視窗的剪貼簿檢視器鏈結中每一個視窗。

```
afx_msg void OnChangeCbChain(
    HWND hWndRemove,
    HWND hWndAfter);
```

### <a name="parameters"></a>參數

*hWndRemove*<br/>
指定正在從剪貼簿檢視器鏈結中移除的視窗控制代碼。

*hWndAfter*<br/>
指定遵循從剪貼簿檢視器鏈結中移除視窗的視窗控制代碼。

### <a name="remarks"></a>備註

每個`CWnd`物件，接受`OnChangeCbChain`呼叫中，應該使用[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函式，以傳送[WM_CHANGECBCHAIN](/windows/desktop/dataxchg/wm-changecbchain)剪貼簿檢視器中的 [下一步] 視窗的訊息鏈結 (傳回的控制代碼`SetClipboardViewer`)。 如果*hWndRemove*是在鏈結中，所指定視窗的下一步 視窗*hWndAfter*會成為下一步 視窗中，和剪貼簿訊息都會傳遞給它。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchangeuistate"></a>  CWnd::OnChangeUIState

應變更使用者介面 (UI) 狀態時呼叫。

```
afx_msg void OnChangeUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要採取的動作。 可為下列其中一個值：

- UIS_CLEAR UI 狀態項目 (依*nUIElement*) 應該隱藏。

- UIS_INITIALIZE UI 狀態項目 (依*nUIElement*) 應該變更為根據的最後一個輸入事件。 如需詳細資訊，請參閱 <<c0>  **備註**一節[WM_CHANGEUISTATE](/windows/desktop/menurc/wm-changeuistate)。

- UIS_SET UI 狀態項目 (依*nUIElement*) 應該為可見的。

*nUIElement*<br/>
指定受影響的 UI 狀態項目或控制項的樣式。 可為下列其中一個值：

- UISF_HIDEACCEL 鍵盤快速鍵。

- UISF_HIDEFOCUS 焦點指標。

- UISF_ACTIVE Windows XP:應該繪製控制項，用於使用中控制項的樣式。

### <a name="remarks"></a>備註

此成員函式會模擬[WM_CHANGEUISTATE](/windows/desktop/menurc/wm-changeuistate)訊息、 Windows SDK 中所述。

##  <a name="onchar"></a>  CWnd::OnChar

按鍵轉譯為非系統字元時，架構會呼叫此成員函式。

```
afx_msg void OnChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
包含索引鍵的字元碼值。

*nRepCnt*<br/>
包含的重複計數的按鍵輸入會重複執行，當使用者按住按鍵的次數。

*nFlags*<br/>
包含掃描程式碼、 索引鍵轉換程式碼前, 一個索引鍵的狀態和內容的程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-15|指定的重複計數。 值是按鍵輸入會因為使用者按住鍵而重複的次數。|
|16-23|指定掃描程式碼。 值取決於原始設備製造商 (OEM)|
|24|指定的索引鍵是否是延伸的金鑰，例如增強 101-或 102-key 鍵盤上出現的右 ALT 和 CTRL 鍵。 值為 1，如果它是延伸的金鑰;否則，它會是 0。|
|25-28|Windows 內部使用。|
|29|指定的內容程式碼。 如果按下按鍵; 時，按住 ALT 鍵，則值為 1否則，值為 0。|
|30|指定前一個索引鍵的狀態。 如果金鑰已關閉，才能傳送訊息，或如果機碼設定為 0，則值為 1。|
|31|指定轉換狀態。 如果發行的索引鍵時，或如果按下索引鍵為 0，則值為 1。|

### <a name="remarks"></a>備註

之前，會呼叫此函式[OnKeyUp](#onkeyup)成員函式以及以後[OnKeyDown](#onkeydown)呼叫成員函式。 `OnChar` 包含所按下或放開的鍵盤按鍵的值。

因為沒有不一定是一對一的對應關係按下的索引鍵之間及`OnChar`產生的呼叫中的資訊*nFlags*通常不是有用的應用程式。 中的資訊*nFlags*僅適用於最新呼叫`OnKeyUp`成員函式或`OnKeyDown`成員函式之前呼叫`OnChar`。

IBM 增強 101 和 102-key 鍵盤、 增強的金鑰為右邊的 alt 鍵和右邊的 CTRL 鍵，鍵盤; 的主要區段INS、 DEL、 首頁、 結束、 PAGE UP、 PAGE down 鍵、 和左邊的數字鍵台; 叢集中的方向鍵斜線 （/） 和數字鍵盤上的 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元*nFlags*。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchartoitem"></a>  CWnd::OnCharToItem

當清單方塊時，呼叫[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式會傳送其擁有者[WM_CHARTOITEM](/windows/desktop/Controls/wm-chartoitem)訊息以回應[WM_CHAR](#onchar)訊息。

```
afx_msg int OnCharToItem(
    UINT nChar,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定使用者按下的索引鍵的值。

*pListBox*<br/>
指定清單方塊的指標。 它可能是暫時性的。

*nIndex*<br/>
指定目前的插入號位置。

### <a name="return-value"></a>傳回值

架構會呼叫此成員函式，來指定在呼叫的回應中的應用程式執行的動作。 傳回值-2 表示應用程式處理選取的項目的所有層面，並想要在清單方塊的任何進一步的動作。 傳回值-1 表示清單方塊應該執行的預設動作，以回應按鍵輸入。 大於或等於 0 的傳回值的清單方塊中指定的項目以零為起始的索引，並指出清單方塊應該執行的預設動作，在指定的項目上的按鍵輸入。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onchildactivate"></a>  CWnd::OnChildActivate

如果`CWnd`物件是多個文件介面 (MDI) 子視窗，`OnChildActivate`是由架構呼叫，當使用者按一下視窗的標題列或視窗中啟動時，移動或調整大小。

```
afx_msg void OnChildActivate();
```

##  <a name="onchildnotify"></a>  CWnd::OnChildNotify

此視窗的父視窗收到通知訊息，此視窗時，會呼叫此成員函式。

```
virtual BOOL OnChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
Windows 訊息編號，傳送至父視窗。

*wParam*<br/>
*Wparam*訊息相關聯。

*lParam*<br/>
*Lparam*訊息相關聯。

*pLResult*<br/>
要從父代的視窗程序傳回值的指標。 若預期沒有傳回值，這個指標會是 NULL。

### <a name="return-value"></a>傳回值

如果這個視窗會負責處理訊息傳送至其父代則為非零否則為 0。

### <a name="remarks"></a>備註

永遠不會直接呼叫此成員函式。

此成員函式的預設實作會傳回 0，表示父代應該處理訊息。

覆寫此成員函式，來擴充控制項通知訊息的回應方式。

##  <a name="onclipboardupdate"></a>  CWnd::OnClipboardUpdate

剪貼簿內容已變更時，架構會呼叫此成員函式。

```
afx_msg void OnClipboardUpdate();
```

##  <a name="onclose"></a>  CWnd::OnClose

架構會呼叫此成員函式做為訊號，`CWnd`或應用程式會終止。

```
afx_msg void OnClose();
```

### <a name="remarks"></a>備註

預設實作會呼叫`DestroyWindow`。

##  <a name="oncolorizationcolorchanged"></a>  CWnd::OnColorizationColorChanged

當非工作區轉譯原則已變更時，架構會呼叫這個成員。

```
afx_msg void OnColorizationColorChanged(
    DWORD dwColorizationColor,
    BOOL bOpacity);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*dwColorizationColor*|[in]指定新的顏色標示色彩。<br /><br /> 色彩格式是十六進位數字的表單 0xAARRGGBB 中，其中的四個元件的每個範圍都是從 0x00 到 0xFF。 AA 元件是 alpha 值 RR 是紅色的色彩、 GG 為綠色，，BB 是藍色。|
|*bOpacity*|[in]如果新的色彩會與不透明度; 混合，則為 TRUE。如果不是，則為 FALSE。|

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMNCRENDERINGCHANGED](/windows/desktop/dwm/wm-dwmcolorizationcolorchanged)通知訊息時，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncommand"></a>  CWnd::OnCommand

當使用者從選取項目 功能表或快速鍵按鍵輸入會轉譯時子控制項傳送通知訊息時，架構會呼叫此成員函式。

```
virtual BOOL OnCommand(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
低序位字組*wParam*識別功能表項目、 控制項或快速鍵的命令識別碼。 高序位文字*wParam*指定通知訊息，如果訊息是從控制項。 如果訊息是從加速器，高序位文字會是 1。 如果訊息是從功能表中，高序位文字會是 0。

*lParam*<br/>
識別傳送訊息，如果訊息是從控制項的控制項。 否則，請*lParam*為 0。

### <a name="return-value"></a>傳回值

應用程式會傳回非零值，如果它會處理此訊息;否則為 0。

### <a name="remarks"></a>備註

`OnCommand` 會處理訊息對應的控制項通知和 ON_COMMAND 項目，並呼叫適當的成員函式。

在衍生類別處理此成員函式會覆寫[WM_COMMAND](/windows/desktop/menurc/wm-command)訊息。 覆寫將無法處理的訊息對應，除非基底類別`OnCommand`呼叫。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncompacting"></a>  CWnd::OnCompacting

當 Windows 偵測到，12.5%以上的系統時間，在 30 至 60 秒的間隔內花在壓縮的記憶體時，架構會呼叫此成員函式的所有最上層視窗。

```
afx_msg void OnCompacting(UINT nCpuTime);
```

### <a name="parameters"></a>參數

*nCpuTime*<br/>
指定目前 Windows 壓縮的記憶體，以 CPU 時間花在執行其他作業所花費的 CPU 時間的比例。 比方說，8000 h 表示 50%的 CPU 花時間壓縮記憶體。

### <a name="remarks"></a>備註

這表示系統記憶體過低。

當`CWnd`物件收到此呼叫時，它應該釋放記憶體越好，並考量目前的應用程式並在 Windows 中執行的應用程式總數的活動層級。 應用程式可以呼叫 Windows 函式，以判斷執行多少個應用程式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncompareitem"></a>  CWnd::OnCompareItem

架構會呼叫此成員函式，來排序的子系主控描繪下拉式方塊或清單方塊中指定新的項目相對位置。

```
afx_msg int OnCompareItem(
    int nIDCtl,
    LPCOMPAREITEMSTRUCT lpCompareItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
傳送 WM_COMPAREITEM 訊息控制項的識別項。

*lpCompareItemStruct*<br/>
包含的長指標[COMPAREITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcompareitemstruct)資料結構，其中包含的識別項和應用程式提供兩個項目，在下拉式方塊或清單方塊中的資料。

### <a name="return-value"></a>傳回值

表示兩個項目相對位置。 它可能是下列值之一：

|值|意義|
|-----------|-------------|
|-1|項目 1 排序項目 2 之前。|
|0|項目 1 和 2 的項目排序相同。|
|1|項目 2 之後，排序項目 1。|

### <a name="remarks"></a>備註

如果下拉式方塊或清單方塊以建立[CBS_SORT](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)或是[LBS_SORT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式，Windows 下拉式方塊或清單方塊的擁有者 WM_COMPAREITEM 訊息時傳送應用程式加入新項目。

在下拉式方塊或清單方塊中的兩個項目在新式`COMPAREITEMSTRUCT`結構所指*lpCompareItemStruct*。 `OnCompareItem` 應該會傳回值，指出其中一個項目應該會出現在其他。 一般而言，Windows 會發出此呼叫數次之前它會決定將新項目的確切的位置。

如果`hwndItem`的成員`COMPAREITEMSTRUCT`所屬的結構[CListBox](../../mfc/reference/clistbox-class.md)或是[CComboBox](../../mfc/reference/ccombobox-class.md)物件，則`CompareItem`呼叫虛擬函式的適當的類別。 覆寫`CComboBox::CompareItem`或是`CListBox::CompareItem`在您的衍生`CListBox`或`CComboBox`可執行項目比較的類別。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncompositionchanged"></a>  CWnd::OnCompositionChanged

當桌面視窗管理員 (DWM) 組合已啟用或停用時，架構會呼叫此成員函式的所有最上層視窗。

```
afx_msg void OnCompositionChanged();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMCOMPOSITIONCHANGED](/windows/desktop/dwm/wm-dwmcompositionchanged)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncontextmenu"></a>  CWnd::OnContextMenu

當使用者按下滑鼠右按鈕 （以滑鼠右鍵按一下） 在視窗中的，由架構呼叫。

```
afx_msg void OnContextMenu(
    CWnd* pWnd,
    CPoint pos);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
在其中使用者以滑鼠右鍵按一下滑鼠之視窗控制代碼。 這可以是子視窗的視窗接收訊息。 如需有關如何處理此訊息的詳細資訊，請參閱 < 備註 > 一節。

*pos*<br/>
按一下滑鼠時的螢幕座標中的資料指標，位置。

### <a name="remarks"></a>備註

您可以藉由顯示使用內容功能表處理此訊息[TrackPopupMenu](../../mfc/reference/cmenu-class.md#trackpopupmenu)。

如果您不會顯示操作功能表，您就應該傳遞到此訊息[DefWindowProc](#defwindowproc)函式。 如果您的視窗是子視窗，`DefWindowProc`將訊息傳送至父代。 否則，`DefWindowProc`會顯示預設內容功能表，如果指定的位置是在視窗的標題。

##  <a name="oncopydata"></a>  CWnd::OnCopyData

此成員函式是由資料複製到另一個應用程式架構呼叫。

```
afx_msg BOOL OnCopyData(
    CWnd* pWnd,
    COPYDATASTRUCT* pCopyDataStruct);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
指標`CWnd`傳送資料的物件。

*pCopyDataStruct*<br/>
指標[COPYDATASTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcopydatastruct)結構，其中包含要傳送的資料。

### <a name="return-value"></a>傳回值

如果接收應用程式已成功接受資料，則傳回 TRUE。 否則，會傳回 FALSE。

### <a name="remarks"></a>備註

傳遞的資料必須包含指標或物件無法存取應用程式接收資料的其他參考。

在複製資料時，它不能變更的傳送處理程序的另一個執行緒。

接收應用程式應該考慮資料唯讀狀態。 參數所指向的結構*pCopyDataStruct*無效，只在傳輸資料; 不過，接收應用程式應該不會釋放與結構相關聯的記憶體。

如果接收應用程式需要存取資料，此函式傳回之後，它必須複製到本機的緩衝區所收到的資料。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oncreate"></a>  CWnd::OnCreate

當應用程式要求，藉由呼叫建立 Windows 視窗時，架構會呼叫此成員函式[Create](#create)或是[CreateEx](#createex)成員函式。

```
afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreateStruct*<br/>
指向[CREATESTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcreatestructa)包含的相關資訊的結構`CWnd`物件所建立。

### <a name="return-value"></a>傳回值

`OnCreate` 必須傳回 0，以繼續建立`CWnd`物件。 如果應用程式會傳回-1，就會終結視窗。

### <a name="remarks"></a>備註

`CWnd`物件收到此呼叫，建立視窗之後，但之前變成可見。 `OnCreate` 之前，會呼叫`Create`或`CreateEx`成員函式傳回。

若要執行任何所需的初始化衍生類別的這個成員函式會覆寫。

`CREATESTRUCT`結構包含用來建立視窗之參數的複本。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onctlcolor"></a>  CWnd::OnCtlColor

繪製子控制項時，架構會呼叫此成員函式。

```
afx_msg HBRUSH OnCtlColor(
    CDC* pDC,
    CWnd* pWnd,
    UINT nCtlColor);
```

### <a name="parameters"></a>參數

*pDC*<br/>
包含子視窗的顯示內容的指標。 可能是暫時性的。

*pWnd*<br/>
包含要求之色彩的控制項的指標。 可能是暫時性的。

*nCtlColor*<br/>
包含下列的值，指定的控制項類型的其中一個：

- CTLCOLOR_BTN 按鈕控制項

- CTLCOLOR_DLG 對話方塊

- CTLCOLOR_EDIT 編輯控制項

- CTLCOLOR_LISTBOX 清單方塊控制項

- CTLCOLOR_MSGBOX 訊息方塊

- CTLCOLOR_SCROLLBAR 捲軸控制項

- CTLCOLOR_STATIC 靜態控制項

### <a name="return-value"></a>傳回值

`OnCtlColor` 必須傳回至用來繪製控制項的背景筆刷的控制代碼。

### <a name="remarks"></a>備註

大部分控制項傳送此訊息至其父代 （通常為對話方塊） 來準備*pDC*繪製控制項使用正確的色彩。

若要變更文字色彩，請呼叫`SetTextColor`具有所需的紅、 綠和藍 (RGB) 值的成員函式。

若要變更單一行編輯控制項的背景色彩，設定筆刷的控制代碼在 CTLCOLOR_EDIT 和 CTLCOLOR_MSGBOX 訊息代碼，並呼叫[CDC::SetBkColor](../../mfc/reference/cdc-class.md#setbkcolor) CTLCOLOR_EDIT 程式碼的回應中的函式。

`OnCtlColor` 將不會呼叫下拉式方塊的清單方塊的下拉式清單方塊所以實際上下拉式方塊的子系並不視窗的子系。 若要變更下拉式清單方塊的色彩，請建立`CComboBox`使用的覆寫`OnCtlColor`，以檢查在 CTLCOLOR_LISTBOX`nCtlColor`參數。 在這個處理常式，`SetBkColor`成員函式必須用來設定文字的背景色彩。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。 將下列方法加入至對話方塊類別，使用 Visual Studio 屬性 窗格加入 WM_CTLCOLOR 訊息處理常式。 或者，您可以手動新增 ON_WM_CTLCOLOR() 項目至訊息對應中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#107](../../mfc/reference/codesnippet/cpp/cwnd-class_47.cpp)]

##  <a name="ondeadchar"></a>  CWnd::OnDeadChar

架構會呼叫此成員函式時[OnKeyUp](#onkeyup)成員函式並[OnKeyDown](#onkeydown)呼叫成員函式。

```
afx_msg void OnDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定的索引鍵的寄不出的字元值。

*nRepCnt*<br/>
指定的重複計數。

*nFlags*<br/>
指定掃描程式碼、 索引鍵轉換程式碼前, 一個索引鍵的狀態和內容的程式碼，如下列清單所示：

|值|描述|
|-----------|-----------------|
|0-7|掃描程式碼 （OEM 相依值）。 高序位字組的低位元組。|
|8|擴充索引鍵，例如函式金鑰或 （如果它是擴充的索引鍵為 1; 否則為 0） 的數字鍵台上的索引鍵。|
|9-10|未使用。|
|11-12|Windows 內部使用。|
|13|（如果按下按鍵時，按住 ALT 鍵則為 1; 否則為 0） 的內容程式碼。|
|14|先前的重要狀態 (1 如果金鑰已關閉，再呼叫，也就是 0，如果索引鍵已啟動)。|
|15|轉換狀態 （如果發行的索引鍵為 1，0，表示按下索引鍵）。|

### <a name="remarks"></a>備註

此成員函式可用來指定廢鍵的字元值。 廢鍵是索引鍵，例如，結合使用其他字元來形成複合字元的母音變化 (雙精度浮點數 dot) 字元。 比方說，母音變化-O 字元所組成廢鍵、 母音變化和 O 鍵。

應用程式通常使用`OnDeadChar`以提供使用者意見反應，按下每個索引鍵相關。 比方說，應用程式可以強調文字中顯示的目前字元位置而不移動插入號。

因為沒有不一定是一對一的對應關係按下的索引鍵之間及`OnDeadChar`呼叫時，資訊*nFlags*通常不是有用的應用程式。 中的資訊*nFlags*僅適用於最新呼叫[OnKeyUp](#onkeyup)成員函式或[OnKeyDown](#onkeydown)成員函式前面`OnDeadChar`呼叫。

IBM 增強 101 和 102-key 鍵盤、 增強的金鑰為右邊的 alt 鍵和右邊的 CTRL 鍵，鍵盤; 的主要區段INS、 DEL、 首頁、 結束、 PAGE UP、 PAGE down 鍵、 和左邊的數字鍵台; 叢集中的方向鍵斜線 （/） 和數字鍵盤上的 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元*nFlags*。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondeleteitem"></a>  CWnd::OnDeleteItem

架構會呼叫此成員函式，來通知主控描繪清單方塊或下拉式方塊的擁有者，會終結清單方塊或下拉式方塊，或藉由已移除項目[CComboBox::DeleteString](../../mfc/reference/ccombobox-class.md#deletestring)， [CListBox::DeleteString](../../mfc/reference/clistbox-class.md#deletestring)， [CComboBox::ResetContent](../../mfc/reference/ccombobox-class.md#resetcontent)，或[CListBox::ResetContent](../../mfc/reference/clistbox-class.md#resetcontent)。

```
afx_msg void OnDeleteItem(
    int nIDCtl,
    LPDELETEITEMSTRUCT lpDeleteItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
傳送 WM_DELETEITEM 訊息控制項的識別項。

*lpDeleteItemStruct*<br/>
指定的長指標[DELETEITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagdeleteitemstruct)資料結構，包含已刪除的清單方塊項目的相關資訊。

### <a name="remarks"></a>備註

如果`hwndItem`隸屬`DELETEITEMSTRUCT`結構屬於下拉式方塊或清單方塊中，則`DeleteItem`呼叫虛擬函式的適當的類別。 覆寫`DeleteItem`刪除項目專屬資料的適當的控制項類別成員函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondestroy"></a>  CWnd::OnDestroy

架構會呼叫此成員函式，以通知`CWnd`它正在被終結的物件。

```
afx_msg void OnDestroy();
```

### <a name="remarks"></a>備註

`OnDestroy` 之後，會呼叫`CWnd`從螢幕中移除物件。

`OnDestroy` 針對第一次呼叫`CWnd`終結，然後為子視窗的`CWnd`，它們會終結。 可以假定所有的子視窗是否仍然存在而`OnDestroy`執行。

如果`CWnd`物件終結是剪貼簿檢視器鏈結的一部分 (藉由呼叫設定[SetClipboardViewer](#setclipboardviewer)成員函式)，則`CWnd`必須本身從鏈結中移除剪貼簿檢視器藉由呼叫[ChangeClipboardChain](#changeclipboardchain)成員函式傳回前的`OnDestroy`函式。

##  <a name="ondestroyclipboard"></a>  CWnd::OnDestroyClipboard

架構會呼叫剪貼簿擁有者為此成員函式時透過呼叫清空剪貼簿[EmptyClipboard](/windows/desktop/api/winuser/nf-winuser-emptyclipboard) Windows 函式。

```
afx_msg void OnDestroyClipboard();
```

##  <a name="ondevicechange"></a>  CWnd::OnDeviceChange

架構會呼叫此成員函式，以通知應用程式或裝置驅動程式的裝置或電腦的硬體組態的變更。

```
afx_msg BOOL OnDeviceChange(
    UINT nEventType,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*nEventType*<br/>
事件類型。 請參閱 < 備註 > 一節的可用值的描述

*dwData*<br/>
包含事件特定資料結構的位址。 其意義取決於指定的事件。

### <a name="remarks"></a>備註

適用於提供軟體可控制的功能，例如退出和鎖定的裝置作業系統通常會傳送 DBT_DEVICEREMOVEPENDING 訊息，讓應用程式，裝置驅動程式正常結束其使用的裝置。

如果作業系統強制移除的裝置，則它不可能這麼做之前傳送 DBT_DEVICEQUERYREMOVE 訊息。

*NEvent*參數可以是下列值之一：

- [DBT_DEVICEARRIVAL](/windows/desktop/DevIO/dbt-devicearrival)裝置已插入和現已推出。

- [DBT_DEVICEQUERYREMOVE](/windows/desktop/DevIO/dbt-devicequeryremove)移除裝置的權限要求。 任何應用程式可以拒絕此要求，並取消移除。

- [DBT_DEVICEQUERYREMOVEFAILED](/windows/desktop/DevIO/dbt-devicequeryremovefailed)移除裝置的要求已被取消。

- [DBT_DEVICEREMOVEPENDING](/windows/desktop/DevIO/dbt-deviceremovepending)裝置即將被移除。 無法拒絕。

- [DBT_DEVICEREMOVECOMPLETE](/windows/desktop/DevIO/dbt-deviceremovecomplete)裝置已被移除。

- [DBT_DEVICETYPESPECIFIC](/windows/desktop/DevIO/dbt-devicetypespecific)裝置特有的事件。

- [DBT_CONFIGCHANGED](/windows/desktop/DevIO/dbt-configchanged)目前的組態已變更。

- DBT_DEVNODES_CHANGED 裝置節點已變更。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondevmodechange"></a>  CWnd::OnDevModeChange

架構會呼叫此成員函式，針對所有最上層`CWnd`物件，當使用者變更裝置模式設定。

```
afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
```

### <a name="parameters"></a>參數

*lpDeviceName*<br/>
指向 Windows 初始化檔案、 WIN 中指定的裝置名稱。INI。

### <a name="remarks"></a>備註

處理 WM_DEVMODECHANGE 訊息的應用程式可能會重新初始化其裝置模式設定。 使用 Windows 應用程式`ExtDeviceMode`函式，儲存並還原裝置設定通常不會處理此函式。

當使用者從控制台中變更預設印表機，不會呼叫此函式。 在此情況下，`OnWinIniChange`呼叫函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondrawclipboard"></a>  CWnd::OnDrawClipboard

剪貼簿的內容變更時，架構會呼叫此成員函式針對剪貼簿檢視器鏈結中每個視窗。

```
afx_msg void OnDrawClipboard();
```

### <a name="remarks"></a>備註

只有已加入剪貼簿檢視器鏈結，藉由呼叫的應用程式[SetClipboardViewer](#setclipboardviewer)成員函式需要回應這個呼叫。

收到的每個視窗`OnDrawClipboard`呼叫應該呼叫[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函式來傳遞[WM_DRAWCLIPBOARD](/windows/desktop/dataxchg/wm-drawclipboard)入剪貼簿檢視器鏈結中下一個視窗的訊息。 下一步 的視窗控制代碼由[SetClipboardViewer](#setclipboardviewer)成員函式，則可以修改回應[OnChangeCbChain](#onchangecbchain)成員函式呼叫。

##  <a name="ondrawiconicthumbnailorlivepreview"></a>  CWnd::OnDrawIconicThumbnailOrLivePreview

需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。

```
virtual void OnDrawIconicThumbnailOrLivePreview(
    CDC& dc,
    CRect rect,
    CSize szRequiredThumbnailSize,
    BOOL bIsThumbnail,
    BOOL& bAlphaChannelSet);
```

### <a name="parameters"></a>參數

*dc*<br/>
指定的裝置內容。

*rect*<br/>
指定要呈現的區域的週框矩形。

*szRequiredThumbnailSize*<br/>
指定目標縮圖的大小。 如果應該忽略*bIsThumbnail*為 FALSE。

*bIsThumbnail*<br/>
指定圖示的縮圖或即時預覽 (peek) 是否會呼叫這個方法。

*bAlphaChannelSet*<br/>
[out]將它設定為 TRUE，如果您的實作初始化中選取一個點陣圖的 alpha 色板*dc*。

### <a name="remarks"></a>備註

在衍生類別中置換此方法，並在指定的裝置內容上繪製自訂縮圖] 和 [查看。 如果*bThumbnail*為 TRUE 時， *szRequiredThumbnailSize*可以忽略。 在此情況下您應該留意您繪製完整大小的點陣圖 （也就是涵蓋整個工作區點陣圖）。 裝置內容 ( *dc*) 隨附於所選的 32 位元點陣圖。 預設實作會將 WM_PRINT 傳送到這個視窗 PRF_CLIENT、 PRF_CHILDREN 和 PRF_NONCLIENT 旗標。

##  <a name="ondrawitem"></a>  CWnd::OnDrawItem

架構會呼叫此成員函式擁有者的主控描繪按鈕控制項、 下拉式方塊控制項、 清單方塊控制項或當控制項的視覺外觀的功能表或功能表已變更。

```
afx_msg void OnDrawItem(
    int nIDCtl,
    LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
包含傳送 WM_DRAWITEM 訊息之控制項的識別碼。 如果功能表傳送訊息， *nIDCtl*包含 0。

*lpDrawItemStruct*<br/>
指定的長指標`DRAWITEMSTRUCT`資料結構，包含要繪製的項目和繪圖所需的類型資訊。

### <a name="remarks"></a>備註

`itemAction`隸屬[DRAWITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagdrawitemstruct)結構會定義要執行繪製作業。 此成員內的資料可讓控制項的擁有者，以判斷需要繪製的動作。

在傳回之前無法處理此訊息，應用程式應該確保所識別的裝置內容*hDC*隸屬`DRAWITEMSTRUCT`結構會還原成預設狀態。

如果`hwndItem`成員所屬[CButton](../../mfc/reference/cbutton-class.md)， [CMenu](../../mfc/reference/cmenu-class.md)， [CListBox](../../mfc/reference/clistbox-class.md)，或[CComboBox](../../mfc/reference/ccombobox-class.md)物件，則`DrawItem`會呼叫虛擬函式的適當的類別。 覆寫`DrawItem`項目繪製適當的控制項類別成員函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ondropfiles"></a>  CWnd::OnDropFiles

當使用者放開滑鼠左的按鈕已本身註冊為捨棄檔案的收件者的範圍內時，架構會呼叫此成員函式。

```
afx_msg void OnDropFiles(HDROP hDropInfo);
```

### <a name="parameters"></a>參數

*hDropInfo*<br/>
描述的已卸除的檔案的內部資料結構的指標。 這個控制代碼由`DragFinish`， `DragQueryFile`，和`DragQueryPoint`Windows 函式來擷取已卸除檔案的相關資訊。

### <a name="remarks"></a>備註

一般而言，衍生的類別會設計為支援卸除的檔案，而且它會註冊本身在視窗建構期間。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onenable"></a>  CWnd::OnEnable

應用程式變更的啟用的狀態時，架構會呼叫此成員函式`CWnd`物件。

```
afx_msg void OnEnable(BOOL bEnable);
```

### <a name="parameters"></a>參數

*bEnable*<br/>
指定是否`CWnd`啟用或停用物件。 這個參數為 TRUE，如果`CWnd`已啟用; 它會是 FALSE，如果`CWnd`已停用。

### <a name="remarks"></a>備註

`OnEnable` 之前，會呼叫[EnableWindow](#enablewindow)成員函式傳回，但之後視窗啟用狀態 ( [WS_DISABLED](styles-used-by-mfc.md#window-styles)樣式位元) 已變更。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onendsession"></a>  CWnd::OnEndSession

架構會呼叫此成員函式，在後的`CWnd`物件已傳回非零的值從[OnQueryEndSession](#onqueryendsession)成員函式呼叫。

```
afx_msg void OnEndSession(BOOL bEnding);
```

### <a name="parameters"></a>參數

*bEnding*<br/>
指定要結束工作階段。 它會為 TRUE，如果工作階段正在結束;否則為 FALSE。

### <a name="remarks"></a>備註

`OnEndSession`呼叫會通知`CWnd`物件實際上是否即將結束工作階段。

如果*曲解*為 TRUE 時，Windows 可能會終止所有的應用程式都無法處理此呼叫傳回之後的任何時間。 因此，需要 執行中的終止所需的所有工作的應用程式`OnEndSession`。

您不需要呼叫[DestroyWindow](#destroywindow)成員函式或[PostQuitMessage](/windows/desktop/api/winuser/nf-winuser-postquitmessage)工作階段結束時，Windows 函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onenteridle"></a>  CWnd::OnEnterIdle

架構會呼叫此成員函式，以通知應用程式的主視窗程序強制回應對話方塊或功能表正在進入閒置狀態。

```
afx_msg void OnEnterIdle(
    UINT nWhy,
    CWnd* pWho);
```

### <a name="parameters"></a>參數

*nWhy*<br/>
指定訊息是否為對話方塊或功能表所顯示的結果。 這個參數可以是下列值之一：

- MSGF_DIALOGBOX 系統是閒置這是因為所顯示的對話方塊。

- MSGF_MENU 系統處於閒置狀態這是因為會顯示功能表。

*pWho*<br/>
指定對話方塊中的指標 (如果*nWhy*是 MSGF_DIALOGBOX)，或包含顯示的功能表中的視窗 (如果*nWhy*是 MSGF_MENU)。 這個指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

強制回應對話方塊或功能表進入閒置狀態時沒有郵件正在等待其佇列中，已處理一個或多個先前的訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onentermenuloop"></a>  CWnd::OnEnterMenuLoop

已進入功能表強制回應迴圈時，架構會呼叫此成員函式。

```
afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定相關的功能表是否快顯功能表。 有非零值，如果成功，函式否則為 0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onentersizemove"></a>  CWnd::OnEnterSizeMove

架構會呼叫此成員函式的受影響的視窗進入移動或調整大小強制回應迴圈後的一次。

```
afx_msg void OnEnterSizeMove();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_ENTERSIZEMOVE](/windows/desktop/winmsg/wm-entersizemove)通知，Windows SDK 中所述。

視窗進入移動或調整大小強制回應迴圈，當使用者按一下視窗的標題列或調整大小框線，或當視窗通過[WM_SYSCOMMAND](/windows/desktop/menurc/wm-syscommand)訊息給[CWnd::DefWindowProc](#defwindowproc)函式和*wParam* SC_MOVE 或 SC_SIZE，指定該訊息的參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onerasebkgnd"></a>  CWnd::OnEraseBkgnd

架構會呼叫此成員函式時`CWnd`物件背景需要清除 （比方說，當調整大小時）。

```
afx_msg BOOL OnEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
指定的裝置內容物件。

### <a name="return-value"></a>傳回值

它會清除在背景中; 如果為非零否則為 0。

### <a name="remarks"></a>備註

若要準備失效的區域來繪製呼叫它。

預設實作會清除背景中使用所指定的視窗類別背景筆刷`hbrBackground`視窗類別結構的成員。

如果`hbrBackground`成員為 NULL，您的覆寫版本`OnEraseBkgnd`應該清除的背景色彩。 您的版本也應該對齊與預期的筆刷的原點`CWnd`藉由第一個呼叫的座標[UnrealizeObject](/windows/desktop/api/wingdi/nf-wingdi-unrealizeobject)的筆刷，，然後選取 筆刷。

覆寫`OnEraseBkgnd`如果處理訊息，並清除的背景，應傳回非零值以回應 WM_ERASEBKGND; 這表示，再清除不需要。 它會傳回 0，如果視窗仍標示為需要清除。 (一般而言，這表示`fErase`隸屬`PAINTSTRUCT`結構將會是 TRUE。)

Windows 會假設背景計算 MM_TEXT 對應模式。 如果裝置內容使用任何其他對應模式，清除的區域可能無法在用戶端區域的可見部分。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onexitmenuloop"></a>  CWnd::OnExitMenuLoop

已結束功能表強制回應迴圈時，架構會呼叫此成員函式。

```
afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定相關的功能表是否快顯功能表。 有非零值，如果成功，函式否則為 0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onexitsizemove"></a>  CWnd::OnExitSizeMove

架構會呼叫此成員函式的受影響的視窗結束移動或調整大小強制回應迴圈後的一次。

```
afx_msg void OnExitSizeMove();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_EXITSIZEMOVE](/windows/desktop/winmsg/wm-exitsizemove)通知，Windows SDK 中所述。

視窗進入移動或調整大小強制回應迴圈，當使用者按一下視窗的標題列或調整大小框線，或當視窗通過[WM_SYSCOMMAND](/windows/desktop/menurc/wm-syscommand)訊息給[CWnd::DefWindowProc](#defwindowproc)函式和*wParam* SC_MOVE 或 SC_SIZE，指定該訊息的參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onfontchange"></a>  CWnd::OnFontChange

系統中的所有最上層視窗都會收到`OnFontChange`應用程式變更字型資源集區之後，從架構呼叫。

```
afx_msg void OnFontChange();
```

### <a name="remarks"></a>備註

加入或從系統移除字型的應用程式 (例如，透過[AddFontResource](/windows/desktop/api/wingdi/nf-wingdi-addfontresourcea)或是[RemoveFontResource](/windows/desktop/api/wingdi/nf-wingdi-removefontresourcea) Windows 函式) 應該傳送[WM_FONTCHANGE](/windows/desktop/gdi/wm-fontchange)訊息給所有最上層視窗。

若要傳送此訊息，請使用[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函式搭配*hWnd*參數設定為 HWND_BROADCAST。

##  <a name="ongetdlgcode"></a>  CWnd::OnGetDlgCode

呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。

```
afx_msg UINT OnGetDlgCode();
```

### <a name="return-value"></a>傳回值

一或多個下列值，指出哪一種類型的輸入應用程式處理序：

- DLGC_BUTTON 按鈕 （一般）。

- DLGC_DEFPUSHBUTTON 預設按鈕。

- DLGC_HASSETSEL EM_SETSEL 訊息。

- 預設按鈕處理 DLGC_UNDEFPUSHBUTTON 否。 （應用程式可以使用這個旗標與 DLGC_BUTTON，表示它會處理按鈕輸入，但是依賴系統有預設按鈕的處理）。

- DLGC_RADIOBUTTON 選項按鈕。

- DLGC_STATIC 靜態控制項。

- DLGC_WANTALLKEYS 所有鍵盤輸入。

- DLGC_WANTARROWS 方向鍵。

- DLGC_WANTCHARS WM_CHAR 訊息。

- DLGC_WANTMESSAGE 所有鍵盤輸入。 應用程式傳遞此訊息至控制項。

- DLGC_WANTTAB TAB 鍵。

### <a name="remarks"></a>備註

一般來說，Windows 會處理所有方向鍵和 TAB 鍵輸入`CWnd`控制項。 藉由覆寫`OnGetDlgCode`、`CWnd`控制項可以選擇特定類型的輸入程序本身。

預設值`OnGetDlgCode`函式的預先定義的控制項類別，傳回碼適用於每個類別。

##  <a name="ongetminmaxinfo"></a>  CWnd::OnGetMinMaxInfo

每當 Windows 必須知道最大化的位置或維度，或最小值或追蹤大小的最大值時，架構會呼叫此成員函式。

```
afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
```

### <a name="parameters"></a>參數

*lpMMI*<br/>
指向`MINMAXINFO`結構，包含視窗的相關資訊的最大化，大小和位置和大小的最小和最大的追蹤。 如需有關此結構的詳細資訊，請參閱[MINMAXINFO](/windows/desktop/api/winuser/ns-winuser-tagminmaxinfo)結構。

### <a name="remarks"></a>備註

其框線完全延伸，最大化的大小會是視窗的大小。 追蹤視窗大小的上限為可藉由使用框線，調整視窗大小的最大視窗大小。 追蹤視窗的大小最小值是最小的視窗大小可藉由使用框線調整視窗大小。

Windows 會填入一個點指定不同的位置和維度的預設值的陣列。 應用程式可能會變更這些值`OnGetMinMaxInfo`。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onhelp"></a>  CWnd::OnHelp

在應用程式 (使用目前的內容) 中處理 F1 說明。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>備註

請參閱[CWinApp::OnHelp](../../mfc/reference/cwinapp-class.md#onhelp)如需詳細資訊。

##  <a name="onhelpfinder"></a>  CWnd::OnHelpFinder

處理 ID_HELP_FINDER 和 ID_DEFAULT_HELP 命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>備註

請參閱[CWinApp::OnHelpFinder](../../mfc/reference/cwinapp-class.md#onhelpfinder)如需詳細資訊。

##  <a name="onhelpindex"></a>  CWnd::OnHelpIndex

處理 ID_HELP_INDEX 命令，並提供預設的說明主題。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>備註

請參閱[CWinApp::OnHelpIndex](../../mfc/reference/cwinapp-class.md#onhelpindex)如需詳細資訊。

##  <a name="onhelpinfo"></a>  CWnd::OnHelpInfo

當使用者按下 F1 鍵時，由架構呼叫。

```
afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
```

### <a name="parameters"></a>參數

*lpHelpInfo*<br/>
指標[HELPINFO](/windows/desktop/api/winuser/ns-winuser-taghelpinfo)包含功能表項目、 控制項、 對話方塊中或要求說明 視窗的相關資訊的結構。

### <a name="return-value"></a>傳回值

如果視窗有鍵盤焦點，或者如果功能表是作用中視窗，則傳回 TRUE。 如果沒有任何視窗擁有鍵盤焦點，則會傳回 FALSE。

### <a name="remarks"></a>備註

如果功能表在使用中時按下 F1 時，收到 WM_HELP 會傳送至與功能表關聯的視窗否則，WM_HELP 會傳送具有鍵盤焦點的視窗。 如果沒有任何視窗擁有鍵盤焦點，WM_HELP 會傳送到目前作用中視窗。

##  <a name="onhelpusing"></a>  CWnd::OnHelpUsing

處理 ID_HELP_USING 命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>備註

請參閱[CWinApp::OnHelpUsing](../../mfc/reference/cwinapp-class.md#onhelpusing)如需詳細資訊。

##  <a name="onhotkey"></a>  CWnd::OnHotKey

當使用者按下全系統的便捷鍵時，架構會呼叫此成員函式。

```
afx_msg void OnHotKey(
    UINT nHotKeyId,
    UINT nKey1,
    UINT nKey2);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHotKeyId*|[in]熱鍵產生訊息識別項。 如果訊息由系統定義的快速鍵產生，此參數將會是下列值之一：<br /><br /> 按-IDHOT_SNAPDESKTOP-嵌入式管理單元桌面的便捷鍵。<br />按-IDHOT_SNAPWINDOW-嵌入式管理單元 視窗的便捷鍵。|
|*nKey1*|[in]位元組合 (OR) 旗標，表示按下組合中所指定之金鑰的金鑰*nKey2*參數。 可能值為：<br /><br /> -向下保留 MOD_ALT-任一 ALT 鍵。<br />-向下保留 MOD_CONTROL-任一 CTRL 鍵。<br />-向下保留 MOD_SHIFT-任一 SHIFT 鍵。<br />-向下保留 MOD_WIN-任一 WINDOWS 鍵。 這些金鑰則標示為 「 Microsoft Windows 」 標誌。|
|*nKey2*|[in]熱鍵虛擬按鍵碼。|

### <a name="remarks"></a>備註

這個方法會接收[WM_HOTKEY](/windows/desktop/inputdev/wm-hotkey)通知，Windows SDK 中所述。 此訊息會放在頂端的 已註冊的熱鍵執行緒相關聯的訊息佇列。 使用[RegisterHotKey](/windows/desktop/api/winuser/nf-winuser-registerhotkey)函式，註冊全系統的快速鍵。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onhscroll"></a>  CWnd::OnHScroll

當使用者按一下視窗的水平捲軸，架構會呼叫此成員函式。

```
afx_msg void OnHScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSBCode*<br/>
指定捲軸的程式碼，指出使用者的捲動要求。 這個參數可以是下列其中一項：

- 若要最左邊的 SB_LEFT 捲軸。

- SB_ENDSCROLL 結束捲軸。

- SB_LINELEFT 捲軸向左。

- SB_LINERIGHT 捲軸的權限。

- 左 SB_PAGELEFT 捲動一頁。

- SB_PAGERIGHT 捲動一頁右邊。

- 最右側的 SB_RIGHT 捲軸。

- 絕對位置 SB_THUMBPOSITION 捲軸。 目前的位置由指定*nPos*參數。

- SB_THUMBTRACK 拖曳捲動方塊到指定的位置。 目前的位置由指定*nPos*參數。

*nPos*<br/>
指定捲動方塊的位置，捲軸的程式碼是否 SB_THUMBPOSITION 或 SB_THUMBTRACK;否則，不使用。 初始的捲軸範圍，根據*nPos*可以是負數，並且應該轉換成**int**如有必要。

*pScrollBar*<br/>
如果捲動訊息來自捲軸控制項，包含控制項的指標。 如果使用者按一下視窗的捲軸，則這個參數會是 NULL。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

SB_THUMBTRACK 捲軸的程式碼通常會使用捲動方塊被拖曳的期間，提供一些意見反應的應用程式。

如果應用程式單位捲動捲軸所控制的內容，也必須重設使用捲軸方塊的位置[SetScrollPos](#setscrollpos)成員函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#108](../../mfc/reference/codesnippet/cpp/cwnd-class_48.cpp)]

##  <a name="onhscrollclipboard"></a>  CWnd::OnHScrollClipboard

剪貼簿擁有者`OnHScrollClipboard`剪貼簿資料時，剪貼簿檢視器便會呼叫成員函式`CF_OWNERDISPLAY`格式化，並在剪貼簿檢視器的水平捲軸上沒有的事件。

```
afx_msg void OnHScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 剪貼簿檢視器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSBCode*<br/>
指定的其中一個下列的捲軸代碼中的低序位字組：

- 到右下的 SB_BOTTOM 捲軸。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 一個向下捲動一行。

- SB_LINEUP 捲軸上一行。

- 向下 SB_PAGEDOWN 捲動一頁。

- SB_PAGEUP 一個向上捲動一頁。

- 絕對位置 SB_THUMBPOSITION 捲軸。 目前的位置中提供*nPos*。

- 往左上方的 SB_TOP 捲軸。

*nPos*<br/>
如果捲軸的程式碼 SB_THUMBPOSITION;，包含捲動方塊位置否則無法使用。

### <a name="remarks"></a>備註

擁有者應該捲動剪貼簿影像、 使適當的區段失效，並更新捲軸值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oniconerasebkgnd"></a>  CWnd::OnIconEraseBkgnd

架構會呼叫此成員函式，針對最小化 （圖示）`CWnd`物件時必須填滿圖示的背景再繪製圖示。

```
afx_msg void OnIconEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
指定的裝置內容物件的圖示。 可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

`CWnd` 類別圖示定義視窗的預設實作; 時，才會收到此呼叫否則[OnEraseBkgnd](#onerasebkgnd)呼叫。

[DefWindowProc](#defwindowproc)成員函式會填滿圖示背景以父視窗的背景筆刷。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninitmenu"></a>  CWnd::OnInitMenu

當功能表即將變成現用時，架構會呼叫此成員函式。

```
afx_msg void OnInitMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
指定要初始化的功能表。 可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

`OnInitMenu` 當使用者按一下功能表列上的項目，或按下功能表鍵時呼叫。 若要修改的功能表，顯示此成員函式會覆寫。

`OnInitMenu` 只會呼叫一次，功能表第一次存取時 （例如，當使用者按一下功能表列上的項目）。 這個方法不提供功能表項目的相關資訊。 當使用者移動的功能表中的項目 （例如，藉由跨數個功能表項目中移動滑鼠） 函式不會呼叫一次。 一旦使用者從功能表結束 （例如，藉由按一下應用程式工作區），並稍後再按一下 功能表列上的項目，則會再次呼叫此函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninitmenupopup"></a>  CWnd::OnInitMenuPopup

當快顯功能表即將變成現用時，架構會呼叫此成員函式。

```
afx_msg void OnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nIndex,
    BOOL bSysMenu);
```

### <a name="parameters"></a>參數

*pPopupMenu*<br/>
指定快顯功能表的功能表的物件。 可能是暫時性的不應該儲存供稍後使用。

*nIndex*<br/>
指定在主功能表中的快顯功能表的索引。

*bSysMenu*<br/>
如果快顯功能表 [控制] 功能表中，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

這可讓應用程式，以修改快顯功能表，而不需要變更整個功能表顯示。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninputdevicechange"></a>  CWnd::OnInputDeviceChange

新增或從系統移除 I/O 裝置時，架構會呼叫此成員函式。

```
afx_msg void OnInputDeviceChange(unsigned short uFlag);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*uFlag*|[in]這個旗標可以包含下列值：<br /><br /> -GIDC_ARRIVAL-新裝置已新增至系統。<br />-GIDC_REMOVAL-裝置已從系統中移除。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUT_DEVICE_CHANGE](/windows/desktop/inputdev/wm-input-device-change)通知，Windows SDK 中所述。 是泛型的輸入的裝置的訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninputlangchange"></a>  CWnd::OnInputLangChange

變更應用程式的輸入的語言之後，架構會呼叫這個成員的最上層受影響的視窗。

```
afx_msg void OnInputLangChange(
    UINT nCharSet,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nCharSet*|[in]新的地區設定的字元集。 如需詳細資訊，請參閱 < *lfCharSet*的參數[LOGFONT](/windows/desktop/api/wingdi/ns-wingdi-taglogfonta)結構。|
|*nLocaleId*|[in]輸入法地區設定識別碼。 如需詳細資訊，請參閱 <<c0> [ 語言識別碼常數和字串](/windows/desktop/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUTLANGCHANGE](/windows/desktop/winmsg/wm-inputlangchange)通知訊息時，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="oninputlangchangerequest"></a>  CWnd::OnInputLangChangeRequest

當使用者選擇新的輸入的語言時，架構會呼叫這個成員具有焦點的視窗。

```
afx_msg void OnInputLangChangeRequest(
    UINT nFlags,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[in]位元 (OR) 旗標的組合，表示從上一個或下一個地區設定的地區設定中，已安裝的清單中選取新的地區設定或新輸入地區設定的鍵盤配置可以搭配系統字元集。<br /><br /> 可能的值為 INPUTLANGCHANGE_BACKWARD、 INPUTLANGCHANGE_FORWARD 和 INPUTLANGCHANGE_SYSCHARSET。|
|*nLocaleId*|[in]輸入法地區設定識別碼。 如需詳細資訊，請參閱 <<c0> [ 語言識別碼常數和字串](/windows/desktop/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUTLANGCHANGEREQUEST](/windows/desktop/winmsg/wm-inputlangchangerequest)通知訊息時，Windows SDK 中所述。 當使用者選擇新的輸入的語言，使用鍵盤控制台應用程式，或從系統工作列上的指示指定的其中一個快速鍵時，會公佈此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onkeydown"></a>  CWnd::OnKeyDown

在按下非系統鍵時，架構會呼叫此成員函式。

```
afx_msg void OnKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定指定的索引鍵的虛擬按鍵碼。 如需標準虛擬按鍵碼的清單，請參閱 Winuser.h

*nRepCnt*<br/>
重複計數 （次按鍵輸入會重複使用者按住按鍵的結果數目）。

*nFlags*<br/>
指定掃描程式碼、 索引鍵轉換程式碼前, 一個索引鍵的狀態和內容的程式碼，如下列清單所示：

|值|描述|
|-----------|-----------------|
|0-7|掃描程式碼 （OEM 相依值）。|
|8|擴充索引鍵，例如函式金鑰或 (1，表示它是擴充的索引鍵) 的數字鍵台上的索引鍵。|
|9-10|未使用。|
|11-12|Windows 內部使用。|
|13|（如果按下按鍵時，按住 ALT 鍵則為 1; 否則為 0） 的內容程式碼。|
|14|先前的重要狀態 (1 如果金鑰已關閉，再呼叫，也就是 0，如果索引鍵已啟動)。|
|15|轉換狀態 （如果發行的索引鍵為 1，0，表示按下索引鍵）。|

對於 WM_KEYDOWN 訊息，索引鍵轉換位元 (bit 15) 為 0，而內容程式碼位元 （位元 13） 為 0。

### <a name="remarks"></a>備註

非系統鍵是未按下 ALT 鍵並按下鍵盤按鍵或鍵盤按鍵已按下時`CWnd`具有輸入的焦點。

因為自動重複，多個`OnKeyDown`呼叫可能會發生在之前[OnKeyUp](#onkeyup)成員函式呼叫。 表示先前的主要狀態的位元可以用來判斷是否`OnKeyDown`呼叫是第一個向下轉換或重複向下轉換。

IBM 增強 101 和 102-key 鍵盤、 增強的金鑰為右邊的 alt 鍵和右邊的 CTRL 鍵，鍵盤; 的主要區段INS、 DEL、 首頁、 結束、 PAGE UP、 PAGE down 鍵、 和左邊的數字鍵台; 叢集中的方向鍵斜線 （/） 和數字鍵盤上的 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元*nFlags*。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onkeyup"></a>  CWnd::OnKeyUp

放開非系統鍵時，架構會呼叫此成員函式。

```
afx_msg void OnKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定指定的索引鍵的虛擬按鍵碼。 如需標準虛擬按鍵碼的清單，請參閱 Winuser.h

*nRepCnt*<br/>
重複計數 （次按鍵輸入會重複使用者按住按鍵的結果數目）。

*nFlags*<br/>
指定掃描程式碼、 索引鍵轉換程式碼前, 一個索引鍵的狀態和內容的程式碼，如下列清單所示：

|值|描述|
|-----------|-----------------|
|0-7|掃描程式碼 （OEM 相依值）。 高序位字組的低位元組。|
|8|擴充索引鍵，例如函式金鑰或 （如果它是擴充的索引鍵為 1; 否則為 0） 的數字鍵台上的索引鍵。|
|9-10|未使用。|
|11-12|Windows 內部使用。|
|13|（如果按下按鍵時，按住 ALT 鍵則為 1; 否則為 0） 的內容程式碼。|
|14|先前的重要狀態 (1 如果金鑰已關閉，再呼叫，也就是 0，如果索引鍵已啟動)。|
|15|轉換狀態 （如果發行的索引鍵為 1，0，表示按下索引鍵）。|

對於 WM_KEYUP 訊息，索引鍵轉換位元 (bit 15) 為 1，內容程式碼位元 （位元 13） 為 0。

### <a name="remarks"></a>備註

非系統鍵是未按下 ALT 鍵並按下鍵盤按鍵或鍵盤按鍵已按下時`CWnd`具有輸入的焦點。

IBM 增強 101 和 102-key 鍵盤、 增強的金鑰為右邊的 alt 鍵和右邊的 CTRL 鍵，鍵盤; 的主要區段INS、 DEL、 首頁、 結束、 PAGE UP、 PAGE down 鍵、 和左邊的數字鍵台; 叢集中的方向鍵斜線 （/） 和數字鍵盤上的 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元*nFlags*。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onkillfocus"></a>  CWnd::OnKillFocus

架構會失去輸入的焦點前立即呼叫此成員函式。

```
afx_msg void OnKillFocus(CWnd* pNewWnd);
```

### <a name="parameters"></a>參數

*pNewWnd*<br/>
指定收到輸入的焦點視窗的指標 （可能是 NULL，或可能是暫時性）。

### <a name="remarks"></a>備註

如果`CWnd`物件顯示插入號，插入號應該會在此時被終結。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onlbuttondblclk"></a>  CWnd::OnLButtonDblClk

當使用者按兩下滑鼠左鍵時，架構會呼叫此成員函式。

```
afx_msg void OnLButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

有 CS_DBLCLKS 的 windows [WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)樣式會收到`OnLButtonDblClk`呼叫。 這是 Microsoft Foundation Class windows 的預設值。 Windows 呼叫`OnLButtonDblClk`當使用者按下，釋出，然後按下滑鼠左的按鈕內系統的按兩下時間限制。 按兩下滑鼠左鍵時，實際上會產生四個事件：[WM_LBUTTONDOWN](#onlbuttondown)， [WM_LBUTTONUP](#onlbuttonup)訊息、 需要知道 WM_LBUTTONDBLCLK 呼叫時，以及另一個 WM_LBUTTONUP 訊息在放開按鍵時。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onlbuttondown"></a>  CWnd::OnLButtonDown

當使用者按下滑鼠左的按鈕時，架構會呼叫此成員函式。

```
afx_msg void OnLButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onlbuttonup"></a>  CWnd::OnLButtonUp

當使用者放開滑鼠左的按鈕時，架構會呼叫此成員函式。

```
afx_msg void OnLButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmbuttondblclk"></a>  CWnd::OnMButtonDblClk

當使用者按兩下滑鼠中鍵時，架構會呼叫此成員函式。

```
afx_msg void OnMButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

有 CS_DBLCLKS 的 windows [WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)樣式會收到`OnMButtonDblClk`呼叫。 這是所有 Microsoft Foundation Class 視窗的預設值。 Windows 會產生`OnMButtonDblClk`呼叫時，在使用者按下、 版本，然後按下滑鼠中間按鈕一次在系統中按兩下 時間限制。 按兩下滑鼠中鍵時，實際上會產生四個事件：[WM_MBUTTONDOWN](#onmbuttondown)並[WM_MBUTTONUP](#onmbuttonup)訊息、 WM_MBUTTONDBLCLK 呼叫，以及另一個 WM_MBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmbuttondown"></a>  CWnd::OnMButtonDown

當使用者按下滑鼠中鍵時，架構會呼叫此成員函式。

```
afx_msg void OnMButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmbuttonup"></a>  CWnd::OnMButtonUp

當使用者放開滑鼠中鍵時，架構會呼叫此成員函式。

```
afx_msg void OnMButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmdiactivate"></a>  CWnd::OnMDIActivate

架構會呼叫此成員函式，在已停用子視窗的子視窗，使其無法啟動。

```
afx_msg void OnMDIActivate(
    BOOL bActivate,
    CWnd* pActivateWnd,
    CWnd* pDeactivateWnd);
```

### <a name="parameters"></a>參數

*bActivate*<br/>
如果子系會啟用並如果它在已停用，則為 FALSE，則為 TRUE。

*pActivateWnd*<br/>
包含要啟動的 MDI 子視窗的指標。 當 MDI 子視窗收到*pActivateWnd*包含要啟動的子視窗的指標。 這個指標可能是暫時性的不應該儲存供稍後使用。

*pDeactivateWnd*<br/>
包含在已停用的 MDI 子視窗的指標。 這個指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

獨立 MDI 框架視窗啟用 MDI 子視窗。 當框架會變成作用中、 與上次啟動的子視窗`OnMDIActivate`呼叫都會收到[WM_NCACTIVATE](#onncactivate)訊息，來繪製作用中的視窗框架和標題列，但它不會收到另一個`OnMDIActivate`呼叫。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmeasureitem"></a>  CWnd::OnMeasureItem

架構會呼叫此成員函式由架構主控描繪按鈕、 下拉式方塊、 清單方塊或功能表項目擁有者建立控制項時。

```
afx_msg void OnMeasureItem(
    int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
控制項的 ID。

*lpMeasureItemStruct*<br/>
指向[MEASUREITEMSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagmeasureitemstruct)資料結構，其中包含主控描繪控制項的維度。

### <a name="remarks"></a>備註

覆寫此成員函式，並填寫`MEASUREITEMSTRUCT`所指向的資料結構*lpMeasureItemStruct*和傳回，這會通知 Windows 的控制項的維度，並可讓處理與使用者互動的 Windows正確地控制。

如果清單方塊或下拉式方塊以建立[LBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)或是[CBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)樣式，架構會呼叫此函式的擁有者，每個項目在控制項中，否則這函式會呼叫一次。

Windows 起始的呼叫`OnMeasureItem`下拉式方塊和傳送之前，先建立 OWNERDRAWFIXED 樣式的清單方塊的擁有者[WM_INITDIALOG](/windows/desktop/dlgbox/wm-initdialog)訊息。 如此一來，當擁有者收到此呼叫時，Windows 尚未尚未判定的高度和寬度的控制項; 中所使用的字型函式呼叫和計算需要這些值應該發生的程式庫的應用程式的 main 函式。

如果要測量的項目`CMenu`，`CListBox`或是`CComboBox`物件，則`MeasureItem`呼叫虛擬函式的適當的類別。 覆寫`MeasureItem`計算並設定每個項目的大小適當的控制項類別成員函式。

`OnMeasureItem` 將會呼叫控制項的類別建立在執行階段，或建立 LBS_OWNERDRAWVARIABLE 或 CBS_OWNERDRAWVARIABLE 樣式時，才可以。 如果控制項由對話方塊編輯器中，建立`OnMeasureItem`將不會呼叫。 這是因為[WM_MEASUREITEM](/windows/desktop/Controls/wm-measureitem)及早在控制項的建立程序中傳送訊息。 如果您子類別使用`DDX_Control`， `SubclassDlgItem`，或`SubclassWindow`，子類別化在建立程序之後，通常會發生。 因此，沒有任何方法來處理[WM_MEASUREITEM](/windows/desktop/Controls/wm-measureitem)控制項中的訊息`OnChildNotify`函式，這是 MFC 用來實作 ON_WM_MEASUREITEM_REFLECT 的機制。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenuchar"></a>  CWnd::OnMenuChar

當使用者按下功能表的助憶鍵字元，不符合任何預先定義的助憶鍵在目前的功能表中，架構會呼叫此成員函式。

```
afx_msg LRESULT OnMenuChar(
    UINT nChar,
    UINT nFlags,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

*nChar*<br/>
根據組建設定中，指定使用者按下的 ANSI 或 Unicode 字元。

*nFlags*<br/>
如果功能表快顯功能表，請包含 MF_POPUP 旗標。 如果功能表是在控制項，它就會包含 MF_SYSMENU 旗標。

*pMenu*<br/>
包含所選的指標`CMenu`。 指標可能是暫時性的不應該儲存。

### <a name="return-value"></a>傳回值

傳回值的高序位文字應該包含下列指令碼的其中一個：

|值|描述|
|-----------|-----------------|
|0|會告知 Windows 捨棄使用者按下並系統說話者上建立的短嗶聲的字元。|
|1|會告知 Windows 關閉目前的功能表。|
|2|通知 Windows 傳回值的低序位字組包含特定項目的項目數目。 Windows 會選取此項目。|

如果高序位文字包含 0 或 1，則會忽略低序位字組。 快速鍵 （捷徑） 來選取放在功能表中的點陣圖時，應用程式應該處理此訊息。

### <a name="remarks"></a>備註

它會傳送至`CWnd`擁有功能表。 `OnMenuChar` 也稱為時使用者按下 alt 鍵和任何其他的金鑰，即使金鑰沒有對應至助憶鍵字元。 在此情況下， *pMenu*指向所擁有的功能表`CWnd`，以及*nFlags*為 0。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenudrag"></a>  CWnd::OnMenuDrag

當使用者開始拖曳功能表項目時，架構會呼叫目前的拖放功能表的這個成員函式。

```
afx_msg UINT OnMenuDrag(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nPos*|[in]在拖曳作業開始時之功能表項目的索引位置。|
|*pMenu*|[in]指標[CMenu](../../mfc/reference/cmenu-class.md)物件，包含功能表項目。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MND_CONTINUE|功能表應保持作用中。 如果已釋放滑鼠，則應該忽略。|
|MND_ENDMENU|功能表應該會結束。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MENUDRAG](/windows/desktop/menurc/wm-menudrag)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenugetobject"></a>  CWnd::OnMenuGetObject

當滑鼠游標進入功能表項目，或從項目中央移到頂端或底部的項目時，架構會呼叫目前的拖放功能表的這個成員函式。

```
afx_msg UINT OnMenuGetObject(MENUGETOBJECTINFO* pMenuGetObjectInfo);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*pMenu*|[in]指標[MENUGETOBJECTINFO](/windows/desktop/api/winuser/ns-winuser-tagmenugetobjectinfo)所在的結構，其中包含滑鼠游標拖放功能表的相關資訊。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MNGO_NOERROR|支援拖放並拖曳作業的介面指標都會傳入`pvObj`隸屬[MENUGETOBJECTINFO](/windows/desktop/api/winuser/ns-winuser-tagmenugetobjectinfo)結構。 目前，只有[IDropTarget](/windows/desktop/api/oleidl/nn-oleidl-idroptarget)支援介面。|
|MNGO_NOINTERFACE|不支援任何卸除並拖曳的介面。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MENUGETOBJECT](/windows/desktop/menurc/wm-menugetobject)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenurbuttonup"></a>  CWnd::OnMenuRButtonUp

當使用者放開滑鼠右按鈕，而游標位於功能表項目上時，架構會呼叫此成員函式。

```
afx_msg void OnMenuRButtonUp(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nPos*|[in]功能表項目時放開滑鼠右按鈕的索引位置。|
|*pMenu*|[in]指標[CMenu](../../mfc/reference/cmenu-class.md)物件，包含功能表項目。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MENURBUTTONUP](/windows/desktop/menurc/wm-menurbuttonup)通知，Windows SDK 中所述。 [WM_MENURBUTTONUP](/windows/desktop/menurc/wm-menurbuttonup)訊息可讓應用程式提供即時線上功能表項目訊息中指定的功能表。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmenuselect"></a>  CWnd::OnMenuSelect

如果`CWnd`物件會與功能表關聯`OnMenuSelect`使用者選取功能表項目時，由架構呼叫。

```
afx_msg void OnMenuSelect(
    UINT nItemID,
    UINT nFlags,
    HMENU hSysMenu);
```

### <a name="parameters"></a>參數

*nItemID*<br/>
識別選取的項目。 如果選取的項目是功能表項目*nItemID*包含功能表項目識別碼。 如果選取的項目包含快顯功能表中， *nItemID*包含快顯功能表的索引，以及*hSysMenu*包含主要的 （按下入） 功能表的控制代碼。

*nFlags*<br/>
包含下列功能表旗標的組合：

- MF_BITMAP 項目是一個點陣圖。

- 會檢查 MF_CHECKED 項目。

- MF_DISABLED 項目已停用。

- MF_GRAYED 項目會呈現暗灰色。

- 使用滑鼠選取 MF_MOUSESELECT 項目。

- MF_OWNERDRAW 項目是主控描繪項目。

- MF_POPUP 項目包含快顯功能表。

- MF_SEPARATOR 項目是功能表項目分隔符號。

- MF_SYSMENU 項目都包含在 [控制] 功能表。

*hSysMenu*<br/>
如果*nFlags*包含 MF_SYSMENU，識別與訊息關聯的功能表。 如果*nFlags*包含 MF_POPUP，則會識別主功能表的控制代碼。 如果*nFlags*包含 MF_SYSMENU 和 MF_POPUP，都不是未使用。

### <a name="remarks"></a>備註

如果*nFlags*包含 0xFFFF 並*hSysMenu*包含 0，因為使用者按下 ESC 鍵或按下功能表之外，Windows 已關閉功能表。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmouseactivate"></a>  CWnd::OnMouseActivate

當游標處於非現用視窗，且使用者按下滑鼠按鈕時，架構會呼叫此成員函式。

```
afx_msg int OnMouseActivate(
    CWnd* pDesktopWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pDesktopWnd*<br/>
指定 [啟動] 視窗的最上層的父視窗的指標。 指標可能是暫時性的不應該儲存。

*nHitTest*<br/>
指定[點擊測試](#onnchittest)區碼。 點擊的測試是測試，決定游標的位置。

*message*<br/>
指定滑鼠訊息數目。

### <a name="return-value"></a>傳回值

指定是否要啟動`CWnd`以及是否要捨棄的滑鼠事件。 它必須是下列值之一：

- 啟用 MA_ACTIVATE`CWnd`物件。

- MA_NOACTIVATE 不要啟動`CWnd`物件。

- 啟用 MA_ACTIVATEANDEAT`CWnd`物件，並捨棄的滑鼠事件。

- MA_NOACTIVATEANDEAT 不要啟動`CWnd`物件，並捨棄的滑鼠事件。

### <a name="remarks"></a>備註

預設實作會將此訊息傳遞給父視窗中，任何處理發生之前。 如果父視窗傳回 TRUE，則會停止處理。

如需個別的點擊測試區域代碼的說明，請參閱 < [OnNcHitTest](#onnchittest)成員函式

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCAxCtl#9](../../mfc/reference/codesnippet/cpp/cwnd-class_49.cpp)]

##  <a name="onmousehover"></a>  CWnd::OnMouseHover

當游標停留在先前呼叫中指定的時間週期 視窗的工作區時，架構會呼叫此成員函式[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。

```
afx_msg void OnMouseHover(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nFlags*|[in]位元組合 (OR) 旗標，表示按下的輔助按鍵。 比方說，MK_CONTROL 旗標表示，按下 CTRL 鍵。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於用戶端區域左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MOUSEHOVER](/windows/desktop/inputdev/wm-mousehover)通知，Windows SDK 中所述。

*NFlags*參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱 <<c0> [ 有關滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|已按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左的按鈕。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右按鈕。|
|MK_SHIFT|已按下 SHIFT 鍵。|
|MK_XBUTTON1|Microsoft intellimouse 滑鼠的 XBUTTON1 滑鼠按鈕已按下。|
|MK_XBUTTON2|Microsoft IntelliMouse XBUTTON2 滑鼠按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmousehwheel"></a>  CWnd::OnMouseHWheel

當目前的視窗由所組成的桌面視窗管理員 (DWM)，且該視窗最大化時，架構會呼叫這個成員。

```
afx_msg void OnMouseHWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nFlags*|[in]位元組合 (OR) 旗標，表示按下的輔助按鍵。 比方說，MK_CONTROL 旗標表示，按下 CTRL 鍵。<br /><br /> 如需旗標的清單，請參閱中的 < 訊息參數 > 子標題[有關滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。|
|*zDelta*|[in]表示旋轉的滾輪時，以表示倍數或部門的 WHEEL_DELTA，這是 120 的距離。 正值表示滾輪旋轉至右側;負值表示滾輪已輪到左邊。|
|*pt*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於用戶端區域左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_MOUSEHWHEEL](/windows/desktop/inputdev/wm-mousehwheel)通知訊息時，Windows SDK 中所述。 此訊息會傳送至視窗具有焦點時滑鼠的水平滾輪傾斜或旋轉。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmouseleave"></a>  CWnd::OnMouseLeave

當游標離開之前的呼叫中所指定視窗的工作區時，架構會呼叫此成員函式[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。

```
afx_msg void OnMouseLeave();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_MOUSELEAVE](/windows/desktop/inputdev/wm-mouseleave)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmousemove"></a>  CWnd::OnMouseMove

當滑鼠游標移動時，架構會呼叫此成員函式。

```
afx_msg void OnMouseMove(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

不會捕捉滑鼠，如果收到 WM_MOUSEMOVE 訊息`CWnd`物件下方滑鼠資料指標; 否則訊息會進入已捕捉滑鼠的視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmousewheel"></a>  CWnd::OnMouseWheel

當使用者滾動滑鼠滾輪，且遇到滾輪的下一波陷，架構會呼叫此成員函式。

```
afx_msg BOOL OnMouseWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果右滑鼠按鈕，將設定 MK_RBUTTON 已關閉。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*zDelta*<br/>
表示距離旋轉。 *ZDelta*值以表示倍數或部門的 WHEEL_DELTA，這是 120。 小於零的值，指出旋轉後 （朝向使用者），而大於零，表示向前旋轉 （遠離使用者） 的值。 使用者可以藉由變更滑鼠軟體中的滾輪設定反轉此回應。 請參閱 「 備註 」，如需有關此參數。

*pt*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於螢幕左上角。

### <a name="return-value"></a>傳回值

如果滑鼠滾輪捲動啟用，則為非零否則為 0。

### <a name="remarks"></a>備註

覆寫時，除非`OnMouseWheel`呼叫的預設值[WM_MOUSEWHEEL](/windows/desktop/inputdev/wm-mousewheel)。 Windows 會自動將訊息路由至具有焦點的控制項或子視窗。 Win32 函式[DefWindowProc](/windows/desktop/api/winuser/nf-winuser-defwindowproca)傳播父鏈結，處理視窗訊息。

*ZDelta*參數是 WHEEL_DELTA，設定在 120 的倍數。 這個值是要採取的動作的臨界值和一個這類動作 （例如，捲動正一波陷） 應該針對每個差異。

WHEEL_DELTA 以便進行更精細地解析滾輪，例如自由旋轉的滾輪，以任何格設定為 120。 更精細地解析滾輪傳送更多的訊息，每次旋轉，但每個訊息都較小的差異值。 若要使用這類滾輪，請新增傳入*zDelta*值，直到達到 WHEEL_DELTA 時 （以便您可以取得相同的回應為給定的差異旋轉），或捲動以回應更頻繁的訊息部分的行。 您也可以選擇捲軸的資料粒度，以及這些差異會累積，直到達到 WHEEL_DELTA。

覆寫此成員函式，以提供您自己的滑鼠滾輪捲動行為。

> [!NOTE]
> `OnMouseWheel` Windows NT 4.0 及更新版本，會處理訊息。 對於 Windows 95/98 或 Windows NT 3.51 訊息處理，使用[OnRegisteredMouseWheel](#onregisteredmousewheel)。

##  <a name="onmove"></a>  CWnd::OnMove

架構會呼叫此成員函式之後,`CWnd`在移動物件。

```
afx_msg void OnMove(
    int x,
    int y);
```

### <a name="parameters"></a>參數

*x*<br/>
指定用戶端區域的左上角的新 x 座標位置。 重疊和快顯視窗中，螢幕座標中指定這個新的位置和子視窗的父代用戶端座標。

*y*<br/>
指定用戶端區域的左上角的新 y 座標位置。 重疊和快顯視窗中，螢幕座標中指定這個新的位置和子視窗的父代用戶端座標。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onmoving"></a>  CWnd::OnMoving

架構會呼叫此成員函式，而使用者正在移動`CWnd`物件。

```
afx_msg void OnMoving(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*nSide*<br/>
要移動的視窗邊緣。

*lpRect*<br/>
位址[CRect](../../atl-mfc-shared/reference/crect-class.md)或是[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，就會包含項目的座標。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncactivate"></a>  CWnd::OnNcActivate

當非工作區需要變更以表示作用中或非作用中狀態時，架構會呼叫此成員函式。

```
afx_msg BOOL OnNcActivate(BOOL bActive);
```

### <a name="parameters"></a>參數

*bActive*<br/>
指定的標題列或圖示需要時變更，以表示作用中或非作用中狀態。 *BActive*參數為 TRUE，如果作用中的標題，或為要繪製的圖示。 它將為 FALSE 的非作用中的標題或圖示。

### <a name="return-value"></a>傳回值

如果 Windows 應該繼續進行; 的預設處理，非零值。若要防止在已停用的標題列或圖示的 0。

### <a name="remarks"></a>備註

預設實作會繪製的標題列和標題列中其作用中色彩的文字如果*bActive*為 true，則和其非作用中色彩如果*bActive*為 FALSE。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnccalcsize"></a>  CWnd::OnNcCalcSize

大小和位置的工作區需要計算時，架構會呼叫此成員函式。

```
afx_msg void OnNcCalcSize(
    BOOL bCalcValidRects,
    NCCALCSIZE_PARAMS* lpncsp);
```

### <a name="parameters"></a>參數

*bCalcValidRects*<br/>
指定應用程式是否應該指定用戶端區域的哪一個部分包含有效的資訊。 Windows 會將有效的資訊複製到新的用戶端區域內的指定區域。 如果此參數為 TRUE，應用程式應指定用戶端區域的哪一部分無效。

*lpncsp*<br/>
指向[NCCALCSIZE_PARAMS](/windows/desktop/api/winuser/ns-winuser-tagnccalcsize_params)包含應用程式可以用來計算新的大小和位置資訊的資料結構`CWnd`矩形 （包括工作區、 框線、 標題、 捲軸等等）.

### <a name="remarks"></a>備註

藉由處理這個訊息，應用程式可以控制視窗的工作區的內容的大小或視窗的位置變更時。

值為何*bCalcValidRects*，在所指定之陣列中的第一個矩形`rgrc`結構成員的`NCCALCSIZE_PARAMS`結構包含視窗的座標。 子視窗座標是相對於父視窗工作區。 為最上層的視窗的螢幕座標。 應用程式應該修改`rgrc[0]`矩形以反映的大小和位置的工作區。

`rgrc[1]`並`rgrc[2]`矩形的有效期只有當*bCalcValidRects*為 TRUE。 在此情況下，`rgrc[1]`移動或調整大小之前，矩形會包含視窗的座標。 `rgrc[2]`矩形包含視窗的工作區座標之前已移動的視窗。 所有座標都是相對於父視窗或畫面。

預設實作會計算視窗特性 （顯示捲軸列、 功能表等），為基礎的工作區的大小，並會在將結果放*lpncsp*。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnccreate"></a>  CWnd::OnNcCreate

架構會呼叫此成員函式之前[WM_CREATE](#oncreate)訊息時`CWnd`第一次建立物件。

```
afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreateStruct*<br/>
指向[CREATESTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcreatestructa)的資料結構`CWnd`。

### <a name="return-value"></a>傳回值

如果建立非工作區，則為非零。 它會是 0，如果發生錯誤`Create`函式會傳回**失敗**在此情況下。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncdestroy"></a>  CWnd::OnNcDestroy

當非工作區正在損毀，而最後一個成員函式稱為 Windows 視窗終結時由架構呼叫。

```
afx_msg void OnNcDestroy();
```

### <a name="remarks"></a>備註

預設實作會執行某些清除，然後會呼叫虛擬成員函式[PostNcDestroy](#postncdestroy)。

覆寫`PostNcDestroy`如果您想要執行您自己的清除作業，例如**刪除此**作業。 如果您覆寫`OnNcDestroy`，您必須呼叫`OnNcDestroy`您基底類別，以確保在內部配置視窗就會釋放任何記憶體中。

##  <a name="onnchittest"></a>  CWnd::OnNcHitTest

架構會呼叫此成員函式`CWnd`物件，其中包含資料指標 (或`CWnd`物件所[SetCapture](#setcapture)成員函式來擷取滑鼠輸入) 每次滑鼠移動。

```
afx_msg LRESULT OnNcHitTest(CPoint point);
```

### <a name="parameters"></a>參數

*point*<br/>
包含資料指標 x 和 y 座標。 這些座標永遠是螢幕座標。

### <a name="return-value"></a>傳回值

滑鼠點擊測試的其中一個列舉值。 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)如值的清單。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnclbuttondblclk"></a>  CWnd::OnNcLButtonDblClk

架構會呼叫此成員函式，當使用者按兩下滑鼠左鍵，而游標位於的非工作區內`CWnd`。

```
afx_msg void OnNcLButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)如值的清單。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

如果適用的話[WM_SYSCOMMAND](#onsyscommand)傳送訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnclbuttondown"></a>  CWnd::OnNcLButtonDown

當使用者按下滑鼠左鍵，而游標位於的非工作區內時，架構會呼叫此成員函式`CWnd`物件。

```
afx_msg void OnNcLButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)如值的清單。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

如果適用的話[WM_SYSCOMMAND](#onsyscommand)傳送。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至您的函式的參數反映收到訊息時架構所收到的參數。如果您呼叫此函式的基底類別實作時，該實作會使用原本不是您提供參數與訊息傳遞至函數的參數。

##  <a name="onnclbuttonup"></a>  CWnd::OnNcLButtonUp

當使用者放開滑鼠左鍵，而游標位於的非工作區內時，架構會呼叫此成員函式。

```
afx_msg void OnNcLButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。 請參閱[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)如值的清單。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

如果適用的話[WM_SYSCOMMAND](#onsyscommand)傳送。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmbuttondblclk"></a>  CWnd::OnNcMButtonDblClk

當使用者按兩下滑鼠中鍵，而游標位於的非工作區內，架構會呼叫此成員函式。

```
afx_msg void OnNcMButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmbuttondown"></a>  CWnd::OnNcMButtonDown

當使用者按下滑鼠中鍵，而游標位於的非工作區內時，架構會呼叫此成員函式。

```
afx_msg void OnNcMButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmbuttonup"></a>  CWnd::OnNcMButtonUp

當使用者放開滑鼠中鍵，而游標位於的非工作區內時，架構會呼叫此成員函式。

```
afx_msg void OnNcMButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmousehover"></a>  CWnd::OnNcMouseHover

當游標停留在先前呼叫中指定的時間週期 視窗中非工作區時，架構會呼叫此成員函式[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。

```
afx_msg void OnNcMouseHover(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|[in]所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於螢幕左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NCMOUSEHOVER](/windows/desktop/inputdev/wm-ncmousehover)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmouseleave"></a>  CWnd::OnNcMouseLeave

當游標離開之前的呼叫中所指定視窗的非工作區時，架構會呼叫此成員函式[TrackMouseEvent](/windows/desktop/api/winuser/nf-winuser-trackmouseevent)。

```
afx_msg void OnNcMouseLeave();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_NCMOUSELEAVE](/windows/desktop/inputdev/wm-ncmouseleave)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncmousemove"></a>  CWnd::OnNcMouseMove

當資料指標的非工作區內移動時，架構會呼叫此成員函式。

```
afx_msg void OnNcMouseMove(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

如果適用的話[WM_SYSCOMMAND](#onsyscommand)傳送訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncpaint"></a>  CWnd::OnNcPaint

當非工作區需要繪製時，架構會呼叫此成員函式。

```
afx_msg void OnNcPaint();
```

### <a name="remarks"></a>備註

預設實作會繪製視窗框架。

應用程式可以覆寫此呼叫，並繪製它自己自訂的視窗框架。 即使框架的形狀會改變，會一律矩形的裁剪區域。

##  <a name="onncrbuttondblclk"></a>  CWnd::OnNcRButtonDblClk

架構會呼叫此成員函式，當使用者按兩下滑鼠右鍵，而游標位於的非工作區內`CWnd`。

```
afx_msg void OnNcRButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncrbuttondown"></a>  CWnd::OnNcRButtonDown

當使用者按下滑鼠右按鈕，而游標位於的非工作區內時，架構會呼叫此成員函式。

```
afx_msg void OnNcRButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncrbuttonup"></a>  CWnd::OnNcRButtonUp

當使用者放開滑鼠右按鈕，而游標位於的非工作區內時，架構會呼叫此成員函式。

```
afx_msg void OnNcRButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[點擊測試的程式碼](#onnchittest)。 點擊的測試是測試，決定游標的位置。

*point*<br/>
指定`CPoint`物件，包含 x 和 y 螢幕座標的游標位置。 這些座標永遠是相對於螢幕左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncrenderingchanged"></a>  CWnd::OnNcRenderingChanged

當非工作區轉譯原則已變更時，架構會呼叫這個成員。

```
afx_msg void OnNcRenderingChanged(BOOL bIsRendering);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*bIsRendering*|[in]如果已啟用的視窗中中, 非工作區的桌面視窗管理員 (DWM) 呈現，則為 TRUE。如果轉譯已停用，則為 FALSE。|

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMNCRENDERINGCHANGED](/windows/desktop/dwm/wm-dwmncrenderingchanged)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncxbuttondblclk"></a>  CWnd::OnNcXButtonDblClk

當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時，架構會呼叫此成員函式。

```
void OnNcXButtonDblClk(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nHitTest*|[in]所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息。|
|*nButton*|[in]值，如果第一個 Microsoft Intellimouse X 按鈕是按兩下 XBUTTON1 或 XBUTTON2 如果第二個 X 按鈕按兩下時。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於用戶端區域左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONDBLCLK](/windows/desktop/inputdev/wm-xbuttondblclk)通知，Windows SDK 中所述。 此訊息會張貼包含游標的視窗。 如果視窗已捕捉滑鼠，會不會發佈此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncxbuttondown"></a>  CWnd::OnNcXButtonDown

當使用者按下 XBUTTON1 或 XBUTTON2 的滑鼠游標位於視窗的非工作區時，架構會呼叫此成員函式。

```
afx_msg void OnNcXButtonDown(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nHitTest*|[in]所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息。|
|*nButton*|[in]的值如果按下第一個 X 滑鼠鍵的 XBUTTON1 或 XBUTTON2 如果第二個 X 按鈕按下。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於螢幕左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NCXBUTTONDOWN](/windows/desktop/inputdev/wm-ncxbuttondown)通知，Windows SDK 中所述。 此訊息會張貼包含游標的視窗。 如果視窗已捕捉滑鼠，會不會發佈此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onncxbuttonup"></a>  CWnd::OnNcXButtonUp

當使用者放開 XBUTTON1 或 XBUTTON2 的滑鼠，而游標位於視窗的非工作區時，架構會呼叫此成員函式。

```
afx_msg void OnNcXButtonUp(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|[in]所傳回的點擊測試值[CWnd::DefWindowProc](#defwindowproc)函式的結果處理[WM_NCHITTEST](/windows/desktop/inputdev/wm-nchittest)訊息。|
|*nButton*|[in]值為第一個 X 放開滑鼠按鈕時，如果 XBUTTON1 或 XBUTTON2 如果第二個 X 按鈕已釋放。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於螢幕左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NCXBUTTONUP](/windows/desktop/inputdev/wm-ncxbuttonup)通知，Windows SDK 中所述。 此訊息會張貼包含游標的視窗。 如果視窗已捕捉滑鼠，會不會發佈此訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnextmenu"></a>  CWnd::OnNextMenu

使用右或向左鍵切換功能表列和系統功能表時，架構會呼叫此成員函式。

```
afx_msg void OnNextMenu(
    UINT nKey,
    LPMDINEXTMENU lpMdiNextMenu);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nKey*|[in]位元組合 (OR) 旗標，表示按下的輔助按鍵。 比方說，MK_CONTROL 旗標表示，按下 CTRL 鍵。<br /><br /> 如需旗標的清單，請參閱中的 < 訊息參數 > 子標題[有關滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。|
|*lpMdiNextMenu*|[in]指標[MDINEXTMENU](/windows/desktop/api/winuser/ns-winuser-tagmdinextmenu)結構，其中包含 [啟動] 功能表的相關資訊。|

### <a name="remarks"></a>備註

這個方法會接收[WM_UNINITMENUPOPUP](/windows/desktop/menurc/wm-uninitmenupopup)通知，Windows SDK 中所述。 為了回應此訊息，可以設定您的應用程式`hmenuNext`隸屬[MDINEXTMENU](/windows/desktop/api/winuser/ns-winuser-tagmdinextmenu)結構，以指定要切換的功能表和`hwndNext`成員來指定要接收通知的功能表訊息的視窗.

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onnotify"></a>  CWnd::OnNotify

架構會呼叫此成員函式，來通知控制項的父視窗，在事件發生在控制項或控制項需要某種類型的資訊。

```
virtual BOOL OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
識別傳送訊息，如果訊息是從控制項的控制項。 否則，請*wParam*為 0。

*lParam*<br/>
通知訊息的指標 (`NMHDR`) 結構，包含通知程式碼和其他資訊。 對於某些通知的訊息，此參數會指向較大的結構，其`NMHDR`做為其第一個成員的結構。

*pResult*<br/>
用來儲存結果的程式碼，如果處理訊息的 LRESULT 變數的指標。

### <a name="return-value"></a>傳回值

應用程式會傳回非零值，如果它會處理此訊息;否則為 0。

### <a name="remarks"></a>備註

`OnNotify` 處理控制項告知的訊息對應。

覆寫此成員函式，以處理 WM_NOTIFY 訊息衍生類別中。 覆寫將無法處理的訊息對應，除非基底類別`OnNotify`呼叫。

如需有關的 WM_NOTIFY 訊息的詳細資訊，請參閱 < 技術提示 61 (TN061)， [ON_NOTIFY 和 WM_NOTIFY 訊息](../../mfc/tn061-on-notify-and-wm-notify-messages.md)。 您也可能想要的相關的主題中所述[控制主題](../../mfc/controls-mfc.md)，和 TN062，[訊息反映的 Windows 控制項](../../mfc/tn062-message-reflection-for-windows-controls.md)。

##  <a name="onnotifyformat"></a>  CWnd::OnNotifyFormat

架構會呼叫此成員函式，來判斷是否目前的視窗接受 ANSI 或 Unicode 結構的 WM_NOTIFY 通知訊息中。

```
afx_msg UINT OnNotifyFormat(
    CWnd* pWnd,
    UINT nCommand);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*pWnd*|[in]指標`CWnd`物件，表示視窗傳送[WM_NOTIFY](/windows/desktop/controls/wm-notify)訊息。<br /><br /> 這個參數是控制項的指標，如果*nCommand*參數則 NF_QUERY 或控制項的父視窗的指標*nCommand*是 NF_REQUERY。|
|*nCommand*|[in]命令值特製化的 WM_NOTIFY 訊息。 可能值為：<br /><br /> -NF_QUERY-<br />     訊息是查詢來決定是否應該在 WM_NOTIFY 訊息中使用 ANSI 或 Unicode 結構。 此訊息會建立一個控制項，然後在 NF_REQUERY 表單，此訊息的回應期間，從控制項傳送至其父視窗。<br />-NF_REQUERY-<br />     訊息是 NF_QUERY 表單傳送此訊息至其父視窗控制項的要求。 此要求會從父視窗中，傳送，並要求重新查詢在 WM_NOTIFY 訊息中使用的結構類型的相關父控制項。 如果*nCommand*參數是 NF_REQUERY，傳回的值是重新查詢作業的結果。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|NFR_ANSI|ANSI 結構應該用於控制項所傳送的 WM_NOTIFY 訊息。|
|NFR_UNICODE|控制項所傳送的 WM_NOTIFY 訊息中，應該使用 Unicode 結構。|
|0|發生錯誤。|

### <a name="remarks"></a>備註

這個方法會接收[WM_NOTIFYFORMAT](/windows/desktop/Controls/wm-notifyformat)通知，Windows SDK 中所述。 WM_NOTIFY 訊息傳送至其父視窗中，將通用控制項和通用控制項的父視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpaint"></a>  CWnd::OnPaint

當 Windows 或應用程式提出的要求，以重新繪製的應用程式視窗的一部份，架構會呼叫此成員函式。

```
afx_msg void OnPaint();
```

### <a name="remarks"></a>備註

[WM_PAINT](/windows/desktop/gdi/the-wm-paint-message)訊息時送[UpdateWindow](#updatewindow)或是[RedrawWindow](#redrawwindow)呼叫成員函式。

視窗可能會收到內部的繪製訊息，因為呼叫`RedrawWindow`RDW_INTERNALPAINT 具有成員函式的旗標集。 在此情況下，視窗不能更新區域。 應用程式應該呼叫[GetUpdateRect](#getupdaterect)成員函式，來判斷視窗是否有更新區域。 如果`GetUpdateRect`傳回 0 時，應用程式不應該呼叫[BeginPaint](#beginpaint)並[EndPaint](#endpaint)成員函式。

應用程式必須負責檢查是否有任何必要的內部重繪或更新來看看每個 WM_PAINT 訊息其內部資料結構，因為 WM_PAINT 訊息可能已造成的不正確的區域和呼叫`RedrawWindow`RDW_INTERNALPAINT 具有成員函式的旗標集。

由 Windows 中，內部 WM_PAINT 訊息會傳送一次。 之後內部 WM_PAINT 訊息傳送至視窗`UpdateWindow`成員函式，將會傳送或張貼直到視窗會失效，或直到沒有進一步的 WM_PAINT 訊息`RedrawWindow`RDW_INTERNALPAINT 使用一次呼叫成員函式設定旗標。

在呈現文件/檢視應用程式中的映像的資訊，請參閱[cview:: Ondraw](../../mfc/reference/cview-class.md#ondraw)。

如需有關使用`WM_Paint`，請參閱 Windows SDK 中的下列主題：

- [WM_PAINT 訊息](/windows/desktop/gdi/the-wm-paint-message)

- [使用 WM_PAINT 訊息](/windows/desktop/gdi/using-the-wm-paint-message)

##  <a name="onpaintclipboard"></a>  CWnd::OnPaintClipboard

剪貼簿擁有者的`OnPaintClipboard`時剪貼簿擁有者已置於 CF_OWNERDISPLAY 格式剪貼簿的資料，且剪貼簿檢視器的工作區需要重新繪製剪貼簿檢視器便會呼叫成員函式。

```
afx_msg void OnPaintClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hPaintStruct);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 [剪貼簿] 應用程式視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*hPaintStruct*<br/>
識別 [PAINTSTRUCT](/windows/desktop/api/winuser/ns-winuser-tagpaintstruct) 資料結構，其定義要繪製工作區的哪一部分。

### <a name="remarks"></a>備註

若要判斷整個工作區或只是它的部分是否需要重新繪製，剪貼簿擁有者必須比較中指定的繪圖區域的維度`rcpaint`隸屬`PAINTSTRUCT`最近中的結構[OnSizeClipboard](#onsizeclipboard)成員函式呼叫。

`OnPaintClipboard` 應該使用[GlobalLock](/windows/desktop/api/winbase/nf-winbase-globallock)鎖定的記憶體，其中包含的 Windows 函式`PAINTSTRUCT`資料結構，並解除鎖定該記憶體[GlobalUnlock](/windows/desktop/api/winbase/nf-winbase-globalunlock)在結束之前的 Windows 函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpalettechanged"></a>  CWnd::OnPaletteChanged

具有輸入焦點的視窗已實現其邏輯色板，藉此變更系統調色盤之後，架構會呼叫此成員函式的所有最上層視窗。

```
afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
```

### <a name="parameters"></a>參數

*pFocusWnd*<br/>
指定造成系統調色盤來變更視窗的指標。 指標可能是暫時性的不應該儲存。

### <a name="remarks"></a>備註

此呼叫可讓沒有輸入焦點，用以了解其邏輯色板，並更新其工作區的色彩調色盤的視窗。

`OnPaletteChanged`針對所有最上層和重疊視窗中，包括變更系統調色盤，並導致 WM_PALETTECHANGED 訊息要傳送的一個呼叫成員函式。 如果任何子視窗使用的色板，此訊息必須傳遞給它。

若要避免無限迴圈，視窗不應該了解其調色盤除非它判斷*pFocusWnd*不包含本身的指標。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpaletteischanging"></a>  CWnd::OnPaletteIsChanging

架構會呼叫此成員函式，以通知應用程式的應用程式即將實現其邏輯色板。

```
afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
```

### <a name="parameters"></a>參數

*pRealizeWnd*<br/>
指定即將實現其邏輯色板的視窗。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onparentnotify"></a>  CWnd::OnParentNotify

家長`OnParentNotify`建立或終結，它的子視窗時，或當使用者按一下滑鼠按鈕，將游標移至子視窗時，成員函式由架構呼叫。

```
afx_msg void OnParentNotify(
    UINT message,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定的事件其正在通知父和子視窗的識別碼。 低序位字組中，事件是*訊息*。 如果事件是 WM_CREATE 或 WM_DESTROY，高序位文字*訊息*是子視窗; 識別碼的高序位文字未定義，否則為。 事件 (低序位文字*訊息*) 可以是下列值之一：

- 正在建立 WM_CREATE 子視窗。

- WM_DESTROY 子視窗正在被終結。

- WM_LBUTTONDOWN 使用者已放置滑鼠游標移至子視窗，並按下滑鼠左的按鈕。

- WM_MBUTTONDOWN 使用者已放置滑鼠游標移至子視窗，並按下滑鼠中間鍵。

- WM_RBUTTONDOWN 使用者已放置滑鼠游標移至子視窗，並按下滑鼠右按鈕。

*lParam*<br/>
如果事件 （低序位字組） 的*訊息*WM_CREATE 或 WM_DESTROY， *lParam*指定的子視窗的視窗控制代碼，否則為*lParam*包含 x 和 y資料指標的座標。 X 座標是低序位字組中，y 座標中的高序位文字。

### <a name="remarks"></a>備註

建立子視窗時，系統就會呼叫`OnParentNotify`正前方[建立](#create)建立視窗的成員函式傳回。 何時終結子視窗時，系統呼叫`OnParentNotify`終結視窗的任何處理發生之前。

`OnParentNotify` 會針對所有上階視窗的子視窗中，包括最上層視窗呼叫。

所有的子視窗，但不包括具有[WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)樣式會將此訊息傳送至其父視窗。 依預設，在對話方塊中的子視窗有 WS_EX_NOPARENTNOTIFY 樣式除非沒有這個樣式建立子視窗呼叫[CreateEx](#createex)成員函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onpowerbroadcast"></a>  CWnd::OnPowerBroadcast

電源管理事件發生時，架構會呼叫此成員函式。

```
afx_msg UINT OnPowerBroadcast(
    UINT nPowerEvent,
    UINT nEventData);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nPowerEvent*|[in]電源管理的事件。|
|*nEventData*|[in]事件特有的資料。|

### <a name="return-value"></a>傳回值

如果事件的要求，傳回 TRUE，以授與的要求或 BROADCAST_QUERY_DENY 拒絕要求。

### <a name="remarks"></a>備註

這個方法會接收[WM_POWERBROADCAST](/windows/desktop/Power/wm-powerbroadcast)訊息，Windows SDK 中所述。

*NPowerEvent*參數指定的事件，例如電池電力偏低電源狀態已經變更、 暫止作業的權限要求，或拒絕、 事件後自動繼續作業，系統暫停之後繼續執行暫停作業或作業。 *NEventData*通常不使用參數。 如需詳細資訊，請參閱 < *wParam*並*lParam*參數[WM_POWERBROADCAST](/windows/desktop/Power/wm-powerbroadcast)訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onquerydragicon"></a>  CWnd::OnQueryDragIcon

架構會呼叫此成員函式的最小化 （圖示） 視窗，並沒有針對其類別定義的圖示。

```
afx_msg HCURSOR OnQueryDragIcon();
```

### <a name="return-value"></a>傳回值

包含資料指標或圖示的控制代碼，以低序位字組的 doubleword 值。 資料指標或圖示必須是與解析度的顯示器驅動程式相容。 如果應用程式會傳回 NULL，系統就會顯示預設資料指標。 預設的傳回值是 NULL。

### <a name="remarks"></a>備註

系統會發出此呼叫來取得要顯示 當使用者拖曳最小化的視窗的游標。 如果應用程式傳回的圖示或游標控制代碼，則系統會將它轉換成黑白。 如果應用程式傳回的控制代碼，控制代碼必須識別單色游標或相容的顯示器驅動程式的解析度的圖示。 應用程式可以呼叫[CWinApp::LoadCursor](../../mfc/reference/cwinapp-class.md#loadcursor)或是[CWinApp::LoadIcon](../../mfc/reference/cwinapp-class.md#loadicon)成員函式從可執行檔中的資源載入的資料指標或圖示，並取得這個控制代碼。

##  <a name="onqueryendsession"></a>  CWnd::OnQueryEndSession

當使用者選擇結束 Windows 工作階段或應用程式的呼叫時，架構會呼叫此成員函式[ExitWindows](/windows/desktop/api/winuser/nf-winuser-exitwindows) Windows 函式。

```
afx_msg BOOL OnQueryEndSession();
```

### <a name="return-value"></a>傳回值

非零值，如果應用程式可以方便地關機;否則為 0。

### <a name="remarks"></a>備註

如果任何應用程式會傳回 0，就不會結束 Windows 工作階段。 Windows 會停止呼叫`OnQueryEndSession`只要一個應用程式會傳回 0，且會傳送[WM_ENDSESSION](#onendsession)訊息，任何應用程式的已傳回非零參數值為 FALSE。

##  <a name="onquerynewpalette"></a>  CWnd::OnQueryNewPalette

架構會呼叫此成員函式時`CWnd`物件即將接收輸入的焦點，讓`CWnd`得以實現其邏輯色板收到焦點時。

```
afx_msg BOOL OnQueryNewPalette();
```

### <a name="return-value"></a>傳回值

非零`CWnd`實現其邏輯色板; 否則為 0。

##  <a name="onqueryopen"></a>  CWnd::OnQueryOpen

架構會呼叫此成員函式時`CWnd`物件最小化，且使用者要求，`CWnd`還原成 preminimized 的大小和位置。

```
afx_msg BOOL OnQueryOpen();
```

### <a name="return-value"></a>傳回值

非零值，如果可以開啟圖示，或 0 表示正在開啟時，防止圖示。

### <a name="remarks"></a>備註

當您在`OnQueryOpen`，`CWnd`不應該執行任何動作，造成啟動或焦點的變更 （例如，建立對話方塊）。

##  <a name="onqueryuistate"></a>  CWnd::OnQueryUIState

呼叫以擷取視窗的使用者介面 (UI) 狀態。

```
afx_msg UINT OnQueryUIState();
```

### <a name="return-value"></a>傳回值

如果會顯示焦點指標和鍵盤快速鍵，則傳回的值是 NULL。 否則，傳回的值可以是一或多個下列值：

- 會隱藏 UISF_HIDEFOCUS 焦點指標。

- 會隱藏 UISF_HIDEACCEL 鍵盤快速鍵。

- UISF_ACTIVE Windows XP:應該繪製控制項，用於使用中控制項的樣式。

### <a name="remarks"></a>備註

此成員函式會模擬[WM_QUERYUISTATE](/windows/desktop/menurc/wm-queryuistate)訊息、 Windows SDK 中所述。

##  <a name="onrawinput"></a>  CWnd::OnRawInput

當目前視窗取得原始輸入時，架構會呼叫此成員函式。

```
afx_msg void OnRawInput(
    UINT nInputCode,
    HRAWINPUT hRawInput);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nInputCode*|[in]表示已在前景應用程式時，是否發生輸入的輸入程式碼。 在任一情況下，應用程式必須呼叫[CWnd::DefWindowProc](#defwindowproc)讓系統可以執行清除作業。<br /><br /> 這個參數可以是下列值之一：<br /><br /> 應用程式處於前景時，就會發生-RIM_INPUT-輸入。<br />應用程式不在前景時，就會發生-RIM_INPUTSINK-輸入。|
|*hRawInput*|[in]控制代碼[RAWINPUT](/windows/desktop/api/winuser/ns-winuser-tagrawinput)結構，其中包含來自裝置的未經處理輸入。|

### <a name="remarks"></a>備註

這個方法會接收[WM_INPUT](/windows/desktop/inputdev/wm-appcommand)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onrbuttondblclk"></a>  CWnd::OnRButtonDblClk

當使用者按兩下滑鼠右鍵時，架構會呼叫此成員函式。

```
afx_msg void OnRButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果滑鼠右按鈕已關閉，就會設定 MK_RBUTTON。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定的 x 和 y 座標的資料指標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

有 CS_DBLCLKS 的 windows [WNDCLASS](/windows/desktop/api/winuser/ns-winuser-tagwndclassa)樣式可以接收`OnRButtonDblClk`呼叫。 這是適用於 Microsoft Foundation 類別程式庫內的 windows 預設值。 Windows 呼叫`OnRButtonDblClk`當使用者按下，釋出，然後再次按下滑鼠右按鈕，在系統中的按兩下 時間限制。 按兩下滑鼠按鈕時，實際上會產生四個事件：[WM_RBUTTONDOWN](#onrbuttondown)並[WM_RBUTTONUP](#onrbuttonup)訊息，`OnRButtonDblClk`呼叫時，並在放開按鍵時的另一個 WM_RBUTTONUP 訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onrbuttondown"></a>  CWnd::OnRButtonDown

當使用者按下滑鼠右按鈕時，架構會呼叫此成員函式。

```
afx_msg void OnRButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果滑鼠右按鈕已關閉，就會設定 MK_RBUTTON。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定的 x 和 y 座標的資料指標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onrbuttonup"></a>  CWnd::OnRButtonUp

當使用者放開滑鼠右按鈕時，架構會呼叫此成員函式。

```
afx_msg void OnRButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
表示各種虛擬索引鍵是否關閉。 這個參數可以是下列值的任何組合：

- 如果 CTRL 按鍵為已關閉，就會設定 MK_CONTROL。

- 如果左滑鼠按鈕，將設定 MK_LBUTTON 已關閉。

- 如果滑鼠中間鍵已關閉，就會設定 MK_MBUTTON。

- 如果 SHIFT 按鍵為已關閉，就會設定 MK_SHIFT。

*point*<br/>
指定的 x 和 y 座標的資料指標。 這些座標永遠是相對於視窗左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onregisteredmousewheel"></a>  CWnd::OnRegisteredMouseWheel

當使用者滾動滑鼠滾輪，且遇到滾輪的下一波陷，架構會呼叫此成員函式。

```
afx_msg LRESULT OnRegisteredMouseWheel(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
水平位置的指標。

*lParam*<br/>
指標的垂直位置。

### <a name="return-value"></a>傳回值

在此階段不顯著。 一律為零。

### <a name="remarks"></a>備註

覆寫時，除非`OnRegisteredMouseWheel`會將訊息路由至適當的視窗 （具有焦點的父視窗），並呼叫[WM_MOUSEWHEEL](/windows/desktop/inputdev/wm-mousewheel)該視窗的處理常式。

覆寫此成員函式，提供您自己的訊息路由，或改變滑鼠滾輪捲動行為。

> [!NOTE]
> `OnRegisteredMouseWheel` Windows 95/98 和 Windows NT 3.51 處理訊息。 對於 Windows NT 4.0 訊息處理，使用[OnMouseWheel](#onmousewheel)。

##  <a name="onrenderallformats"></a>  CWnd::OnRenderAllFormats

剪貼簿擁有者的`OnRenderAllFormats`擁有者應用程式正在被終結時由架構呼叫成員函式。

```
afx_msg void OnRenderAllFormats();
```

### <a name="remarks"></a>備註

剪貼簿擁有者應該將資料呈現在它能夠產生，並將剪貼簿中的每一種格式的資料控制代碼，藉由呼叫的所有格式[SetClipboardData](/windows/desktop/api/winuser/nf-winuser-setclipboarddata) Windows 函式。 這可確保剪貼簿包含有效的資料，即使損毀的應用程式的轉譯資料。 應用程式應該呼叫[OpenClipboard](#openclipboard)成員函式，然後再呼叫[SetClipboardData](/windows/desktop/api/winuser/nf-winuser-setclipboarddata) Windows 函式和呼叫[CloseClipboard](/windows/desktop/api/winuser/nf-winuser-closeclipboard) Windows函式之後。

##  <a name="onrenderformat"></a>  CWnd::OnRenderFormat

剪貼簿擁有者的`OnRenderFormat`需要呈現具有延遲轉譯的特定格式時，成員函式由架構呼叫。

```
afx_msg void OnRenderFormat(UINT nFormat);
```

### <a name="parameters"></a>參數

*nFormat*<br/>
指定的剪貼簿格式。

### <a name="remarks"></a>備註

接收者應該轉譯該格式的資料，並將它傳遞到剪貼簿中，藉由呼叫[SetClipboardData](/windows/desktop/api/winuser/nf-winuser-setclipboarddata) Windows 函式。

請勿呼叫`OpenClipboard`成員函式或`CloseClipboard`內的 Windows 函式`OnRenderFormat`。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsessionchange"></a>  CWnd::OnSessionChange

架構會呼叫此成員函式，以通知應用程式中工作階段狀態的變更。

```
afx_msg void OnSessionChange(
    UINT nSessionState,
    UINT nId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nSessionState*|[in]狀態碼描述工作階段狀態變更。|
|*nId*|[in]工作階段識別項。|

### <a name="remarks"></a>備註

這個方法會接收[WM_WTSSESSION_CHANGE](/windows/desktop/TermServ/wm-wtssession-change)通知，Windows SDK 中所述。

*NSessionState*參數指定的工作階段接上電源插座或從主控台] 或 [遠端終端機、 使用者登入或登出、 工作階段已鎖定或解除鎖定，或工作階段已變更為遠端控制的狀態。 如需詳細資訊，請參閱 < *wParam*的參數[WM_WTSSESSION_CHANGE](/windows/desktop/TermServ/wm-wtssession-change)訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsetcursor"></a>  CWnd::OnSetCursor

架構會呼叫此成員函式不擷取滑鼠輸入，而且滑鼠導致游標移動內`CWnd`物件。

```
afx_msg BOOL OnSetCursor(
    CWnd* pWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pWnd*<br/>
指定包含游標的視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nHitTest*<br/>
指定[點擊測試](#onnchittest)區碼。 資料指標的位置來決定點擊的測試。

*message*<br/>
指定滑鼠訊息數目。

### <a name="return-value"></a>傳回值

非零值會停止進一步處理，或 0，以繼續。

### <a name="remarks"></a>備註

預設實作會呼叫父視窗的`OnSetCursor`處理之前。 如果父視窗傳回 TRUE，將停止進一步處理。 呼叫父視窗可以讓父視窗控制子視窗中的資料指標的設定。

預設實作會設定資料指標的箭號，如果它不是工作區中或已註冊類別的資料指標才。

如果*nHitTest*是 HTERROR 並*訊息*是滑鼠有 button-down 訊息，`MessageBeep`呼叫成員函式。

*訊息*參數為 0 時`CWnd`進入功能表模式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsetfocus"></a>  CWnd::OnSetFocus

架構會在取得輸入的焦點後呼叫此成員函式。

```
afx_msg void OnSetFocus(CWnd* pOldWnd);
```

### <a name="parameters"></a>參數

*pOldWnd*<br/>
包含`CWnd`失去輸入的焦點 （可能是 NULL） 的物件。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

若要顯示插入號，`CWnd`此時應該呼叫適當的插入號函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsettingchange"></a>  CWnd::OnSettingChange

這個架構會呼叫`OnSettingChange`Win32 SystemParametersInfo 函式變更整個系統的設定時的所有最上層視窗。

```
afx_msg void OnSettingChange(
    UINT uFlags,
    LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*uFlags*<br/>
當系統傳送的訊息時`SystemParametersInfo`呼叫時，此參數會指出已變更系統參數的旗標。 如需值的清單，請參閱 < [SystemParametersInfo](/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa) Windows SDK 中。 當應用程式傳送訊息時，這個參數必須是 0。

*lpszSection*<br/>
指向字串，指定已變更區段的名稱。 （字串不包含方括號括住的區段名稱）。

### <a name="remarks"></a>備註

應用程式應將訊息傳送至所有最上層視窗，當它變更系統參數，而 Windows 會傳送訊息，如果使用者變更透過 控制台設定。

ON_WM_SETTINGCHANGE 訊息大致 ON_WM_WININICHANGE 訊息，但是有下列差異：

- 當執行 Windows NT 4.0 或更新版本中，或 Windows 95/98 下，請使用 ON_WM_SETTINGCHANGE。

- 執行 Windows NT 3.51 或更舊版本時，請使用 ON_WININICHANGE。 此訊息現已過時。

您只能有一個這些巨集的訊息對應中。 若要撰寫的程式，適用於 Windows 95/98 和 Windows NT 4.0，請為 ON_WM_SETTINGCHANGE 撰寫處理常式。 在 Windows NT 3.51 下您的處理常式會呼叫`OnSettingChange`並*uFlags*和一律為零。

##  <a name="onshowwindow"></a>  CWnd::OnShowWindow

架構會呼叫此成員函式時`CWnd`物件即將隱藏或顯示。

```
afx_msg void OnShowWindow(
    BOOL bShow,
    UINT nStatus);
```

### <a name="parameters"></a>參數

*bShow*<br/>
指定是否要顯示的視窗。 它會為 TRUE，如果已顯示的視窗;如果視窗已經隱藏，它就會是 FALSE。

*nStatus*<br/>
指定要顯示的視窗狀態。 它會是 0，如果因為傳送訊息`ShowWindow`成員函式呼叫，否則為*nStatus*是下列其中之一：

- SW_PARENTCLOSING 父視窗正在關閉 （進行圖示），或在隱藏快顯視窗。

- 開啟 SW_PARENTOPENING 父視窗 （顯示），或顯示快顯視窗。

### <a name="remarks"></a>備註

視窗是隱藏或顯示時`ShowWindow`呼叫成員函式，當重疊的視窗是最大化，或還原，或重疊或快顯視窗關閉時 （建立圖示），或是開啟 （顯示在螢幕上）。 重疊的視窗關閉時，會隱藏該視窗相關聯的所有快顯視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsize"></a>  CWnd::OnSize

視窗的大小已變更之後，架構會呼叫此成員函式。

```
afx_msg void OnSize(
    UINT nType,
    int cx,
    int cy);
```

### <a name="parameters"></a>參數

*nType*<br/>
指定調整大小要求的類型。 這個參數可以是下列值之一：

- SIZE_MAXIMIZED 視窗已經最大化。

- 最小化 SIZE_MINIMIZED 視窗。

- SIZE_RESTORED 視窗已調整大小，但 SIZE_MINIMIZED 和 SIZE_MAXIMIZED 都不會套用。

- SIZE_MAXHIDE 訊息會傳送至所有快顯視窗中，當某些其他視窗最大化。

- SIZE_MAXSHOW 訊息會傳送至所有快顯視窗中，當某些其他的時段已還原為其先前的大小。

*cx*<br/>
指定工作區的新寬度。

*cy*<br/>
指定工作區的新高度。

### <a name="remarks"></a>備註

如果[SetScrollPos](#setscrollpos)或[MoveWindow](#movewindow)成員函式會呼叫從子視窗`OnSize`，則`bRedraw`參數`SetScrollPos`或`MoveWindow`應該是以非零導致`CWnd`重新繪製。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#109](../../mfc/reference/codesnippet/cpp/cwnd-class_50.cpp)]

##  <a name="onsizeclipboard"></a>  CWnd::OnSizeClipboard

剪貼簿擁有者`OnSizeClipboard`剪貼簿包含資料時，呼叫成員函式以剪貼簿檢視器`CF_OWNERDISPLAY`屬性和工作區的 [剪貼簿檢視器] 視窗的大小已變更。

```
afx_msg void OnSizeClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hRect);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
識別在剪貼簿應用程式視窗。 指標可能是暫時性的不應該儲存。

*hRect*<br/>
識別全域記憶體物件。 記憶體物件包含指定的剪貼簿擁有者，來繪製區域的矩形資料結構。

### <a name="remarks"></a>備註

`OnSizeClipboard`成員函式稱為 null 矩形 (0,0,0,0) 的新大小即將終結或最小化的剪貼簿應用程式時。 這可讓以釋出其顯示資源的剪貼簿擁有者。

內`OnSizeClipboard`，應用程式必須使用[GlobalLock](/windows/desktop/api/winbase/nf-winbase-globallock) Windows 函式鎖定包含矩形的資料結構的記憶體。 已解除鎖定該記憶體的應用程式[GlobalUnlock](/windows/desktop/api/winbase/nf-winbase-globalunlock) Windows 函式會產生或傳回控制項之前。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsizing"></a>  CWnd::OnSizing

架構會呼叫此成員函式，以指出使用者已重新調整大小的矩形。

```
afx_msg void OnSizing(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*nSide*<br/>
要移動的視窗邊緣。

*lpRect*<br/>
位址[CRect](../../atl-mfc-shared/reference/crect-class.md)或是[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，就會包含項目的座標。

### <a name="remarks"></a>備註

藉由處理這個訊息，應用程式監視的大小和拖曳矩形的位置即可，如有需要變更其大小或位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#110](../../mfc/reference/codesnippet/cpp/cwnd-class_51.cpp)]

##  <a name="onspoolerstatus"></a>  CWnd::OnSpoolerStatus

每當加入或從列印管理員佇列中移除工作時，架構會呼叫此成員函式從列印管理員。

```
afx_msg void OnSpoolerStatus(
    UINT nStatus,
    UINT nJobs);
```

### <a name="parameters"></a>參數

*nStatus*<br/>
指定 SP_JOBSTATUS 旗標。

*nJobs*<br/>
指定列印管理員佇列中剩餘的工作數目。

### <a name="remarks"></a>備註

這個呼叫是僅供參考之用。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onstylechanged"></a>  CWnd::OnStyleChanged

架構會呼叫此成員函式，在後的[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga)函式已變更一或多個視窗的樣式。

```
afx_msg void OnStyleChanged(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*nStyleType*<br/>
指定視窗的延伸或 nonextended 的樣式已變更。 這個參數可以是下列值的組合：

- GWL_EXSTYLE 視窗的延伸的樣式已變更。

- GWL_STYLE 視窗的 nonextended 的樣式已變更。

*lpStyleStruct*<br/>
指向[STYLESTRUCT](/windows/desktop/api/winuser/ns-winuser-stylestruct)結構，其中包含新的樣式的視窗。 應用程式可以檢查的樣式，但它不可以變更它們。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onstylechanging"></a>  CWnd::OnStyleChanging

架構會呼叫此成員函式時[SetWindowLong](/windows/desktop/api/winuser/nf-winuser-setwindowlonga)函式即將變更一或多個視窗的樣式。

```
afx_msg void OnStyleChanging(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*nStyleType*<br/>
指定視窗的延伸或 nonextended 的樣式已變更。 這個參數可以是下列值的組合：

- GWL_EXSTYLE 視窗的延伸的樣式已變更。

- GWL_STYLE 視窗的 nonextended 的樣式已變更。

*lpStyleStruct*<br/>
指向[STYLESTRUCT](/windows/desktop/api/winuser/ns-winuser-stylestruct)結構，其中包含新的樣式的視窗。 應用程式可以檢查的樣式，並加以變更。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyschar"></a>  CWnd::OnSysChar

架構會呼叫此成員函式，如果`CWnd`具有輸入的焦點， [WM_SYSKEYUP](#onsyskeyup)並[WM_SYSKEYDOWN](#onsyskeydown)訊息翻譯成。

```
afx_msg void OnSysChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定控制項功能表鍵的 ASCII 字元按鍵的碼。

*nRepCnt*<br/>
指定的重複計數 （次按鍵輸入會重複使用者按住按鍵的結果數目）。

*nFlags*<br/>
*NFlags*參數可以具有下列值：

|值|意義|
|-----------|-------------|
|0-15|指定的重複計數。 值是按鍵輸入會因為使用者按住鍵而重複的次數...|
|16-23|指定掃描程式碼。 值取決於原始設備製造商 (OEM)|
|24|指定的索引鍵是否是延伸的金鑰，例如增強 101-或 102-key 鍵盤上出現的右 ALT 和 CTRL 鍵。 值為 1，如果它是延伸的金鑰;否則，它會是 0。|
|25-28|Windows 內部使用。|
|29|指定的內容程式碼。 如果按下按鍵; 時，按住 ALT 鍵，則值為 1否則，值為 0。|
|30|指定前一個索引鍵的狀態。 如果金鑰已關閉，才能傳送訊息，或如果機碼設定為 0，則值為 1。|
|31|指定轉換狀態。 如果發行的索引鍵時，或如果按下索引鍵為 0，則值為 1。|

### <a name="remarks"></a>備註

它會指定控制項功能表鍵的虛擬按鍵碼。 （如需標準虛擬按鍵碼的清單，請參閱 winuser.h）

內容程式碼為 0 時，可以傳遞 WM_SYSCHAR [WM_SYSCHAR](/windows/desktop/menurc/wm-syschar)訊息給[TranslateAccelerator](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) Windows 函式，會如同它已正常的按鍵訊息，而不是系統處理它字元索引鍵。 這可讓使用用於作用中視窗，即使使用中視窗並沒有輸入的焦點的快速鍵。

IBM 增強 101 和 102-key 鍵盤、 增強的金鑰為右邊的 alt 鍵和右邊的 CTRL 鍵，鍵盤; 的主要區段INS、 DEL、 首頁、 結束、 PAGE UP、 PAGE down 鍵、 和左邊的數字鍵台; 叢集中的方向鍵斜線 （/） 和數字鍵盤上的 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元*nFlags*。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyscolorchange"></a>  CWnd::OnSysColorChange

系統色彩設定中進行變更時，架構會呼叫此成員函式的所有最上層視窗。

```
afx_msg void OnSysColorChange();
```

### <a name="remarks"></a>備註

Windows 呼叫`OnSysColorChange`系統色彩變更會影響任何視窗。

使用現有的系統色彩的筆刷的應用程式應該刪除這些筆刷，並重新建立它們與新的系統色彩。

##  <a name="onsyscommand"></a>  CWnd::OnSysCommand

使用者控制項 功能表中選取命令時，或在使用者選取最大化或最小化按鈕時，架構會呼叫此成員函式。

```
afx_msg void OnSysCommand(
    UINT nID,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定系統所要求的命令類型。 這個參數可以是下列值之一：

- 關閉 SC_CLOSE`CWnd`物件。

- 啟用 SC_HOTKEY`CWnd`應用程式指定熱索引鍵相關聯的物件。 低序位字組*lParam*識別啟動之視窗的 HWND。

- SC_HSCROLL 水平捲動。

- SC_KEYMENU 擷取透過按鍵的功能表。

- SC_MAXIMIZE （或 SC_ZOOM） 最大化`CWnd`物件。

- SC_MINIMIZE （或 SC_ICON） 最小化`CWnd`物件。

- SC_MOUSEMENU 擷取透過滑鼠的功能表上按一下。

- SC_MOVE 移動`CWnd`物件。

- SC_NEXTWINDOW 移到下一個視窗。

- SC_PREVWINDOW 移到上一個視窗。

- 正常位置和大小的 SC_RESTORE 還原視窗。

- SC_SCREENSAVE 執行系統的 [開機] 區段中指定的螢幕保護裝置應用程式。INI 檔案。

- SC_SIZE 大小`CWnd`物件。

- SC_TASKLIST 執行或啟用 Windows 工作管理員 」 應用程式。

- SC_VSCROLL 垂直捲動。

*lParam*<br/>
如果控制項功能表命令會選擇使用滑鼠*lParam*包含游標座標。 低序位文字包含的 x 座標，以及高序位文字包含的 y 座標。 否則不會使用此參數。

- SC_HOTKEY 啟動視窗相關聯應用程式指定的快速鍵。 低序位字組*lParam*識別要啟動的視窗。

- SC_SCREENSAVE Execute 控制台的 [桌面] 區段中指定的畫面儲存應用程式。

### <a name="remarks"></a>備註

根據預設，`OnSysCommand`執行在上表中指定的預先定義動作的控制項功能表要求。

在 WM_SYSCOMMAND 訊息中，四個低序位位元*nID*參數會在內部使用 Windows。 當應用程式測試的值*nID*，它必須結合值 0xFFF0 *nID*使用位元值-和運算子來取得正確的結果。

可以利用修改控制項的功能表中的功能表項目`GetSystemMenu`， `AppendMenu`， `InsertMenu`，和`ModifyMenu`成員函式。 修改 [控制] 功能表的應用程式必須處理 WM_SYSCOMMAND 訊息和應用程式無法處理任何 WM_SYSCOMMAND 訊息必須傳遞給`OnSysCommand`。 任何應用程式所加入的命令值必須處理必要的應用程式，且無法傳遞到`OnSysCommand`。

應用程式可以執行任何系統命令隨時藉由傳遞 WM_SYSCOMMAND 訊息`OnSysCommand`。

從 [控制] 功能表選取項目定義的快速鍵 （捷徑） 按鍵輸入會轉譯成`OnSysCommand`呼叫; 所有按鍵輸入會轉譯成其他加速器[WM_COMMAND](#oncommand)訊息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsysdeadchar"></a>  CWnd::OnSysDeadChar

架構會呼叫此成員函式，如果`CWnd`物件具有輸入焦點時[OnSysKeyUp](#onsyskeyup)或是[OnSysKeyDown](#onsyskeydown)呼叫成員函式。

```
afx_msg void OnSysDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定的索引鍵的寄不出的字元值。

*nRepCnt*<br/>
指定的重複計數。

*nFlags*<br/>
指定掃描程式碼、 索引鍵轉換程式碼前, 一個索引鍵的狀態和內容的程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-7|掃描程式碼 （OEM 相依值）。 高序位字組的低位元組。|
|8|擴充索引鍵，例如函式金鑰或 （如果它是擴充的索引鍵為 1; 否則為 0） 的數字鍵台上的索引鍵。|
|9-10|未使用。|
|11-12|Windows 內部使用。|
|13|（如果按下按鍵時，按住 ALT 鍵則為 1; 否則為 0） 的內容程式碼。|
|14|先前的重要狀態 (1 如果金鑰已關閉，再呼叫，也就是 0，如果索引鍵已啟動)。|
|15|轉換狀態 （如果發行的索引鍵為 1，0，表示按下索引鍵）。|

### <a name="remarks"></a>備註

它會指定廢鍵的字元值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyskeydown"></a>  CWnd::OnSysKeyDown

如果`CWnd`物件具有輸入的焦點，`OnSysKeyDown`當使用者按住 ALT 鍵，然後按下另一個索引鍵，成員函式由架構呼叫。

```
afx_msg void OnSysKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定的索引鍵，按下的虛擬按鍵碼。 如需標準虛擬按鍵碼的清單，請參閱 Winuser.h

*nRepCnt*<br/>
指定的重複計數。

*nFlags*<br/>
指定掃描程式碼、 索引鍵轉換程式碼前, 一個索引鍵的狀態和內容的程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-7|掃描程式碼 （OEM 相依值）。 高序位字組的低位元組。|
|8|擴充索引鍵，例如函式金鑰或 （如果它是擴充的索引鍵為 1; 否則為 0） 的數字鍵台上的索引鍵。|
|9-10|未使用。|
|11-12|Windows 內部使用。|
|13|內容的程式碼 (1，表示當按下按鍵，0 否則，按住 ALT 鍵)。|
|14|先前的重要狀態 (1 如果金鑰已關閉，傳送訊息之前，0 如果金鑰已啟動)。|
|15|轉換狀態 （如果發行的索引鍵為 1，0，表示按下索引鍵）。|

針對`OnSysKeyDown`呼叫中，索引鍵轉換位元 (bit 15) 為 0。 內容程式碼位元 (bit 13) 為 1，如果按下按鍵; 時，ALT 鍵已關閉如果因為沒有任何視窗具有輸入的焦點，將會傳送至作用中視窗的訊息，它就會是 0。

### <a name="remarks"></a>備註

如果沒有任何視窗目前擁有輸入的焦點，作用中視窗的`OnSysKeyDown`呼叫成員函式。 `CWnd`接收訊息的物件可以區別這兩種內容的內容程式碼簽入`nFlags`。

WM_SYSKEYDOWN 訊息的內容程式碼為 0 時，由接收`OnSysKeyDown`可以傳遞給[TranslateAccelerator](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) Windows 函式，會如同它已正常的按鍵訊息，而非系統鍵訊息處理它。 這可讓使用用於作用中視窗，即使使用中視窗並沒有輸入的焦點的快速鍵。

因為自動重複，多個`OnSysKeyDown`呼叫可能會發生在之前[WM_SYSKEYUP](#onsyskeyup)接收訊息。 先前的重要狀態 （位元 14） 可以用來判斷是否`OnSysKeyDown`呼叫表示第一個向下轉換或重複向下轉換。

IBM 增強 101 和 102-key 鍵盤、 增強的金鑰為右邊的 alt 鍵和右邊的 CTRL 鍵，鍵盤; 的主要區段INS、 DEL、 首頁、 結束、 PAGE UP、 PAGE down 鍵、 和左邊的數字鍵台; 叢集中的方向鍵斜線 （/） 和數字鍵盤上的 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元*nFlags*。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onsyskeyup"></a>  CWnd::OnSysKeyUp

如果`CWnd`物件有焦點，`OnSysKeyUp`當使用者放開按鍵時按住 ALT 鍵是已按下時由架構呼叫成員函式。

```
afx_msg void OnSysKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*nChar*<br/>
指定的索引鍵，按下的虛擬按鍵碼。 如需標準虛擬按鍵碼的清單，請參閱 Winuser.h

*nRepCnt*<br/>
指定的重複計數。

*nFlags*<br/>
指定掃描程式碼、 索引鍵轉換程式碼前, 一個索引鍵的狀態和內容的程式碼，如下列清單所示：

|值|意義|
|-----------|-------------|
|0-7|掃描程式碼 （OEM 相依值）。 高序位字組的低位元組。|
|8|擴充索引鍵，例如函式金鑰或 （如果它是擴充的索引鍵為 1; 否則為 0） 的數字鍵台上的索引鍵。|
|9-10|未使用。|
|11-12|Windows 內部使用。|
|13|內容的程式碼 (1，表示當按下按鍵，0 否則，按住 ALT 鍵)。|
|14|先前的重要狀態 (1 如果金鑰已關閉，傳送訊息之前，0 如果金鑰已啟動)。|
|15|轉換狀態 （如果發行的索引鍵為 1，0，表示按下索引鍵）。|

針對`OnSysKeyUp`呼叫中，索引鍵轉換位元 (bit 15) 為 1。 內容程式碼位元 (bit 13) 為 1，如果按下按鍵; 時，ALT 鍵已關閉如果因為沒有任何視窗具有輸入的焦點，將會傳送至作用中視窗的訊息，它就會是 0。

### <a name="remarks"></a>備註

如果沒有任何視窗目前擁有輸入的焦點，作用中視窗的`OnSysKeyUp`呼叫成員函式。 `CWnd`接收呼叫的物件可以區別這兩種內容的內容程式碼簽入*nFlags*。

WM_SYSKEYUP 訊息的內容程式碼為 0 時，由接收`OnSysKeyUp`可以傳遞給[TranslateAccelerator](/windows/desktop/api/winuser/nf-winuser-translateacceleratora) Windows 函式，會如同它已正常的按鍵訊息，而非系統鍵訊息處理它。 這可讓加速器使用用於作用中視窗，即使使用中視窗並沒有輸入的焦點 （快顯） 金鑰。

IBM 增強 101 和 102-key 鍵盤、 增強的金鑰為右邊的 alt 鍵和右邊的 CTRL 鍵，鍵盤; 的主要區段INS、 DEL、 首頁、 結束、 PAGE UP、 PAGE down 鍵、 和左邊的數字鍵台; 叢集中的方向鍵斜線 （/） 和數字鍵盤上的 ENTER 鍵。 有些其他鍵盤可能支援中的擴充金鑰位元*nFlags*。

非美國增強的 102-key 鍵盤，右邊的 ALT 鍵是以 CTRL + ALT 按鍵組合來處理。 以下顯示訊息和造成當使用者按下並釋放這個機碼的呼叫的順序：

|序列|函式存取|傳遞的訊息|
|--------------|-----------------------|--------------------|
|1.|[WM_KEYDOWN](#onkeydown)|VK_CONTROL|
|2.|[WM_KEYDOWN](#onkeydown)|VK_MENU|
|3.|[WM_KEYUP](#onkeyup)|VK_CONTROL|
|4.|[WM_SYSKEYUP](/windows/desktop/inputdev/wm-syskeyup)|VK_MENU|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="ontcard"></a>  CWnd::OnTCard

當使用者按一下可設計的按鈕時，架構會呼叫此成員函式。

```
afx_msg void OnTCard(
    UINT idAction,
    DWORD dwActionData);
```

### <a name="parameters"></a>參數

*idAction*<br/>
表示採取動作的使用者。 這個參數可以是下列值之一：

- IDABORT 使用者按一下可設計的 [中止] 按鈕。

- IDCANCEL 使用者按一下可設計的 [取消] 按鈕。

- IDCLOSE 使用者關閉訓練卡。

- IDHELP 使用者按一下可設計的 Windows 協助按鈕。

- IDIGNORE 使用者按一下可設計的 [忽略] 按鈕。

- IDOK 使用者按一下可設計的 [確定] 按鈕。

- IDNO 使用者按下可設計沒有 按鈕。

- IDRETRY 使用者按一下可設計的重試 按鈕。

- HELP_TCARD_DATA 使用者按一下可設計的按鈕。 *DwActionData*參數會包含說明作者指定長整數。

- HELP_TCARD_NEXT 使用者按一下可設計的下一步 按鈕。

- HELP_TCARD_OTHER_CALLER 另一個應用程式已要求訓練卡片。

- IDYES 使用者按一下可設計的 [是] 按鈕。

*dwActionData*<br/>
如果*idAction*指定 HELP_TCARD_DATA，這個參數是說明作者指定長整數。 否則，此參數為零。

### <a name="remarks"></a>備註

只有在應用程式已起始使用 Windows 說明訓練卡片時，會呼叫此函數。 應用程式會藉由呼叫中指定 HELP_TCARD 命令起始訓練卡片[WinHelp](../../mfc/reference/cwinapp-class.md#winhelp)函式。

##  <a name="ontimechange"></a>  CWnd::OnTimeChange

變更系統時間後，架構會呼叫此成員函式。

```
afx_msg void OnTimeChange();
```

### <a name="remarks"></a>備註

有任何的變更系統時間傳送此訊息給所有最上層視窗的應用程式。 若要將 WM_TIMECHANGE 訊息傳送至所有最上層視窗中，應用程式可以使用[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函式搭配其*hwnd*參數設定為 HWND_BROADCAST。

##  <a name="ontimer"></a>  CWnd::OnTimer

架構會呼叫此成員函式中指定每個間隔後[SetTimer](#settimer)用來安裝計時器的成員函式。

```
afx_msg void OnTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定計時器識別的項。

### <a name="remarks"></a>備註

[DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函式傳送[WM_TIMER](/windows/desktop/winmsg/wm-timer)訊息應用程式的訊息佇列中沒有其他訊息時。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

  請參閱中的範例[CWnd::SetTimer](#settimer)。

##  <a name="ontoolhittest"></a>  CWnd::OnToolHitTest

某個點是否位於指定工具的周框中，架構會呼叫判定此成員函式。

```
virtual INT_PTR OnToolHitTest(
    CPoint point,
    TOOLINFO* pTI) const;
```

### <a name="parameters"></a>參數

*point*<br/>
指定資料指標 x 和 y 座標。 這些座標永遠是相對於視窗左上角

*pTI*<br/>
指標[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa)結構。 預設會設定下列的結構值：

- *hwnd*  =  `m_hWnd`視窗的控制代碼

- *uId*  =  `(UINT)hWndChild`子視窗的控制代碼

- *uFlags* &#124;= TTF_IDISHWND 處理的工具

- *lpszText* = LPSTR_TEXTCALLBACK 指標，要在指定的視窗中顯示為字串

### <a name="return-value"></a>傳回值

如果找不到的工具提示控制項、 視窗控制項識別碼。 如果工具提示控制項找不到，-1。

### <a name="remarks"></a>備註

如果重點是在矩形中，它會擷取工具的相關資訊。

如果與工具提示相關聯的區域不是一個按鈕， `OnToolHitTest` TTF_NOTBUTTON 和 TTF_CENTERTIP 設定結構旗標。

覆寫`OnToolHitTest`提供比預設值所提供的不同的資訊。

請參閱[TOOLINFO](/windows/desktop/api/commctrl/ns-commctrl-tagtoolinfoa)，在 Windows SDK 中，如需結構的詳細資訊。

##  <a name="ontouchinput"></a>  CWnd::OnTouchInput

處理來自 Windows 觸控的單一輸入。

```
virtual BOOL OnTouchInput(
    CPoint pt,
    int nInputNumber,
    int nInputsCount,
    PTOUCHINPUT pInput);
```

### <a name="parameters"></a>參數

*pt*<br/>
畫面已觸及 （在工作區座標中） 的點。

*nInputNumber*<br/>
觸控輸入的數目。

*nInputsCount*<br/>
觸控輸入的總數。

*pInput*<br/>
TOUCHINPUT 結構的指標。

### <a name="return-value"></a>傳回值

如果應用程式會處理 Windows 觸控輸入，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="ontouchinputs"></a>  CWnd::OnTouchInputs

處理來自 Windows 觸控的輸入。

```
virtual BOOL OnTouchInputs(
    UINT nInputsCount,
    PTOUCHINPUT pInputs);
```

### <a name="parameters"></a>參數

*nInputsCount*<br/>
總數 Windows 觸控輸入。

*pInputs*<br/>
TOUCHINPUT 的陣列。

### <a name="return-value"></a>傳回值

如果應用程式，則為 TRUE 的處理序 Windows 觸控輸入;否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="onunichar"></a>  CWnd::OnUniChar

當按下按鍵時，架構會呼叫此成員函式。 也就是目前的視窗擁有鍵盤焦點和[WM_KEYDOWN](/windows/desktop/inputdev/wm-keydown)訊息轉譯[TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage)函式。

```
afx_msg void OnUniChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*nChar*|[in]指定的按鍵的字元碼。|
|*nRepCnt*|[in]指定目前訊息的重複計數。 值是按鍵輸入是因為使用者按住鍵而 autorepeated 的次數。 如果按鍵輸入會保存夠久的時間，會傳送多則訊息。 不過，不是累計的重複計數。|
|*nFlags*|[in]旗標，指定掃描程式碼、 擴充的索引鍵、 內容程式碼，先前的主要狀態和轉移狀態下, 表所示：<br /><br /> **0-7:** 指定掃描程式碼。 值取決於原始設備製造商 (OEM)。<br /><br /> **8:** 指定擴充的索引鍵，例如增強的 101 或 102-key 鍵盤上出現的右 ALT 和 CTRL 鍵。 旗標為 1，如果金鑰是延伸的金鑰;否則，它會是 0。<br /><br /> **9-12:** Windows 內部使用。<br /><br /> **13:** 指定的內容程式碼。 旗標為 1，如果按下按鍵; 時，按住 ALT 鍵否則，值為 0。<br /><br /> **14:** 指定前一個索引鍵的狀態。 旗標是如果金鑰已關閉，再傳送訊息，則為 1 或 0，如果索引鍵已啟動。<br /><br /> **15:** 指定轉換狀態。 旗標會是 1，表示被釋放，索引鍵，則為 0，如果按下索引鍵。|

### <a name="remarks"></a>備註

這個方法會接收[WM_UNICHAR](/windows/desktop/inputdev/wm-unichar)通知，Windows SDK 中所述。 [WM_UNICHAR](/windows/desktop/inputdev/wm-unichar)訊息可傳送或張貼至 ANSI windows 的 Unicode 字元。 它相當於[WM_CHAR](/windows/desktop/inputdev/wm-char)訊息，但會使用 Unicode 轉換格式-32 編碼 (UTF-32)，而[WM_CHAR](/windows/desktop/inputdev/wm-char)訊息會使用 utf-16。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onuninitmenupopup"></a>  CWnd::OnUnInitMenuPopup

架構會呼叫此成員函式時下拉式功能表或子功能表被終結。

```
afx_msg void OnUnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nFlags);
```

### <a name="parameters"></a>參數

|參數|說明|
|---------------|-----------------|
|*pMenu*|[in]指標[CMenu](../../mfc/reference/cmenu-class.md)物件，代表功能表或子功能表。|
|*nFlags*|[in]已被終結功能表。 目前，它只能是視窗] 功能表的 [MF_SYSMENU。|

### <a name="remarks"></a>備註

這個方法會接收[WM_UNINITMENUPOPUP](/windows/desktop/menurc/wm-uninitmenupopup)通知，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onupdateuistate"></a>  CWnd::OnUpdateUIState

呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。

```
afx_msg void OnUpdateUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要執行的動作。 可為下列其中一個值：

- UIS_CLEAR UI 狀態項目 (依*nUIElement*) 應該隱藏。

- UIS_INITIALIZE UI 狀態項目 (依*nUIElement*) 應該變更為根據的最後一個輸入事件。 如需詳細資訊，請參閱 <<c0>  **備註**一節[WM_UPDATEISTATE](/windows/desktop/menurc/wm-updateuistate)。

- UIS_SET UI 狀態項目 (依*nUIElement*) 應該為可見的。

*nUIElement*<br/>
指定受影響的 UI 狀態項目或控制項的樣式。 可為下列其中一個值：

- UISF_HIDEACCEL 鍵盤快速鍵。

- UISF_HIDEFOCUS 焦點指標。

- UISF_ACTIVE Windows XP:應該繪製控制項，用於使用中控制項的樣式。

### <a name="remarks"></a>備註

此成員函式會模擬[WM_UPDATEUISTATE](/windows/desktop/menurc/wm-updateuistate)訊息、 Windows SDK 中所述。

##  <a name="onuserchanged"></a>  CWnd::OnUserChanged

使用者登入或登出後，架構會呼叫這個成員的所有視窗。

```
afx_msg void OnUserChanged();
```

### <a name="remarks"></a>備註

這個方法會接收[WM_USERCHANGED](/windows/desktop/winmsg/wm-userchanged)通知訊息時，Windows SDK 中所述。 當使用者登入或登出時，作業系統會更新使用者專屬設定。 系統會傳送此訊息之後立即更新的設定。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onvkeytoitem"></a>  CWnd::OnVKeyToItem

如果`CWnd`物件會擁有與清單方塊[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式，清單方塊將會傳送 WM_VKEYTOITEM 訊息以回應 WM_KEYDOWN 訊息。

```
afx_msg int OnVKeyToItem(
    UINT nKey,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*nKey*<br/>
指定使用者按下的按鍵的虛擬按鍵碼。 如需標準虛擬按鍵碼的清單，請參閱 Winuser.h

*pListBox*<br/>
指定清單方塊的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nIndex*<br/>
指定目前的插入號位置。

### <a name="return-value"></a>傳回值

指定在回應訊息的應用程式執行的動作。 傳回值-2 表示應用程式處理的選取項目所有層面，並不需要任何進一步的動作清單方塊。 傳回值-1 表示清單方塊應該執行的預設動作，以回應按鍵輸入。 大於或等於 0 的傳回值的清單方塊中指定的項目以零為起始的索引，並指出清單方塊應該執行的預設動作，在指定的項目上的按鍵輸入。

### <a name="remarks"></a>備註

僅有的清單方塊的架構會呼叫此成員函式[LBS_HASSTRINGS](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onvscroll"></a>  CWnd::OnVScroll

當使用者按一下視窗的垂直捲軸，架構會呼叫此成員函式。

```
afx_msg void OnVScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSBCode*<br/>
指定捲軸的程式碼，指出使用者的捲動要求。 這個參數可以是下列其中一項：

- SB_BOTTOM 捲動到下方。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 一個向下捲動一行。

- SB_LINEUP 捲軸上一行。

- 向下 SB_PAGEDOWN 捲動一頁。

- SB_PAGEUP 一個向上捲動一頁。

- 絕對位置 SB_THUMBPOSITION 捲軸。 目前的位置中提供*nPos*。

- SB_THUMBTRACK 拖曳捲動方塊到指定的位置。 目前的位置中提供*nPos*。

- 至上 SB_TOP 捲軸。

*nPos*<br/>
捲軸的程式碼是否 SB_THUMBPOSITION 或 SB_THUMBTRACK; 包含目前的捲動方塊位置否則無法使用。 初始的捲軸範圍，根據*nPos*可以是負數，並且應該轉換成**int**如有必要。

*pScrollBar*<br/>
如果捲動訊息來自捲軸控制項，包含控制項的指標。 如果使用者按一下視窗的捲軸，則這個參數會是 NULL。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`OnVScroll` 通常會使用捲動方塊被拖曳的期間，提供一些意見反應的應用程式。

如果`OnVScroll`將內容捲動`CWnd`物件，它也必須重設使用捲軸方塊的位置[SetScrollPos](#setscrollpos)成員函式。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onvscrollclipboard"></a>  CWnd::OnVScrollClipboard

剪貼簿擁有者的`OnVScrollClipboard`剪貼簿的資料有 CF_OWNERDISPLAY 格式，並在 剪貼簿檢視器的垂直捲軸沒有事件剪貼簿檢視器便會呼叫成員函式。

```
afx_msg void OnVScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppWnd*<br/>
指定 剪貼簿檢視器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSBCode*<br/>
指定下列的捲軸值的其中一個：

- SB_BOTTOM 捲動到下方。

- SB_ENDSCROLL 結束捲軸。

- SB_LINEDOWN 一個向下捲動一行。

- SB_LINEUP 捲軸上一行。

- 向下 SB_PAGEDOWN 捲動一頁。

- SB_PAGEUP 一個向上捲動一頁。

- 絕對位置 SB_THUMBPOSITION 捲軸。 目前的位置中提供*nPos*。

- 至上 SB_TOP 捲軸。

*nPos*<br/>
如果捲軸的程式碼 SB_THUMBPOSITION;，包含捲動方塊位置否則*nPos*未使用。

### <a name="remarks"></a>備註

擁有者應該捲動剪貼簿影像、 使適當的區段失效，並更新捲軸值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwindowmaximizedchanged"></a>  CWnd::OnWindowMaximizedChanged

當目前的視窗最大化，且視窗由桌面視窗管理員 (DWM) 時，架構會呼叫這個成員。

```
afx_msg void OnWindowMaximizedChanged(BOOL bIsMaximized);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*bIsMaximized*|[in]如果目前的視窗會最大化，並不為 FALSE，則為 TRUE。|

### <a name="remarks"></a>備註

這個方法會接收[WM_DWMWINDOWMAXIMIZEDCHANGE](/windows/desktop/dwm/wm-dwmwindowmaximizedchange)通知訊息時，Windows SDK 中所述。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwindowposchanged"></a>  CWnd::OnWindowPosChanged

架構會呼叫此成員函式時呼叫的結果改變大小、 位置或疊置順序[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos)成員函式或另一個視窗管理函式。

```
afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
指向[WINDOWPOS](/windows/desktop/api/winuser/ns-winuser-tagwindowpos)資料結構，包含視窗的新大小和位置的相關資訊。

### <a name="remarks"></a>備註

預設實作會傳送[WM_SIZE](/windows/desktop/winmsg/wm-size)並[WM_MOVE](/windows/desktop/winmsg/wm-move)至視窗的訊息。 如果應用程式處理，不會傳送這些訊息`OnWindowPosChanged`呼叫而不需要呼叫其基底類別。 它會執行任何移動或調整大小變更的呼叫期間的處理更有效率`OnWindowPosChanged`而無需呼叫其基底類別。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwindowposchanging"></a>  CWnd::OnWindowPosChanging

當大小、 位置或疊置順序即將因呼叫而變更時，架構會呼叫此成員函式[SetWindowPos](/windows/desktop/api/winuser/nf-winuser-setwindowpos)成員函式或另一個視窗管理函式。

```
afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
指向`WINDOWPOS`資料結構，包含視窗的新大小和位置的相關資訊。

### <a name="remarks"></a>備註

應用程式可以藉由設定或清除適當的位元，在視窗來防止變更**旗標**隸屬[WINDOWPOS](/windows/desktop/api/winuser/ns-winuser-tagwindowpos)結構。

與視窗[WS_OVERLAPPED](styles-used-by-mfc.md#window-styles)或是[WS_THICKFRAME](styles-used-by-mfc.md#window-styles)樣式的預設實作會將傳送[WM_GETMINMAXINFO](/windows/desktop/winmsg/wm-getminmaxinfo)至視窗的訊息。 這是以驗證新的大小和視窗的位置，並強制執行所需 CS_BYTEALIGNCLIENT 和 CS_BYTEALIGN 用戶端樣式。 應用程式可以藉由不呼叫其基底類別中覆寫這項功能。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwininichange"></a>  CWnd::OnWinIniChange

架構會呼叫此成員函式之後的變更已對 Windows 初始化檔案，WIN。INI。

```
afx_msg void OnWinIniChange(LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*lpszSection*<br/>
指向字串，指定已變更區段的名稱。 （字串不包含方括號括住的區段名稱）。

### <a name="remarks"></a>備註

[SystemParametersInfo](/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa) Windows 函式呼叫`OnWinIniChange`應用程式使用函式來變更設定，以 win 之後。INI 檔案。

若要將 WM_WININICHANGE 訊息傳送至所有最上層視窗中，應用程式可以使用[SendMessage](/windows/desktop/api/winuser/nf-winuser-sendmessage) Windows 函式搭配其*hwnd*參數設定為 HWND_BROADCAST。

如果應用程式變更中的許多不同章節就贏了。在同一時間 INI，應用程式應該傳送一個 WM_WININICHANGE 訊息*lpszSection*設為 NULL。 否則，應用程式應該傳送 WM_WININICHANGE 每次呼叫獲獎的變更。INI。

如果應用程式接收`OnWinIniChange`呼叫，其*lpszSection*設為 NULL，應用程式應該檢查 WIN 中的所有區段。影響應用程式的 INI。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onwndmsg"></a>  CWnd::OnWndMsg

此成員函式會呼叫`WindowProc`，或訊息反映期間呼叫。

```
virtual BOOL OnWndMsg(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定訊息相關的其他資訊。

*lParam*<br/>
指定訊息相關的其他資訊。

*pResult*<br/>
傳回值[WindowProc](#windowproc)。 取決於訊息;可以是 NULL。

### <a name="return-value"></a>傳回值

如果訊息已處理，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

`OnWndMsg` 判斷訊息類型和任一呼叫適當的架構函式 (例如[OnCommand](#oncommand) WM_COMMAND 的) 或訊息對應中找到適當的訊息。

如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="onxbuttondblclk"></a>  CWnd::OnXButtonDblClk

當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時，架構會呼叫此成員函式。

```
afx_msg void OnXButtonDblClk(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[in]位元組合 (OR) 旗標，表示按下的輔助按鍵。 比方說，MK_CONTROL 旗標表示，按下 CTRL 鍵。|
|*nButton*|[in]值，如果第一個 Microsoft Intellimouse X 按鈕是按兩下 XBUTTON1 或 XBUTTON2 如果第二個 X 按鈕按兩下時。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於用戶端區域左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONDBLCLK](/windows/desktop/inputdev/wm-xbuttondblclk)通知，Windows SDK 中所述。 如果沒有擷取滑鼠，則會將訊息張貼到游標下方視窗。 否則，將訊息張貼至已捕捉滑鼠的視窗。

*NFlags*參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱 <<c0> [ 有關滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|已按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左的按鈕。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右按鈕。|
|MK_SHIFT|已按下 SHIFT 鍵。|
|MK_XBUTTON1|Microsoft intellimouse 滑鼠的 XBUTTON1 滑鼠按鈕已按下。|
|MK_XBUTTON2|Microsoft IntelliMouse XBUTTON2 滑鼠按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onxbuttondown"></a>  CWnd::OnXButtonDown

當使用者按 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時，架構會呼叫此成員函式。

```
afx_msg void OnXButtonDown(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[in]位元組合 (OR) 旗標，表示按下的輔助按鍵。 比方說，MK_CONTROL 旗標表示，按下 CTRL 鍵。|
|*nButton*|[in]值為第一個 Microsoft Intellimouse X 按鈕已按下，如果 XBUTTON1 或 XBUTTON2 如果第二個 X 按鈕已按下。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於用戶端區域左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONDOWN](/windows/desktop/inputdev/wm-xbuttondown)通知，Windows SDK 中所述。 如果沒有擷取滑鼠，則會將訊息張貼到游標下方視窗。 否則，將訊息張貼至已捕捉滑鼠的視窗。

*NFlags*參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱 <<c0> [ 有關滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|已按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左的按鈕。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右按鈕。|
|MK_SHIFT|已按下 SHIFT 鍵。|
|MK_XBUTTON1|Microsoft intellimouse 滑鼠的 XBUTTON1 滑鼠按鈕已按下。|
|MK_XBUTTON2|Microsoft IntelliMouse XBUTTON2 滑鼠按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="onxbuttonup"></a>  CWnd::OnXButtonUp

當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時，架構會呼叫此成員函式。

```
afx_msg void OnXButtonUp(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[in]位元組合 (OR) 旗標，表示按下的輔助按鍵。 比方說，MK_CONTROL 旗標表示，按下 CTRL 鍵。|
|*nButton*|[in]值，如果第一個 Microsoft Intellimouse X 按鈕已按兩下 XBUTTON1 或 XBUTTON2 如果第二個 X 按鈕在已按兩下。|
|*point*|[in]A [CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件，指定*x*並*y*相對於用戶端區域左上角的游標座標。|

### <a name="remarks"></a>備註

這個方法會接收[WM_XBUTTONUP](/windows/desktop/inputdev/wm-xbuttonup)通知，Windows SDK 中所述。 如果沒有擷取滑鼠，則會將訊息張貼到游標下方視窗。 否則，將訊息張貼至已捕捉滑鼠的視窗。

*NFlags*參數可以是下表所列的輔助按鍵的組合。 如需詳細資訊，請參閱 <<c0> [ 有關滑鼠輸入](/windows/desktop/inputdev/about-mouse-input)。

|輔助按鍵|描述|
|------------------|-----------------|
|MK_CONTROL|已按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左的按鈕。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右按鈕。|
|MK_SHIFT|已按下 SHIFT 鍵。|
|MK_XBUTTON1|Microsoft intellimouse 滑鼠的 XBUTTON1 滑鼠按鈕已按下。|
|MK_XBUTTON2|Microsoft IntelliMouse XBUTTON2 滑鼠按鈕已按下。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

##  <a name="openclipboard"></a>  CWnd::OpenClipboard

開啟剪貼簿。

```
BOOL OpenClipboard();
```

### <a name="return-value"></a>傳回值

如果透過開啟剪貼簿，則為非零`CWnd`，或 0，如果另一個應用程式或視窗有 剪貼簿開啟。

### <a name="remarks"></a>備註

其他應用程式不能修改剪貼簿，直到[CloseClipboard](/windows/desktop/api/winuser/nf-winuser-closeclipboard)呼叫 Windows 函式。

目前`CWnd`物件將不會變成直到剪貼簿的擁有者[EmptyClipboard](/windows/desktop/api/winuser/nf-winuser-emptyclipboard)呼叫 Windows 函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#111](../../mfc/reference/codesnippet/cpp/cwnd-class_52.cpp)]

##  <a name="operator_hwnd"></a>  HWND cwnd:: Operator

若要取得的控制代碼，請使用這個運算子`CWnd`物件。

```
operator HWND() const;
```

##  <a name="operator_neq"></a>  Cwnd:: Operator ！ =

比較兩個`CWnd`物件來判斷是否它們不需要相同[m_hWnd](#m_hwnd)。

```
BOOL operator!=(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd*<br/>
對 `CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

如果相等，非零值。否則為 0。

##  <a name="operator_eq_eq"></a>  Cwnd:: Operator = =

比較兩個`CWnd`物件，判斷它們是否相同[m_hWnd](#m_hwnd)。

```
BOOL operator==(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd*<br/>
對 `CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

如果相等，非零值。否則為 0。

##  <a name="paintwindowlesscontrols"></a>  CWnd::PaintWindowlessControls

在控制項容器上繪製無視窗控制項。

```
BOOL PaintWindowlessControls(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
在其上繪製無視窗控制項的裝置內容。

### <a name="return-value"></a>傳回值

如果沒有控制項容器且無視窗控制項，則為 TRUE 會傳回是成功繪製，否則為 FALSE。

##  <a name="postmessage"></a>  CWnd::PostMessage

將訊息放在視窗的訊息佇列，並傳回而不需等待處理的訊息對應的視窗。

```
BOOL PostMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要張貼的訊息。

*wParam*<br/>
指定額外的訊息資訊。 此參數的內容取決於所張貼的訊息。

*lParam*<br/>
指定額外的訊息資訊。 此參數的內容取決於所張貼的訊息。

### <a name="return-value"></a>傳回值

如果張貼的訊息時，為非零否則為 0。

### <a name="remarks"></a>備註

訊息佇列中的訊息藉由呼叫擷取[GetMessage](/windows/desktop/api/winuser/nf-winuser-getmessage)或是[PeekMessage](/windows/desktop/api/winuser/nf-winuser-peekmessagea) Windows 函式。

Windows [PostMessage](/windows/desktop/api/winuser/nf-winuser-postmessagea)函式可用來存取另一個應用程式。

### <a name="example"></a>範例

  範例，請參閱[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)。

##  <a name="postncdestroy"></a>  CWnd::PostNcDestroy

預設會呼叫[OnNcDestroy](#onncdestroy)終結視窗後的成員函式。

```
virtual void PostNcDestroy();
```

### <a name="remarks"></a>備註

在衍生的類別可用於自訂的清除作業，例如刪除的此函式**這**指標。

##  <a name="precreatewindow"></a>  CWnd::PreCreateWindow

由架構建立附加至此 Windows 視窗前呼叫`CWnd`物件。

```
virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
```

### <a name="parameters"></a>參數

*cs*<br/>
A [CREATESTRUCT](/windows/desktop/api/winuser/ns-winuser-tagcreatestructa)結構。

### <a name="return-value"></a>傳回值

非零值，如果應該繼續視窗建立;0 表示建立失敗。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow` 現在將指派的 hMenu 成員*cs*要**這**如果功能表是 NULL，而且樣式包含 WS_CHILD 的指標。 功能正常運作，請確定您的對話方塊控制項都有識別碼，不是 NULL。
>
> 這項變更會修正損毀 managed/原生 interop 案例中。 中的追蹤陳述式`CWnd::Create`警示問題的開發人員。

永遠不會直接呼叫此函式。

此函式的預設實作會檢查有 NULL 視窗類別名稱，並換成適當的預設值。 若要修改此成員函式會覆寫`CREATESTRUCT`結構之前建立的視窗。

每個類別衍生自`CWnd`自己的功能將其覆寫`PreCreateWindow`。 根據設計，這些衍生的`PreCreateWindow`並未記載。 若要判斷用於每個類別和樣式之間的相互依存性的樣式，您可以檢查您的應用程式基底類別的 MFC 原始程式碼。 如果您選擇覆寫`PreCreateWindow,`您可以判斷您的應用程式基底類別中所使用的樣式是否提供您需要使用從 MFC 原始程式檔所收集資訊的功能。

如需有關如何變更視窗樣式的詳細資訊，請參閱 <<c0> [ 變更 MFC 所建立的視窗樣式](../../mfc/changing-the-styles-of-a-window-created-by-mfc.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#112](../../mfc/reference/codesnippet/cpp/cwnd-class_53.cpp)]

##  <a name="presubclasswindow"></a>  CWnd::PreSubclassWindow

此成員函式是由架構以允許其他必要子類別化視窗子類別化之前呼叫。

```
virtual void PreSubclassWindow();
```

### <a name="remarks"></a>備註

覆寫此成員函式可讓控制項的動態子類別化。 它是一種進階可覆寫。

##  <a name="pretranslatemessage"></a>  CWnd::PreTranslateMessage

[CWinApp](../../mfc/reference/cwinapp-class.md) 類別用來轉譯分派至 [TranslateMessage](/windows/desktop/api/winuser/nf-winuser-translatemessage) 和 [DispatchMessage](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) Windows 函式之前的視窗訊息。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
指向[MSG](/windows/desktop/api/winuser/ns-winuser-tagmsg)結構，其中包含要處理的訊息。

### <a name="return-value"></a>傳回值

非零值，如果訊息已轉譯，而且不應該分派;如果訊息未被翻譯，因此應該分派，0。

##  <a name="print"></a>  CWnd::Print

呼叫此成員函式，以繪製在指定的裝置內容中，通常是印表機裝置內容中目前的視窗。

```
void Print(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定的繪圖選項。 這個參數可以是下列其中一個或多個旗標：

- PRF_CHECKVISIBLE 繪製視窗，才會顯示。

- PRF_CHILDREN 繪製可見的子系的所有視窗。

- PRF_CLIENT 繪製視窗工作區。

- PRF_ERASEBKGND 清除背景再繪製視窗。

- PRF_NONCLIENT 繪製視窗中的非工作區。

- PRF_OWNED 繪製所有擁有的 windows。

### <a name="remarks"></a>備註

[CWnd::DefWindowProc](#defwindowproc)函式會處理此訊息，根據指定的繪圖選項：

- 如果指定 PRF_CHECKVISIBLE 看不到  視窗中，執行任何動作。

- 如果指定 PRF_NONCLIENT，繪製指定的裝置內容中非工作區。

- 如果指定 PRF_ERASEBKGND，傳送視窗[WM_ERASEBKGND](/windows/desktop/winmsg/wm-erasebkgnd)訊息。

- 如果指定 PRF_CLIENT，傳送視窗[wm_printclient 繪製](/windows/desktop/gdi/wm-printclient)訊息。

- 如果設定 PRF_CHILDREN，傳送每個可見的子視窗[WM_PRINT](/windows/desktop/gdi/wm-print)訊息。

- 如果設定 PRF_OWNED，傳送每個可見擁有的視窗 WM_PRINT 訊息。

##  <a name="printclient"></a>  CWnd::PrintClient

呼叫此成員函式，來繪製指定的裝置內容 （通常是印表機裝置內容） 中的任何視窗。

```
void PrintClient(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定繪圖選項。 這個參數可以是下列其中一個或多個旗標：

- PRF_CHECKVISIBLE 繪製視窗，才會顯示。

- PRF_CHILDREN 繪製可見的子系的所有視窗。

- PRF_CLIENT 繪製視窗工作區。

- PRF_ERASEBKGND 清除背景再繪製視窗。

- PRF_NONCLIENT 繪製視窗中的非工作區。

- PRF_OWNED 繪製所有擁有的 windows。

##  <a name="printwindow"></a>  CWnd::PrintWindow

將視覺視窗複製到指定的裝置內容，通常是印表機 DC。

```
BOOL PrintWindow(
    CDC* pDC,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
要列印至的裝置內容指標。

*nFlags*<br/>
指定的繪圖選項。 如需可能值的清單，請參閱 < [PrintWindow](/windows/desktop/api/winuser/nf-winuser-printwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[PrintWindow](/windows/desktop/api/winuser/nf-winuser-printwindow)、 Windows SDK 中所述。

##  <a name="redrawwindow"></a>  CWnd::RedrawWindow

更新指定的矩形或區域中指定的視窗工作區。

```
BOOL RedrawWindow(
    LPCRECT lpRectUpdate = NULL,
    CRgn* prgnUpdate = NULL,
    UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
```

### <a name="parameters"></a>參數

*lpRectUpdate*<br/>
指向[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)包含更新矩形的座標。 如果這個參數就會忽略*prgnUpdate*包含有效的區域控制代碼。

*prgnUpdate*<br/>
識別更新區域。 如果兩個*prgnUpdate*並*lpRectUpdate*為 NULL 時，整個工作區加入到更新區域。

*flags*<br/>
下列旗標用來使其失效的視窗：

- RDW_ERASE 會使視窗收到[WM_ERASEBKGND](/windows/desktop/winmsg/wm-erasebkgnd)訊息時的視窗會重新繪製。 也必須指定 RDW_INVALIDATE 旗標;否則 RDW_ERASE 沒有任何作用。

- RDW_FRAME 會造成交集更新區域，以接收視窗中非工作區的任何一部分[WM_NCPAINT](/windows/desktop/gdi/wm-ncpaint)訊息。 也必須指定 RDW_INVALIDATE 旗標;否則 RDW_FRAME 沒有任何作用。

- 會導致 RDW_INTERNALPAINT [WM_PAINT](/windows/desktop/gdi/wm-paint)訊息張貼到視窗中，不論視窗是否包含無效的地區。

- RDW_INVALIDATE 失效*lpRectUpdate*或是*prgnUpdate* （僅限一個可能不為 NULL）。 兩者都是 NULL，則會對整個視窗失效。

下列旗標用來驗證視窗：

- RDW_NOERASE 隱藏任何暫止 WM_ERASEBKGND 訊息。

- RDW_NOFRAME 隱藏任何暫止 WM_NCPAINT 訊息。 這個旗標必須 RDW_VALIDATE 搭配使用，通常可搭配 RDW_NOCHILDREN。 應該小心的情況下，使用此選項，因為它無法防止正確繪製視窗的部分。

- RDW_NOINTERNALPAINT 隱藏任何暫止的內部 WM_PAINT 訊息。 這個旗標不會影響所產生的無效區域 WM_PAINT 訊息。

- 驗證 RDW_VALIDATE *lpRectUpdate*或是*prgnUpdate* （僅限一個可能不為 NULL）。 如果兩者都是 NULL 時，會驗證整個視窗。 這個旗標不會影響內部 WM_PAINT 訊息。

下列旗標控制重新繪製時，就會發生。 不由執行繪製`RedrawWindow`函式，除非指定其中一個這些位元。

- RDW_ERASENOW 導致 WM_NCPAINT 和 WM_ERASEBKGND 之前收到的訊息，如有必要，則函數會傳回受影響的 windows （如 RDW_ALLCHILDREN 和 RDW_NOCHILDREN 旗標所指定）。 WM_PAINT 訊息會延後。

- RDW_UPDATENOW 導致 WM_NCPAINT、 WM_ERASEBKGND 和 WM_PAINT 之前收到的訊息，如有必要，則函數會傳回受影響的 windows （如 RDW_ALLCHILDREN 和 RDW_NOCHILDREN 旗標所指定）。

根據預設，windows 會受到`RedrawWindow`函式取決於指定的視窗是否有 WS_CLIPCHILDREN 樣式。 不會影響 WS_CLIPCHILDREN windows 子視窗。 不過，WS_CLIPCHILDREN windows 這些視窗會以遞迴方式驗證或失效，直到遇到 WS_CLIPCHILDREN 視窗為止。 下列旗標控制哪些 windows 受到`RedrawWindow`函式：

- RDW_ALLCHILDREN 包含子視窗，如果有的話，repainting 作業中。

- RDW_NOCHILDREN 排除子視窗，如果有的話，從 repainting 的作業。

### <a name="return-value"></a>傳回值

如果已順利啟動。 重新繪製視窗，非零值。否則為 0。

### <a name="remarks"></a>備註

當`RedrawWindow`成員函式用來使其失效的桌面 視窗中，屬於該視窗不會收到[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息。 若要重新繪製桌面，應用程式應該使用[CWnd::ValidateRgn](#validatergn)， [CWnd::InvalidateRgn](#invalidatergn)， [CWnd::UpdateWindow](#updatewindow)，或[RedrawWindow](/windows/desktop/api/winuser/nf-winuser-redrawwindow)

##  <a name="reflectchildnotify"></a>  CWnd::ReflectChildNotify

此訊息函式會呼叫從 framework [OnChildNotify](#onchildnotify)。

```
BOOL ReflectChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要反映的訊息。

*wParam*<br/>
指定訊息相關的其他資訊。

*lParam*<br/>
指定訊息相關的其他資訊。

*pResult*<br/>
傳回由父視窗的子視窗所產生的結果。 可以是 NULL。

### <a name="return-value"></a>傳回值

如果已反映訊息;，則為 TRUE。否則為 FALSE。

### <a name="remarks"></a>備註

它是協助程式函式會反映*訊息*至其來源。

反映會直接傳送訊息[CWnd::OnWndMsg](#onwndmsg)或是[CCmdTarget::OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)。

如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="reflectlastmsg"></a>  CWnd::ReflectLastMsg

以反映子視窗的最後一個訊息，架構會呼叫此成員函式。

```
static BOOL PASCAL ReflectLastMsg(
    HWND hWndChild,
    LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*hWndChild*<br/>
子視窗的控制代碼。

*pResult*<br/>
傳回由父視窗的子視窗所產生的結果。 可以是 NULL。

### <a name="return-value"></a>傳回值

非零值，如果已處理的訊息;否則為 0。

### <a name="remarks"></a>備註

此成員函式會呼叫[SendChildNotifyLastMsg](#sendchildnotifylastmsg)如果視窗識別*hWndChild* OLE 控制項或永久的對應中的視窗。

如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="releasedc"></a>  CWnd::ReleaseDC

釋放裝置內容，釋放它用於其他應用程式。

```
int ReleaseDC(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
識別裝置內容，以釋出。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

效果`ReleaseDC`成員函式取決於裝置內容類型。

應用程式必須呼叫`ReleaseDC`成員函式，每次呼叫[GetWindowDC](#getwindowdc)成員函式和每次呼叫[GetDC](#getdc)成員函式。

##  <a name="repositionbars"></a>  CWnd::RepositionBars

呼叫以定位並調整大小之視窗的工作區中的控制列。

```
void RepositionBars(UINT nIDFirst,
    UINT nIDLast,
    UINT nIDLeftOver,
    UINT nFlag = reposDefault,
    LPRECT lpRectParam = NULL,
    LPCRECT lpRectClient = NULL,
    BOOL bStretch = TRUE) ;
```

### <a name="parameters"></a>參數

*nIDFirst*<br/>
識別碼的第一個範圍內重新定位並調整大小的控制列。

*nIDLast*<br/>
要定位並調整大小的控制列範圍中最後一個識別碼。

*nIDLeftOver*<br/>
指定用來填滿其餘的工作區 窗格的識別碼。

*nFlag*<br/>
可以有下列值之一：

- `CWnd::reposDefault` 執行控制列的配置。 *lpRectParam*未使用，而且可以是 NULL。

- `CWnd::reposQuery` 控制列配置不是;相反地*lpRectParam*如同配置實際完成的動作，會將工作區的大小，以初始化。

- `CWnd::reposExtra` 值相加*lpRectParam*的工作區*nIDLast*而也會執行配置。

*lpRectParam*<br/>
指向[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect); 的使用方式取決於值*旗*。

*lpRectClient*<br/>
指向[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)包含可用的用戶端區域。 如果是 NULL，則將使用視窗的工作區。

*bStretch*<br/>
指出軸是否應該自動縮放以框架的大小。

### <a name="remarks"></a>備註

*NIDFirst*並*nIDLast*參數定義的工作區中重新定位的控制列識別碼的範圍。 *NIDLeftOver*參數指定的子視窗 （通常是檢視） 重新定位和調整大小以填滿其餘的工作區未填入的控制列識別碼。

##  <a name="runmodalloop"></a>  CWnd::RunModalLoop

呼叫此成員函式，來擷取、 轉換、 或分派訊息，直到[ContinueModal](#continuemodal)會傳回 FALSE。

```
int RunModalLoop(DWORD dwFlags = 0);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定要傳送的 Windows 訊息。 可為下列其中一個值：

- MLF_NOIDLEMSG 不傳送[WM_ENTERIDLE](/windows/desktop/dlgbox/wm-enteridle)至上一層的訊息。

- MLF_NOKICKIDLE 不將 WM_KICKIDLE 訊息傳送至視窗中。

- 當訊息佇列變成閒置時，MLF_SHOWONIDLE 顯示視窗。

### <a name="return-value"></a>傳回值

指定的值*n 結果*參數傳遞給[EndModalLoop](#endmodalloop)成員函式，然後用來結束強制回應迴圈。

### <a name="remarks"></a>備註

根據預設，`ContinueModal`會傳回 FALSE 之後`EndModalLoop`呼叫。 傳回值依現狀*n 結果*至`EndModalLoop`。

##  <a name="screentoclient"></a>  CWnd::ScreenToClient

將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。

```
void ScreenToClient(LPPOINT lpPoint) const;  void ScreenToClient(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[POINT 結構](/windows/desktop/api/windef/ns-windef-tagpoint)，其中包含要轉換的螢幕座標。

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，其中包含要轉換的螢幕座標。

### <a name="remarks"></a>備註

`ScreenToClient`成員函式會取代指定的螢幕座標*lpPoint*或是*lpRect*用戶端座標。 這個新座標是相對於左上角`CWnd`工作區。

### <a name="example"></a>範例

  範例，請參閱[CListCtrl::GetItemRect](../../mfc/reference/clistctrl-class.md#getitemrect)。

##  <a name="scrollwindow"></a>  CWnd::ScrollWindow

將目前的工作區的內容捲動`CWnd`物件。

```
void ScrollWindow(
    int xAmount,
    int yAmount,
    LPCRECT lpRect = NULL,
    LPCRECT lpClipRect = NULL);
```

### <a name="parameters"></a>參數

*xAmount*<br/>
以裝置為單位，水平捲動的指定單位的數量。 這個參數必須為負值，向左捲動。

*yAmount*<br/>
以裝置為單位，垂直捲動的指定單位的數量。 這個參數必須為負值，向上捲動。

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，指定要捲動的部分。 如果*lpRect*為 NULL，就會捲動整個工作區。 如果資料指標矩形交集捲動矩形，已重新定位到插入號。

*lpClipRect*<br/>
指向`CRect`物件或`RECT`結構，指定要捲動的裁剪方框。 在此矩形內的位元會捲動。 即使是在中，不會影響此矩形的外面的位元*lpRect*矩形。 如果*lpClipRect*是 NULL，不裁剪對捲軸的矩形。

### <a name="remarks"></a>備註

如果插入號位於`CWnd`捲動，`ScrollWindow`自動隱藏插入號，以防止它被清除，並在捲軸完成之後，接著還原插入號。 插入號位置會隨之調整。

區域未發現`ScrollWindow`成員函式不會重新繪製，但會合併到目前`CWnd`物件的更新區域。 應用程式最後將會收到[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息，通知區域需要重新繪製。 若要捲動的同時，重新繪製之未涵蓋範圍的區域，呼叫[UpdateWindow](#updatewindow)成員函式後立即呼叫`ScrollWindow`。

如果*lpRect*是 NULL，在視窗中的 windows 位移所指定之數量的任何子系位置*xAmount*並*yAmount*，和任何無效的 (unpainted) 區域中`CWnd`也位移。 `ScrollWindow` 當速度*lpRect*是 NULL。

如果*lpRect*不是 NULL，子視窗的位置不是已變更，和不正確的區域中`CWnd`不位移。 若要防止更新問題時*lpRect*是 not NULL，請呼叫`UpdateWindow`成員函式來重新繪製`CWnd`再呼叫`ScrollWindow`。

##  <a name="scrollwindowex"></a>  CWnd::ScrollWindowEx

捲動視窗的工作區的內容。

```
int ScrollWindowEx(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* prgnUpdate,
    LPRECT lpRectUpdate,
    UINT flags);
```

### <a name="parameters"></a>參數

*dx*<br/>
以裝置為單位，水平捲動的指定單位的數量。 這個參數必須為負值，向左捲動。

*dy*<br/>
以裝置為單位，垂直捲動的指定單位的數量。 這個參數必須為負值，向上捲動。

*lpRectScroll*<br/>
指向[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，指定要捲動的部分。 如果此參數為 NULL，就會捲動整個工作區。

*lpRectClip*<br/>
指向`RECT`結構，指定要捲動的裁剪方框。 此結構的優先順序高於所指的矩形*lpRectScroll*。 在此矩形內的位元會捲動。 即使是在中，不會影響此矩形的外面的位元*lpRectScroll*矩形。 如果此參數為 NULL，就會捲動矩形上執行不裁剪。

*prgnUpdate*<br/>
識別已修改為保存捲動失效的區域的區域。 這個參數可以是 NULL。

*lpRectUpdate*<br/>
指向`RECT`會收到捲動失效的矩形界限的結構。 這個參數可以是 NULL。

*flags*<br/>
可以有下列值之一：

- SW_ERASE 時指定 SW_INVALIDATE，清除新失效的區域，藉由傳送[WM_ERASEBKGND](/windows/desktop/winmsg/wm-erasebkgnd)至視窗的訊息。

- SW_INVALIDATE 失效的區域識別*prgnUpdate*捲動後。

- 所有的子視窗之矩形的交集所指向的 SW_SCROLLCHILDREN 捲動*lpRectScroll*中指定的像素為單位的數目*dx*並*dy*。 Windows 會傳送[WM_MOVE](/windows/desktop/winmsg/wm-move)相交的所有子視窗的訊息*lpRectScroll*，即使它們不會移動。 子視窗捲動和的資料指標矩形交集捲動矩形時，已重新定位到插入號。

### <a name="return-value"></a>傳回值

傳回值是 SIMPLEREGION （矩形失效的區域）、 COMPLEXREGION （非矩形失效的區域，重疊矩形）、 或 NULLREGION （沒有失效的區域），如果成功，函式否則，傳回值是錯誤。

### <a name="remarks"></a>備註

此函數很相似[ScrollWindow](/windows/desktop/api/winuser/nf-winuser-scrollwindow)函式，以及一些額外的功能。

如果[SW_INVALIDATE](/windows/desktop/api/winuser/nf-winuser-scrollwindowex)並[SW_ERASE](/windows/desktop/api/winuser/nf-winuser-scrollwindowex)未指定，`ScrollWindowEx`成員函式也不會使之區域的捲動以外的位置。 如果其中一個這些旗標設定，`ScrollWindowEx`失效這個區域。 應用程式會呼叫才會更新區域[UpdateWindow](/windows/desktop/api/winuser/nf-winuser-updatewindow)成員函式時，會呼叫[RedrawWindow](/windows/desktop/api/winuser/nf-winuser-redrawwindow)成員函式 (指定[RDW_UPDATENOW](/windows/desktop/api/winuser/nf-winuser-redrawwindow)或[RDW_ERASENOW](/windows/desktop/api/winuser/nf-winuser-redrawwindow))，或擷取[WM_PAINT](/windows/desktop/gdi/wm-paint)從應用程式佇列的訊息。

如果視窗有[WS_CLIPCHILDREN](/windows/desktop/api/winuser/nf-winuser-createwindowa)樣式，傳回所指定的區域*prgnUpdate*並*lpRectUpdate*代表總計必須捲動視窗的區域更新，包括需要更新的子視窗中的任何區域。

如果[SW_SCROLLCHILDREN](/windows/desktop/api/winuser/nf-winuser-scrollwindowex)指定旗標，Windows 不會正確更新畫面捲動之子視窗的一部分。 來源矩形外捲動的子視窗的部分並不會清除，且將不會重新繪製正確地在新的目的地。 使用[DeferWindowPos](/windows/desktop/api/winuser/nf-winuser-deferwindowpos)並非位於完全內的移動子視窗的 Windows 函式*lpRectScroll*矩形。 如果設定 SW_SCROLLCHILDREN 旗標，且插入號矩形交集捲動矩形，已重新定位到資料指標。

所有輸入和輸出的座標 (如*lpRectScroll*， *lpRectClip*， *lpRectUpdate*，以及*prgnUpdate*) 假設為用戶端座標，不論視窗是否有 CS_OWNDC 或 CS_CLASSDC 類別樣式。 使用[LPtoDP](/windows/desktop/api/wingdi/nf-wingdi-lptodp)並[DPtoLP](/windows/desktop/api/wingdi/nf-wingdi-dptolp)來回轉換邏輯座標位置，如有必要的 Windows 函式。

##  <a name="sendchildnotifylastmsg"></a>  CWnd::SendChildNotifyLastMsg

通知訊息給子視窗，從提供的父視窗，讓子視窗可以處理工作，架構會呼叫此成員函式。

```
BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*pResult*<br/>
傳回由父視窗的子視窗所產生的結果。

### <a name="return-value"></a>傳回值

如果子視窗已處理訊息傳送至其父代則為非零否則為 0。

### <a name="remarks"></a>備註

`SendChildNotifyLastMsg` 目前的訊息傳送至來源，才會反映的訊息。

如需訊息反映的詳細資訊，請參閱[處理反映訊息](../../mfc/handling-reflected-messages.md)。

##  <a name="senddlgitemmessage"></a>  CWnd::SendDlgItemMessage

將訊息傳送至控制項。

```
LRESULT SendDlgItemMessage(
    int nID,
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定將接收的訊息對話方塊控制項的識別項。

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定訊息相關的其他資訊。

*lParam*<br/>
指定訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

指定傳回控制項的視窗程序，或 0，如果找不到控制項的值。

### <a name="remarks"></a>備註

`SendDlgItemMessage`成員函式不會傳回之前處理訊息。

使用`SendDlgItemMessage`等同於取得`CWnd`* 設為指定的控制項並呼叫[SendMessage](#sendmessage)成員函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#113](../../mfc/reference/codesnippet/cpp/cwnd-class_54.cpp)]

##  <a name="sendmessage"></a>  CWnd::SendMessage

將指定的訊息傳送至這個視窗。

```
LRESULT SendMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定訊息相關的其他資訊。

*lParam*<br/>
指定訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

訊息處理的結果;其值取決於傳送的訊息。

### <a name="remarks"></a>備註

`SendMessage`成員函式會直接呼叫的視窗程序，並不會傳回該視窗程序已經處理此訊息。 這是相對於[PostMessage](#postmessage)成員函式，它會將訊息放入該視窗的訊息佇列，並立即傳回。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

##  <a name="sendmessagetodescendants"></a>  CWnd::SendMessageToDescendants

呼叫此成員函式可將指定的 Windows 訊息傳送至所有下階視窗。

```
void SendMessageToDescendants(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0,
    BOOL bDeep = TRUE,
    BOOL bOnlyPerm = FALSE);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定訊息相關的其他資訊。

*lParam*<br/>
指定訊息相關的其他資訊。

*bDeep*<br/>
指定要搜尋的層級。 如果為 TRUE，以遞迴方式搜尋所有子系;如果為 FALSE，則搜尋僅直接子系。

*bOnlyPerm*<br/>
指定是否將暫存的 windows 中接收訊息。 如果為 TRUE，暫存的 windows 可以接收訊息。如果為 FALSE，僅永久 windows 就會收到的訊息。 如需有關暫存的 windows，請參閱[技術的附註 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="remarks"></a>備註

如果*bDeep*為 FALSE 時，只是為了在視窗的直接子系傳送訊息，否則訊息會傳送至所有下階視窗。

如果*bDeep*並*bOnlyPerm*為 TRUE，則會繼續搜尋以下暫存的 windows。 在此情況下，只有在搜尋期間發生的永久性 windows 收到的訊息。 如果*bDeep*為 FALSE 時，訊息只會傳送到視窗的直接子系。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#114](../../mfc/reference/codesnippet/cpp/cwnd-class_55.cpp)]

##  <a name="sendnotifymessage"></a>  CWnd::SendNotifyMessage

將指定的訊息傳送至視窗。

```
BOOL SendNotifyMessage(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要傳送的訊息。

*wParam*<br/>
指定訊息相關的其他資訊。

*lParam*<br/>
指定訊息相關的其他資訊。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果視窗由呼叫的執行緒中，建立`SendNotifyMessage`呼叫視窗的視窗程序，且沒有傳回之前的視窗程序已經處理此訊息。 如果視窗由不同的執行緒建立`SendNotifyMessage`將訊息傳遞至視窗程序，並傳回立即; 它不會等候完成處理訊息的視窗程序。

##  <a name="setactivewindow"></a>  CWnd::SetActiveWindow

可讓`CWnd`作用中視窗。

```
CWnd* SetActiveWindow();
```

### <a name="return-value"></a>傳回值

前一個使用中視窗。

傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

`SetActiveWindow`應該謹慎使用成員函式，因為它允許任意接管使用中視窗並輸入的焦點的應用程式。 一般來說，Windows 會負責所有啟用。

##  <a name="setcapture"></a>  CWnd::SetCapture

導致所有後續滑鼠輸入傳送至目前`CWnd`物件，不論資料指標的位置。

```
CWnd* SetCapture();
```

### <a name="return-value"></a>傳回值

先前接收到所有的滑鼠輸入視窗物件的指標。 如果沒有這類的時段，它就會是 NULL。 傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

當`CWnd`不再需要所有的滑鼠輸入，應用程式應該呼叫[ReleaseCapture](/windows/desktop/api/winuser/nf-winuser-releasecapture)函式，以便其他視窗可以接收滑鼠輸入。

擷取滑鼠輸入，而不再 WM_NCHITTEST 或 WM_SETCURSOR 訊息會傳送至作用中視窗中。

##  <a name="setcaretpos"></a>  CWnd::SetCaretPos

將插入號位置設定。

```
static void PASCAL SetCaretPos(POINT point);
```

### <a name="parameters"></a>參數

*point*<br/>
指定新的 x 和 y 座標 （在工作區座標中） 插入號。

### <a name="remarks"></a>備註

`SetCaretPos`成員函式會在它屬於目前的工作中的視窗時，才將將插入號移。 `SetCaretPos` 將插入號移，或有插入號會隱藏。

插入號是共用的資源。 如果它沒有自己的插入號，視窗應該不會將插入號。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#115](../../mfc/reference/codesnippet/cpp/cwnd-class_56.cpp)]

##  <a name="setclipboardviewer"></a>  CWnd::SetClipboardViewer

將剪貼簿的內容變更時 （藉由 WM_DRAWCLIPBOARD 訊息） 收到通知的視窗的鏈結，此視窗。

```
HWND SetClipboardViewer();
```

### <a name="return-value"></a>傳回值

如果成功的剪貼簿檢視器鏈結中下一步 的視窗控制代碼。 應用程式應該將此控制代碼 （它可以儲存為成員變數） 儲存至剪貼簿檢視器鏈結訊息回應時使用。

### <a name="remarks"></a>備註

視窗的剪貼簿檢視器鏈結的一部分必須回應[WM_DRAWCLIPBOARD](#ondrawclipboard)， [WM_CHANGECBCHAIN](#onchangecbchain)，和[WM_DESTROY](#ondestroy)訊息，並將訊息傳遞至下一步鏈結中的視窗。

此成員函式會將 WM_DRAWCLIPBOARD 訊息傳送至視窗。 尚未退回剪貼簿檢視器鏈結中下一個視窗的控制代碼，因為應用程式不應該傳遞 WM_DRAWCLIPBOARD 收到訊息時，它在呼叫期間`SetClipboardViewer`。

若要從剪貼簿檢視器鏈結中移除本身，應用程式必須呼叫[ChangeClipboardChain](#changeclipboardchain)成員函式。

##  <a name="setdlgctrlid"></a>  CWnd::SetDlgCtrlID

將視窗識別碼或視窗的控制項 ID 設定為新的值。

```
int SetDlgCtrlID(int nID);
```

### <a name="parameters"></a>參數

*nID*<br/>
要設定控制項的識別項的新值。

### <a name="return-value"></a>傳回值

先前的識別項的視窗中，如果登錄成功。否則為 0。

### <a name="remarks"></a>備註

任何子視窗，而不只一個對話方塊中的控制項時，可以將此視窗。 最上層的視窗時，無法將此視窗。

##  <a name="setdlgitemint"></a>  CWnd::SetDlgItemInt

在對話方塊中，以指定的整數值的字串表示，設定指定控制項的文字。

```
void SetDlgItemInt(
    int nID,
    UINT nValue,
    BOOL bSigned = TRUE);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要變更控制項的整數識別碼。

*nValue*<br/>
指定用來產生項目文字的整數值。

*bSigned*<br/>
指定是否帶正負號或不帶正負號的整數值。 如果此參數為 TRUE， *n 值*簽署。 如果此參數為 TRUE 並*n 值*小於 0，正負號放在字串中的第一個數字前面的減號。 如果此參數為 FALSE 時， *n 值*不帶正負號。

### <a name="remarks"></a>備註

`SetDlgItemInt` 傳送[WM_SETTEXT](/windows/desktop/winmsg/wm-settext)訊息指定的控制項。

### <a name="example"></a>範例

  範例，請參閱[CWnd::SetDlgItemText](#setdlgitemtext)。

##  <a name="setdlgitemtext"></a>  CWnd::SetDlgItemText

設定的標題或文字視窗或對話方塊方塊中所擁有的控制項。

```
void SetDlgItemText(
    int nID,
    LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*nID*<br/>
識別要設定其文字的控制項。

*lpszString*<br/>
指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或 null 終止的字串，其中包含要複製到控制項的文字。

### <a name="remarks"></a>備註

`SetDlgItemText` 傳送[WM_SETTEXT](/windows/desktop/winmsg/wm-settext)訊息指定的控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#116](../../mfc/reference/codesnippet/cpp/cwnd-class_57.cpp)]

##  <a name="setforegroundwindow"></a>  CWnd::SetForegroundWindow

將建立視窗的執行緒放置到前景並啟動視窗。

```
BOOL SetForegroundWindow();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

鍵盤輸入會導向至視窗中，並為使用者變更各種不同的視覺提示。 前景視窗是與使用者目前正在使用的視窗。 前景視窗只適用於最上層視窗 （框架的視窗或對話方塊方塊）。

### <a name="example"></a>範例

  範例，請參閱[CWnd::FindWindow](#findwindow)。

##  <a name="setfocus"></a>  CWnd::SetFocus

宣告輸入焦點。

```
CWnd* SetFocus();
```

### <a name="return-value"></a>傳回值

先前擁有輸入的焦點的視窗物件的指標。 如果沒有這類的時段，它就會是 NULL。 傳回的指標可能是暫時性的不應該儲存。

### <a name="remarks"></a>備註

輸入的焦點，會指示此視窗的所有後續的鍵盤輸入。 任何先前擁有輸入的焦點的視窗會失去它。

`SetFocus`成員函式會傳送[WM_KILLFOCUS](/windows/desktop/inputdev/wm-killfocus)失去輸入的焦點的視窗訊息並[WM_SETFOCUS](/windows/desktop/inputdev/wm-setfocus)收到輸入的焦點的視窗訊息。 它也會啟動視窗或其父代。

如果目前的視窗是作用中，但未取得焦點 （也就是沒有任何視窗具有焦點），按下任意鍵會產生訊息[WM_SYSCHAR](#onsyschar)， [WM_SYSKEYDOWN](#onsyskeydown)，或[WM_SYSKEYUP](#onsyskeyup).

##  <a name="setfont"></a>  CWnd::SetFont

將 WM_SETFONT 訊息傳送至視窗，以使用指定的字型。

```
void SetFont(
    CFont* pFont,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*pFont*<br/>
指向 `CFont` 物件的指標。

*bRedraw*<br/>
視窗處理 WM_SETFONT 訊息之後，立即重繪，則為 TRUE否則為 FALSE。

### <a name="remarks"></a>備註

這個方法沒有任何作用，除非視窗處理 WM_SETFONT 的訊息。 MFC 類別衍生自`CWnd`處理此訊息，因為它們會附加至包含 WM_SETFONT 訊息的訊息處理常式的預先定義的視窗類別。 若要使用此方法中，您可以從衍生的類別`CWnd`必須定義 WM_SETFONT 訊息的方法處理常式。

##  <a name="seticon"></a>  CWnd::SetIcon

呼叫所識別的控制代碼設為特定的圖示，此成員函式*hIcon*。

```
HICON SetIcon(
    HICON hIcon,
    BOOL bBigIcon);
```

### <a name="parameters"></a>參數

*hIcon*<br/>
上一個圖示控制代碼。

*bBigIcon*<br/>
指定 32 像素 32 像素圖示，如果為 TRUE;指定的 16 像素 16 像素圖示，如果為 FALSE。

### <a name="return-value"></a>傳回值

圖示控制代碼。

### <a name="remarks"></a>備註

註冊視窗類別時，它會選取一個圖示。

### <a name="example"></a>範例

  範例，請參閱[CWnd::GetSystemMenu](#getsystemmenu)。

##  <a name="setlayeredwindowattributes"></a>  CWnd::SetLayeredWindowAttributes

設定分層視窗的不透明和透明色鍵。

```
BOOL SetLayeredWindowAttributes(
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*crKey*<br/>
指定透明色彩索引鍵，用於當您在撰寫分層的視窗 COLORREF 值指標。 以此種色彩視窗所繪製的所有像素會是透明的。 若要產生 COLORREF，使用 RGB 巨集。

*bAlpha*<br/>
用來描述層疊視窗的不透明度的 alpha 值。 如需詳細資訊，請參閱 <<c0> `SourceConstantAlpha` 隸屬[BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction)結構。 當*bAlpha*是 0，則是完全透明的視窗。 當*bAlpha*為 255，視窗是不透明。

*dwFlags*<br/>
指定要採取的動作。 這個參數可以是下列一或多個下列的值。 如需可能值的清單，請參閱 < [SetLayeredWindowAttributes](/windows/desktop/api/winuser/nf-winuser-setlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[SetLayeredWindowAttributes](/windows/desktop/api/winuser/nf-winuser-setlayeredwindowattributes)、 Windows SDK 中所述。

##  <a name="setmenu"></a>  CWnd::SetMenu

將目前的功能表，設定指定的功能表。

```
BOOL SetMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
識別新的功能表。 如果此參數為 NULL，則會移除目前的功能表。

### <a name="return-value"></a>傳回值

非零值，如果變更功能表;否則為 0。

### <a name="remarks"></a>備註

會使視窗以反映功能表變更重新繪製。

`SetMenu` 將不會終結上一個功能表。 應用程式應該呼叫[CMenu::DestroyMenu](../../mfc/reference/cmenu-class.md#destroymenu)成員函式來完成這項工作。

### <a name="example"></a>範例

  範例，請參閱[CMenu::LoadMenu](../../mfc/reference/cmenu-class.md#loadmenu)。

##  <a name="setowner"></a>  CWnd::SetOwner

將目前視窗的擁有者設為指定的視窗物件。

```
void SetOwner(CWnd* pOwnerWnd);
```

### <a name="parameters"></a>參數

*pOwnerWnd*<br/>
識別視窗物件的新擁有者。 如果此參數為 NULL，則視窗物件會有沒有擁有者。

### <a name="remarks"></a>備註

然後，此擁有者就可以從目前的視窗物件中，來接收命令訊息。 根據預設，目前視窗的父代是其擁有者。

通常很有用的視窗階層架構無關的視窗物件之間建立連線。 例如， [CToolBar](../../mfc/reference/ctoolbar-class.md)將通知傳送至其父代而非其擁有者。 這可讓工具列時傳送通知給另一個視窗 （例如的就地框架視窗） 成為一個視窗 （例如 OLE 容器應用程式視窗） 的子系。 此外，伺服器視窗停用或啟用期間就地時編輯框架視窗所擁有的任何視窗是隱藏或顯示。 藉由呼叫，會明確設定此擁有權`SetOwner`。

此函式擁有權證明是不同的擁有權證明[GetWindow](/windows/desktop/api/winuser/nf-winuser-getwindow)。

##  <a name="setparent"></a>  CWnd::SetParent

變更子視窗的父視窗。

```
CWnd* SetParent(CWnd* pWndNewParent);
```

### <a name="parameters"></a>參數

*pWndNewParent*<br/>
識別新的父視窗。

### <a name="return-value"></a>傳回值

先前的父視窗物件如果成功的指標。 傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

如果子視窗為可見的 Windows 會執行適當的重繪並重新繪製。

##  <a name="setproperty"></a>  CWnd::SetProperty

呼叫此成員函式設定所指定的 OLE 控制項屬性*dwDispID*。

```
void AFX_CDECL SetProperty(
    DISPID dwDispID,
    VARTYPE vtProp, ...);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
識別要設定的屬性。

*vtProp*<br/>
指定要設定的屬性類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*...*<br/>
所指定之類型的單一參數*vtProp*。

### <a name="remarks"></a>備註

> [!NOTE]
> 此函式應該只在呼叫`CWnd`物件，表示 OLE 控制項。

如需有關如何使用 OLE 控制項容器中的此成員函式的詳細資訊，請參閱[ActiveX 控制項容器：程式設計 ActiveX 控制項容器中的 ActiveX 控制項](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

##  <a name="setredraw"></a>  CWnd::SetRedraw

應用程式呼叫`SetRedraw`允許重新繪製，或防止重繪變更的變更。

```
void SetRedraw(BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*bRedraw*<br/>
指定的重繪旗標的狀態。 如果此參數為 TRUE，就會設定重繪旗標。如果為 FALSE，則會清除旗標。

### <a name="remarks"></a>備註

此成員函式設定或清除重繪旗標。 雖然重繪旗標已清除，內容將不會在每次變更之後更新，且將會重繪旗標設定時，才不繪製。 例如，需要將數個項目新增至清單方塊的應用程式可以清除重繪旗標，新增項目，，然後設定重繪旗標。 最後，應用程式可以呼叫[Invalidate](#invalidate)或是[InvalidateRect](#invalidaterect)成員函式，會導致重新繪製的清單方塊。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#117](../../mfc/reference/codesnippet/cpp/cwnd-class_58.cpp)]

##  <a name="setscrollinfo"></a>  CWnd::SetScrollInfo

呼叫此成員函式可設定的資訊`SCROLLINFO`結構維護的捲軸相關。

```
BOOL SetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果非工作區的一部分，nBar 也會指出是否捲軸置於水平、 垂直或兩者。 它必須是下列其中一項：

- SB_CTL 包含捲軸控制項的參數。 `m_hWnd`資料成員必須是捲軸控制項的控制代碼。

- SB_HORZ 指定視窗為水平捲軸。

- SB_VERT 指定視窗的垂直捲軸。

*lpScrollInfo*<br/>
指標[SCROLLINFO](/windows/desktop/api/winuser/ns-winuser-tagscrollinfo)結構。 請參閱 Windows SDK，如需有關這個結構。

*bRedraw*<br/>
指定捲軸是否應該重新繪製以反映新的位置。 如果*bRedraw*為 TRUE 時，會重新繪製捲軸。 如果是 FALSE，會不重新繪製。 根據預設，會重新繪製捲軸。

### <a name="return-value"></a>傳回值

如果成功，傳回為 TRUE。 否則，它就是 FALSE。

### <a name="remarks"></a>備註

[SCROLLINFO](/windows/desktop/api/winuser/ns-winuser-tagscrollinfo)結構包含捲軸，包括最小值和最大捲動位置、 頁面大小和捲軸方塊 （捲動方塊） 的位置的相關資訊。 請參閱`SCROLLINFO`結構變更結構的預設值的詳細資訊的 Windows SDK 中的主題。

MFC Windows 訊息，表示捲軸位置的處理常式[CWnd::OnHScroll](#onhscroll)並[CWnd::OnVScroll](#onvscroll)，提供僅 16 位元的位置資料。 [GetScrollInfo](#getscrollinfo)和`SetScrollInfo`提供 32 位元的捲軸位置資料。 因此，應用程式可以呼叫`GetScrollInfo`同時處理`CWnd::OnHScroll`或`CWnd::OnVScroll`取得 32 位元的捲軸位置資料。

> [!NOTE]
> [CWnd::GetScrollInfo](#getscrollinfo)允許應用程式使用 32 位元的捲軸位置。

##  <a name="setscrollpos"></a>  CWnd::SetScrollPos

設定捲動方塊的目前位置，而且，如果要求，會重新繪製捲軸以反映新的捲動方塊的位置。

```
int SetScrollPos(
    int nBar,
    int nPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸設定。 這個參數可以是下列其中一項：

- SB_HORZ 設定視窗的水平捲軸中的捲動方塊的位置。

- SB_VERT 設定在視窗的垂直捲軸的捲動方塊的位置。

*nPos*<br/>
指定捲動方塊的新位置。 它必須是捲動的範圍內。

*bRedraw*<br/>
指定是否應該以反映新的捲動方塊位置中繪製的捲軸。 如果此參數為 TRUE，則會重新繪製捲軸;如果為 FALSE，會不會重新繪製捲軸。

### <a name="return-value"></a>傳回值

捲動方塊之前的位置。

### <a name="remarks"></a>備註

設定*bRedraw*為 FALSE 適合另一個函式的後續呼叫將會重新繪製捲軸時。

##  <a name="setscrollrange"></a>  CWnd::SetScrollRange

設定給定捲軸的最小和最大位置值。

```
void SetScrollRange(
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸設定。 這個參數可以是下列值：

- SB_HORZ 設定視窗的水平捲軸的範圍。

- SB_VERT 設定視窗的垂直捲軸的範圍。

*nMinPos*<br/>
指定捲動位置的最小值。

*nMaxPos*<br/>
指定捲動位置的最大值。

*bRedraw*<br/>
指定捲軸是否應該重新繪製以反映變更。 如果*bRedraw*為 TRUE 時，會重新繪製捲軸; 如果為 FALSE，未重新繪製捲軸。

### <a name="remarks"></a>備註

它也可以用來隱藏或顯示標準的捲軸。

應用程式不應該呼叫此函式以處理捲軸通知訊息時隱藏捲軸。

如果呼叫`SetScrollRange`緊接在後面的呼叫[SetScrollPos](#setscrollpos)成員函式*bRedraw*中的參數`SetScrollPos`成員函式應該是 0，以防止從捲軸正在繪製兩次。

標準的捲軸的預設範圍是 0 到 100 之間。 捲軸控制項的預設範圍是空的 (同時*nMinPos*並*nMaxPos*值為 0)。 所指定的值之間的差異*nMinPos*並*nMaxPos*不能大於 INT_MAX。

##  <a name="settimer"></a>  CWnd::SetTimer

安裝系統計時器。

```
UINT_PTR SetTimer(
    UINT_PTR nIDEvent,
    UINT nElapse,
    void (CALLBACK* lpfnTimer)(HWND,
    UINT,
    UINT_PTR,
    DWORD));
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定非零的計時器識別項。 如果計時器識別項是唯一的這個相同的值由`SetTimer`。 否則，`SetTimer`決定新的唯一值，並傳回該。 針對視窗計時器 （具有 NULL 回呼函式），值必須是唯一只會針對目前的視窗相關聯的其他視窗計時器。 對於回呼計時器，值必須是唯一的所有處理序中的所有計時器。 因此，當您建立回呼計時器時，它是更有可能傳回的值可能會從您指定的值不同。

*nElapse*<br/>
指定的逾時值或間隔，以毫秒為單位。

*lpfnTimer*<br/>
指定的應用程式所提供的地址`TimerProc`處理的回呼函式[WM_TIMER](/windows/desktop/winmsg/wm-timer)訊息。 如果此參數為 NULL，WM_TIMER 訊息會放在訊息佇列中的應用程式，而且由`CWnd`物件。

### <a name="return-value"></a>傳回值

如果函式成功，新的計時器的計時器識別項。 此值可能會或可能無法透過傳入的值相等*nIDEvent*參數。 應用程式應該一律傳遞傳回值[KillTimer](#killtimer)成員函式，才能刪除計時器。 如果成功則為非零否則就是 0。

### <a name="remarks"></a>備註

指定的間隔值，以及每次間隔耗盡時，系統將 WM_TIMER 訊息張貼至安裝的應用程式的安裝訊息佇列，或將訊息傳遞給應用程式定義`TimerProc`回呼函式。

*LpfnTimer*回呼函式需要未命名`TimerProc`，但它必須宣告為 static 並定義，如下所示。

```
void CALLBACK TimerProc(
    HWND hWnd,   // handle of CWnd that called SetTimer
    UINT nMsg,   // WM_TIMER
    UINT_PTR nIDEvent,   // timer identification
    DWORD dwTime    // system time);
```

### <a name="example"></a>範例

這個範例會使用`CWnd::SetTimer`， `CWnd::OnTimer`，和`CWnd::KillTimer`處理 WM_TIMER 訊息。 第一個計時器設定將 WM_TIMER 訊息傳送到主框架視窗每隔 2 秒`OnStartTimer`。 `OnTimer`事件處理常式處理主框架視窗的 WM_TIMER 訊息。 這個方法會使電腦喇叭每 2 秒發出嗶聲。 第二個計時器將訊息傳送至回呼函式每隔 3.75 秒。 `OnStopTimer` 將會停止藉由呼叫的兩個計時器`CWnd::KillTimer`每個計時器 ID

[!code-cpp[NVC_MFCWindowing#118](../../mfc/reference/codesnippet/cpp/cwnd-class_59.cpp)]

##  <a name="setwindowcontexthelpid"></a>  CWnd::SetWindowContextHelpId

呼叫此成員函式，指定視窗相關聯的說明內容識別碼。

```
BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
```

### <a name="parameters"></a>參數

*dwContextHelpId*<br/>
說明內容識別碼。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果為子視窗並沒有說明內容識別碼，它會繼承其父視窗的識別碼。 同樣地，如果擁有的視窗並沒有說明內容識別碼，它會繼承其主控視窗的識別碼。 此繼承的說明內容識別碼可讓應用程式設定 對話方塊的單一識別項和所有控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#119](../../mfc/reference/codesnippet/cpp/cwnd-class_60.cpp)]

##  <a name="setwindowplacement"></a>  CWnd::SetWindowPlacement

設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);
```

### <a name="parameters"></a>參數

*lpwndpl*<br/>
指向[WINDOWPLACEMENT](/windows/desktop/api/winuser/ns-winuser-tagwindowplacement)結構，指定新的顯示狀態和位置。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

##  <a name="setwindowpos"></a>  CWnd::SetWindowPos

變更大小、 位置和子系，快顯視窗，和最上層視窗的疊置順序。

```
BOOL SetWindowPos(
    const CWnd* pWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*pWndInsertAfter*<br/>
識別`CWnd`便會優先的物件 （為高於） 這`CWnd`疊置順序中的物件。 這個參數可以是一個指向`CWnd`或變數的指標，下列值之一：

- `wndBottom` 讓此視窗底部的疊置順序。 如果這個`CWnd`是最上層的視窗中，視窗會失去其最上層的狀態;，系統會在視窗底部的 所有其他視窗。

- `wndTop` 讓此視窗頂端的疊置順序。

- `wndTopMost` 讓此視窗以上所有非最上層視窗。 即使停用時，視窗就會維護其最上層的位置。

- `wndNoTopMost` 重新定位至所有非最上層視窗的上方視窗 (也就是所有的最上層視窗後面)。 如果視窗已在非最上層視窗，這個旗標會有任何作用。

如需如何使用此參數的規則，請參閱本主題的 < 備註 > 一節。

*x*<br/>
指定視窗左側的新位置。

*y*<br/>
指定視窗頂端的新位置。

*cx*<br/>
指定視窗的新寬度。

*cy*<br/>
指定視窗的新高度。

*nFlags*<br/>
指定調整大小和位置選項。 這個參數可以是下列旗標的組合：

- SWP_DRAWFRAME 視窗周圍繪製畫面格 （[] 視窗建立時定義）。

- SWP_FRAMECHANGED 傳送 WM_NCCALCSIZE 訊息至 視窗中，即使未變更視窗的大小。 如果未指定此旗標，則只在視窗的大小變更時，才傳送 WM_NCCALCSIZE。

- SWP_HIDEWINDOW 隱藏視窗。

- SWP_NOACTIVATE 不會啟動視窗。 視窗時如果未設定此旗標，已啟用，並移到最上層或非最上層群組的頂端 (視設定而定*pWndInsertAfter*參數)。

- SWP_NOCOPYBITS 捨棄工作區的整個內容。 如果未指定此旗標，工作區的有效內容就會儲存，並複製回工作區之後的視窗大小或重新調整位置。

- SWP_NOMOVE 會保留目前的位置 (會忽略*x*並*y*參數)。

- SWP_NOOWNERZORDER 不會變更疊置順序中的主控視窗的位置。

- SWP_NOREDRAW 不重繪其變更。 如果設定此旗標，任何種類的無重繪就會發生。 這適用於工作區、 非工作區 （包括標題和捲軸），並發現因為移動視窗的父任何的視窗部分。 當設定這個旗標時，應用程式必須明確地失效，或重繪視窗和父視窗，必須重新繪製的任何組件。

- SWP_NOREPOSITION SWP_NOOWNERZORDER 與相同。

- SWP_NOSENDCHANGING 會防止視窗接收 WM_WINDOWPOSCHANGING 訊息。

- SWP_NOSIZE 會保留目前的大小 (會忽略*cx*並*cy*參數)。

- SWP_NOZORDER 會保留目前的訂購 (會忽略*pWndInsertAfter*)。

- SWP_SHOWWINDOW 顯示視窗。

### <a name="return-value"></a>傳回值

如果成功，函式，非零值。否則就是 0。

### <a name="remarks"></a>備註

Windows 會在他們的疊置順序，根據畫面上排序在頂端的疊置順序的視窗會出現在順序中的所有其他視窗上方。

為子視窗的所有座標都是工作區座標 （相對於父視窗工作區的左上角）。

視窗可以移到疊置順序的頂端設定*pWndInsertAfter*參數 **& wndTopMost**並確保未設定 SWP_NOZORDER 旗標，或設定視窗的疊置順序，其值高於任何現有的最上層視窗。 當非最上層的視窗為最上層，其擁有的 windows 也會有最上層。 不會變更其擁有者。

在最上層視窗不再是最上層，如果它已重新定位到下 ( **& wndBottom**) 或後任何非最上層視窗的疊置順序。 當在最上層視窗由非最上層時，所有其擁有者和其所擁有的 windows 也會有非最上層視窗。

如果 SWP_NOACTIVATE 和 SWP_NOZORDER 都未指定 （亦即，當應用程式要求視窗會同時啟動，並放在指定的疊置順序），在指定的值*pWndInsertAfter*只能用於在下列情況：

- 既不 **& wndTopMost**也不 **& wndNoTopMost**中指定*pWndInsertAfter*參數。

- 此範圍不是使用中視窗。

應用程式無法啟動為非現用視窗而不需要也將它帶到疊置順序的頂端。 應用程式可以變更疊置順序的已啟動的視窗，而沒有任何限制。

在非最上層視窗可能擁有最上層的視窗中，但反之則不然。 在最上層視窗所擁有的任何視窗 （例如對話方塊） 是本身所做的最上層的視窗，以確保所有擁有 windows 保持其擁有者。

3\.1 和更新版本的 Windows 版本，windows 可以移到疊置順序的頂端和藉由設定及其 WS_EX_TOPMOST 樣式那里鎖定。 在這類最上層的視窗會維持停用時，即使其最上層的位置。 例如，選取 WinHelp 最上層命令就會最頂部的 [說明] 視窗和它，然後保持可見，當您返回您的應用程式。

若要建立最上層視窗，呼叫`SetWindowPos`具有*pWndInsertAfter*參數等於 **& wndTopMost**，或設定 WS_EX_TOPMOST 樣式，當您建立的視窗。

如果疊置順序包含任何使用 WS_EX_TOPMOST 樣式的視窗，以移動視窗 **& wndTopMost**值會放在上方的所有非最上層視窗，但以下任何最上層的視窗。 當應用程式啟動時沒有 WS_EX_TOPMOST 位元非使用中的視窗時，所有非最上層視窗之上，但低於任何最上層視窗移動視窗。

如果`SetWindowPos`時，會呼叫*pWndInsertAfter*參數 **& wndBottom**和`CWnd`是最上層的視窗中，視窗失去其最上層的狀態 （清除 WS_EX_TOPMOST），而系統會在視窗底部的疊置順序。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#120](../../mfc/reference/codesnippet/cpp/cwnd-class_61.cpp)]

##  <a name="setwindowrgn"></a>  CWnd::SetWindowRgn

呼叫此成員函式設定視窗的區域。

```
int SetWindowRgn(
    HRGN hRgn,
    BOOL bRedraw);
```

### <a name="parameters"></a>參數

*hRgn*<br/>
區域控制代碼。

*bRedraw*<br/>
如果為 TRUE，作業系統會重新繪製視窗設定區域; 之後否則，則沒有。 一般而言，設定*bRedraw*為 TRUE，如果視窗為可見。 如果設為 TRUE，系統 WM_WINDOWPOSCHANGING 和 WM_WINDOWPOSCHANGED 將訊息傳送至視窗。

### <a name="return-value"></a>傳回值

如果此函數成功，傳回的值為非零值。 如果此函式失敗，則傳回值為零。

### <a name="remarks"></a>備註

視窗的視窗區域的座標是相對於視窗中，非工作區視窗的左上角。

在成功呼叫之後`SetWindowRgn`，作業系統擁有區域控制代碼所指定的區域*hRgn*。 作業系統不會進行區域的複本，因此不會進行任何進一步函式呼叫與這個區域控制代碼，並請勿關閉此區域控制代碼。

##  <a name="setwindowtext"></a>  CWnd::SetWindowText

設定為指定文字的視窗的標題。

```
void SetWindowText(LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或 null 結束的字串，來作為新的標題或控制項文字。

### <a name="remarks"></a>備註

如果視窗是控制項，會設定在控制項內的文字。

此函式會導致[WM_SETTEXT](/windows/desktop/winmsg/wm-settext)訊息傳送到這個視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#121](../../mfc/reference/codesnippet/cpp/cwnd-class_62.cpp)]

##  <a name="showcaret"></a>  CWnd::ShowCaret

顯示插入號在畫面上插入號的目前位置。

```
void ShowCaret();
```

### <a name="remarks"></a>備註

顯示後，插入號會開始自動閃爍。

`ShowCaret`成員函式會顯示插入號只，是否它有目前的圖形，並不已隱藏兩個以上的時間連續。 如果插入號不屬於此視窗，將不會顯示插入號。

隱藏該插入號是累計的。 如果[HideCaret](#hidecaret)成員函式呼叫五次連續，`ShowCaret`必須呼叫五次顯示插入號。

插入號是共用的資源。 具有輸入的焦點或作用中時，只有視窗應該會顯示插入號。

### <a name="example"></a>範例

  範例，請參閱[CWnd::CreateCaret](#createcaret)。

##  <a name="showownedpopups"></a>  CWnd::ShowOwnedPopups

顯示或隱藏此視窗所擁有的所有快顯視窗。

```
void ShowOwnedPopups(BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*bShow*<br/>
指定是否要顯示或隱藏快顯視窗。 如果此參數為 TRUE 時，會顯示所有隱藏的快顯視窗。 如果此參數為 FALSE，則會隱藏所有可見的快顯視窗。

### <a name="example"></a>範例

  範例，請參閱[CWnd::SetWindowPos](#setwindowpos)。

##  <a name="showscrollbar"></a>  CWnd::ShowScrollBar

顯示或隱藏捲軸。

```
void ShowScrollBar(
    UINT nBar,
    BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲軸是否為控制項或視窗非工作區的一部分。 如果是中, 非工作區的一部分*nBar*也會指出是否捲軸置於水平、 垂直或兩者。 它必須是下列其中一項：

- SB_BOTH 指定水平和垂直捲軸的視窗。

- SB_HORZ 指定視窗為水平捲軸。

- SB_VERT 指定視窗的垂直捲軸。

*bShow*<br/>
指定 Windows 會顯示或隱藏捲軸。 如果此參數為 TRUE 時，會顯示捲軸;否則，系統會隱藏捲軸。

### <a name="remarks"></a>備註

應用程式不應該呼叫`ShowScrollBar`處理捲軸通知訊息時隱藏捲軸。

##  <a name="showwindow"></a>  CWnd::ShowWindow

設定視窗的可見性狀態。

```
BOOL ShowWindow(int nCmdShow);
```

### <a name="parameters"></a>參數

*nCmdShow*<br/>
指定如何`CWnd`顯示。 它必須是下列值之一：

- SW_HIDE 會隱藏此視窗，並將啟用傳遞至另一個視窗。

- SW_MINIMIZE 視窗最小化，並啟動系統的清單中的最上層視窗。

- SW_RESTORE 啟動並顯示視窗。 如果視窗是最小化或最大化，則 Windows 會將它還原至其原始大小和位置。

- SW_SHOW 啟動視窗並將它顯示在其目前的大小和位置。

- Sw_showmaximized 其中一個啟動的視窗，並顯示最大化視窗。

- SW_SHOWMINIMIZED 啟動視窗並將它顯示為圖示。

- SW_SHOWMINNOACTIVE 以圖示顯示視窗。 目前使用中視窗保持作用中。

- SW_SHOWNA 顯示視窗在其目前的狀態。 目前使用中視窗保持作用中。

- SW_SHOWNOACTIVATE 顯示視窗中的最新的大小和位置。 目前使用中視窗保持作用中。

- SW_SHOWNORMAL 啟動並顯示視窗。 如果視窗是最小化或最大化，則 Windows 會將它還原至其原始大小和位置。

### <a name="return-value"></a>傳回值

非零值，如果視窗是先前可見的。0`CWnd`之前隱藏。

### <a name="remarks"></a>備註

`ShowWindow` 必須呼叫每個應用程式的主視窗一次[CWinApp::m_nCmdShow](../../mfc/reference/cwinapp-class.md#m_ncmdshow)。 後續呼叫`ShowWindow`必須使用其中一種以上所列，而不是所指定的值`CWinApp::m_nCmdShow`。

### <a name="example"></a>範例

  範例，請參閱[CWnd::CalcWindowRect](#calcwindowrect)。

##  <a name="subclassdlgitem"></a>  CWnd::SubclassDlgItem

呼叫此成員函式，「 動態子類別化 」 從對話方塊範本建立的控制項，並將它附加至這個`CWnd`物件。

```
BOOL SubclassDlgItem(
    UINT nID,
    CWnd* pParent);
```

### <a name="parameters"></a>參數

*nID*<br/>
控制項的 id。

*pParent*<br/>
控制項的父代 （通常為對話方塊）。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

透過 windows 訊息動態子類別控制項時，將會路由傳送`CWnd`的訊息對應，並呼叫中的訊息處理常式`CWnd`第一次的類別。 傳遞至基底類別的訊息會傳遞至控制項中的預設訊息處理常式。

此成員函式會將附加至 Windows 控制項`CWnd`物件，並取代控制項的`WndProc`和`AfxWndProc`函式。 函式會儲存舊`WndProc`所傳回的位置中`GetSuperWndProcAddr`成員函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#122](../../mfc/reference/codesnippet/cpp/cwnd-class_63.cpp)]

##  <a name="subclasswindow"></a>  CWnd::SubclassWindow

呼叫此成員函式可 「 動態子類別 」 視窗，並將它附加至這個`CWnd`物件。

```
BOOL SubclassWindow(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
視窗的控制代碼。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

透過 windows 訊息動態子類別化視窗時，將會路由傳送`CWnd`的訊息對應，並呼叫中的訊息處理常式`CWnd`第一次的類別。 傳遞至基底類別的訊息會傳遞至視窗中的預設訊息處理常式。

此成員函式會將附加至 Windows 控制項`CWnd`物件，並取代視窗的`WndProc`和`AfxWndProc`函式。 函式會儲存一個指向舊`WndProc`在`CWnd`物件。

> [!NOTE]
> 視窗必須已附加 MFC 物件時呼叫此函式。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#123](../../mfc/reference/codesnippet/cpp/cwnd-class_64.cpp)]

##  <a name="unlockwindowupdate"></a>  CWnd::UnlockWindowUpdate

呼叫此成員函式，來解除鎖定鎖定已使用的視窗`CWnd::LockWindowUpdate`。

```
void UnlockWindowUpdate();
```

### <a name="remarks"></a>備註

可以使用鎖定一次只有一個視窗`LockWindowUpdate`。 請參閱[CWnd::LockWindowUpdate](#lockwindowupdate)或 Win32 函式[LockWindowUpdate](/windows/desktop/api/winuser/nf-winuser-lockwindowupdate)如需有關鎖定 windows。

##  <a name="unsubclasswindow"></a>  CWnd::UnsubclassWindow

呼叫此成員函式，來設定`WndProc`回到其原始值和中斷連結所來自的 HWND 識別視窗`CWnd`物件。

```
HWND UnsubclassWindow();
```

### <a name="return-value"></a>傳回值

Unsubclassed 視窗的控制代碼。

### <a name="example"></a>範例

  範例，請參閱[CWnd::SubclassWindow](#subclasswindow)。

##  <a name="updatedata"></a>  CWnd::UpdateData

呼叫此成員函式，來初始化對話方塊中中的資料，或是擷取並驗證對話方塊中的資料。

```
BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
```

### <a name="parameters"></a>參數

*bSaveAndValidate*<br/>
旗標，指出是否對話方塊 (FALSE) 正在初始化或資料擷取 (TRUE)。

### <a name="return-value"></a>傳回值

非零值，如果作業成功，否則為 0。 如果*bSaveAndValidat*e 是 TRUE，則傳回值為非零值，表示已成功驗證的資料。

### <a name="remarks"></a>備註

架構會自動呼叫`UpdateData`具有*bSaveAndValidate*設定為 FALSE 時的預設實作中建立強制回應對話方塊[CDialog::OnInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)。 對話方塊會顯示之前，就會發生在呼叫。 預設實作[CDialog::OnOK](../../mfc/reference/cdialog-class.md#onok)呼叫此成員函式*bSaveAndValidate*設成 TRUE 來擷取資料，以及如果成功，會關閉對話方塊。 （如果在對話方塊中按一下 [取消] 按鈕時，對話方塊會關閉而不所擷取的資料。）

##  <a name="updatedialogcontrols"></a>  CWnd::UpdateDialogControls

呼叫此成員函式更新對話方塊按鈕和對話方塊或使用的視窗中的其他控制項的狀態[ON_UPDATE_COMMAND_UI](message-map-macros-mfc.md#on_update_command_ui)回呼機制。

```
void UpdateDialogControls(
    CCmdTarget* pTarget,
    BOOL bDisableIfNoHndler);
```

### <a name="parameters"></a>參數

*pTarget*<br/>
指向 應用程式的主框架視窗，並用於路由更新訊息。

*bDisableIfNoHndler*<br/>
旗標，指出是否不有任何更新處理常式的控制項應該自動顯示為已停用。

### <a name="remarks"></a>備註

如果子控制項沒有處理常式和*bDisableIfNoHndler*為 TRUE 時，將會停用的子控制項。

架構會呼叫此成員函式對話方塊列或工具列中控制項的應用程式的一部分閒置處理。

##  <a name="updatelayeredwindow"></a>  CWnd::UpdateLayeredWindow

更新分層視窗的位置、大小、形狀、內容和透明度。

```
BOOL UpdateLayeredWindow(
    CDC* pDCDst,
    POINT* pptDst,
    SIZE* psize,
    CDC* pDCSrc,
    POINT* pptSrc,
    COLORREF crKey,
    BLENDFUNCTION* pblend,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*pDCDst*<br/>
螢幕裝置內容指標。 它會用於調色盤色彩比對視窗內容更新時。 如果*pDCDst*是 NULL，將使用預設調色盤。

如果*pDCSrc*為 NULL，就*pDCDst*必須是 NULL。

*pptDst*<br/>
指標`POINT`結構，指定的分層視窗的新螢幕位置。 如果目前的位置不會變更， *pptDst*可以是 NULL。

*psize*<br/>
指標`SIZE`結構，指定新的分層視窗的大小。 如果未變更視窗的大小，請*psize*可以是 NULL。

如果*pDCSrc*為 NULL，就*psize*必須是 NULL。

*pDCSrc*<br/>
DC，定義層疊的視窗的介面指標。 如果未變更的圖形和視覺內容視窗，請*pDCSrc*可以是 NULL。

*pptSrc*<br/>
指標`POINT`結構，指定在裝置內容中的圖層的位置。

如果*pDCSrc*為 NULL，就*pptSrc*應該是 NULL。

*crKey*<br/>
指定透明色彩索引鍵，用於當您在撰寫分層的視窗 COLORREF 值指標。 以此種色彩視窗所繪製的所有像素會是透明的。 若要產生 COLORREF，使用 RGB 巨集。

*pblend*<br/>
指標[BLENDFUNCTION](/windows/desktop/api/wingdi/ns-wingdi-_blendfunction)結構，指定撰寫分層的視窗時要使用的透明度值。

*dwFlags*<br/>
指定要採取的動作。 這個參數可以是下列一或多個下列的值。 如需可能值的清單，請參閱 < [UpdateLayeredWindow](/windows/desktop/api/winuser/nf-winuser-updatelayeredwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函式模擬函式的功能[UpdateLayeredWindow](/windows/desktop/api/winuser/nf-winuser-updatelayeredwindow)、 Windows SDK 中所述。

##  <a name="updatewindow"></a>  CWnd::UpdateWindow

更新工作區，藉由傳送[WM_PAINT](/windows/desktop/gdi/wm-paint)訊息若不是空的更新區域。

```
void UpdateWindow();
```

### <a name="remarks"></a>備註

`UpdateWindow`成員函式會傳送 WM_PAINT 訊息直接略過應用程式佇列。 如果更新區域是空的不會傳送 WM_PAINT。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#124](../../mfc/reference/codesnippet/cpp/cwnd-class_65.cpp)]

##  <a name="validaterect"></a>  CWnd::ValidateRect

移除 [] 視窗中的更新區域的矩形，驗證給定矩形內的工作區。

```
void ValidateRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/desktop/api/windef/ns-windef-tagrect)，其中包含從更新區域中移除矩形的用戶端座標。 如果*lpRect*是 NULL，在驗證完整的視窗。

### <a name="remarks"></a>備註

[BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 既不`ValidateRect`也[ValidateRgn](#validatergn)應該呼叫成員函式，如果更新區域的一部分需要之前先驗證[WM_PAINT](/windows/desktop/gdi/wm-paint)下次產生。

Windows 會繼續產生 WM_PAINT 訊息，直到目前的更新區域會進行驗證。

##  <a name="validatergn"></a>  CWnd::ValidateRgn

移除目前的更新區域，視窗的區域，驗證給定區域內的工作區。

```
void ValidateRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
指標[CRgn](../../mfc/reference/crgn-class.md)物件，識別定義要移除的更新區域的區域的區域。 如果此參數為 NULL，則會移除整個工作區。

### <a name="remarks"></a>備註

指定的區域必須事先建立區域函式。 區域座標會假設為用戶端座標。

[BeginPaint](#beginpaint)成員函式會自動驗證整個工作區。 既不[ValidateRect](#validaterect)和`ValidateRgn`應該呼叫成員函式，如果必須在下一步 之前進行驗證的更新區域一部分[WM_PAINT](/windows/desktop/gdi/wm-paint)會產生訊息。

##  <a name="windowfrompoint"></a>  CWnd::WindowFromPoint

擷取視窗，其中包含指定的點;*點*必須在螢幕上指定的點螢幕座標。

```
static CWnd* PASCAL WindowFromPoint(POINT point);
```

### <a name="parameters"></a>參數

*point*<br/>
指定[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[點](/windows/desktop/api/windef/ns-windef-tagpoint)資料結構，定義要檢查點。

### <a name="return-value"></a>傳回值

重點在於視窗物件的指標。 如果沒有保留時間存在在指定的時間點，它就會是 NULL。 傳回的指標可能是暫時性的不應該儲存供稍後使用。

### <a name="remarks"></a>備註

`WindowFromPoint` 不會擷取隱藏或停用 視窗中，即使是在視窗內的點。 應用程式應該使用[ChildWindowFromPoint](#childwindowfrompoint)限制性的搜尋的成員函式。

##  <a name="windowproc"></a>  CWnd::WindowProc

提供 Windows 程序 ( `WindowProc`) 的`CWnd`物件。

```
virtual LRESULT WindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理 Windows 訊息。

*wParam*<br/>
提供用於處理訊息的其他資訊。 參數值取決於訊息。

*lParam*<br/>
提供用於處理訊息的其他資訊。 參數值取決於訊息。

### <a name="return-value"></a>傳回值

傳回的值取決於訊息。

### <a name="remarks"></a>備註

它會將訊息透過視窗的訊息對應的分派。

##  <a name="winhelp"></a>  CWnd::WinHelp

呼叫以初始化 WinHelp 應用程式。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他資料。 所使用的值而定的值*nCmd*參數。

*nCmd*<br/>
指定要求的說明類型。 如需可能的值，以及它們如何影響*dwData*參數，請參閱[WinHelp](/windows/desktop/api/winuser/nf-winuser-winhelpa) Windows SDK 中的 Windows 函式。

### <a name="remarks"></a>備註

請參閱[CWinApp::WinHelp](../../mfc/reference/cwinapp-class.md#winhelp)如需詳細資訊。

##  <a name="registertouchwindow"></a>  CWnd::RegisterTouchWindow

註冊或取消註冊 Windows 觸控支援。

```
BOOL RegisterTouchWindow(
    BOOL bRegister = TRUE,
    ULONG ulFlags = 0);
```

### <a name="parameters"></a>參數

*bRegister*<br/>
TRUE 表示註冊 Windows 觸控支援;FALSE 否則。

*ulFlags*<br/>
一組的位元旗標，指定選擇性的修改。 此欄位可能包含 0 或下列值之一：TWF_FINETOUCH TWF_WANTPALM。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

##  <a name="resizedynamiclayout"></a>  CWnd::ResizeDynamicLayout

如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。

```
virtual void ResizeDynamicLayout();
```

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[CCmdTarget 類別](../../mfc/reference/ccmdtarget-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[CFrameWnd 類別](../../mfc/reference/cframewnd-class.md)<br/>
[CView 類別](../../mfc/reference/cview-class.md)
