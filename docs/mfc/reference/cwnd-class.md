---
title: CWnd 類別
ms.date: 11/19/2018
f1_keywords:
- CWnd
- AFXWIN/CWnd
- AFXWIN/CWnd::CWnd
- AFXWIN/CWnd::accDoDefaultAction
- AFXWIN/CWnd::accHitTest
- AFXWIN/CWnd::accLocation
- AFXWIN/CWnd::accNavigate
- AFXWIN/CWnd::accSelect
- AFXWIN/CWnd::AnimateWindow
- AFXWIN/CWnd::ArrangeIconicWindows
- AFXWIN/CWnd::Attach
- AFXWIN/CWnd::BeginModalState
- AFXWIN/CWnd::BeginPaint
- AFXWIN/CWnd::BindDefaultProperty
- AFXWIN/CWnd::BindProperty
- AFXWIN/CWnd::BringWindowToTop
- AFXWIN/CWnd::CalcWindowRect
- AFXWIN/CWnd::CancelToolTips
- AFXWIN/CWnd::CenterWindow
- AFXWIN/CWnd::ChangeClipboardChain
- AFXWIN/CWnd::CheckDlgButton
- AFXWIN/CWnd::CheckRadioButton
- AFXWIN/CWnd::ChildWindowFromPoint
- AFXWIN/CWnd::ClientToScreen
- AFXWIN/CWnd::CloseWindow
- AFXWIN/CWnd::ContinueModal
- AFXWIN/CWnd::Create
- AFXWIN/CWnd::CreateAccessibleProxy
- AFXWIN/CWnd::CreateCaret
- AFXWIN/CWnd::CreateControl
- AFXWIN/CWnd::CreateEx
- AFXWIN/CWnd::CreateGrayCaret
- AFXWIN/CWnd::CreateSolidCaret
- AFXWIN/CWnd::DeleteTempMap
- AFXWIN/CWnd::DestroyWindow
- AFXWIN/CWnd::Detach
- AFXWIN/CWnd::DlgDirList
- AFXWIN/CWnd::DlgDirListComboBox
- AFXWIN/CWnd::DlgDirSelect
- AFXWIN/CWnd::DlgDirSelectComboBox
- AFXWIN/CWnd::DragAcceptFiles
- AFXWIN/CWnd::DragDetect
- AFXWIN/CWnd::DrawAnimatedRects
- AFXWIN/CWnd::DrawCaption
- AFXWIN/CWnd::DrawMenuBar
- AFXWIN/CWnd::EnableActiveAccessibility
- AFXWIN/CWnd::EnableDynamicLayout
- AFXWIN/CWnd::EnableD2DSupport
- AFXWIN/CWnd::EnableScrollBar
- AFXWIN/CWnd::EnableScrollBarCtrl
- AFXWIN/CWnd::EnableToolTips
- AFXWIN/CWnd::EnableTrackingToolTips
- AFXWIN/CWnd::EnableWindow
- AFXWIN/CWnd::EndModalLoop
- AFXWIN/CWnd::EndModalState
- AFXWIN/CWnd::EndPaint
- AFXWIN/CWnd::ExecuteDlgInit
- AFXWIN/CWnd::FilterToolTipMessage
- AFXWIN/CWnd::FindWindow
- AFXWIN/CWnd::FindWindowEx
- AFXWIN/CWnd::FlashWindow
- AFXWIN/CWnd::FlashWindowEx
- AFXWIN/CWnd::FromHandle
- AFXWIN/CWnd::FromHandlePermanent
- AFXWIN/CWnd::get_accChild
- AFXWIN/CWnd::get_accChildCount
- AFXWIN/CWnd::get_accDefaultAction
- AFXWIN/CWnd::get_accDescription
- AFXWIN/CWnd::get_accFocus
- AFXWIN/CWnd::get_accHelp
- AFXWIN/CWnd::get_accHelpTopic
- AFXWIN/CWnd::get_accKeyboardShortcut
- AFXWIN/CWnd::get_accName
- AFXWIN/CWnd::get_accParent
- AFXWIN/CWnd::get_accRole
- AFXWIN/CWnd::get_accSelection
- AFXWIN/CWnd::get_accState
- AFXWIN/CWnd::get_accValue
- AFXWIN/CWnd::GetActiveWindow
- AFXWIN/CWnd::GetAncestor
- AFXWIN/CWnd::GetCapture
- AFXWIN/CWnd::GetCaretPos
- AFXWIN/CWnd::GetCheckedRadioButton
- AFXWIN/CWnd::GetClientRect
- AFXWIN/CWnd::GetClipboardOwner
- AFXWIN/CWnd::GetClipboardViewer
- AFXWIN/CWnd::GetControlUnknown
- AFXWIN/CWnd::GetDC
- AFXWIN/CWnd::GetDCEx
- AFXWIN/CWnd::GetDCRenderTarget
- AFXWIN/CWnd::GetDescendantWindow
- AFXWIN/CWnd::GetDesktopWindow
- AFXWIN/CWnd::GetDlgCtrlID
- AFXWIN/CWnd::GetDlgItem
- AFXWIN/CWnd::GetDlgItemInt
- AFXWIN/CWnd::GetDlgItemText
- AFXWIN/CWnd::GetDSCCursor
- AFXWIN/CWnd::GetDynamicLayout
- AFXWIN/CWnd::GetExStyle
- AFXWIN/CWnd::GetFocus
- AFXWIN/CWnd::GetFont
- AFXWIN/CWnd::GetForegroundWindow
- AFXWIN/CWnd::GetIcon
- AFXWIN/CWnd::GetLastActivePopup
- AFXWIN/CWnd::GetLayeredWindowAttributes
- AFXWIN/CWnd::GetMenu
- AFXWIN/CWnd::GetNextDlgGroupItem
- AFXWIN/CWnd::GetNextDlgTabItem
- AFXWIN/CWnd::GetNextWindow
- AFXWIN/CWnd::GetOleControlSite
- AFXWIN/CWnd::GetOpenClipboardWindow
- AFXWIN/CWnd::GetOwner
- AFXWIN/CWnd::GetParent
- AFXWIN/CWnd::GetParentFrame
- AFXWIN/CWnd::GetParentOwner
- AFXWIN/CWnd::GetProperty
- AFXWIN/CWnd::GetRenderTarget
- AFXWIN/CWnd::GetSafeHwnd
- AFXWIN/CWnd::GetSafeOwner
- AFXWIN/CWnd::GetScrollBarCtrl
- AFXWIN/CWnd::GetScrollBarInfo
- AFXWIN/CWnd::GetScrollInfo
- AFXWIN/CWnd::GetScrollLimit
- AFXWIN/CWnd::GetScrollPos
- AFXWIN/CWnd::GetScrollRange
- AFXWIN/CWnd::GetStyle
- AFXWIN/CWnd::GetSystemMenu
- AFXWIN/CWnd::GetTitleBarInfo
- AFXWIN/CWnd::GetTopLevelFrame
- AFXWIN/CWnd::GetTopLevelOwner
- AFXWIN/CWnd::GetTopLevelParent
- AFXWIN/CWnd::GetTopWindow
- AFXWIN/CWnd::GetUpdateRect
- AFXWIN/CWnd::GetUpdateRgn
- AFXWIN/CWnd::GetWindow
- AFXWIN/CWnd::GetWindowContextHelpId
- AFXWIN/CWnd::GetWindowDC
- AFXWIN/CWnd::GetWindowedChildCount
- AFXWIN/CWnd::GetWindowInfo
- AFXWIN/CWnd::GetWindowlessChildCount
- AFXWIN/CWnd::GetWindowPlacement
- AFXWIN/CWnd::GetWindowRect
- AFXWIN/CWnd::GetWindowRgn
- AFXWIN/CWnd::GetWindowText
- AFXWIN/CWnd::GetWindowTextLength
- AFXWIN/CWnd::HideCaret
- AFXWIN/CWnd::HiliteMenuItem
- AFXWIN/CWnd::HtmlHelp
- AFXWIN/CWnd::Invalidate
- AFXWIN/CWnd::InvalidateRect
- AFXWIN/CWnd::InvalidateRgn
- AFXWIN/CWnd::InvokeHelper
- AFXWIN/CWnd::IsChild
- AFXWIN/CWnd::IsD2DSupportEnabled
- AFXWIN/CWnd::IsDialogMessage
- AFXWIN/CWnd::IsDlgButtonChecked
- AFXWIN/CWnd::IsDynamicLayoutEnabled
- AFXWIN/CWnd::IsIconic
- AFXWIN/CWnd::IsTouchWindow
- AFXWIN/CWnd::IsWindowEnabled
- AFXWIN/CWnd::IsWindowVisible
- AFXWIN/CWnd::IsZoomed
- AFXWIN/CWnd::KillTimer
- AFXWIN/CWnd::LockWindowUpdate
- AFXWIN/CWnd::MapWindowPoints
- AFXWIN/CWnd::MessageBox
- AFXWIN/CWnd::ModifyStyle
- AFXWIN/CWnd::ModifyStyleEx
- AFXWIN/CWnd::MoveWindow
- AFXWIN/CWnd::NotifyWinEvent
- AFXWIN/CWnd::OnAmbientProperty
- AFXWIN/CWnd::OnDrawIconicThumbnailOrLivePreview
- AFXWIN/CWnd::OnHelp
- AFXWIN/CWnd::OnHelpFinder
- AFXWIN/CWnd::OnHelpIndex
- AFXWIN/CWnd::OnHelpUsing
- AFXWIN/CWnd::OnToolHitTest
- AFXWIN/CWnd::OpenClipboard
- AFXWIN/CWnd::PaintWindowlessControls
- AFXWIN/CWnd::PostMessage
- AFXWIN/CWnd::PreCreateWindow
- AFXWIN/CWnd::PreSubclassWindow
- AFXWIN/CWnd::PreTranslateMessage
- AFXWIN/CWnd::Print
- AFXWIN/CWnd::PrintClient
- AFXWIN/CWnd::PrintWindow
- AFXWIN/CWnd::RedrawWindow
- AFXWIN/CWnd::RegisterTouchWindow
- AFXWIN/CWnd::ReleaseDC
- AFXWIN/CWnd::RepositionBars
- AFXWIN/CWnd::RunModalLoop
- AFXWIN/CWnd::ScreenToClient
- AFXWIN/CWnd::ScrollWindow
- AFXWIN/CWnd::ScrollWindowEx
- AFXWIN/CWnd::SendChildNotifyLastMsg
- AFXWIN/CWnd::SendDlgItemMessage
- AFXWIN/CWnd::SendMessage
- AFXWIN/CWnd::SendMessageToDescendants
- AFXWIN/CWnd::SendNotifyMessage
- AFXWIN/CWnd::SetActiveWindow
- AFXWIN/CWnd::SetCapture
- AFXWIN/CWnd::SetCaretPos
- AFXWIN/CWnd::SetClipboardViewer
- AFXWIN/CWnd::SetDlgCtrlID
- AFXWIN/CWnd::SetDlgItemInt
- AFXWIN/CWnd::SetDlgItemText
- AFXWIN/CWnd::SetFocus
- AFXWIN/CWnd::SetFont
- AFXWIN/CWnd::SetForegroundWindow
- AFXWIN/CWnd::SetIcon
- AFXWIN/CWnd::SetLayeredWindowAttributes
- AFXWIN/CWnd::SetMenu
- AFXWIN/CWnd::SetOwner
- AFXWIN/CWnd::SetParent
- AFXWIN/CWnd::SetProperty
- AFXWIN/CWnd::SetRedraw
- AFXWIN/CWnd::SetScrollInfo
- AFXWIN/CWnd::SetScrollPos
- AFXWIN/CWnd::SetScrollRange
- AFXWIN/CWnd::SetTimer
- AFXWIN/CWnd::SetWindowContextHelpId
- AFXWIN/CWnd::SetWindowPlacement
- AFXWIN/CWnd::SetWindowPos
- AFXWIN/CWnd::SetWindowRgn
- AFXWIN/CWnd::SetWindowText
- AFXWIN/CWnd::ShowCaret
- AFXWIN/CWnd::ShowOwnedPopups
- AFXWIN/CWnd::ShowScrollBar
- AFXWIN/CWnd::ShowWindow
- AFXWIN/CWnd::SubclassDlgItem
- AFXWIN/CWnd::SubclassWindow
- AFXWIN/CWnd::UnlockWindowUpdate
- AFXWIN/CWnd::UnsubclassWindow
- AFXWIN/CWnd::UpdateData
- AFXWIN/CWnd::UpdateDialogControls
- AFXWIN/CWnd::UpdateLayeredWindow
- AFXWIN/CWnd::UpdateWindow
- AFXWIN/CWnd::ValidateRect
- AFXWIN/CWnd::ValidateRgn
- AFXWIN/CWnd::WindowFromPoint
- AFXWIN/CWnd::WinHelp
- AFXWIN/CWnd::Default
- AFXWIN/CWnd::DefWindowProc
- AFXWIN/CWnd::DoDataExchange
- AFXWIN/CWnd::GetCurrentMessage
- AFXWIN/CWnd::InitDynamicLayout
- AFXWIN/CWnd::LoadDynamicLayoutResource
- AFXWIN/CWnd::OnActivate
- AFXWIN/CWnd::OnActivateApp
- AFXWIN/CWnd::OnAppCommand
- AFXWIN/CWnd::OnAskCbFormatName
- AFXWIN/CWnd::OnCancelMode
- AFXWIN/CWnd::OnCaptureChanged
- AFXWIN/CWnd::OnChangeCbChain
- AFXWIN/CWnd::OnChangeUIState
- AFXWIN/CWnd::OnChar
- AFXWIN/CWnd::OnCharToItem
- AFXWIN/CWnd::OnChildActivate
- AFXWIN/CWnd::OnChildNotify
- AFXWIN/CWnd::OnClipboardUpdate
- AFXWIN/CWnd::OnClose
- AFXWIN/CWnd::OnColorizationColorChanged
- AFXWIN/CWnd::OnCommand
- AFXWIN/CWnd::OnCompacting
- AFXWIN/CWnd::OnCompareItem
- AFXWIN/CWnd::OnCompositionChanged
- AFXWIN/CWnd::OnContextMenu
- AFXWIN/CWnd::OnCopyData
- AFXWIN/CWnd::OnCreate
- AFXWIN/CWnd::OnCtlColor
- AFXWIN/CWnd::OnDeadChar
- AFXWIN/CWnd::OnDeleteItem
- AFXWIN/CWnd::OnDestroy
- AFXWIN/CWnd::OnDestroyClipboard
- AFXWIN/CWnd::OnDeviceChange
- AFXWIN/CWnd::OnDevModeChange
- AFXWIN/CWnd::OnDrawClipboard
- AFXWIN/CWnd::OnDrawItem
- AFXWIN/CWnd::OnDropFiles
- AFXWIN/CWnd::OnEnable
- AFXWIN/CWnd::OnEndSession
- AFXWIN/CWnd::OnEnterIdle
- AFXWIN/CWnd::OnEnterMenuLoop
- AFXWIN/CWnd::OnEnterSizeMove
- AFXWIN/CWnd::OnEraseBkgnd
- AFXWIN/CWnd::OnExitMenuLoop
- AFXWIN/CWnd::OnExitSizeMove
- AFXWIN/CWnd::OnFontChange
- AFXWIN/CWnd::OnGetDlgCode
- AFXWIN/CWnd::OnGetMinMaxInfo
- AFXWIN/CWnd::OnHelpInfo
- AFXWIN/CWnd::OnHotKey
- AFXWIN/CWnd::OnHScroll
- AFXWIN/CWnd::OnHScrollClipboard
- AFXWIN/CWnd::OnIconEraseBkgnd
- AFXWIN/CWnd::OnInitMenu
- AFXWIN/CWnd::OnInitMenuPopup
- AFXWIN/CWnd::OnInputDeviceChange
- AFXWIN/CWnd::OnInputLangChange
- AFXWIN/CWnd::OnInputLangChangeRequest
- AFXWIN/CWnd::OnKeyDown
- AFXWIN/CWnd::OnKeyUp
- AFXWIN/CWnd::OnKillFocus
- AFXWIN/CWnd::OnLButtonDblClk
- AFXWIN/CWnd::OnLButtonDown
- AFXWIN/CWnd::OnLButtonUp
- AFXWIN/CWnd::OnMButtonDblClk
- AFXWIN/CWnd::OnMButtonDown
- AFXWIN/CWnd::OnMButtonUp
- AFXWIN/CWnd::OnMDIActivate
- AFXWIN/CWnd::OnMeasureItem
- AFXWIN/CWnd::OnMenuChar
- AFXWIN/CWnd::OnMenuDrag
- AFXWIN/CWnd::OnMenuGetObject
- AFXWIN/CWnd::OnMenuRButtonUp
- AFXWIN/CWnd::OnMenuSelect
- AFXWIN/CWnd::OnMouseActivate
- AFXWIN/CWnd::OnMouseHover
- AFXWIN/CWnd::OnMouseHWheel
- AFXWIN/CWnd::OnMouseLeave
- AFXWIN/CWnd::OnMouseMove
- AFXWIN/CWnd::OnMouseWheel
- AFXWIN/CWnd::OnMove
- AFXWIN/CWnd::OnMoving
- AFXWIN/CWnd::OnNcActivate
- AFXWIN/CWnd::OnNcCalcSize
- AFXWIN/CWnd::OnNcCreate
- AFXWIN/CWnd::OnNcDestroy
- AFXWIN/CWnd::OnNcHitTest
- AFXWIN/CWnd::OnNcLButtonDblClk
- AFXWIN/CWnd::OnNcLButtonDown
- AFXWIN/CWnd::OnNcLButtonUp
- AFXWIN/CWnd::OnNcMButtonDblClk
- AFXWIN/CWnd::OnNcMButtonDown
- AFXWIN/CWnd::OnNcMButtonUp
- AFXWIN/CWnd::OnNcMouseHover
- AFXWIN/CWnd::OnNcMouseLeave
- AFXWIN/CWnd::OnNcMouseMove
- AFXWIN/CWnd::OnNcPaint
- AFXWIN/CWnd::OnNcRButtonDblClk
- AFXWIN/CWnd::OnNcRButtonDown
- AFXWIN/CWnd::OnNcRButtonUp
- AFXWIN/CWnd::OnNcRenderingChanged
- AFXWIN/CWnd::OnNcXButtonDblClk
- AFXWIN/CWnd::OnNcXButtonDown
- AFXWIN/CWnd::OnNcXButtonUp
- AFXWIN/CWnd::OnNextMenu
- AFXWIN/CWnd::OnNotify
- AFXWIN/CWnd::OnNotifyFormat
- AFXWIN/CWnd::OnPaint
- AFXWIN/CWnd::OnPaintClipboard
- AFXWIN/CWnd::OnPaletteChanged
- AFXWIN/CWnd::OnPaletteIsChanging
- AFXWIN/CWnd::OnParentNotify
- AFXWIN/CWnd::OnPowerBroadcast
- AFXWIN/CWnd::OnQueryDragIcon
- AFXWIN/CWnd::OnQueryEndSession
- AFXWIN/CWnd::OnQueryNewPalette
- AFXWIN/CWnd::OnQueryOpen
- AFXWIN/CWnd::OnQueryUIState
- AFXWIN/CWnd::OnRawInput
- AFXWIN/CWnd::OnRButtonDblClk
- AFXWIN/CWnd::OnRButtonDown
- AFXWIN/CWnd::OnRButtonUp
- AFXWIN/CWnd::OnRenderAllFormats
- AFXWIN/CWnd::OnRenderFormat
- AFXWIN/CWnd::OnSessionChange
- AFXWIN/CWnd::OnSetCursor
- AFXWIN/CWnd::OnSetFocus
- AFXWIN/CWnd::OnSettingChange
- AFXWIN/CWnd::OnShowWindow
- AFXWIN/CWnd::OnSize
- AFXWIN/CWnd::OnSizeClipboard
- AFXWIN/CWnd::OnSizing
- AFXWIN/CWnd::OnSpoolerStatus
- AFXWIN/CWnd::OnStyleChanged
- AFXWIN/CWnd::OnStyleChanging
- AFXWIN/CWnd::OnSysChar
- AFXWIN/CWnd::OnSysColorChange
- AFXWIN/CWnd::OnSysCommand
- AFXWIN/CWnd::OnSysDeadChar
- AFXWIN/CWnd::OnSysKeyDown
- AFXWIN/CWnd::OnSysKeyUp
- AFXWIN/CWnd::OnTCard
- AFXWIN/CWnd::OnTimeChange
- AFXWIN/CWnd::OnTimer
- AFXWIN/CWnd::OnTouchInput
- AFXWIN/CWnd::OnTouchInputs
- AFXWIN/CWnd::OnUniChar
- AFXWIN/CWnd::OnUnInitMenuPopup
- AFXWIN/CWnd::OnUpdateUIState
- AFXWIN/CWnd::OnUserChanged
- AFXWIN/CWnd::OnVKeyToItem
- AFXWIN/CWnd::OnVScroll
- AFXWIN/CWnd::OnVScrollClipboard
- AFXWIN/CWnd::OnWindowPosChanged
- AFXWIN/CWnd::OnWindowPosChanging
- AFXWIN/CWnd::OnWinIniChange
- AFXWIN/CWnd::OnWndMsg
- AFXWIN/CWnd::OnXButtonDblClk
- AFXWIN/CWnd::OnXButtonDown
- AFXWIN/CWnd::OnXButtonUp
- AFXWIN/CWnd::PostNcDestroy
- AFXWIN/CWnd::ReflectChildNotify
- AFXWIN/CWnd::ReflectLastMsg
- AFXWIN/CWnd::ResizeDynamicLayout
- AFXWIN/CWnd::WindowProc
- AFXWIN/CWnd::m_hWnd
helpviewer_keywords:
- CWnd [MFC], CWnd
- CWnd [MFC], accDoDefaultAction
- CWnd [MFC], accHitTest
- CWnd [MFC], accLocation
- CWnd [MFC], accNavigate
- CWnd [MFC], accSelect
- CWnd [MFC], AnimateWindow
- CWnd [MFC], ArrangeIconicWindows
- CWnd [MFC], Attach
- CWnd [MFC], BeginModalState
- CWnd [MFC], BeginPaint
- CWnd [MFC], BindDefaultProperty
- CWnd [MFC], BindProperty
- CWnd [MFC], BringWindowToTop
- CWnd [MFC], CalcWindowRect
- CWnd [MFC], CancelToolTips
- CWnd [MFC], CenterWindow
- CWnd [MFC], ChangeClipboardChain
- CWnd [MFC], CheckDlgButton
- CWnd [MFC], CheckRadioButton
- CWnd [MFC], ChildWindowFromPoint
- CWnd [MFC], ClientToScreen
- CWnd [MFC], CloseWindow
- CWnd [MFC], ContinueModal
- CWnd [MFC], Create
- CWnd [MFC], CreateAccessibleProxy
- CWnd [MFC], CreateCaret
- CWnd [MFC], CreateControl
- CWnd [MFC], CreateEx
- CWnd [MFC], CreateGrayCaret
- CWnd [MFC], CreateSolidCaret
- CWnd [MFC], DeleteTempMap
- CWnd [MFC], DestroyWindow
- CWnd [MFC], Detach
- CWnd [MFC], DlgDirList
- CWnd [MFC], DlgDirListComboBox
- CWnd [MFC], DlgDirSelect
- CWnd [MFC], DlgDirSelectComboBox
- CWnd [MFC], DragAcceptFiles
- CWnd [MFC], DragDetect
- CWnd [MFC], DrawAnimatedRects
- CWnd [MFC], DrawCaption
- CWnd [MFC], DrawMenuBar
- CWnd [MFC], EnableActiveAccessibility
- CWnd [MFC], EnableDynamicLayout
- CWnd [MFC], EnableD2DSupport
- CWnd [MFC], EnableScrollBar
- CWnd [MFC], EnableScrollBarCtrl
- CWnd [MFC], EnableToolTips
- CWnd [MFC], EnableTrackingToolTips
- CWnd [MFC], EnableWindow
- CWnd [MFC], EndModalLoop
- CWnd [MFC], EndModalState
- CWnd [MFC], EndPaint
- CWnd [MFC], ExecuteDlgInit
- CWnd [MFC], FilterToolTipMessage
- CWnd [MFC], FindWindow
- CWnd [MFC], FindWindowEx
- CWnd [MFC], FlashWindow
- CWnd [MFC], FlashWindowEx
- CWnd [MFC], FromHandle
- CWnd [MFC], FromHandlePermanent
- CWnd [MFC], get_accChild
- CWnd [MFC], get_accChildCount
- CWnd [MFC], get_accDefaultAction
- CWnd [MFC], get_accDescription
- CWnd [MFC], get_accFocus
- CWnd [MFC], get_accHelp
- CWnd [MFC], get_accHelpTopic
- CWnd [MFC], get_accKeyboardShortcut
- CWnd [MFC], get_accName
- CWnd [MFC], get_accParent
- CWnd [MFC], get_accRole
- CWnd [MFC], get_accSelection
- CWnd [MFC], get_accState
- CWnd [MFC], get_accValue
- CWnd [MFC], GetActiveWindow
- CWnd [MFC], GetAncestor
- CWnd [MFC], GetCapture
- CWnd [MFC], GetCaretPos
- CWnd [MFC], GetCheckedRadioButton
- CWnd [MFC], GetClientRect
- CWnd [MFC], GetClipboardOwner
- CWnd [MFC], GetClipboardViewer
- CWnd [MFC], GetControlUnknown
- CWnd [MFC], GetDC
- CWnd [MFC], GetDCEx
- CWnd [MFC], GetDCRenderTarget
- CWnd [MFC], GetDescendantWindow
- CWnd [MFC], GetDesktopWindow
- CWnd [MFC], GetDlgCtrlID
- CWnd [MFC], GetDlgItem
- CWnd [MFC], GetDlgItemInt
- CWnd [MFC], GetDlgItemText
- CWnd [MFC], GetDSCCursor
- CWnd [MFC], GetDynamicLayout
- CWnd [MFC], GetExStyle
- CWnd [MFC], GetFocus
- CWnd [MFC], GetFont
- CWnd [MFC], GetForegroundWindow
- CWnd [MFC], GetIcon
- CWnd [MFC], GetLastActivePopup
- CWnd [MFC], GetLayeredWindowAttributes
- CWnd [MFC], GetMenu
- CWnd [MFC], GetNextDlgGroupItem
- CWnd [MFC], GetNextDlgTabItem
- CWnd [MFC], GetNextWindow
- CWnd [MFC], GetOleControlSite
- CWnd [MFC], GetOpenClipboardWindow
- CWnd [MFC], GetOwner
- CWnd [MFC], GetParent
- CWnd [MFC], GetParentFrame
- CWnd [MFC], GetParentOwner
- CWnd [MFC], GetProperty
- CWnd [MFC], GetRenderTarget
- CWnd [MFC], GetSafeHwnd
- CWnd [MFC], GetSafeOwner
- CWnd [MFC], GetScrollBarCtrl
- CWnd [MFC], GetScrollBarInfo
- CWnd [MFC], GetScrollInfo
- CWnd [MFC], GetScrollLimit
- CWnd [MFC], GetScrollPos
- CWnd [MFC], GetScrollRange
- CWnd [MFC], GetStyle
- CWnd [MFC], GetSystemMenu
- CWnd [MFC], GetTitleBarInfo
- CWnd [MFC], GetTopLevelFrame
- CWnd [MFC], GetTopLevelOwner
- CWnd [MFC], GetTopLevelParent
- CWnd [MFC], GetTopWindow
- CWnd [MFC], GetUpdateRect
- CWnd [MFC], GetUpdateRgn
- CWnd [MFC], GetWindow
- CWnd [MFC], GetWindowContextHelpId
- CWnd [MFC], GetWindowDC
- CWnd [MFC], GetWindowedChildCount
- CWnd [MFC], GetWindowInfo
- CWnd [MFC], GetWindowlessChildCount
- CWnd [MFC], GetWindowPlacement
- CWnd [MFC], GetWindowRect
- CWnd [MFC], GetWindowRgn
- CWnd [MFC], GetWindowText
- CWnd [MFC], GetWindowTextLength
- CWnd [MFC], HideCaret
- CWnd [MFC], HiliteMenuItem
- CWnd [MFC], HtmlHelp
- CWnd [MFC], Invalidate
- CWnd [MFC], InvalidateRect
- CWnd [MFC], InvalidateRgn
- CWnd [MFC], InvokeHelper
- CWnd [MFC], IsChild
- CWnd [MFC], IsD2DSupportEnabled
- CWnd [MFC], IsDialogMessage
- CWnd [MFC], IsDlgButtonChecked
- CWnd [MFC], IsDynamicLayoutEnabled
- CWnd [MFC], IsIconic
- CWnd [MFC], IsTouchWindow
- CWnd [MFC], IsWindowEnabled
- CWnd [MFC], IsWindowVisible
- CWnd [MFC], IsZoomed
- CWnd [MFC], KillTimer
- CWnd [MFC], LockWindowUpdate
- CWnd [MFC], MapWindowPoints
- CWnd [MFC], MessageBox
- CWnd [MFC], ModifyStyle
- CWnd [MFC], ModifyStyleEx
- CWnd [MFC], MoveWindow
- CWnd [MFC], NotifyWinEvent
- CWnd [MFC], OnAmbientProperty
- CWnd [MFC], OnDrawIconicThumbnailOrLivePreview
- CWnd [MFC], OnHelp
- CWnd [MFC], OnHelpFinder
- CWnd [MFC], OnHelpIndex
- CWnd [MFC], OnHelpUsing
- CWnd [MFC], OnToolHitTest
- CWnd [MFC], OpenClipboard
- CWnd [MFC], PaintWindowlessControls
- CWnd [MFC], PostMessage
- CWnd [MFC], PreCreateWindow
- CWnd [MFC], PreSubclassWindow
- CWnd [MFC], PreTranslateMessage
- CWnd [MFC], Print
- CWnd [MFC], PrintClient
- CWnd [MFC], PrintWindow
- CWnd [MFC], RedrawWindow
- CWnd [MFC], RegisterTouchWindow
- CWnd [MFC], ReleaseDC
- CWnd [MFC], RepositionBars
- CWnd [MFC], RunModalLoop
- CWnd [MFC], ScreenToClient
- CWnd [MFC], ScrollWindow
- CWnd [MFC], ScrollWindowEx
- CWnd [MFC], SendChildNotifyLastMsg
- CWnd [MFC], SendDlgItemMessage
- CWnd [MFC], SendMessage
- CWnd [MFC], SendMessageToDescendants
- CWnd [MFC], SendNotifyMessage
- CWnd [MFC], SetActiveWindow
- CWnd [MFC], SetCapture
- CWnd [MFC], SetCaretPos
- CWnd [MFC], SetClipboardViewer
- CWnd [MFC], SetDlgCtrlID
- CWnd [MFC], SetDlgItemInt
- CWnd [MFC], SetDlgItemText
- CWnd [MFC], SetFocus
- CWnd [MFC], SetFont
- CWnd [MFC], SetForegroundWindow
- CWnd [MFC], SetIcon
- CWnd [MFC], SetLayeredWindowAttributes
- CWnd [MFC], SetMenu
- CWnd [MFC], SetOwner
- CWnd [MFC], SetParent
- CWnd [MFC], SetProperty
- CWnd [MFC], SetRedraw
- CWnd [MFC], SetScrollInfo
- CWnd [MFC], SetScrollPos
- CWnd [MFC], SetScrollRange
- CWnd [MFC], SetTimer
- CWnd [MFC], SetWindowContextHelpId
- CWnd [MFC], SetWindowPlacement
- CWnd [MFC], SetWindowPos
- CWnd [MFC], SetWindowRgn
- CWnd [MFC], SetWindowText
- CWnd [MFC], ShowCaret
- CWnd [MFC], ShowOwnedPopups
- CWnd [MFC], ShowScrollBar
- CWnd [MFC], ShowWindow
- CWnd [MFC], SubclassDlgItem
- CWnd [MFC], SubclassWindow
- CWnd [MFC], UnlockWindowUpdate
- CWnd [MFC], UnsubclassWindow
- CWnd [MFC], UpdateData
- CWnd [MFC], UpdateDialogControls
- CWnd [MFC], UpdateLayeredWindow
- CWnd [MFC], UpdateWindow
- CWnd [MFC], ValidateRect
- CWnd [MFC], ValidateRgn
- CWnd [MFC], WindowFromPoint
- CWnd [MFC], WinHelp
- CWnd [MFC], Default
- CWnd [MFC], DefWindowProc
- CWnd [MFC], DoDataExchange
- CWnd [MFC], GetCurrentMessage
- CWnd [MFC], InitDynamicLayout
- CWnd [MFC], LoadDynamicLayoutResource
- CWnd [MFC], OnActivate
- CWnd [MFC], OnActivateApp
- CWnd [MFC], OnAppCommand
- CWnd [MFC], OnAskCbFormatName
- CWnd [MFC], OnCancelMode
- CWnd [MFC], OnCaptureChanged
- CWnd [MFC], OnChangeCbChain
- CWnd [MFC], OnChangeUIState
- CWnd [MFC], OnChar
- CWnd [MFC], OnCharToItem
- CWnd [MFC], OnChildActivate
- CWnd [MFC], OnChildNotify
- CWnd [MFC], OnClipboardUpdate
- CWnd [MFC], OnClose
- CWnd [MFC], OnColorizationColorChanged
- CWnd [MFC], OnCommand
- CWnd [MFC], OnCompacting
- CWnd [MFC], OnCompareItem
- CWnd [MFC], OnCompositionChanged
- CWnd [MFC], OnContextMenu
- CWnd [MFC], OnCopyData
- CWnd [MFC], OnCreate
- CWnd [MFC], OnCtlColor
- CWnd [MFC], OnDeadChar
- CWnd [MFC], OnDeleteItem
- CWnd [MFC], OnDestroy
- CWnd [MFC], OnDestroyClipboard
- CWnd [MFC], OnDeviceChange
- CWnd [MFC], OnDevModeChange
- CWnd [MFC], OnDrawClipboard
- CWnd [MFC], OnDrawItem
- CWnd [MFC], OnDropFiles
- CWnd [MFC], OnEnable
- CWnd [MFC], OnEndSession
- CWnd [MFC], OnEnterIdle
- CWnd [MFC], OnEnterMenuLoop
- CWnd [MFC], OnEnterSizeMove
- CWnd [MFC], OnEraseBkgnd
- CWnd [MFC], OnExitMenuLoop
- CWnd [MFC], OnExitSizeMove
- CWnd [MFC], OnFontChange
- CWnd [MFC], OnGetDlgCode
- CWnd [MFC], OnGetMinMaxInfo
- CWnd [MFC], OnHelpInfo
- CWnd [MFC], OnHotKey
- CWnd [MFC], OnHScroll
- CWnd [MFC], OnHScrollClipboard
- CWnd [MFC], OnIconEraseBkgnd
- CWnd [MFC], OnInitMenu
- CWnd [MFC], OnInitMenuPopup
- CWnd [MFC], OnInputDeviceChange
- CWnd [MFC], OnInputLangChange
- CWnd [MFC], OnInputLangChangeRequest
- CWnd [MFC], OnKeyDown
- CWnd [MFC], OnKeyUp
- CWnd [MFC], OnKillFocus
- CWnd [MFC], OnLButtonDblClk
- CWnd [MFC], OnLButtonDown
- CWnd [MFC], OnLButtonUp
- CWnd [MFC], OnMButtonDblClk
- CWnd [MFC], OnMButtonDown
- CWnd [MFC], OnMButtonUp
- CWnd [MFC], OnMDIActivate
- CWnd [MFC], OnMeasureItem
- CWnd [MFC], OnMenuChar
- CWnd [MFC], OnMenuDrag
- CWnd [MFC], OnMenuGetObject
- CWnd [MFC], OnMenuRButtonUp
- CWnd [MFC], OnMenuSelect
- CWnd [MFC], OnMouseActivate
- CWnd [MFC], OnMouseHover
- CWnd [MFC], OnMouseHWheel
- CWnd [MFC], OnMouseLeave
- CWnd [MFC], OnMouseMove
- CWnd [MFC], OnMouseWheel
- CWnd [MFC], OnMove
- CWnd [MFC], OnMoving
- CWnd [MFC], OnNcActivate
- CWnd [MFC], OnNcCalcSize
- CWnd [MFC], OnNcCreate
- CWnd [MFC], OnNcDestroy
- CWnd [MFC], OnNcHitTest
- CWnd [MFC], OnNcLButtonDblClk
- CWnd [MFC], OnNcLButtonDown
- CWnd [MFC], OnNcLButtonUp
- CWnd [MFC], OnNcMButtonDblClk
- CWnd [MFC], OnNcMButtonDown
- CWnd [MFC], OnNcMButtonUp
- CWnd [MFC], OnNcMouseHover
- CWnd [MFC], OnNcMouseLeave
- CWnd [MFC], OnNcMouseMove
- CWnd [MFC], OnNcPaint
- CWnd [MFC], OnNcRButtonDblClk
- CWnd [MFC], OnNcRButtonDown
- CWnd [MFC], OnNcRButtonUp
- CWnd [MFC], OnNcRenderingChanged
- CWnd [MFC], OnNcXButtonDblClk
- CWnd [MFC], OnNcXButtonDown
- CWnd [MFC], OnNcXButtonUp
- CWnd [MFC], OnNextMenu
- CWnd [MFC], OnNotify
- CWnd [MFC], OnNotifyFormat
- CWnd [MFC], OnPaint
- CWnd [MFC], OnPaintClipboard
- CWnd [MFC], OnPaletteChanged
- CWnd [MFC], OnPaletteIsChanging
- CWnd [MFC], OnParentNotify
- CWnd [MFC], OnPowerBroadcast
- CWnd [MFC], OnQueryDragIcon
- CWnd [MFC], OnQueryEndSession
- CWnd [MFC], OnQueryNewPalette
- CWnd [MFC], OnQueryOpen
- CWnd [MFC], OnQueryUIState
- CWnd [MFC], OnRawInput
- CWnd [MFC], OnRButtonDblClk
- CWnd [MFC], OnRButtonDown
- CWnd [MFC], OnRButtonUp
- CWnd [MFC], OnRenderAllFormats
- CWnd [MFC], OnRenderFormat
- CWnd [MFC], OnSessionChange
- CWnd [MFC], OnSetCursor
- CWnd [MFC], OnSetFocus
- CWnd [MFC], OnSettingChange
- CWnd [MFC], OnShowWindow
- CWnd [MFC], OnSize
- CWnd [MFC], OnSizeClipboard
- CWnd [MFC], OnSizing
- CWnd [MFC], OnSpoolerStatus
- CWnd [MFC], OnStyleChanged
- CWnd [MFC], OnStyleChanging
- CWnd [MFC], OnSysChar
- CWnd [MFC], OnSysColorChange
- CWnd [MFC], OnSysCommand
- CWnd [MFC], OnSysDeadChar
- CWnd [MFC], OnSysKeyDown
- CWnd [MFC], OnSysKeyUp
- CWnd [MFC], OnTCard
- CWnd [MFC], OnTimeChange
- CWnd [MFC], OnTimer
- CWnd [MFC], OnTouchInput
- CWnd [MFC], OnTouchInputs
- CWnd [MFC], OnUniChar
- CWnd [MFC], OnUnInitMenuPopup
- CWnd [MFC], OnUpdateUIState
- CWnd [MFC], OnUserChanged
- CWnd [MFC], OnVKeyToItem
- CWnd [MFC], OnVScroll
- CWnd [MFC], OnVScrollClipboard
- CWnd [MFC], OnWindowPosChanged
- CWnd [MFC], OnWindowPosChanging
- CWnd [MFC], OnWinIniChange
- CWnd [MFC], OnWndMsg
- CWnd [MFC], OnXButtonDblClk
- CWnd [MFC], OnXButtonDown
- CWnd [MFC], OnXButtonUp
- CWnd [MFC], PostNcDestroy
- CWnd [MFC], ReflectChildNotify
- CWnd [MFC], ReflectLastMsg
- CWnd [MFC], ResizeDynamicLayout
- CWnd [MFC], WindowProc
- CWnd [MFC], m_hWnd
ms.assetid: 49a832ee-bc34-4126-88b3-bc1d9974f6c4
ms.openlocfilehash: c2ea240ba736c95026b2b6d2af45296245881bab
ms.sourcegitcommit: 7a6116e48c3c11b97371b8ae4ecc23adce1f092d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/22/2020
ms.locfileid: "81751709"
---
# <a name="cwnd-class"></a>CWnd 類別

提供 MFC 程式庫中所有視窗類別的基本功能。

## <a name="syntax"></a>語法

```
class CWnd : public CCmdTarget
```

## <a name="members"></a>成員

### <a name="public-constructors"></a>公用建構函式

|名稱|描述|
|----------|-----------------|
|[CWnd::CWnd](#cwnd)|建構 `CWnd` 物件。|

### <a name="public-methods"></a>公用方法

|名稱|描述|
|----------|-----------------|
|[CWnd::accDoDefaultAction](#accdodefaultaction)|由架構呼叫以執行物件的預設動作。|
|[CWnd::accHitTest](#acchittest)|由架構呼叫以擷取畫面中給定點的子項目或子物件。|
|[CWnd::accLocation](#acclocation)|由架構呼叫以擷取指定物件目前畫面的位置。|
|[CWnd::accNavigate](#accnavigate)|由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。|
|[CWnd::accSelect](#accselect)|由架構呼叫以修改選取或移動指定物件的鍵盤焦點。|
|[CWnd::AnimateWindow](#animatewindow)|建立相關聯的視窗物件的動畫。|
|[CWnd::ArrangeIconicWindows](#arrangeiconicwindows)|排列所有最小化 (圖示) 子視窗。|
|[CWnd::Attach](#attach)|將 Windows 控制代碼附加至 `CWnd` 物件。|
|[CWnd::BeginModalState](#beginmodalstate)|呼叫此成員函式以製作框架視窗強制回應。|
|[CWnd::BeginPaint](#beginpaint)|準備 `CWnd` 進行繪製。|
|[CWnd::BindDefaultProperty](#binddefaultproperty)|將呼叫物件的預設簡單繫結屬性 (在類型程式庫中標示)，繫結至資料來源控制項相關聯的游標。|
|[CWnd::BindProperty](#bindproperty)|將資料繫結控制項上的游標繫結屬性繫結至資料來源控制項，並註冊該關聯性與 MFC 繫結管理員。|
|[CWnd::BringWindowToTop](#bringwindowtotop)|將 `CWnd` 帶到重疊視窗堆疊的最上層。|
|[CWnd::CalcWindowRect](#calcwindowrect)|呼叫可從用戶端矩形計算視窗矩形。|
|[CWnd::CancelToolTips](#canceltooltips)|停用工具提示控制項。|
|[CWnd::CenterWindow](#centerwindow)|將相對於其父系的視窗置中。|
|[CWnd::ChangeClipboardChain](#changeclipboardchain)|從剪貼簿檢視器的鏈結中移除 `CWnd`。|
|[CWnd::CheckDlgButton](#checkdlgbutton)|在按鈕控制項旁放置核取記號，或從中移除核取記號。|
|[CWnd::CheckRadioButton](#checkradiobutton)|檢查指定的選項按鈕，及移除指定的按鈕群組中所有其他選項按鈕的核取記號。|
|[CWnd::ChildWindowFromPoint](#childwindowfrompoint)|判斷 (如果有的話) 是否有子視窗包含指定的點。|
|[CWnd::ClientToScreen](#clienttoscreen)|將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。|
|[CWnd::CloseWindow](#closewindow)|將視窗最小化。|
|[CWnd::ContinueModal](#continuemodal)|繼續視窗的強制回應狀態。|
|[CWnd::Create](#create)|建立並初始化 `CWnd` 物件相關聯的子視窗。|
|[CWnd::CreateAccessibleProxy](#createaccessibleproxy)|建立指定物件的 Active Accessibility Proxy。|
|[CWnd::CreateCaret](#createcaret)|建立系統游標的新形狀，並取得插入號的擁有權。|
|[CWnd::CreateControl](#createcontrol)|建立將由 `CWnd` 物件在 MFC 程式中表示的 ActiveX 控制項。|
|[CWnd::CreateEx](#createex)|建立 Windows 重疊、快顯視窗或子視窗，並將其附加至 `CWnd` 物件。|
|[CWnd::CreateGrayCaret](#creategraycaret)|建立系統游標的灰色區塊，並取得插入號的擁有權。|
|[CWnd::CreateSolidCaret](#createsolidcaret)|建立系統游標的實心區塊，並取得插入號的擁有權。|
|[CWnd::DeleteTempMap](#deletetempmap)|由 `CWinApp` 閒置時間處理常式自動呼叫，並刪除 `FromHandle` 建立的任何暫存 `CWnd` 物件。|
|[CWnd::DestroyWindow](#destroywindow)|終結附加的 Windowd 視窗。|
|[CWnd::Detach](#detach)|從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。|
|[CWnd::DlgDirList](#dlgdirlist)|使用檔案或目錄清單填入清單方塊。|
|[CWnd::DlgDirListComboBox](#dlgdirlistcombobox)|使用檔案或目錄清單來填入下拉式方塊的清單方塊。|
|[CWnd::DlgDirSelect](#dlgdirselect)|從清單方塊擷取目前的選取範圍。|
|[CWnd::DlgDirSelectComboBox](#dlgdirselectcombobox)|從下拉式方塊的清單方塊中擷取目前的選取範圍。|
|[CWnd::DragAcceptFiles](#dragacceptfiles)|指出視窗將接受拖曳的檔案。|
|[CWnd::DragDetect](#dragdetect)|擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。|
|[CWnd::DrawAnimatedRects](#drawanimatedrects)|繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。|
|[CWnd::DrawCaption](#drawcaption)|繪製標題。|
|[CWnd::DrawMenuBar](#drawmenubar)|重新繪製功能表列。|
|[CWnd::EnableActiveAccessibility](#enableactiveaccessibility)|啟用使用者定義的 `Active Accessibility` 函式。|
|[CWnd::EnableDynamicLayout](#enabledynamiclayout)|可在使用者調整視窗大小時，動態調整子視窗的位置與大小。|
|[CWnd::EnableD2DSupport](#enabled2dsupport)|啟用或停用視窗 `D2D` 支援。 初始化主視窗之前先呼叫這個方法。|
|[CWnd::EnableScrollBar](#enablescrollbar)|啟用或停用一個捲軸的一或兩個箭號。|
|[CWnd::EnableScrollBarCtrl](#enablescrollbarctrl)|啟用或停用同層級捲軸控制項。|
|[CWnd::EnableToolTips](#enabletooltips)|啟用工具提示控制項。|
|[CWnd::EnableTrackingToolTips](#enabletrackingtooltips)|啟用追蹤模式中的工具提示控制項。|
|[CWnd::EnableWindow](#enablewindow)|啟用或停用滑鼠和鍵盤輸入。|
|[CWnd::EndModalLoop](#endmodalloop)|結束視窗的強制回應狀態。|
|[CWnd::EndModalState](#endmodalstate)|呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。|
|[CWnd::EndPaint](#endpaint)|標記繪製的結束。|
|[CWnd::ExecuteDlgInit](#executedlginit)|初始化對話方塊資源。|
|[CWnd::FilterToolTipMessage](#filtertooltipmessage)|擷取對話方塊中控制項相關聯的標題或文字。|
|[CWnd::FindWindow](#findwindow)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FindWindowEx](#findwindowex)|傳回由其視窗名稱和視窗類別識別的視窗控制代碼。|
|[CWnd::FlashWindow](#flashwindow)|閃爍視窗一次。|
|[CWnd::FlashWindowEx](#flashwindowex)|閃爍視窗與其他功能。|
|[CWnd::FromHandle](#fromhandle)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。|
|[CWnd::FromHandlePermanent](#fromhandlepermanent)|將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。|
|[CWnd::get_accChild](#get_accchild)|由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。|
|[CWnd::get_accChildCount](#get_accchildcount)|由架構呼叫以擷取屬於此物件的子物件數目。|
|[CWnd::get_accDefaultAction](#get_accdefaultaction)|由架構呼叫以擷取具有物件預設動作描述的字串。|
|[CWnd::get_accDescription](#get_accdescription)|由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。|
|[CWnd::get_accFocus](#get_accfocus)|由架構呼叫以擷取具有鍵盤焦點的物件。|
|[CWnd::get_accHelp](#get_acchelp)|由框架呼叫以檢索物件的**幫助**屬性字串。|
|[CWnd::get_accHelpTopic](#get_acchelptopic)|由架構呼叫以擷取 `WinHelp` 檔 (與指定物件和該檔案中適切主題的識別項關聯) 的完整路徑。|
|[CWnd::get_accKeyboardShortcut](#get_acckeyboardshortcut)|由架構呼叫以擷取指定物件的快速鍵或便捷鍵。|
|[CWnd::get_accName](#get_accname)|由架構呼叫以擷取指定物件的名稱。|
|[CWnd::get_accParent](#get_accparent)|由架構呼叫以擷取物件之父代的 `IDispatch` 介面。|
|[CWnd::get_accRole](#get_accrole)|由架構呼叫以擷取含有指定物件的角色描述資訊。|
|[CWnd::get_accSelection](#get_accselection)|由架構呼叫以擷取此物件的選取子物件。|
|[CWnd::get_accState](#get_accstate)|由架構呼叫以擷取指定物件的目前狀態。|
|[CWnd::get_accValue](#get_accvalue)|由架構呼叫以擷取指定物件的值。|
|[CWnd::GetActiveWindow](#getactivewindow)|擷取使用中視窗。|
|[CWnd::GetAncestor](#getancestor)|擷取指定視窗的上階視窗物件。|
|[CWnd::GetCapture](#getcapture)|擷取具有滑鼠捕捉的 `CWnd`。|
|[CWnd::GetCaretPos](#getcaretpos)|擷取插入號之目前位置的用戶端座標。|
|[CWnd::GetCheckedRadioButton](#getcheckedradiobutton)|傳回按鈕群組中目前核取的選項按鈕的識別碼。|
|[CWnd::GetClientRect](#getclientrect)|取得 `CWnd` 工作區的維度。|
|[CWnd::GetClipboardOwner](#getclipboardowner)|擷取剪貼簿的目前擁有者的指標。|
|[CWnd::GetClipboardViewer](#getclipboardviewer)|擷取剪貼簿檢視器鏈結中的第一個視窗的指標。|
|[CWnd::GetControlUnknown](#getcontrolunknown)|擷取至未知 ActiveX 控制項的指標。|
|[CWnd::GetDC](#getdc)|擷取工作區的顯示內容。|
|[CWnd::GetDCEx](#getdcex)|擷取工作區的顯示內容，並在繪製時啟用裁剪。|
|[CWnd::GetDCRenderTarget](#getdcrendertarget)|擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。|
|[CWnd::GetDescendantWindow](#getdescendantwindow)|搜尋所有下階視窗，並傳回具有指定識別碼的視窗。|
|[CWnd::GetDesktopWindow](#getdesktopwindow)|擷取 Windows 桌面視窗。|
|[CWnd::GetDlgCtrlID](#getdlgctrlid)|如果 `CWnd` 是子視窗，呼叫這個函式會傳回它的識別碼值。|
|[CWnd::GetDlgItem](#getdlgitem)|從指定的對話方塊中擷取具有指定識別碼的控制項。|
|[CWnd::GetDlgItemInt](#getdlgitemint)|將指定對話方塊中的控制項文字轉譯成整數值。|
|[CWnd::GetDlgItemText](#getdlgitemtext)|擷取與控制項相關聯的標題或文字。|
|[CWnd::GetDSCCursor](#getdsccursor)|擷取料來源控制項的 DataSource、UserName、Password 和 SQL 屬性所定義之基礎游標的指標。|
|[CWnd::GetDynamicLayout](#getdynamiclayout)|擷取動態配置管理員物件的指標。|
|[CWnd::GetExStyle](#getexstyle)|傳回視窗的延伸樣式。|
|[CWnd::GetFocus](#getfocus)|擷取目前具有輸入焦點的 `CWnd`。|
|[CWnd::GetFont](#getfont)|擷取目前的字型。|
|[CWnd::GetForegroundWindow](#getforegroundwindow)|讓指標回到前景視窗 (使用者目前使用的最上層視窗)。|
|[CWnd::GetIcon](#geticon)|擷取圖示的控制代碼。|
|[CWnd::GetLastActivePopup](#getlastactivepopup)|判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。|
|[CWnd::GetLayeredWindowAttributes](#getlayeredwindowattributes)|擷取分層視窗的不透明和透明色鍵。|
|[CWnd::GetMenu](#getmenu)|擷取指定功能表的指標。|
|[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)|搜尋控制項群組內的下一個 (或上一個) 控制項。|
|[CWnd::GetNextDlgTabItem](#getnextdlgtabitem)|檢索第一個控件,其[WS_TABSTOP](styles-used-by-mfc.md#window-styles)樣式位於指定控制項之後(或之前)。|
|[CWnd::GetNextWindow](#getnextwindow)|傳回視窗管理員清單中的下一個 (或上一個) 視窗。|
|[CWnd::GetOleControlSite](#getolecontrolsite)|擷取指定的 ActiveX 控制項的自訂網站。|
|[CWnd::GetOpenClipboardWindow](#getopenclipboardwindow)|擷取目前已開啟剪貼簿的視窗指標。|
|[CWnd::GetOwner](#getowner)|擷取 `CWnd` 擁有者的指標。|
|[CWnd::GetParent](#getparent)|擷取 `CWnd` 的父視窗 (如果有的話)。|
|[CWnd::GetParentFrame](#getparentframe)|擷取 `CWnd` 物件的父框架視窗。|
|[CWnd::GetParentOwner](#getparentowner)|傳回子視窗的父視窗指標。|
|[CWnd:獲取財產](#getproperty)|擷取 ActiveX 控制項屬性。|
|[CWnd::GetRenderTarget](#getrendertarget)|取得與此視窗相關聯的呈現目標。|
|[CWnd::GetSafeHwnd](#getsafehwnd)|如果`m_hWnd`**此**指標為 NULL,則傳回或 NULL。|
|[CWnd::GetSafeOwner](#getsafeowner)|擷取給定視窗的安全擁有者。|
|[CWnd::GetScrollBarCtrl](#getscrollbarctrl)|傳回一個同層級捲軸控制項。|
|[CWnd::GetScrollBarInfo](#getscrollbarinfo)|擷取所指定之捲軸的相關資訊。|
|[CWnd::GetScrollInfo](#getscrollinfo)|擷取 `SCROLLINFO` 結構維護的捲軸相關資訊。|
|[CWnd::GetScrollLimit](#getscrolllimit)|擷取捲軸的限制。|
|[CWnd::GetScrollPos](#getscrollpos)|擷取捲動方塊的目前位置。|
|[CWnd::GetScrollRange](#getscrollrange)|複製給定捲軸目前的最小和最大捲軸位置。|
|[CWnd::GetStyle](#getstyle)|傳回目前的視窗樣式。|
|[CWnd::GetSystemMenu](#getsystemmenu)|可讓應用程式存取控制功能表以進行複製和修改。|
|[CWnd::GetTitleBarInfo](#gettitlebarinfo)|擷取指定之標題列的相關資訊。|
|[CWnd::GetTopLevelFrame](#gettoplevelframe)|擷取視窗的最上層框架視窗。|
|[CWnd::GetTopLevelOwner](#gettoplevelowner)|擷取最上層視窗。|
|[CWnd::GetTopLevelParent](#gettoplevelparent)|擷取視窗的最上層父代。|
|[CWnd::GetTopWindow](#gettopwindow)|傳回屬於 `CWnd` 的第一個子視窗。|
|[CWnd::GetUpdateRect](#getupdaterect)|擷取完全圍住 `CWnd` 更新區域的最小矩形座標。|
|[CWnd::GetUpdateRgn](#getupdatergn)|擷取 `CWnd` 更新區域。|
|[CWnd::GetWindow](#getwindow)|傳回與此視窗具有指定關聯性的視窗。|
|[CWnd::GetWindowContextHelpId](#getwindowcontexthelpid)|擷取說明內容識別碼。|
|[CWnd::GetWindowDC](#getwindowdc)|擷取整個視窗的顯示內容，包括標題列、功能表和捲軸。|
|[CWnd::GetWindowedChildCount](#getwindowedchildcount)|傳回相關聯子視窗的數目。|
|[CWnd::GetWindowInfo](#getwindowinfo)|傳回視窗的相關資訊。|
|[CWnd::獲取無視窗兒童計數](#getwindowlesschildcount)|傳回相關聯的無視窗子視窗數目。|
|[CWnd::GetWindowPlacement](#getwindowplacement)|擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::GetWindowRect](#getwindowrect)|取得 `CWnd` 的螢幕座標。|
|[CWnd::GetWindowRgn](#getwindowrgn)|擷取視窗的視窗區域複本。|
|[CWnd::GetWindowText](#getwindowtext)|傳回視窗文字或標題 (如果有的話)。|
|[CWnd::GetWindowTextLength](#getwindowtextlength)|傳回視窗的文字或標題的長度。|
|[CWnd::HideCaret](#hidecaret)|藉由從顯示畫面移除插入號來隱藏該插入號。|
|[CWnd::HiliteMenuItem](#hilitemenuitem)|反白顯示或從最上層 (功能表列) 的功能表項目中移除反白顯示。|
|[CWnd::HtmlHelp](#htmlhelp)|呼叫以初始化 HTMLHelp 應用程式。|
|[CWnd::Invalidate](#invalidate)|使整個工作區失效。|
|[CWnd::InvalidateRect](#invalidaterect)|將矩形加入至目前的更新區域，使給定矩形內的工作區失效。|
|[CWnd::InvalidateRgn](#invalidatergn)|將區域加入至目前的更新區域，使給定區域內的工作區失效。|
|[CWnd::InvokeHelper](#invokehelper)|叫用 ActiveX 控制項方法或屬性。|
|[CWnd::IsChild](#ischild)|指出 `CWnd` 是子視窗，還是指定視窗的其他直屬下階。|
|[CWnd::IsD2DSupportEnabled](#isd2dsupportenabled)|確定是否啟用了 D2D 支援。|
|[CWnd::IsDialogMessage](#isdialogmessage)|判斷指定的訊息是否適用於非強制回應對話方塊，若是則處理它。|
|[CWnd::IsDlgButtonChecked](#isdlgbuttonchecked)|決定是否核取按鈕控制項。|
|[CWnd::IsDynamicLayoutEnabled](#isdynamiclayoutenabled)|決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。|
|[CWnd::IsIconic](#isiconic)|決定是否將 `CWnd` 降到最低 (圖示)。|
|[CWnd::IsTouchWindow](#istouchwindow)|指定 `CWnd` 是否有觸控支援。|
|[CWnd::IsWindowEnabled](#iswindowenabled)|決定是否為滑鼠和鍵盤輸入啟用視窗。|
|[CWnd::IsWindowVisible](#iswindowvisible)|決定視窗是否可見。|
|[CWnd::IsZoomed](#iszoomed)|決定是否將 `CWnd` 最大化。|
|[CWnd::KillTimer](#killtimer)|刪除系統計時器。|
|[CWnd::LockWindowUpdate](#lockwindowupdate)|停用或重新啟用在給定視窗中繪製。|
|[CWnd::MapWindowPoints](#mapwindowpoints)|將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。|
|[CWnd::MessageBox](#messagebox)|建立並顯示視窗，其中包含應用程式提供的訊息和標題。|
|[CWnd::ModifyStyle](#modifystyle)|修改目前的視窗樣式。|
|[CWnd::ModifyStyleEx](#modifystyleex)|修改視窗的延伸樣式。|
|[CWnd::MoveWindow](#movewindow)|變更 `CWnd` 的位置和維度。|
|[CWnd::NotifyWinEvent](#notifywinevent)|表示發生預先定義之事件的系統。|
|[CWnd::OnAmbientProperty](#onambientproperty)|實作環境屬性值。|
|[CWnd::OnDrawIconicThumbnailOrLivePreview](#ondrawiconicthumbnailorlivepreview)|需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。|
|[CWnd::OnHelp](#onhelp)|在應用程式 (使用目前的內容) 中處理 F1 說明。|
|[CWnd::OnHelpFinder](#onhelpfinder)|處理ID_HELP_FINDER和ID_DEFAULT_HELP命令。|
|[CWnd::OnHelpIndex](#onhelpindex)|處理ID_HELP_INDEX命令並提供默認幫助主題。|
|[CWnd::OnHelpUsing](#onhelpusing)|處理ID_HELP_USING命令。|
|[CWnd::OnToolHitTest](#ontoolhittest)|決定一個點是否位於指定工具的周框中並擷取工具的相關資訊。|
|[CWnd::OpenClipboard](#openclipboard)|開啟剪貼簿。 在調用 Windows [CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard)功能之前,其他應用程式將無法修改剪貼簿。|
|[CWnd::PaintWindowlessControls](#paintwindowlesscontrols)|在控制項容器上繪製無視窗控制項。|
|[CWnd::PostMessage](#postmessage)|在應用程式佇列中放置訊息，然後傳回，而不需等待視窗處理訊息。|
|[CWnd::PreCreateWindow](#precreatewindow)|在建立附加至此 `CWnd` 物件的 Windows 視窗前呼叫。|
|[CWnd::PreSubclassWindow](#presubclasswindow)|允許在調用[子類視窗](#subclasswindow)之前進行其他必要的子類。|
|[CWnd::PreTranslateMessage](#pretranslatemessage)|由 `CWinApp` 使用，可先篩選視窗訊息，再將它們分派至 `TranslateMessage` 和 `DispatchMessage` Windows 函式。|
|[CWnd::Print](#print)|在指定的裝置內容中繪製目前的視窗。|
|[CWnd::PrintClient](#printclient)|在指定的裝置內容中繪製任何視窗 (通常是印表機裝置內容)。|
|[CWnd::PrintWindow](#printwindow)|將視覺視窗複製到指定的裝置內容，通常是印表機 DC。|
|[CWnd::RedrawWindow](#redrawwindow)|更新工作區中指定的矩形或區域。|
|[CWnd::RegisterTouchWindow](#registertouchwindow)|註冊/取消註冊視窗 Windows 觸控支援。|
|[CWnd::ReleaseDC](#releasedc)|釋放用戶端和視窗裝置內容，釋放這些內容供其他應用程式使用。|
|[CWnd::RepositionBars](#repositionbars)|工作區中的重新置放控制列。|
|[CWnd::RunModalLoop](#runmodalloop)|擷取、轉換或分派處於強制回應狀態之視窗的訊息。|
|[CWnd::ScreenToClient](#screentoclient)|將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。|
|[CWnd::ScrollWindow](#scrollwindow)|捲動工作區的內容。|
|[CWnd::ScrollWindowEx](#scrollwindowex)|捲動工作區的內容。 類似於 `ScrollWindow`，但具有額外的功能。|
|[CWnd::SendChildNotifyLastMsg](#sendchildnotifylastmsg)|從父視窗中將通知訊息提供給子視窗，讓子視窗可以處理工作。|
|[CWnd::SendDlgItemMessage](#senddlgitemmessage)|將訊息傳送至指定的控制項。|
|[CWnd::SendMessage](#sendmessage)|傳送訊息給 `CWnd` 物件，在處理訊息後才會傳回。|
|[CWnd::SendMessageToDescendants](#sendmessagetodescendants)|傳送訊息給視窗的所有下階視窗。|
|[CWnd::SendNotifyMessage](#sendnotifymessage)|將指定的訊息傳送至視窗並儘速傳回，視呼叫執行緒是否建立視窗而定。|
|[CWnd::SetActiveWindow](#setactivewindow)|啟用視窗。|
|[CWnd::SetCapture](#setcapture)|導致所有後續滑鼠輸入傳送至 `CWnd`。|
|[CWnd::SetCaretPos](#setcaretpos)|將插入號移動到指定的位置。|
|[CWnd::SetClipboardViewer](#setclipboardviewer)|將 `CWnd` 新增到視窗的鏈結，每當剪貼簿的內容變更時就會通知這些視窗。|
|[CWnd::SetDlgCtrlID](#setdlgctrlid)|設定視窗或視窗的控制項識別碼 (這可以是任何子視窗，而不只是對話方塊中的控制項)。|
|[CWnd::SetDlgItemInt](#setdlgitemint)|將控制項的文字設為表示整數值的字串。|
|[CWnd::SetDlgItemText](#setdlgitemtext)|在指定的對話方塊中設定控制項的標題或文字。|
|[CWnd::SetFocus](#setfocus)|宣告輸入焦點。|
|[CWnd::SetFont](#setfont)|設定目前的字型。|
|[CWnd::SetForegroundWindow](#setforegroundwindow)|將建立視窗的執行緒放置到前景並啟動視窗。|
|[CWnd::SetIcon](#seticon)|將控制代碼設為特定的圖示。|
|[CWnd::SetLayeredWindowAttributes](#setlayeredwindowattributes)|設定分層視窗的不透明和透明色鍵。|
|[CWnd::SetMenu](#setmenu)|將功能表設定為指定的功能表。|
|[CWnd::SetOwner](#setowner)|變更 `CWnd` 的擁有者。|
|[CWnd::SetParent](#setparent)|變更父視窗。|
|[CWnd::SetProperty](#setproperty)|設定 ActiveX 控制項屬性。|
|[CWnd::SetRedraw](#setredraw)|允許重新繪製 `CWnd` 中的變更，或防止重新繪製進行變更。|
|[CWnd::SetScrollInfo](#setscrollinfo)|設定捲軸的相關資訊。|
|[CWnd::SetScrollPos](#setscrollpos)|設定捲動方塊的目前位置，而且如果指定，會重新繪製捲軸以反映新位置。|
|[CWnd::SetScrollRange](#setscrollrange)|設定給定捲軸的最小和最大位置值。|
|[CWnd::SetTimer](#settimer)|安裝系統計時器,在觸發時發送[WM_TIMER](#ontimer)消息。|
|[CWnd::SetWindowContextHelpId](#setwindowcontexthelpid)|設定說明內容識別碼。|
|[CWnd::SetWindowPlacement](#setwindowplacement)|設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。|
|[CWnd::SetWindowPos](#setwindowpos)|變更大小、位置和子系順序、快顯視窗，和最上層視窗。|
|[CWnd::SetWindowRgn](#setwindowrgn)|設定視窗的區域。|
|[CWnd::SetWindowText](#setwindowtext)|將視窗文字或標題 (如果有的話) 設為指定的文字。|
|[CWnd::ShowCaret](#showcaret)|在畫面上插入號的目前位置上顯示插入號。 顯示後，插入號會開始自動閃爍。|
|[CWnd::ShowOwnedPopups](#showownedpopups)|顯示或隱藏視窗擁有的所有快顯視窗。|
|[CWnd::ShowScrollBar](#showscrollbar)|顯示或隱藏捲軸。|
|[CWnd::ShowWindow](#showwindow)|顯示或隱藏視窗。|
|[CWnd::SubclassDlgItem](#subclassdlgitem)|將 Windows 控制項附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::SubclassWindow](#subclasswindow)|將視窗附加至 `CWnd` 物件，並使其透過 `CWnd` 的訊息對應來路由訊息。|
|[CWnd::UnlockWindowUpdate](#unlockwindowupdate)|解除鎖定已使用 `CWnd::LockWindowUpdate` 鎖定的視窗。|
|[CWnd::UnsubclassWindow](#unsubclasswindow)|從`CWnd`物件分離視窗|
|[CWnd::UpdateData](#updatedata)|從對話方塊中初始化或擷取資料。|
|[CWnd::UpdateDialogControls](#updatedialogcontrols)|呼叫以更新對話方塊按鈕和其他控制項的狀態。|
|[CWnd::UpdateLayeredWindow](#updatelayeredwindow)|更新分層視窗的位置、大小、形狀、內容和透明度。|
|[CWnd::UpdateWindow](#updatewindow)|更新工作區。|
|[CWnd::ValidateRect](#validaterect)|從目前的更新區域中移除矩形，驗證給定矩形內的工作區。|
|[CWnd::ValidateRgn](#validatergn)|從目前的更新區域中移除區域，驗證給定區域內的工作區。|
|[CWnd::WindowFromPoint](#windowfrompoint)|識別包含指定點的視窗。|
|[CWnd::WinHelp](#winhelp)|呼叫以初始化 WinHelp 應用程式。|

### <a name="protected-methods"></a>保護方法

|名稱|描述|
|----------|-----------------|
|[CWnd::Default](#default)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DefWindowProc](#defwindowproc)|呼叫預設視窗程序，提供應用程式不會處理的任何視窗訊息的預設處理程序。|
|[CWnd::DoDataExchange](#dodataexchange)|適用於對話方塊資料交換和驗證。 由 `UpdateData` 呼叫。|
|[CWnd::GetCurrentMessage](#getcurrentmessage)|傳回此視窗目前正在處理的訊息指標。 僅當在`On`*消息*處理程序成員函數中時才應調用。|
|[CWnd::InitDynamicLayout](#initdynamiclayout)|由架構呼叫以初始化視窗的動態配置。|
|[CWnd::LoadDynamicLayoutResource](#loaddynamiclayoutresource)|從資源檔載入動態配置資訊。|
|[Cwnd::打開啟動](#onactivate)|當 `CWnd` 啟動或停用時呼叫。|
|[CWnd::OnActivateApp](#onactivateapp)|當應用程式即將啟動或停用時呼叫。|
|[CWnd::OnAppCommand](#onappcommand)|當使用者產生應用程式命令事件時呼叫。|
|[CWnd::OnAskCbFormatName](#onaskcbformatname)|當剪貼簿擁有者將顯示剪貼簿內容時，由剪貼簿檢視器應用程式呼叫。|
|[CWnd::OnCancelMode](#oncancelmode)|呼叫以讓 `CWnd` 取消任何內部的模式，例如滑鼠捕捉。|
|[CWnd::OnCaptureChanged](#oncapturechanged)|將訊息傳送至正失去滑鼠捕捉的視窗。|
|[CWnd::OnChangeCbChain](#onchangecbchain)|通知正在從鏈結中移除指定的視窗。|
|[CWnd::OnChangeUIState](#onchangeuistate)|應變更使用者介面 (UI) 狀態時呼叫。|
|[CWnd::OnChar](#onchar)|按鍵轉譯為非系統字元時呼叫。|
|[CWnd::OnCharToItem](#onchartoitem)|由具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣子清單框調用,以回應[WM_CHAR](#onchar)消息。|
|[CWnd::OnChildActivate](#onchildactivate)|每當 `CWnd` 的大小或位置變更，或 `CWnd` 已啟動時，針對多重文件介面 (MDI) 子視窗呼叫。|
|[CWnd::OnChildNotify](#onchildnotify)|由父視窗呼叫，讓通知控制項有機會回應控制項通知。|
|[CWnd::OnClipboardUpdate](#onclipboardupdate)|於剪貼簿內容已變更時呼叫。|
|[CWnd::OnClose](#onclose)|呼叫以表示 `CWnd` 應該關閉。|
|[CWnd::OnColorizationColorChanged](#oncolorizationcolorchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnCommand](#oncommand)|當使用者選取命令時呼叫。|
|[CWnd::OnCompacting](#oncompacting)|當 Windows 偵測到系統記憶體過低時呼叫。|
|[CWnd::OnCompareItem](#oncompareitem)|呼叫以判斷子排序之主控描繪的下拉式方塊或清單方塊中新項目的相對位置。|
|[CWnd::OnCompositionChanged](#oncompositionchanged)|當桌面視窗管理員 (DWM) 組合啟用或停用時，為所有最上層視窗呼叫。|
|[CWnd::OnContextMenu](#oncontextmenu)|當使用者在視窗中按一下滑鼠右鍵時呼叫。|
|[CWnd::OnCopyData](#oncopydata)|在應用程式之間複製資料。|
|[CWnd::OnCreate](#oncreate)|在視窗建立過程中呼叫。|
|[CWnd::OnCtlColor](#onctlcolor)|即將繪製控制項時，如果`CWnd` 是控制項的父代則呼叫。|
|[CWnd::OnDeadChar](#ondeadchar)|當按鍵轉譯為非系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnDeleteItem](#ondeleteitem)|當主控描繪子清單方塊或下拉式方塊損毀，或從控制項移除項目時呼叫。|
|[CWnd::OnDestroy](#ondestroy)|`CWnd` 正在損毀時呼叫。|
|[CWnd::OnDestroyClipboard](#ondestroyclipboard)|當通過調用 Windows[空剪板](/windows/win32/api/winuser/nf-winuser-emptyclipboard)功能清空剪貼簿時調用。|
|[CWnd::OnDeviceChange](#ondevicechange)|將裝置或電腦的硬體組態變更通知應用程式或裝置驅動程式。|
|[CWnd::OnDevModeChange](#ondevmodechange)|當使用者變更裝置模式設定時，針對所有最上層視窗呼叫。|
|[CWnd::OnDrawClipboard](#ondrawclipboard)|於剪貼簿內容變更時呼叫。|
|[CWnd::OnDrawItem](#ondrawitem)|主控描繪子按鈕控制項、下拉式方塊控制項、清單方塊控制項或功能表的視覺外觀必須繪製時呼叫。|
|[CWnd::OnDropFiles](#ondropfiles)|當使用者在視窗 (已本身註冊為捨棄檔案的收件者) 上放開滑鼠按鈕時呼叫。|
|[CWnd::OnEnable](#onenable)|啟用或停用 `CWnd` 時呼叫。|
|[CWnd::OnEndSession](#onendsession)|當工作階段正在結束時呼叫。|
|[CWnd::OnEnterIdle](#onenteridle)|呼叫此函式，可將強制回應對話方塊或功能表正在進入閒置狀態的訊息，通知應用程式的主視窗程序。|
|[CWnd::OnEnterMenuLoop](#onentermenuloop)|已進入功能表強制回應迴圈時呼叫。|
|[CWnd::OnEnterSizeMove](#onentersizemove)|在受影響的視窗進入移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnEraseBkgnd](#onerasebkgnd)|視窗背景需要清除時呼叫。|
|[CWnd::OnExitMenuLoop](#onexitmenuloop)|已結束功能表強制回應迴圈時呼叫。|
|[CWnd::OnExitSizeMove](#onexitsizemove)|在受影響的視窗結束移動或調整大小的強制回應迴圈後呼叫。|
|[CWnd::OnFontChange](#onfontchange)|字型資源的集區變更時呼叫。|
|[CWnd::OnGetDlgCode](#ongetdlgcode)|呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。|
|[CWnd::OnGetMinMaxInfo](#ongetminmaxinfo)|每當 Windows 必須知道最大化的位置或維度，或最小或最大的追蹤大小時呼叫。|
|[CWnd::OnHelpInfo](#onhelpinfo)|當使用者按下 F1 鍵時，由架構呼叫。|
|[CWnd::OnHotKey](#onhotkey)|當使用者按下全系統的便捷鍵時呼叫。|
|[CWnd::OnHScroll](#onhscroll)|當使用者按一下 `CWnd` 的水平捲軸時呼叫。|
|[CWnd::OnHScrollClipboard](#onhscrollclipboard)|當剪貼簿擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnIconEraseBkgnd](#oniconerasebkgnd)|當 `CWnd` 減到最小 (圖示)，且必須先填入圖示的背景再繪製圖示時呼叫。|
|[CWnd::OnInitMenu](#oninitmenu)|當功能表即將變成現用時呼叫。|
|[CWnd::OnInitMenuPopup](#oninitmenupopup)|當快顯功能表即將變成現用時呼叫。|
|[CWnd::OnInputDeviceChange](#oninputdevicechange)|從系統中新增或移除 I/O 裝置時呼叫。|
|[CWnd::OnInputLangChange](#oninputlangchange)|在應用程式的輸入語言變更後呼叫。|
|[CWnd::OnInputLangChangeRequest](#oninputlangchangerequest)|當使用者選擇新的輸入語言時呼叫。|
|[CWnd::OnKeyDown](#onkeydown)|按下非系統鍵時呼叫。|
|[CWnd::OnKeyUp](#onkeyup)|放開非系統鍵時呼叫。|
|[CWnd::OnKillFocus](#onkillfocus)|在 `CWnd` 遺失輸入焦點前立即呼叫。|
|[CWnd::OnLButtonDblClk](#onlbuttondblclk)|當使用者按兩下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonDown](#onlbuttondown)|當使用者按下滑鼠左鍵時呼叫。|
|[CWnd::OnLButtonUp](#onlbuttonup)|當使用者放開滑鼠左鍵時呼叫。|
|[CWnd::OnMButtonDblClk](#onmbuttondblclk)|當使用者按兩下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonDown](#onmbuttondown)|當使用者按下滑鼠中鍵時呼叫。|
|[CWnd::OnMButtonUp](#onmbuttonup)|當使用者放開滑鼠中鍵時呼叫。|
|[CWnd::OnMDIActivate](#onmdiactivate)|當 MDI 子視窗啟用或停用時呼叫。|
|[CWnd::OnMeasureItem](#onmeasureitem)|建立控制項時，針對主控描繪子下拉式方塊、清單方塊或功能表項目呼叫。 `CWnd` 會將控制項維度通知 Windows。|
|[CWnd::OnMenuChar](#onmenuchar)|當使用者按下功能表的助憶鍵字元，且該字元不符合目前功能表中任何預先定義的助憶鍵時呼叫。|
|[CWnd::OnMenuDrag](#onmenudrag)|當使用者開始拖曳功能表項目時呼叫。|
|[CWnd::OnMenuGetObject](#onmenugetobject)|當滑鼠游標進入功能表項目，或從項目中央移到項目上方或下方時呼叫。|
|[CWnd::OnMenuRButtonUp](#onmenurbuttonup)|當游標位於功能表項目上，而使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnMenuSelect](#onmenuselect)|當使用者選取功能表項目時呼叫。|
|[CWnd::OnMouseActivate](#onmouseactivate)|當游標處於非使用中視窗，且使用者按下滑鼠按鈕時呼叫。|
|[CWnd::OnMouseHover](#onmousehover)|當游標懸停在視窗的工作區上,在之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的時間段時調用。|
|[CWnd::OnMouseHWheel](#onmousehwheel)|當目前的視窗由桌面視窗管理員 (DWM) 組成，且該視窗最大化時呼叫。|
|[CWnd::OnMouseLeave](#onmouseleave)|當游標離開之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的視窗的工作區時調用。|
|[CWnd::OnMouseMove](#onmousemove)|當滑鼠游標移動時呼叫。|
|[CWnd::OnMouseWheel](#onmousewheel)|當使用者旋轉滑鼠滾輪時呼叫。 使用 Windows NT 4.0 訊息處理。|
|[CWnd::OnMove](#onmove)|在 `CWnd` 的位置變更後呼叫。|
|[CWnd::OnMoving](#onmoving)|指出使用者正在移動 `CWnd` 物件。|
|[CWnd::OnNcActivate](#onncactivate)|當非工作區需要變更以表示作用中或非作用中狀態時呼叫。|
|[CWnd::OnNcCalcSize](#onnccalcsize)|需要計算工作區的大小和位置時呼叫。|
|[CWnd::OnNcCreate](#onnccreate)|在創建非工作區時在[OnCreate](#oncreate)之前調用。|
|[CWnd::OnNcDestroy](#onncdestroy)|當非工作區正在損毀時呼叫。|
|[CWnd::OnNcHitTest](#onnchittest)|每次移動滑鼠時，如果 `CWnd` 包含游標，或已使用 `SetCapture` 擷取滑鼠輸入時呼叫。|
|[CWnd::OnNcLButtonDblClk](#onnclbuttondblclk)|當使用者按兩下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonDown](#onnclbuttondown)|當使用者按下滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcLButtonUp](#onnclbuttonup)|當使用者放開滑鼠左鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDblClk](#onncmbuttondblclk)|當使用者按兩下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonDown](#onncmbuttondown)|當使用者按下滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMButtonUp](#onncmbuttonup)|當使用者放開滑鼠中鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcMouseHover](#onncmousehover)|當游標懸停在視窗的非工作區上,在之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的時間段時調用。|
|[CWnd::OnNcMouseLeave](#onncmouseleave)|當游標離開之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的視窗的非工作區時,框架將調用此成員函數。|
|[CWnd::OnNcMouseMove](#onncmousemove)|當游標在 `CWnd` 的非工作區內移動時呼叫。|
|[CWnd::OnNcPaint](#onncpaint)|當非工作區需要繪製時呼叫。|
|[CWnd::OnNcRButtonDblClk](#onncrbuttondblclk)|當使用者按兩下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonDown](#onncrbuttondown)|當使用者按下滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRButtonUp](#onncrbuttonup)|當使用者放開滑鼠右鍵，而游標位於 `CWnd` 的非工作區內時呼叫。|
|[CWnd::OnNcRenderingChanged](#onncrenderingchanged)|當非工作區的轉譯原則已變更時呼叫。|
|[CWnd::OnNcXButtonDblClk](#onncxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonDown](#onncxbuttondown)|當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNcXButtonUp](#onncxbuttonup)|當使用者放開滑鼠的 XBUTTON1 或 XBUTTON2，而游標位於視窗的非工作區時呼叫。|
|[CWnd::OnNextMenu](#onnextmenu)|當使用向右鍵或向左鍵切換功能表列和系統功能表時呼叫。|
|[CWnd::OnNotify](#onnotify)|由架構呼叫，將其中一個控制項已發生的事件，或控制項需要資訊等狀況通知父視窗。|
|[CWnd::OnNotifyFormat](#onnotifyformat)|呼叫以決定目前視窗的 WM_NOTIFY 通知訊息中是否接受 ANSI 或 Unicode 結構。|
|[CWnd::OnPaint](#onpaint)|呼叫以重新繪製視窗的一部份。|
|[CWnd::OnPaintClipboard](#onpaintclipboard)|當需要重新繪製剪貼簿檢視器的工作區時呼叫。|
|[CWnd::OnPaletteChanged](#onpalettechanged)|呼叫以允許使用調色盤的視窗調整其邏輯色板的大小，並更新其工作區。|
|[CWnd::OnPaletteIsChanging](#onpaletteischanging)|當應用程式即將實現其邏輯色板時通知其他應用程式。|
|[CWnd::OnParentNotify](#onparentnotify)|建立或終結子視窗時，或當使用者按一下滑鼠按鈕，而游標移至子視窗上方時，進行呼叫。|
|[CWnd::OnPowerBroadcast](#onpowerbroadcast)|電源管理事件發生時呼叫。|
|[CWnd::OnQueryDragIcon](#onquerydragicon)|最小化 (圖示化) `CWnd` 即將由使用者拖曳時呼叫。|
|[CWnd::OnQueryEndSession](#onqueryendsession)|當使用者選擇結束 Windows 工作階段時呼叫。|
|[CWnd::OnQueryNewPalette](#onquerynewpalette)|通知 `CWnd` 即將接收輸入焦點。|
|[CWnd::OnQueryOpen](#onqueryopen)|當 `CWnd` 是圖示，且使用者要求開啟圖示時呼叫。|
|[CWnd::OnQueryUIState](#onqueryuistate)|呼叫以擷取視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnRawInput](#onrawinput)|當目前視窗取得原始輸入時呼叫。|
|[CWnd::OnRButtonDblClk](#onrbuttondblclk)|當使用者按兩下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonDown](#onrbuttondown)|當使用者按下滑鼠右鍵時呼叫。|
|[CWnd::OnRButtonUp](#onrbuttonup)|當使用者放開滑鼠右鍵時呼叫。|
|[CWnd::OnRenderAllFormats](#onrenderallformats)|當擁有者應用程式正在被破壞，而且需要呈現其所有格式時呼叫。|
|[CWnd::OnRenderFormat](#onrenderformat)|需要呈現具有延遲轉譯需求的特定格式時，針對剪貼簿擁有者呼叫。|
|[CWnd::OnSessionChange](#onsessionchange)|呼叫以將工作階段狀態的變更通知應用程式。|
|[CWnd::OnSetCursor](#onsetcursor)|如果不擷取滑鼠輸入，而且滑鼠導致游標在視窗內移動，則呼叫。|
|[CWnd::OnSetFocus](#onsetfocus)|在 `CWnd` 取得輸入焦點後呼叫。|
|[CWnd::OnSettingChange](#onsettingchange)|當 Win32 `SystemParametersInfo` 函式變更整個系統的設定時呼叫。|
|[CWnd::OnShowWindow](#onshowwindow)|當 `CWnd` 要隱藏或顯示時呼叫。|
|[CWnd::OnSize](#onsize)|在 `CWnd` 大小變更後呼叫。|
|[CWnd::OnSizeClipboard](#onsizeclipboard)|當剪貼簿檢視器視窗中的工作區大小變更後呼叫。|
|[CWnd::OnSizing](#onsizing)|表示使用者正在重新調整矩形的大小。|
|[CWnd::OnSpoolerStatus](#onspoolerstatus)|每當加入工作或從列印管理員佇列中移除工作時，從列印管理員呼叫。|
|[CWnd::OnStyleChanged](#onstylechanged)|指示[SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) Windows 函數已更改視窗的一個或多個樣式。|
|[CWnd::OnStyleChanging](#onstylechanging)|指示[SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw) Windows 函數即將更改視窗的一個或多個樣式。|
|[CWnd::OnSysChar](#onsyschar)|按鍵轉譯為系統字元時呼叫。|
|[CWnd::OnSysColorChange](#onsyscolorchange)|當系統色彩設定中進行變更時，為所有最上層視窗呼叫。|
|[CWnd::OnSysCommand](#onsyscommand)|當使用者從 [控制] 功能表中選取命令時，或在使用者選取 [最大化] 或 [最小化] 按鈕時呼叫。|
|[CWnd::OnSysDeadChar](#onsysdeadchar)|當按鍵轉譯為系統無效字元 (例如強調符號) 時呼叫。|
|[CWnd::OnSysKeyDown](#onsyskeydown)|當使用者按住 ALT 鍵，然後按下另一個按鍵時呼叫。|
|[CWnd::OnSysKeyUp](#onsyskeyup)|當使用者在按住 ALT 鍵時放開按下的按鍵時呼叫。|
|[CWnd::OnTCard](#ontcard)|使用者按一下可設計的按鈕時呼叫。|
|[CWnd::OnTimeChange](#ontimechange)|在系統時間變更後，針對所有最上層視窗呼叫。|
|[CWnd::OnTimer](#ontimer)|在[SetTimer](#settimer)中指定的每個間隔之後調用。|
|[CWnd::OnTouchInput](#ontouchinput)|處理來自 Windows 觸控的單一輸入。|
|[CWnd::OnTouchInputs](#ontouchinputs)|處理來自 Windows 觸控的輸入。|
|[CWnd::OnUniChar](#onunichar)|按下按鍵時呼叫。 也就是說,當前視窗具有鍵盤焦點,並且[翻譯Message](/windows/win32/api/winuser/nf-winuser-translatemessage)函數將[WM_KEYDOWN](/windows/win32/inputdev/wm-keydown)消息翻譯。|
|[CWnd::OnUnInitMenuPopup](#onuninitmenupopup)|於下拉式功能表或子功能表被終結時呼叫。|
|[CWnd::OnUpdateUIState](#onupdateuistate)|呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。|
|[CWnd::OnUserChanged](#onuserchanged)|在使用者登入或登出後呼叫。|
|[CWnd::OnVKeyToItem](#onvkeytoitem)|由擁有`CWnd`的清單框調用,以回應[WM_KEYDOWN](#onkeydown)消息。|
|[CWnd::OnVScroll](#onvscroll)|當使用者按一下視窗的垂直捲軸時呼叫。|
|[CWnd::OnVScrollClipboard](#onvscrollclipboard)|當擁有者應該捲動剪貼簿影像、使適當的區段失效，及更新捲軸值時呼叫。|
|[CWnd::OnWindowPosChanged](#onwindowposchanged)|當大小、位置或 Z 順序因調用[SetWindowPos](#setwindowpos)或其他視窗管理功能而發生更改時調用。|
|[CWnd::OnWindowPosChanging](#onwindowposchanging)|當大小、位置或 Z 順序由於調用[SetWindowPos](#setwindowpos)或其他視窗管理功能而即將更改時調用。|
|[CWnd::OnWinIniChange](#onwininichange)|在 Windows 初始化檔案 (WIN.INI) 變更後，針所有最上層視窗呼叫。|
|[CWnd::OnWndMsg](#onwndmsg)|指出是否已處理視窗訊息。|
|[CWnd::OnXButtonDblClk](#onxbuttondblclk)|當使用者按兩下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonDown](#onxbuttondown)|當使用者按下 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::OnXButtonUp](#onxbuttonup)|當使用者放開 XBUTTON1 或 XBUTTON2，而游標位於視窗的工作區時呼叫。|
|[CWnd::PostNcDestroy](#postncdestroy)|此虛擬函數在視窗被銷毀後由預設[OnNc銷毀](#onncdestroy)函數調用。|
|[CWnd::ReflectChildNotify](#reflectchildnotify)|將訊息反映至其來源的 Helper 函式。|
|[CWnd::ReflectLastMsg](#reflectlastmsg)|將最後一個訊息反映到子視窗。|
|[CWnd::ResizeDynamicLayout](#resizedynamiclayout)|如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。|
|[CWnd::WindowProc](#windowproc)|提供 `CWnd` 的視窗程序。 透過訊息對應的預設分派訊息。|

### <a name="public-operators"></a>公用運算子

|名稱|描述|
|----------|-----------------|
|[HWND CWnd::operator](#operator_hwnd)|呼叫以取得視窗的控制代碼。|
|[CWnd::operator !=](#operator_neq)|確定視窗是否與句柄[m_hWnd](#m_hwnd)的視窗不同。|
|[CWnd::操作員 |](#operator_eq_eq)|確定視窗是否與句柄[為m_hWnd](#m_hwnd)的視窗相同。|

### <a name="public-data-members"></a>公用資料成員

|名稱|描述|
|----------|-----------------|
|[CWnd::m_hWnd](#m_hwnd)|指示附加到此`CWnd`的HWND。|

## <a name="remarks"></a>備註

`CWnd` 物件不同於 Windows 視窗，但兩者緊密連結。 `CWnd` 物件是由 `CWnd` 建構函式和解構函式所建立或終結。 另一方面,Windows 視窗是 Windows 內部的數據`Create`結構,由成員函數`CWnd`創建並由虛擬析構函數銷毀。 [銷毀視窗](#destroywindow)功能在不破壞對象的情況下銷毀 Windows 視窗。

類別`CWnd`與訊息映射機制隱藏函數`WndProc`。 傳入的 Windows 通知訊息通過消息映射自動路由到正確的 **「消息打開」**<em>Message</em>`CWnd`成員功能。 重寫 **「消息」**<em>Message</em>成員函數以處理派生類中成員的特定消息。

`CWnd` 類別也可讓您建立應用程式的 Windows 子視窗。 自 `CWnd` 衍生類別，然後將成員變數加入至衍生類別以儲存應用程式的特定資料。 實作訊息處理常式成員函式，和衍生類別中對應的訊息，以指定訊息被導向至視窗時會發生什麼事。

您在兩個步驟中建立子視窗。 首先,調用構造`CWnd`函數構`CWnd`造 物件,然後調用[Create](#create)成員函數以創建子視窗`CWnd`並將其附加到 物件。

當使用者終止子視窗時，摧毀 `CWnd` 物件，或呼叫 `DestroyWindow` 成員函式來移除視窗並摧毀其資料結構。

在 Microsoft Foundation 類別庫中，會自 `CWnd` 衍生進一步類別以提供特定的視窗類型。 其中許多類,包括CFrameWnd,CMDIFrameWnd,CMDIChildwnd,CView[CView](../../mfc/reference/cview-class.md)和[CDialog,](../../mfc/reference/cdialog-class.md)都是為進一步派生而[CFrameWnd](../../mfc/reference/cframewnd-class.md)[CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)[CMDIChildWnd](../../mfc/reference/cmdichildwnd-class.md)設計的。 派生自`CWnd`的控制項類(如[CButton)](../../mfc/reference/cbutton-class.md)可以直接使用,也可以用於進一步派生類。

有關`CWnd`使用的詳細資訊,請參閱[框架視窗](../../mfc/frame-windows.md)與[視窗物件](../../mfc/window-objects.md)。

## <a name="inheritance-hierarchy"></a>繼承階層架構

[CObject](../../mfc/reference/cobject-class.md)

[CCmdTarget](../../mfc/reference/ccmdtarget-class.md)

`CWnd`

## <a name="requirements"></a>需求

**標題:** afxwin.h

## <a name="cwndaccdodefaultaction"></a><a name="accdodefaultaction"></a>CWnd::accDo默認行動

由架構呼叫以執行物件的預設動作。

```
virtual HRESULT accDoDefaultAction(VARIANT varChild);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要調用的預設操作是對象的預設操作還是物件的子元素之一。 此參數可以是CHILDID_SELF(執行對象的預設操作)或子 ID(以執行物件一個子元素的預設操作)。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱「可存取」中的**返回值**::Windows SDK 中的[「accDoDefaultAction」。。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction)

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

重寫`CWnd`派生類中的此函數以執行物件的預設操作。 有關詳細資訊,請參閱 Windows SDK 中的[「可存取物件::accDoDefaultAction」。。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accdodefaultaction)

## <a name="cwndacchittest"></a><a name="acchittest"></a>CWnd::accHitTest

由架構呼叫以擷取畫面中給定點的子項目或子物件。

```
virtual HRESULT accHitTest(
    long xLeft,
    long yTop,
    VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*x 左*<br/>
要命中測試的點的 X 座標(以螢幕單位為單位)。

*yTop*<br/>
要命中測試的點的 Y 座標(以螢幕單位為單位)。

*普瓦爾兒童*<br/>
接收在*xLeft*和*yTop*指定的點識別物件的資訊。 請參閱[「可存取點::windows SDK 中的 pvarID:accHitTest」。。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-acchittest) *pvarID*

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::accHitTest` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::accHitTest」。。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-acchittest)

## <a name="cwndacclocation"></a><a name="acclocation"></a>CWnd::位置

由架構呼叫以擷取指定物件目前畫面的位置。

```
virtual HRESULT accLocation(
    long* pxLeft,
    long* pyTop,
    long* pcxWidth,
    long* pcyHeight,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*px 左*<br/>
接收物件的左上角(以螢幕單位為單位)的 x 座標。

*pyTop*<br/>
接收物件左上角(以屏幕單位為單位)的 y 座標。

*pcxWidth*<br/>
接收物件的寬度(以屏幕單位表示)。

*pcyHeight*<br/>
接收物件的高度(以屏幕單位為單位)。

*瓦爾兒童*<br/>
指定要檢索的位置是物件的位置還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::accLocation` SDK 的**傳回值**。

### <a name="remarks"></a>備註

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱`IAccessible::accLocation`Windows SDK。

## <a name="cwndaccnavigate"></a><a name="accnavigate"></a>CWnd::accNavigate

由架構呼叫以便於周遊容器內的另一使用者介面項目並擷取物件 (如果可能)。

```
virtual HRESULT accNavigate(
    long navDir,
    VARIANT varStart,
    VARIANT* pvarEndUpAt);
```

### <a name="parameters"></a>參數

*納夫迪爾*<br/>
指定要導航的方向。 請參閱[「可存取」](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accnavigate)中的*navDir::* 在 Windows SDK 中導航。

*varStart*<br/>
指定起始物件。 請參閱 Windows `IAccessible::accNavigate` SDK 中的 var*Start。*

*普瓦倫多普*<br/>
接收有關目標使用者介面物件的資訊。 請參閱 Windows SDK`IAccessible::accNavigate`中的*pvarEnd。*

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::accNavigate` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問:::accNavigate」。。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accnavigate)

## <a name="cwndaccselect"></a><a name="accselect"></a>CWnd::accSelect

由架構呼叫以修改選取或移動指定物件的鍵盤焦點。

```
virtual HRESULT accSelect(
    long flagsSelect,
    VARIANT varChild);
```

### <a name="parameters"></a>參數

*標誌選擇*<br/>
指定如何更改當前選擇或焦點。 請參閱 *「*[可存取」中的標誌選擇::在](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accselect)Windows SDK 中選擇。

*瓦爾兒童*<br/>
指定要選擇的物件。 此參數可以是CHILDID_SELF(選擇物件本身)或子 ID(以選擇物件的一個子項)。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::accSelect` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::accSelect」。。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-accselect)

## <a name="cwndanimatewindow"></a><a name="animatewindow"></a>CWnd::動畫視窗

顯示或隱藏視窗時產生特殊效果。

```
BOOL AnimateWindow(
    DWORD dwTime,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*dwTime*<br/>
指定播放動畫所需的時間(以毫秒為單位)。 通常,動畫需要 200 毫秒才能播放。

*dwFlags*<br/>
指定動畫類型。 有關可能值的完整清單,請參閱[AnimateWindow.](/windows/win32/api/winuser/nf-winuser-animatewindow)

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[AnimateWindow](/windows/win32/api/winuser/nf-winuser-animatewindow)的功能,如 Windows SDK 中所述。

## <a name="cwndarrangeiconicwindows"></a><a name="arrangeiconicwindows"></a>CWnd::排列圖示視窗

排列所有最小化 (圖示) 子視窗。

```
UINT ArrangeIconicWindows();
```

### <a name="return-value"></a>傳回值

如果函數成功,則一行圖示的高度;否則 0。

### <a name="remarks"></a>備註

此成員功能還排列桌面視窗中的圖示,該圖示涵蓋整個螢幕。 [Get DesktopWindow](#getdesktopwindow)成員函數檢索指向桌面視窗物件的指標。

在 MDI 用戶端視窗中安排旗標性的 MDI 子視窗,請致電[CMDIFrameWnd::MDIIcon 排列](../../mfc/reference/cmdiframewnd-class.md#mdiiconarrange)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#66](../../mfc/reference/codesnippet/cpp/cwnd-class_1.cpp)]

## <a name="cwndattach"></a><a name="attach"></a>CWnd::附加

將 Windows 視窗`CWnd`附加到 物件。

```
BOOL Attach(HWND hWndNew);
```

### <a name="parameters"></a>參數

*hWndNew*<br/>
指定 Windows 視窗的句柄。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="example"></a>範例

此示例展示如何使用附加和分離映射到 MDI 用戶端視窗。

[!code-cpp[NVC_MFCWindowing#67](../../mfc/reference/codesnippet/cpp/cwnd-class_2.h)]

[!code-cpp[NVC_MFCWindowing#68](../../mfc/reference/codesnippet/cpp/cwnd-class_3.cpp)]

[!code-cpp[NVC_MFCWindowing#69](../../mfc/reference/codesnippet/cpp/cwnd-class_4.cpp)]

## <a name="cwndbeginmodalstate"></a><a name="beginmodalstate"></a>CWnd::開始模式狀態

呼叫此成員函式以製作框架視窗強制回應。

```
virtual void BeginModalState();
```

## <a name="cwndbeginpaint"></a><a name="beginpaint"></a>CWnd::開始繪畫

準備`CWnd`繪畫,並填`PAINTSTRUCT`寫 有關繪畫的資訊的數據結構。

```
CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向用於接收繪畫資訊的[PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct)結構。

### <a name="return-value"></a>傳回值

標識`CWnd`的設備上下文。 指標可能是臨時的,不應存儲在[EndPaint](#endpaint)的範圍之外。

### <a name="remarks"></a>備註

繪製結構包含一個 RECT 資料結構,該結構具有完全包含更新區域的最小矩形和指定背景是否已擦除的標誌。

更新區域由[「無效](#invalidate)、[無效」](#invalidaterect)或[「無效 Rgn」](#invalidatergn)成員函數設定,並在系統調整、行動、創建、滾動或執行影響工作區的任何其他操作後設定。 如果將更新區域標記為已進行已更新,則`BeginPaint`發送[WM_ONERASEBKGND](#onerasebkgnd)消息。

不要調用成員函數`BeginPaint`,除非回應[WM_PAINT](#onpaint)消息。 對成員函數的每個`BeginPaint`調用都必須具有對[EndPaint](#endpaint)成員函數的匹配調用。 如果 care 在要繪製的區域`BeginPaint`中, 則成員函數會自動隱藏 caret,以防止其被擦除。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#70](../../mfc/reference/codesnippet/cpp/cwnd-class_5.cpp)]

## <a name="cwndbinddefaultproperty"></a><a name="binddefaultproperty"></a>CWnd::綁定默認屬性

將呼叫物件的預設簡單綁定屬性(如類型庫中標記的編輯控制項)綁定到資料來源控制項的 DataSource、使用者名、密碼和 SQL 屬性定義的基礎游標。

```cpp
void BindDefaultProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    LPCTSTR szFieldName,
    CWnd* pDSCWnd);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
指定要綁定到資料來源控制件的資料綁定控制項上屬性的DISPID。

*vtProp*<br/>
指定要綁定的屬性的類型,例如,VT_BSTR、VT_VARIANT等。

*szfield名稱*<br/>
指定列的名稱,在數據源控制件提供的游標中,該屬性將綁定到該列。

*pDSCWnd*<br/>
指向承載將屬性綁定到的數據源控制元件的視窗。 使用`GetDlgItem`DCS 的主機視窗的資源 ID 呼叫以檢索此指標。

### <a name="remarks"></a>備註

呼叫`CWnd`此函數的物件必須是數據綁定控制項。

### <a name="example"></a>範例

`BindDefaultProperty`可在以下內容中使用:

[!code-cpp[NVC_MFC_AxDataBinding#2](../../mfc/reference/codesnippet/cpp/cwnd-class_7.cpp)]

## <a name="cwndbindproperty"></a><a name="bindproperty"></a>CWnd::綁定財產

將數據綁定控件(如網格控件)上的遊標綁定屬性綁定到數據源控制項,並註冊與 MFC 綁定管理器的關係。

```cpp
void BindProperty(
    DISPID dwDispId,
    CWnd* pWndDSC);
```

### <a name="parameters"></a>參數

*dwDispId*<br/>
指定要綁定到資料來源控制件的資料綁定控制項上屬性的DISPID。

*pWndDSC*<br/>
指向承載將屬性綁定到的數據源控制元件的視窗。 使用`GetDlgItem`DCS 的主機視窗的資源 ID 呼叫以檢索此指標。

### <a name="remarks"></a>備註

呼叫`CWnd`此函數的物件必須是數據綁定控制項。

### <a name="example"></a>範例

`BindProperty`可在以下內容中使用:

[!code-cpp[NVC_MFC_AxDataBinding#4](../../mfc/reference/codesnippet/cpp/cwnd-class_9.cpp)]

## <a name="cwndbringwindowtotop"></a><a name="bringwindowtotop"></a>Cwnd::將視窗頂

將 `CWnd` 帶到重疊視窗堆疊的最上層。

```cpp
void BringWindowToTop();
```

### <a name="remarks"></a>備註

此外，`BringWindowToTop` 會啟用快顯、最上層和 MDI 子視窗。 需使用 `BringWindowToTop` 成員函式，才能顯示出重疊視窗部分或完全遮住的視窗。

此函數只是調用 Win32 [BringWindowTop](/windows/win32/api/winuser/nf-winuser-bringwindowtotop)函數。 呼叫[SetWindowPos](#setwindowpos)函數以更改視窗在 Z 順序中的位置。 `BringWindowToTop` 函式不會將視窗樣式變更為最上層視窗。 有關詳細資訊,請參閱[HWND_TOP和HWND_TOPMOST之間的區別](https://devblogs.microsoft.com/oldnewthing/?p=33263)

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#71](../../mfc/reference/codesnippet/cpp/cwnd-class_10.cpp)]

## <a name="cwndcalcwindowrect"></a><a name="calcwindowrect"></a>CWnd::卡爾視窗雷ct

計算可以包含指定客戶端矩形的視窗矩形。

```
virtual void CalcWindowRect(
    LPRECT lpClientRect,
    UINT nAdjustType = adjustBorder);
```

### <a name="parameters"></a>參數

*lpClientrect*<br/>
[進出]指向矩形結構的指標。 在輸入時,此結構包含用戶端矩形。 方法完成後,此結構包含可以包含指定用戶端矩形的視窗矩形。

*nAdjust 類型*<br/>
[在]用於`CWnd::adjustBorder`計算沒有WS_EX_CLIENTEDGE樣式的視窗座標;否則,請使用`CWnd::adjustOutside`。

### <a name="remarks"></a>備註

計算的視窗矩形的大小不包括功能表欄的空間。

有關更多使用限制,請參閱[調整 WindowrectEx](/windows/win32/api/winuser/nf-winuser-adjustwindowrectex)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#72](../../mfc/reference/codesnippet/cpp/cwnd-class_11.cpp)]

## <a name="cwndcanceltooltips"></a><a name="canceltooltips"></a>CWnd::取消工具提示

如果目前顯示工具提示,請呼叫此成員函數從螢幕中刪除工具提示。

```
static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
```

### <a name="parameters"></a>參數

*bKeys*<br/>
TRUE 在按下鍵時取消工具提示,並將狀態列文本設置為預設值;否則 FALSE。

### <a name="remarks"></a>備註

> [!NOTE]
> 使用此成員函數不會影響代碼管理的工具提示。 它只影響由 CWnd 管理的工具提示控制[::啟用工具提示](#enabletooltips)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#73](../../mfc/reference/codesnippet/cpp/cwnd-class_12.cpp)]

## <a name="cwndcenterwindow"></a><a name="centerwindow"></a>CWnd::中心視窗

將相對於其父系的視窗置中。

```cpp
void CenterWindow(CWnd* pAlternateOwner = NULL);
```

### <a name="parameters"></a>參數

*p替代擁有者*<br/>
指向將居中(父視窗以外的)的備用視窗的指標。

### <a name="remarks"></a>備註

通常從[CDialog 調用:onInitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)到相對於應用程式主視窗的中心對話方塊。 默認情況下,函數將子視窗相對於其父視窗和彈出視窗相對於其擁有者居中。 如果彈出視窗不擁有,則相對於螢幕,該視窗居中。 要將視窗相對於不是擁有者或父視窗的特定視窗居中 *,pAlternateOwner*參數可以設置為有效視窗。 要強制相對於螢幕進行居中,請傳遞[CWnd 傳回的值::取得桌面視窗](#getdesktopwindow)作為*p 備用擁有者*。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#74](../../mfc/reference/codesnippet/cpp/cwnd-class_13.cpp)]

## <a name="cwndchangeclipboardchain"></a><a name="changeclipboardchain"></a>CWnd::更改剪板鏈

從`CWnd`剪貼簿檢視器鏈中刪除,並使*hWndNext*指定的視窗`CWnd`成為鏈中 祖先的後代。

```
BOOL ChangeClipboardChain(HWND hWndNext);
```

### <a name="parameters"></a>參數

*hWndNext*<br/>
標識剪貼簿檢視器鏈`CWnd`中後面的視窗。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

## <a name="cwndcheckdlgbutton"></a><a name="checkdlgbutton"></a>CWnd::檢查DlgButton

選擇(將複選標記放在旁邊)或清除(從中刪除複選標記),或者更改三狀態按鈕的狀態。

```cpp
void CheckDlgButton(
    int nIDButton,
    UINT nCheck);
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定要修改的按鈕。

*N檢查*<br/>
指定要執行的操作。 如果*nCheck*是非`CheckDlgButton`零, 則成員函數在按鈕旁邊放置一個複選標記;如果 nCheck 為非零,則成員函數將檢查標記放在按鈕旁邊。如果為 0,則刪除複選標記。 對於三狀態按鈕,如果*nCheck*為 2,則按鈕狀態不確定。

### <a name="remarks"></a>備註

該`CheckDlgButton`函數向指定的按鈕發送[BM_SETCHECK](/windows/win32/Controls/bm-setcheck)消息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#75](../../mfc/reference/codesnippet/cpp/cwnd-class_14.cpp)]

## <a name="cwndcheckradiobutton"></a><a name="checkradiobutton"></a>CWnd::檢查無線按鈕

在組中選擇(向)給定的單選按鈕,並清除(從中刪除)組中的所有其他單選按鈕。

```cpp
void CheckRadioButton(
    int nIDFirstButton,
    int nIDLastButton,
    int nIDCheckButton);
```

### <a name="parameters"></a>參數

*nID 第一按鈕*<br/>
指定群組中第一個單選按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中最後一個單選按鈕的整數識別碼。

*NID 檢查按鈕*<br/>
指定要檢查的單選按鈕的整數識別碼。

### <a name="remarks"></a>備註

該`CheckRadioButton`函數向指定的單選按鈕發送[BM_SETCHECK](/windows/win32/Controls/bm-setcheck)訊息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#76](../../mfc/reference/codesnippet/cpp/cwnd-class_15.cpp)]

## <a name="cwndchildwindowfrompoint"></a><a name="childwindowfrompoint"></a>Cwnd::兒童視窗從點

確定屬於哪個`CWnd`子視窗(如果有)包含指定點。

```
CWnd* ChildWindowFromPoint(POINT point) const;

CWnd* ChildWindowFromPoint(
    POINT point,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*點*<br/>
指定要測試的點的客戶端座標。

*nflags*<br/>
指定要跳過的子視窗。 這裡可以是以下值的組合:

|值|意義|
|-----------|-------------|
|CWP_ALL|不要跳過任何子視窗|
|CWP_SKIPINVISIBLE|跳過不可見的子視窗|
|CWP_SKIPDISABLED|跳過已關閉的子視窗|
|CWP_SKIPTRANSPARENT|跳過透明子視窗|

### <a name="return-value"></a>傳回值

標識包含該點的子視窗。 如果給定點位於工作區之外,則為 NULL。 如果點位於工作區中,但不包含在任何子視窗中,`CWnd`則返回。

此成員函數將返回包含指定點的隱藏或禁用子視窗。

多個視窗可能包含給定點。 但是,此函數僅返回遇到的`CWnd`包含點的第一個視窗的 *。

返回`CWnd`的 * 可能是臨時的,不應存儲以供以後使用。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#77](../../mfc/reference/codesnippet/cpp/cwnd-class_16.cpp)]

## <a name="cwndclienttoscreen"></a><a name="clienttoscreen"></a>Cwnd::用戶端螢幕

將畫面上指定的點或矩形的用戶端座標，轉換為螢幕座標。

```cpp
void ClientToScreen(LPPOINT lpPoint) const;  void ClientToScreen(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
指向包含要轉換的用戶端`CPoint`座標的 POINT[結構](/windows/win32/api/windef/ns-windef-point)或物件。

*lpRect*<br/>
指向包含要轉換的客戶端座`CRect`標 的[RECT 結構](/windows/win32/api/windef/ns-windef-rect)或物件。

### <a name="remarks"></a>備註

成員`ClientToScreen`函`POINT`數`RECT`使用 或 結構中的客戶端座標或*lpPoint*`CPoint`或`CRect`*lpRect*指向的 或 物件來計算新的螢幕座標;然後,它將結構中的座標替換為新座標。 新的螢幕座標相對於系統顯示幕的左上角。

成員`ClientToScreen`函數假定給定的點或矩形位於客戶端座標中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#78](../../mfc/reference/codesnippet/cpp/cwnd-class_17.cpp)]

## <a name="cwndclosewindow"></a><a name="closewindow"></a>CWnd::關閉視窗

將視窗最小化。

```cpp
void CloseWindow();
```

### <a name="remarks"></a>備註

此成員函數類比函數[CloseWindow](/windows/win32/api/winuser/nf-winuser-closewindow)的功能,如 Windows SDK 中所述。

## <a name="cwndcontinuemodal"></a><a name="continuemodal"></a>CWnd::繼續模式化

[RunModalLoop](#runmodalloop)呼叫此成員函數以確定應退出模式狀態。

```
virtual BOOL ContinueModal();
```

### <a name="return-value"></a>傳回值

如果要繼續模式迴圈,則非零;0 呼叫[連接式態循環](#endmodalloop)。

### <a name="remarks"></a>備註

默認情況下,它返回非零直到`EndModalLoop`調用。

## <a name="cwndcreate"></a><a name="create"></a>CWnd::創建

創建指定的子視窗並將其附加到[CWnd](../../mfc/reference/cwnd-class.md)物件。

```
virtual BOOL Create(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    Const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CCreateContext* pContext = NULL);
```

### <a name="parameters"></a>參數

*lpszClass 名稱*<br/>
[在]包含已註冊系統視窗類名稱的 null 終止字串的指標;或預定義的系統視窗類的名稱。

*lpsz 視窗名稱*<br/>
[在]包含視窗顯示名稱的 null 終止字串的指標;否則 NULL 沒有視窗顯示名稱。

*dwStyle*<br/>
[在][視窗樣式](styles-used-by-mfc.md#window-styles)的位組合 (OR)。 WS_POPUP選項不是有效的樣式。

*矩形*<br/>
[在]視窗相對於父視窗左上角的大小和位置。

*pparentwnd*<br/>
[在]指向父視窗的指標。

*nID*<br/>
[在]視窗的識別碼。

*pContext*<br/>
[在]指向[CCreateContext](../../mfc/reference/ccreatecontext-structure.md)結構的指標,該結構用於自訂應用程式的文檔檢視體系結構。

### <a name="return-value"></a>傳回值

如果方法成功,則為 TRUE;否則 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow`現在,如果功能表為 NULL`CREATESTRUCT`且樣式包含WS_CHILD,則將其參數的 hMenu 成員分配給**此**指標。 要獲得正確的功能,請確保對話方塊控制項的 ID 不是 NULL。
>
> 此更改修復了託管/本機互操作方案中的崩潰。 中的`CWnd::Create`TRACE 語句提醒開發人員問題。

使用[Afx 註冊WndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函數註冊視窗類。 使用者定義的視窗類在註冊的模組中可用。

在`Create`方法返回之前和視窗變得可見之前調用[CWnd::onCreate](#oncreate)方法。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#79](../../mfc/reference/codesnippet/cpp/cwnd-class_18.cpp)]

## <a name="cwndcreateaccessibleproxy"></a><a name="createaccessibleproxy"></a>CWnd::建立可存取代理

建立指定物件的 Active Accessibility Proxy。

```
virtual HRESULT CreateAccessibleProxy(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
標識活動輔助功能代理訪問的物件。 可以是以下值之一

|值|意義|
|-----------|-------------|
|OBJID_CLIENT|引用視窗的工作區。|

*lParam*<br/>
提供其他與消息相關的資訊。

*pResult*<br/>
指向存儲結果代碼的 LRESULT 的指標。

### <a name="remarks"></a>備註

建立指定物件的 Active Accessibility Proxy。

## <a name="cwndcreatecaret"></a><a name="createcaret"></a>CWnd::創建關懷

為系統加斯特創建新形狀,並聲稱對該 care 的置置體的擁有權。

```cpp
void CreateCaret(CBitmap* pBitmap);
```

### <a name="parameters"></a>參數

*pBitmap*<br/>
標識定義貼貼形狀的位圖。

### <a name="remarks"></a>備註

位圖以前必須由[CBitmap::CreateBitmap](../../mfc/reference/cbitmap-class.md#createbitmap)成員函數[、CreateDIBitmap](/windows/win32/api/wingdi/nf-wingdi-createdibitmap) Windows 函數或[CBitmap:LoadBitmap](../../mfc/reference/cbitmap-class.md#loadbitmap)成員函數創建。

`CreateCaret`自動銷毀以前的護理形狀(如果有),無論哪個窗口擁有該圖。 創建後,該隱子最初將隱藏。 要顯示 caret,必須調用[ShowCaret](#showcaret)成員函數。

系統資源是共享資源。 `CWnd`僅當具有輸入焦點或處於活動狀態時,才應創建一個 care。 它應該在失去輸入焦點或變為非活動狀態之前銷毀該 care。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#80](../../mfc/reference/codesnippet/cpp/cwnd-class_19.cpp)]

## <a name="cwndcreatecontrol"></a><a name="createcontrol"></a>CWnd::建立控制

使用此成員函數可以創建一個 ActiveX 控件,該控件`CWnd`將由 物件在 MFC 程式中表示。

```
BOOL CreateControl(
    LPCTSTR pszClass,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);

BOOL CreateControl(
    REFCLSID clsid,
    LPCTSTR pszWindowName,
    DWORD dwStyle,
    const POINT* ppt,
    const SIZE* psize,
    CWnd* pParentWnd,
    UINT nID,
    CFile* pPersist = NULL,
    BOOL bStorage = FALSE,
    BSTR bstrLicKey = NULL);
```

### <a name="parameters"></a>參數

*pszClass*<br/>
此字串可能包含類的 OLE"短名稱"(ProgID),例如"CIRC3"。Circ3Ctrl.1" 該名稱需要與控制項註冊的相同名稱匹配。 或者,字串可能包含 CLSID 的字串形式,包含在大括弧中,例如"#9DBAFCCF-592F-101B-85CE-00608CEC297B}"。 在這兩種情況下,`CreateControl`將字串轉換為相應的類 ID。

*pszWindow名稱*<br/>
指向要在控制項中顯示的文本的指標。 設置控制項的標題或文字屬性的值(如果有)。 如果為 NULL,則控制的標題或文本屬性不會更改。

*dwStyle*<br/>
視窗樣式。 可用樣式列在「備註」 下。

*矩形*<br/>
指定控制項的大小和位置。 它可以是[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。

*Ppt*<br/>
指向包含控制項左上角`CPoint`的 POINT[結構](/windows/win32/api/windef/ns-windef-point)或物件。

*pSize*<br/>
包含控制器[SIZE](/windows/win32/api/windef/ns-windef-size)大小的 SIZE`CSize`結構或物件

*pparentwnd*<br/>
指定控制項的父視窗。 它不得為 NULL。

*nID*<br/>
指定控制項的識別碼。

*p 堅持*<br/>
指向包含控制項的持久狀態的[CFile](../../mfc/reference/cfile-class.md)的指標。 默認值為 NULL,指示控制項在不從任何持久儲存還原其狀態的情況下初始化自身。 如果不是 NULL,它應該是`CFile`指向 派生物件的指標,該物件包含控制件的持久數據,其形式是流或存儲。 此數據可能已保存在用戶端的上次啟動中。 `CFile`可以包含其他數據,但必須將其讀寫指標設置為調用`CreateControl`時持久性數據的第一個字節。

*b 儲存*<br/>
指示是否應將*pPersist*中的數據解釋為 IStorage 或 IStream 數據。 如果*pPersist*中的數據是儲存,*則 b 儲存*應為 TRUE。 如果*pPersist*中的數據是流,*則 b 儲存*應為 FALSE。 預設值為 FALSE。

*bstrLicKey*<br/>
可選的許可證金鑰資料。 僅創建需要運行時許可證密鑰的控制項才需要此資料。 如果控制項支援許可,則必須提供許可證金鑰才能成功建立控制項。 預設值是 NULL。

*Clsid*<br/>
控制項的唯一類別 ID。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`CreateControl`是[CWnd::建立](#create)函數的直接模擬,它為建立`CWnd`視窗 。 `CreateControl`創建 ActiveX 控制件而不是普通視窗。

只支援 Windows *dwStyle*標誌`CreateControl`的子集 :

- WS_VISIBLE 創建最初可見的視窗。 如果希望控件立即可見(如普通視窗),則需要。

- WS_DISABLED 創建最初禁用的視窗。 禁用的視窗無法接收使用者輸入。 如果控件具有"已啟用"屬性,則可以進行設置。

- WS_BORDER 創建具有細線邊框的視窗。 如果控件具有 BorderStyle 屬性,則可以進行設置。

- WS_GROUP 指定一組控制件的第一個控制項。 用戶可以使用方向鍵將鍵盤焦點從組中的一個控制項更改為下一個控制項。 在第一個控制項之後使用WS_GROUP樣式定義的所有控制項都屬於同一組。 具有WS_GROUP樣式的下一個控制項將結束組並啟動下一個組。

- WS_TABSTOP 指定可在使用者按下 TAB 鍵時接收鍵盤焦點的控制項。 按下 TAB 鍵會將鍵盤焦點更改為WS_TABSTOP樣式的下一個控制項。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#81](../../mfc/reference/codesnippet/cpp/cwnd-class_20.h)]

## <a name="cwndcreateex"></a><a name="createex"></a>CWnd::創建Ex

創建指定的視窗並將其附加到`CWnd`物件。

```
virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU nIDorHMenu,
    LPVOID lpParam = NULL);

virtual BOOL CreateEx(
    DWORD dwExStyle,
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName,
    DWORD dwStyle,
    const RECT& rect,
    CWnd* pParentWnd,
    UINT nID,
    LPVOID lpParam = NULL);
```

### <a name="parameters"></a>參數

*dwExStyle*<br/>
[擴展視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)的位組合 (OR);否則預設擴充視窗樣式為 NULL。

*lpszClass 名稱*<br/>
包含已註冊系統視窗類名稱的 null 終止字串的指標;或預定義的系統視窗類的名稱。

*lpsz 視窗名稱*<br/>
包含視窗顯示名稱的 null 終止字串的指標;否則 NULL 沒有視窗顯示名稱。

*dwStyle*<br/>
[視窗樣式](styles-used-by-mfc.md#window-styles)的位組合 (OR);否則預設視窗樣式為 NULL。

*x*<br/>
視窗與螢幕左側或父視窗的初始水平距離。

*Y*<br/>
視窗與螢幕頂部或父視窗的初始垂直距離。

*n 寬度*<br/>
視窗的寬度(以像素為單位)。

*nHeight*<br/>
視窗的高度(以像素為單位)。

*hwnd 家長*<br/>
對於子視窗,對父視窗的句柄;否則,如果視窗具有擁有者,則擁有者視窗的句柄。

*尼多爾赫梅*<br/>
對於子視窗,視窗 ID;否則,視窗的功能表的 ID。

*lpParam*<br/>
指向傳遞給[CWnd:::onCreate](#oncreate)方法的用戶數據在*lpCreateParams*欄位中。

*矩形*<br/>
視窗相對於螢幕或父視窗的大小和位置。

*pparentwnd*<br/>
對於子視窗,指向父視窗;否則,如果視窗具有擁有者,則指向所有者視窗。

*nID*<br/>
對於子視窗,視窗 ID;否則,視窗的功能表的 ID。

### <a name="return-value"></a>傳回值

如果方法成功,則為 TRUE;否則 FALSE。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow`現在,如果功能表為 NULL`CREATESTRUCT`且樣式包含WS_CHILD,則將其參數的 hMenu 成員分配給**此**指標。 要獲得正確的功能,請確保對話方塊控制項的 ID 不是 NULL。
>
> 此更改修復了託管/本機互操作方案中的崩潰。 中的`TRACE``CWnd::Create`語句提醒開發人員問題。

默認擴展視窗樣式為WS_EX_LEFT。 默認視窗樣式為WS_OVERLAPPED。

使用[Afx 註冊WndClass](../../mfc/reference/application-information-and-management.md#afxregisterwndclass)函數註冊視窗類。 使用者定義的視窗類在註冊的模組中可用。

子視窗的維度相對於父視窗工作區的左上角。 頂層視窗的尺寸相對於螢幕的左上角。

在`CreateEx`方法返回之前和視窗變得可見之前調用[CWnd::onCreate](#oncreate)方法。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#82](../../mfc/reference/codesnippet/cpp/cwnd-class_21.cpp)]

## <a name="cwndcreategraycaret"></a><a name="creategraycaret"></a>CWnd::創建格雷卡雷

為系統加斯特創建灰色矩形,並聲稱對圖特的擁有權。

```cpp
void CreateGrayCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*n 寬度*<br/>
指定卡斯特的寬度(以邏輯單位表示)。 如果此參數為 0,則寬度設置為系統定義的視窗邊框寬度。

*nHeight*<br/>
指定卡斯特的高度(以邏輯單位表示)。 如果此參數為 0,則高度設置為系統定義的視窗邊框高度。

### <a name="remarks"></a>備註

傾斜的形狀可以是一條線或一個塊。

參數*nWidth*和*nHeight*指定護套的寬度和高度(以邏輯單位為單位);確切的寬度和高度(以像素為單位)取決於映射模式。

使用SM_CXBORDER和SM_CYBORDER索引的[GetSystemMetricS](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 功能可以檢索系統的視窗邊框寬度或高度。 使用視窗邊框寬度或高度可確保在高解析度顯示幕上可以看到卡斯特。

成員`CreateGrayCaret`函數會自動銷毀以前的 caret 形狀(如果有),而不管哪個視窗擁有該圖。 創建後,該隱子最初將隱藏。 要顯示 caret,必須調用[ShowCaret](#showcaret)成員函數。

系統資源是共享資源。 `CWnd`僅當具有輸入焦點或處於活動狀態時,才應創建一個 care。 它應該在失去輸入焦點或變為非活動狀態之前銷毀該 care。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#83](../../mfc/reference/codesnippet/cpp/cwnd-class_22.cpp)]

## <a name="cwndcreatesolidcaret"></a><a name="createsolidcaret"></a>CWnd::創建固體卡丁

為系統加斯特創建一個實體矩形,並聲稱對圖特的擁有權。

```cpp
void CreateSolidCaret(
    int nWidth,
    int nHeight);
```

### <a name="parameters"></a>參數

*n 寬度*<br/>
指定卡斯特的寬度(以邏輯單位表示)。 如果此參數為 0,則寬度設置為系統定義的視窗邊框寬度。

*nHeight*<br/>
指定卡斯特的高度(以邏輯單位表示)。 如果此參數為 0,則高度設置為系統定義的視窗邊框高度。

### <a name="remarks"></a>備註

傾斜的形狀可以是一條線或塊。

參數*nWidth*和*nHeight*指定護套的寬度和高度(以邏輯單位為單位);確切的寬度和高度(以像素為單位)取決於映射模式。

使用SM_CXBORDER和SM_CYBORDER索引的[GetSystemMetricS](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 功能可以檢索系統的視窗邊框寬度或高度。 使用視窗邊框寬度或高度可確保在高解析度顯示幕上可以看到卡斯特。

成員`CreateSolidCaret`函數會自動銷毀以前的 caret 形狀(如果有),而不管哪個視窗擁有該圖。 創建後,該隱子最初將隱藏。 要顯示 caret,必須調用[ShowCaret](#showcaret)成員函數。

系統資源是共享資源。 `CWnd`僅當具有輸入焦點或處於活動狀態時,才應創建一個 care。 它應該在失去輸入焦點或變為非活動狀態之前銷毀該 care。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#84](../../mfc/reference/codesnippet/cpp/cwnd-class_23.cpp)]

## <a name="cwndcwnd"></a><a name="cwnd"></a>CWnd:Cwnd

建構 `CWnd` 物件。

```
CWnd();
```

### <a name="remarks"></a>備註

在調用[CreateEx](#createex)或[Create](#create)成員函數之前,不會創建和附加 Windows 視窗。

## <a name="cwnddefault"></a><a name="default"></a>CWnd::D

調用預設視窗過程。

```
LRESULT Default();
```

### <a name="return-value"></a>傳回值

取決於發送的消息。

### <a name="remarks"></a>備註

默認視窗過程為應用程式未處理的任何視窗消息提供預設處理。 此成員函數可確保處理每條消息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#85](../../mfc/reference/codesnippet/cpp/cwnd-class_24.cpp)]

## <a name="cwnddefwindowproc"></a><a name="defwindowproc"></a>CWnd::DefWindowProc

調用預設視窗過程,該過程為應用程式未處理的任何視窗消息提供預設處理。

```
virtual LRESULT DefWindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理的 Windows 訊息。

*wParam*<br/>
指定其他與消息相關的資訊。

*lParam*<br/>
指定其他與消息相關的資訊。

### <a name="return-value"></a>傳回值

取決於發送的消息。

### <a name="remarks"></a>備註

此成員函數可確保處理每條消息。 調用它的參數應與視窗過程接收的參數相同。

## <a name="cwnddeletetempmap"></a><a name="deletetempmap"></a>CWnd::DeleteTempMap

由`CWinApp`物件的空閑時間處理程式自動調用。

```
static void PASCAL DeleteTempMap();
```

### <a name="remarks"></a>備註

刪除`FromHandle`成員函數創建`CWnd`的任何臨時物件。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#86](../../mfc/reference/codesnippet/cpp/cwnd-class_25.cpp)]

## <a name="cwnddestroywindow"></a><a name="destroywindow"></a>CWnd::D

銷毀附加到`CWnd`物件的 Windows 視窗。

```
virtual BOOL DestroyWindow();
```

### <a name="return-value"></a>傳回值

如果視窗被破壞,則非零;否則 0。

### <a name="remarks"></a>備註

成員`DestroyWindow`函數向視窗發送適當的消息以停用它並刪除輸入焦點。 它還會破壞視窗的功能表、刷新應用程式佇列、銷毀未完成的計時器、刪除剪貼簿擁有權,並中斷「剪貼簿-查看器」鏈(如果`CWnd`位於查看器鏈的頂部)。 它將[WM_DESTROY](#ondestroy)和[WM_NCDESTROY](#onncdestroy)訊息發送到視窗。 它不會破壞物件`CWnd`。

`DestroyWindow`是執行清理的占位符。 因為它是`DestroyWindow`一個虛擬函數,它顯示在類視圖中的任何`CWnd`派生類中。 但是,即使您重寫`CWnd`派生類中的此函數`DestroyWindow`, 也不一定調用。 如果在`DestroyWindow`MFC 代碼中未呼叫,則必須在您自己的代碼中顯式調用它(如果希望呼叫它)。

例如,假設您在`DestroyWindow``CView`派生類中重寫了。 由於 MFC 原始碼`DestroyWindow`不`CFrameWnd`在其 任何 派生類中調用,因此除非顯`DestroyWindow`式調用它 ,否則不會調用重寫。

如果視窗是任何視窗的父視窗,則在銷毀父視窗時,這些子視窗將自動銷毀。 成員`DestroyWindow`函數首先銷毀子視窗,然後銷毀視窗本身。

成員`DestroyWindow`函數還銷毀由[CDialog:::create](../../mfc/reference/cdialog-class.md#create)創建的無模式對話方塊。

如果正在`CWnd`銷毀的是子視窗,並且沒有[設置WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)樣式,則[WM_PARENTNOTIFY](/windows/win32/inputmsg/wm-parentnotify)消息將發送到父級。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#87](../../mfc/reference/codesnippet/cpp/cwnd-class_26.cpp)]

## <a name="cwnddetach"></a><a name="detach"></a>CWnd::D埃塔奇

從 `CWnd` 物件卸離 Windows 控制代碼，並傳回控制代碼。

```
HWND Detach();
```

### <a name="return-value"></a>傳回值

到 Windows 物件的 HWND。

### <a name="example"></a>範例

  請參閱[CWnd 的範例::附加](#attach)。

## <a name="cwnddlgdirlist"></a><a name="dlgdirlist"></a>CWnd::DlgDirlist

使用檔案或目錄清單填入清單方塊。

```
int DlgDirList(
    LPTSTR lpPathSpec,
    int nIDListBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
包含路徑或檔案名的 null 連接端的字串。 `DlgDirList`修改此字串,該字串應足夠長以包含修改。 有關詳細資訊,請參閱以下"備註"部分。

*nIDListBox*<br/>
指定清單框的識別碼。 如果*nIDListBox*為`DlgDirList`0,則假定不存在清單框,並且不會嘗試填充清單框。

*nID靜態路徑*<br/>
指定用於顯示當前驅動器和目錄的靜態文本控制項的識別碼。 如果*nIDStaticPath*為`DlgDirList`0,則假定不存在此類文本控件。

*n 檔案類型*<br/>
指定要顯示的檔案的屬性。 它可以是以下值的任意組合:

- DDL_READWRITE沒有附加屬性的讀取寫入資料檔。

- DDL_READONLY唯讀檔。

- DDL_HIDDEN隱藏檔。

- DDL_SYSTEM系統檔。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE檔案

- DDL_POSTMSGSLB_DIR標誌。 如果設置了LB_DIR標誌,Windows 會將生成的消息放在應用程式`DlgDirList`的 佇列中;如果設置了 LB_DIR 標誌,則 Windows 將生成的消息放在應用程式的佇列中。否則,它們將直接發送到對話框過程。

- DDL_DRIVES驅動器。 如果設置了DDL_DRIVES標誌,則會自動設置DDL_EXCLUSIVE標誌。 因此,要創建包含驅動器和檔的目錄列表,必須調用`DlgDirList`兩次:一次使用DDL_DRIVES標誌集,一次使用列表其餘部分的標誌。

- DDL_EXCLUSIVE獨佔位。 如果設置了獨佔位,則僅列出指定類型的檔;如果設置了獨佔位位,則僅列出指定類型的檔。否則將列出指定類型的正常檔和檔。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

`DlgDirList`將[LB_RESETCONTENT](/windows/win32/Controls/lb-resetcontent)和[LB_DIR](/windows/win32/Controls/lb-dir)訊息發送到列表框。 它填充*nIDListBox*指定的清單框,包含與*lpPathSpec*給出的路徑匹配的所有檔案的名稱。

*lpPathSpec 參數*具有以下形式:

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中,*驅動器*是驅動器號,*目錄*是有效的目錄名稱,*檔名*是必須至少包含一個通配符的有效檔名。 通配符是一個問號 **(?),** 意思是匹配任何字元,和星號<strong>\*</strong>(), 這意味著匹配任意數量的字元。

如果為*lpPathSpec*指定 0 長字串,或是只指定目錄名稱但不包含任何檔案規範,則該字串將改變\*為 " 。\*".

如果*lpPathSpec*包含驅動器和/或目錄名稱,則在填充清單框之前,當前驅動器和目錄將更改為指定的驅動器和目錄。 *nIDStaticPath*標識的文本控制件也會使用新驅動器和/或目錄名稱進行更新。

填充清單框後,透過刪除路徑的驅動器和/或目錄部分來更新*lpPathSpec。*

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#88](../../mfc/reference/codesnippet/cpp/cwnd-class_27.cpp)]

## <a name="cwnddlgdirlistcombobox"></a><a name="dlgdirlistcombobox"></a>CWnd::DlgDirlistComboBox

使用檔案或目錄清單來填入下拉式方塊的清單方塊。

```
int DlgDirListComboBox(
    LPTSTR lpPathSpec,
    int nIDComboBox,
    int nIDStaticPath,
    UINT nFileType);
```

### <a name="parameters"></a>參數

*lpPathSpec*<br/>
包含路徑或檔案名的 null 連接端的字串。 `DlgDirListComboBox`修改此字串,因此此資料不應以字串文本的形式出現。 請參閱以下「備註」 部分。

*nIDComboBox*<br/>
在對話框中指定組合框的標識符。 如果*nIDComboBox*為`DlgDirListComboBox`0,則假定不存在組合框,並且不會嘗試填充組合框。

*nID靜態路徑*<br/>
指定用於顯示當前驅動器和目錄的靜態文本控制項的識別碼。 如果*nIDStaticPath*為`DlgDirListComboBox`0,則假定不存在此類文本控件。

*n 檔案類型*<br/>
指定要顯示檔案的 DOS 檔屬性。 它可以是以下值的任意組合:

- DDL_READWRITE沒有附加屬性的讀取寫入資料檔。

- DDL_READONLY唯讀檔。

- DDL_HIDDEN隱藏檔。

- DDL_SYSTEM系統檔。

- DDL_DIRECTORY 目錄。

- DDL_ARCHIVE檔案

- DDL_POSTMSGSCB_DIR標誌。 如果設置了CB_DIR標誌,Windows 會將生成的消息放在應用程式`DlgDirListComboBox`的 佇列中;如果設置了 CB_DIR標誌,則 Windows 將生成的消息放在應用程式的佇列中。否則,它們將直接發送到對話框過程。

- DDL_DRIVES驅動器。 如果設置了DDL_DRIVES標誌,則會自動設置DDL_EXCLUSIVE標誌。 因此,要創建包含驅動器和檔的目錄列表,必須調用`DlgDirListComboBox`兩次:一次使用DDL_DRIVES標誌集,一次使用列表其餘部分的標誌。

- DDL_EXCLUSIVE獨佔位。 如果設置了獨佔位,則僅列出指定類型的檔;如果設置了獨佔位位,則僅列出指定類型的檔。否則將列出指定類型的正常檔和檔。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果進行了清單,則為非零,甚至是空清單。 0 返回值表示輸入字串不包含有效的搜索路徑。

### <a name="remarks"></a>備註

`DlgDirListComboBox`將[CB_RESETCONTENT](/windows/win32/Controls/cb-resetcontent)消息和[CB_DIR](/windows/win32/Controls/cb-dir)訊息發送到組合框。 它填充*nIDComboBox*指定的組合框的清單框,包含與*lpPathSpec*給出的路徑匹配的所有檔的名稱。

*lpPathSpec 參數*具有以下形式:

`[drive:] [ [\u]directory[\idirectory]...\u] [filename]`

在此範例中,*驅動器*是驅動器號,*目錄*是有效的目錄名稱,*檔名*是必須至少包含一個通配符的有效檔名。 通配符是一個問號 **(?),** 意思是匹配任何字元,和星號<strong>\*</strong>(), 這意味著匹配任意數量的字元。

如果為*lpPathSpec*指定零長度字串,將使用目前目錄,並且不會修改*lpPathSpec。* 如果只指定目錄名稱,但不包含任何文件規範,則字串將更改為""。\*

如果*lpPathSpec*包含驅動器和/或目錄名稱,則在填充清單框之前,當前驅動器和目錄將更改為指定的驅動器和目錄。 *nIDStaticPath*標識的文本控制件也會使用新驅動器和/或目錄名稱進行更新。

填充組合框清單框後,通過刪除路徑的驅動器和/或目錄部分來更新*lpPathSpec。*

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#89](../../mfc/reference/codesnippet/cpp/cwnd-class_28.cpp)]

## <a name="cwnddlgdirselect"></a><a name="dlgdirselect"></a>CWnd::DlgDirSelect

從清單方塊擷取目前的選取範圍。

```
BOOL DlgDirSelect(
    LPTSTR lpString,
    int nIDListBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
指向要在清單框中接收當前選擇的緩衝區。

*nIDListBox*<br/>
在對話框中指定清單框的整數 ID。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它假定清單框已由[DlgDirList](#dlgdirlist)成員函數填充,並且所選內容是驅動器號、檔或目錄名稱。

成員`DlgDirSelect`函數將所選內容複製到*lpString*提供的緩衝區。 如果沒有選擇 *,lpString*不會更改。

`DlgDirSelect`將[LB_GETCURSEL](/windows/win32/Controls/lb-getcursel)和[LB_GETTEXT](/windows/win32/Controls/lb-gettext)訊息發送到清單框。

它不允許從清單框中返回多個檔名。 清單框不能是多選清單框。

## <a name="cwnddlgdirselectcombobox"></a><a name="dlgdirselectcombobox"></a>CWnd::DlgDirSelectComboBox

從下拉式方塊的清單方塊中擷取目前的選取範圍。

```
BOOL DlgDirSelectComboBox(
    LPTSTR lpString,
    int nIDComboBox);
```

### <a name="parameters"></a>參數

*lpString*<br/>
指向要接收所選路徑的緩衝區。

*nIDComboBox*<br/>
在對話框中指定組合框的整數 ID。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

它假定清單框已由[DlgDirListComboBox](#dlgdirlistcombobox)成員函數填充,並且所選內容是驅動器號、檔案或目錄名稱。

成員`DlgDirSelectComboBox`函數將所選內容複製到指定的緩衝區。 如果沒有選擇,則不會更改緩衝區的內容。

`DlgDirSelectComboBox`將[CB_GETCURSEL](/windows/win32/Controls/cb-getcursel)和[CB_GETLBTEXT](/windows/win32/Controls/cb-getlbtext)訊息發送到組合框。

它不允許從組合框中返回多個檔名。

## <a name="cwnddodataexchange"></a><a name="dodataexchange"></a>CWnd::DoDataExchange

由框架調用以交換和驗證對話框數據。

```
virtual void DoDataExchange(CDataExchange* pDX);
```

### <a name="parameters"></a>參數

*pDX*<br/>
`CDataExchange` 物件的指標。

### <a name="remarks"></a>備註

切勿直接調用此函數。 它由[UpdateData](#updatedata)成員函數調用。 調用`UpdateData`以初始化對話框的控制項或從對話框檢索資料。

從[CDialog](../../mfc/reference/cdialog-class.md)派生特定於應用程式的對話方塊類時,如果要利用框架的自動資料交換和驗證,則需要重寫此成員函數。 "添加變數"嚮導將為您編寫此成員函數的重寫版本,其中包含對話框資料交換 (DDX) 和驗證 (DDV) 全域函數調用所需的"數據映射"。

要自動生成此成員函數的重寫版本,請先使用對話方塊編輯器創建對話方塊資源,然後派生特定於應用程式的對話方塊類。 然後,使用"添加變數"嚮導將變數、數據和驗證範圍與新對話方塊中的各種控制項相關聯。 然後,嚮導將寫入包含資料`DoDataExchange`映射的重寫 的 。a。 下面是新增變數精靈產生的 DDX/DDV 程式圖示例:

[!code-cpp[NVC_MFCWindowing#90](../../mfc/reference/codesnippet/cpp/cwnd-class_29.cpp)]

`DoDataExchange`重寫的成員函數必須位於源檔中的宏語句之前。

有關對話框資料交換與認證的詳細資訊,請參閱在[表單中顯示與操作資料](../../data/odbc/displaying-and-manipulating-data-in-a-form.md)以及[對話框資料交換與驗證](../../mfc/dialog-data-exchange-and-validation.md)。 有關添加變數精靈生成的DDX_和DDV_宏的說明,請參閱[技術說明 26](../../mfc/tn026-ddx-and-ddv-routines.md)。

## <a name="cwnddragacceptfiles"></a><a name="dragacceptfiles"></a>CWnd::D拉格接受檔

在應用程式的`CWnd`[CWinApp::initA 函數](../../mfc/reference/cwinapp-class.md#initinstance)中使用指標從視窗內呼叫此成員函數,以指示視窗接受從 Windows 檔管理器或檔資源管理器中刪除的檔。

```cpp
void DragAcceptFiles(BOOL bAccept = TRUE);
```

### <a name="parameters"></a>參數

*B 接受*<br/>
指示是否接受拖動檔的標誌。

### <a name="remarks"></a>備註

只有使用`DragAcceptFiles`*bAccept*參數設定為 TRUE 呼叫的視窗才識別自己能夠處理 Windows 消息WM_DROPFILES。 例如,在 MDI 應用程式中,`CMDIFrameWnd``DragAcceptFiles`如果在函數調用中使用視窗指標,則`CMDIFrameWnd`只有視窗獲取WM_DROPFILES消息。 此消息不會發送到所有打開`CMDIChildWnd`的視窗。 要接收`CMDIChildWnd`此消息的視窗,必須`DragAcceptFiles``CMDIChildWnd`使用 視窗指標呼叫。

要停止接收被拖的檔,請調用成員函數,將*bAccept*設置為 FALSE。

## <a name="cwnddragdetect"></a><a name="dragdetect"></a>CWnd::D拉格檢測

擷取滑鼠並追蹤其移動，直到使用者放開左側按鈕、按下 ESC 鍵，或將滑鼠移到指定點周圍的拖曳矩形外。

```
BOOL DragDetect(POINT pt) const;
```

### <a name="parameters"></a>參數

*pt*<br/>
滑鼠的初始位置,位於螢幕座標中。 函數使用此點確定拖動矩形的座標。

### <a name="return-value"></a>傳回值

如果使用者按住左鍵時將滑鼠移到拖動矩形之外,則返回值為非零。

如果使用者按住左鍵時未將滑鼠移到拖動矩形之外,則返回值為零。

### <a name="remarks"></a>備註

此成員函數類比函數[DragDetect](/windows/win32/api/winuser/nf-winuser-dragdetect)的功能,如 Windows SDK 中所述。

## <a name="cwnddrawanimatedrects"></a><a name="drawanimatedrects"></a>CWnd::D原始動畫Rects

繪製框線矩形，並以動畫效果呈現它來指出圖示的開頭，或最小化或最大化視窗。

```
BOOL DrawAnimatedRects(
    int idAni,
    CONST RECT* lprcFrom,
    CONST RECT* lprcTo);
```

### <a name="parameters"></a>參數

*伊德安尼*<br/>
指定動畫類型。 如果指定IDANI_CAPTION,視窗標題將從*lprcFrom*指定的位置到*lprcTo*指定的位置進行動畫處理。 效果類似於最小化或最大化視窗。

*lprc 從*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構的指標,指定圖示的位置和大小或最小化的視窗。

*利浦帕托*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)結構的指標,指定回復視窗的位置和大小

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[DrawAnimatedRects](/windows/win32/api/winuser/nf-winuser-drawanimatedrects)的功能,如 Windows SDK 中所述。

## <a name="cwnddrawcaption"></a><a name="drawcaption"></a>CWnd::D原始標題

繪製視窗標題。

```
BOOL DrawCaption(
    CDC* pDC,
    LPCRECT lprc,
    UINT uFlags);
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。 該函數將視窗標題繪製到此設備上下文中。

*利赫浦*<br/>
指向 RECT 結構的指標,用於指定視窗標題的邊界矩形。

*uFlags*<br/>
指定繪圖選項。 有關值的完整清單,請參閱[繪製標題](/windows/win32/api/winuser/nf-winuser-drawcaption)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[DrawCaption](/windows/win32/api/winuser/nf-winuser-drawcaption)的功能,如 Windows SDK 中所述。

## <a name="cwnddrawmenubar"></a><a name="drawmenubar"></a>CWnd::D原始選單欄

重新繪製功能表列。

```cpp
void DrawMenuBar();
```

### <a name="remarks"></a>備註

如果在 Windows 創建視窗後更改了功能表欄,請調用此函數以繪製已更改的菜單欄。

### <a name="example"></a>範例

  請參閱[CWnd 的範例::取得選單](#getmenu)。

## <a name="cwndenableactiveaccessibility"></a><a name="enableactiveaccessibility"></a>CWnd::啟用主動輔助功能

啟用使用者定義的活動輔助功能。

```cpp
void EnableActiveAccessibility();
```

### <a name="remarks"></a>備註

MFC 的默認活動輔助功能支援足以用於標準視窗和控制,包括 ActiveX 控制項;但是,如果`CWnd`派生類包含非視窗用戶介面元素,MFC 無法知道它們。 在這種情況下,必須重寫類中的相應[活動輔助功能成員函數](/windows/win32/winauto/sdk-components),並且必須`EnableActiveAccessibility`調用 類的構造函數。

## <a name="cwndenabledynamiclayout"></a><a name="enabledynamiclayout"></a>CWnd::啟用動態佈局

啟用或停用動態配置管理員。 啟用動態配置時，會在使用者調整視窗大小時動態調整子視窗的位置與大小。

```cpp
void EnableDynamicLayout(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*b 啟用*<br/>
TRUE 表示啟用動態配置；FALSE 則停用動態配置。

### <a name="remarks"></a>備註

如果您想要啟用動態配置，除了呼叫這個方法之外，還必須執行其他作業。 您還必須提供動態配置資訊，該資訊指定視窗中的控制項如何回應大小變更。 您可以在資源編輯器中或以程式設計方式，為每個控制項指定這項資訊。 請參考[動態佈局](../../mfc/dynamic-layout.md)。

## <a name="cwndenabled2dsupport"></a><a name="enabled2dsupport"></a>CWnd::啟用D2D支援

啟用或停用視窗 D2D 支援。 初始化主視窗之前先呼叫這個方法。

```cpp
void EnableD2DSupport(
    BOOL bEnable = TRUE,
    BOOL bUseDCRenderTarget = FALSE);
```

### <a name="parameters"></a>參數

*b 啟用*<br/>
指定是否開啟或關閉 D2D 支援。

*bUseDCRender 目標*<br/>
指定是否要使用裝置內容 (DC) 呈現目標 CDCRenderTarget。 如果為 FALSE，則會使用 CHwndRenderTarget。

## <a name="cwndenablescrollbar"></a><a name="enablescrollbar"></a>CWnd::啟用滾動條

啟用或停用一個捲軸的一或兩個箭號。

```
BOOL EnableScrollBar(
    int nSBFlags,
    UINT nArrowFlags = ESB_ENABLE_BOTH);
```

### <a name="parameters"></a>參數

*nSBFlags*<br/>
指定滾動條類型。 可以具有下列其中一個值：

- SB_BOTH 啟用或禁用與視窗關聯的水準和垂直滾動條的箭頭。

- SB_HORZ 啟用或禁用與視窗關聯的水準滾動條的箭頭。

- SB_VERT 啟用或禁用與視窗關聯的垂直滾動條的箭頭。

*nArrowFlags*<br/>
指定滾動條箭頭是啟用還是禁用,以及啟用或禁用哪些箭頭。 可以具有下列其中一個值：

- ESB_ENABLE_BOTH 啟用滾動條的兩個箭頭(預設值)。

- ESB_DISABLE_LTUP禁用水平滾動條的左箭頭或垂直滾動條的向上箭頭。

- ESB_DISABLE_RTDN禁用水平滾動條的右箭頭或垂直滾動條的向下箭頭。

- ESB_DISABLE_BOTH禁用滾動條的兩個箭頭。

### <a name="return-value"></a>傳回值

如果箭頭已啟用或禁用(如指定)則為非零。 否則為 0,表示箭頭已處於請求狀態或發生錯誤。

## <a name="cwndenablescrollbarctrl"></a><a name="enablescrollbarctrl"></a>CWnd::啟用ScrollBarCtrl

啟用或禁用此視窗的滾動條。

```cpp
void EnableScrollBarCtrl(
    int nBar,
    BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
滾動條標識碼。

*b 啟用*<br/>
指定是啟用還是禁用滾動條。

### <a name="remarks"></a>備註

如果視窗具有同級滾動條控件,則使用該滾動條;如果視窗具有同級滾動條控制項,則使用該滾動條。否則使用視窗自己的滾動條。

## <a name="cwndenabletooltips"></a><a name="enabletooltips"></a>CWnd::啟用工具提示

為給定視窗啟用工具提示。

```
BOOL EnableToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*b 啟用*<br/>
指定工具尖端控制項是啟用還是禁用。 TRUE 啟用控件;FALSE 禁用控制項。

### <a name="return-value"></a>傳回值

如果啟用了工具提示,則為 TRUE;否則 FALSE。

### <a name="remarks"></a>備註

覆寫[OnToolHitTest,](#ontoolhittest)為視窗提供[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)結構或結構。

> [!NOTE]
> 某些視窗(如[CToolBar)](../../mfc/reference/ctoolbar-class.md)提供了[OnToolHitTest 的](#ontoolhittest)內建實現。

有關此結構的詳細資訊,請參閱 Windows SDK 中的[TOOLINFO。](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)

除非父`EnableToolTips`視窗派生`CFrameWnd`自 ,否則僅調用不足以顯示子控件的工具提示。 這是因為`CFrameWnd`為TTN_NEEDTEXT通知提供了默認處理程式。 如果父視窗不是派生自`CFrameWnd`,即,如果它是對話框或窗體視圖,則子控件的工具提示將不能正確顯示,除非您為TTN_NEEDTEXT工具提示通知提供了處理程式。 請參考[工具提示](../../mfc/tool-tips-in-windows-not-derived-from-cframewnd.md)。

為視窗提供的預設工具提示`EnableToolTips`沒有與其關聯的文本。 要檢索要顯示的工具提示的文本,TTN_NEEDTEXT通知在顯示工具提示視窗之前發送到工具提示控制件的父視窗。 如果此消息沒有處理程式為`TOOLTIPTEXT`結構的*pszText*成員分配一些值,則工具提示將不會顯示任何文本。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#91](../../mfc/reference/codesnippet/cpp/cwnd-class_30.cpp)]

[!code-cpp[NVC_MFCWindowing#92](../../mfc/reference/codesnippet/cpp/cwnd-class_31.cpp)]

## <a name="cwndenabletrackingtooltips"></a><a name="enabletrackingtooltips"></a>CWnd::啟用追蹤工具提示

啟用或禁用跟蹤工具提示。

```
BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*b 啟用*<br/>
指定是啟用跟蹤工具提示還是禁用。 如果此參數為 TRUE,將啟用跟蹤工具提示。 如果此參數為 FALSE,則將禁用跟蹤工具提示。

### <a name="return-value"></a>傳回值

指示調用`EnableWindow`成員函數之前的狀態。 如果以前禁用了視窗,則返回值為非零。 如果以前啟用了視窗或發生錯誤,則返回值為 0。

### <a name="remarks"></a>備註

追蹤工具提示是工具提示視窗,您可以在螢幕上動態定位。 通過快速更新位置,工具尖端視窗似乎移動平穩,或"跟蹤"。 如果需要工具提示文本在指標移動時跟隨指標的位置,此功能非常有用。

## <a name="cwndenablewindow"></a><a name="enablewindow"></a>CWnd::啟用視窗

啟用或停用滑鼠和鍵盤輸入。

```
BOOL EnableWindow(BOOL bEnable = TRUE);
```

### <a name="parameters"></a>參數

*b 啟用*<br/>
指定是啟用還是禁用給定視窗。 如果此參數為 TRUE,則將啟用該視窗。 如果此參數為 FALSE,則視窗將被禁用。

### <a name="return-value"></a>傳回值

指示調用`EnableWindow`成員函數之前的狀態。 如果以前禁用了視窗,則返回值為非零。 如果以前啟用了視窗或發生錯誤,則返回值為 0。

### <a name="remarks"></a>備註

禁用輸入后,將忽略滑鼠按一下和擊鍵等輸入。 啟用輸入後,視窗將處理所有輸入。

如果啟用的狀態正在更改,則在返回此函數之前發送[WM_ENABLE](#onenable)訊息。

如果禁用,則所有子視窗都隱式禁用,儘管它們未WM_ENABLE消息發送。

必須先啟用視窗,然後才能啟動它。 例如,如果應用程式顯示無模式對話框並禁用其主視窗,則必須在銷毀對話框之前啟用主視窗。 否則,另一個視窗將獲得輸入焦點並啟動。 如果禁用了子視窗,則當 Windows 嘗試確定哪個視窗應獲取滑鼠訊息時,將忽略該視窗。

默認情況下,創建視窗時將啟用該視窗。 應用程式可以在[「創建](#create)」或[「CreateEx」](#createex)成員函數中指定WS_DISABLED樣式,以創建最初禁用的視窗。 創建視窗後,應用程式還可以使用`EnableWindow`成員函數啟用或禁用該視窗。

應用程式可以使用此函數啟用或禁用對話方塊中的控制項。 禁用的控制項無法接收輸入焦點,使用者也無法訪問它。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#93](../../mfc/reference/codesnippet/cpp/cwnd-class_32.cpp)]

## <a name="cwndendmodalloop"></a><a name="endmodalloop"></a>CWnd::結束模態迴圈

終止對`RunModalLoop`的調用。

```
virtual void EndModalLoop(int nResult);
```

### <a name="parameters"></a>參數

*nResult*<br/>
包含要返回給[RunModalLoop](#runmodalloop)呼叫方的值。

### <a name="remarks"></a>備註

*NResult*參數從 傳送`RunModalLoop`到傳回值 。

## <a name="cwndendmodalstate"></a><a name="endmodalstate"></a>CWnd::結束模式狀態

呼叫此成員函式，將框架視窗從強制回應變更為非強制回應。

```
virtual void EndModalState();
```

## <a name="cwndendpaint"></a><a name="endpaint"></a>CWnd::結束油漆

標記給定視窗中繪畫的結束。

```cpp
void EndPaint(LPPAINTSTRUCT lpPaint);
```

### <a name="parameters"></a>參數

*lpPaint*<br/>
指向包含[BeginPaint](#beginpaint)成員函數檢索的繪製資訊的[PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct)結構。

### <a name="remarks"></a>備註

每次`EndPaint`調`BeginPaint`用 成員函數都需要成員函數,但僅在繪製完成後完成。

如果參數被成員函數隱藏,`BeginPaint``EndPaint`則將 care 還原到螢幕。

### <a name="example"></a>範例

  請參閱[CWnd 的範例::開始繪製](#beginpaint)。

## <a name="cwndexecutedlginit"></a><a name="executedlginit"></a>Cwnd::執行Dlginit

初始化對話方塊資源。

```
BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
BOOL ExecuteDlgInit(LPVOID lpResource);
```

### <a name="parameters"></a>參數

*lpsz 資源名稱*<br/>
指定資源名稱的 null 連接字串的指標。

*lp資源*<br/>
指向資源的指標。

### <a name="return-value"></a>傳回值

如果執行了對話框資源,則為 TRUE;如果執行了對話方塊資源,則為 TRUE。否則 FALSE。

### <a name="remarks"></a>備註

`ExecuteDlgInit`將使用綁定到執行模組的資源,或從其他源中使用的資源。 為此,`ExecuteDlgInit`通過調`AfxFindResourceHandle`用 查找資源句柄。 如果您的 MFC 應用程式不使用共用 DLL (MFCx0[U][D])。DLL),`AfxFindResourceHandle`呼叫[AfxGetResourceHandle](application-information-and-management.md#afxgetresourcehandle),它傳回可執行檔的目前資源句柄。 如果您的 MFC 應用程式使用 MFCx0[U][D]。DLL,`AfxFindResourceHandle`走過分享`CDynLinkLibrary`和 MFC 延伸 DLL 的物件清單,以尋找正確的資源句柄。

## <a name="cwndfiltertooltipmessage"></a><a name="filtertooltipmessage"></a>CWnd::過濾器工具提示訊息

由框架調用以顯示工具提示訊息。

```cpp
void FilterToolTipMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
指向工具提示消息的指標。

### <a name="remarks"></a>備註

在大多數 MFC 應用程式中,此方法由[預翻譯訊息](#pretranslatemessage)和[啟用工具提示](#enabletooltips)的框架調用,您不需要自己調用它。

但是,在某些應用程式中(例如某些 ActiveX 控件)中,框架可能不會調用這些方法,您需要自己調用 FilterToolTipMessage。 有關詳細資訊,請參閱[建立工具提示的方法](../../mfc/methods-of-creating-tool-tips.md)。

## <a name="cwndfindwindow"></a><a name="findwindow"></a>CWnd::尋找視窗

返回其視窗類由`CWnd` *lpszClassName*提供,其視窗名稱或標題由*lpszWindowName*提供的頂級級別。

```
static CWnd* PASCAL FindWindow(
    LPCTSTR lpszClassName,
    LPCTSTR lpszWindowName);
```

### <a name="parameters"></a>參數

*lpszClass 名稱*<br/>
指定視窗的類別名稱(`WNDCLASS`結構)的 null 連接端的字串。 如果*lpClassName*為 NULL,則所有類名稱都匹配。

*lpsz 視窗名稱*<br/>
指定視窗名稱(視窗標題)的 null 連接端的字串。 如果*lpWindowName*為 NULL,則所有視窗名稱都匹配。

### <a name="return-value"></a>傳回值

標識具有指定類名稱和視窗名稱的視窗。 如果未找到此類視窗,則為 NULL。

`CWnd`* 可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

此功能不搜索子視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#94](../../mfc/reference/codesnippet/cpp/cwnd-class_33.cpp)]

## <a name="cwndfindwindowex"></a><a name="findwindowex"></a>CWnd::尋找視窗Ex

檢索類名稱和視窗名稱與指定字串匹配的視窗物件。

```
static CWnd* FindWindowEx(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCTSTR lpszClass,
    LPCTSTR lpszWindow);
```

### <a name="parameters"></a>參數

*hwnd 家長*<br/>
要搜索其子視窗的父視窗的句柄。

*hwndChild 後*<br/>
處理子視窗。 搜索以 Z 順序的下一個子窗口開始。 子窗口必須是*hwndParent*的直接子視窗,而不僅僅是後代視窗。

*lpszClass*<br/>
指向 null 連接連接字串的指標,該字串指定以前對[註冊類](/windows/win32/api/winuser/nf-winuser-registerclassw)或[RegisterClassEx](/windows/win32/api/winuser/nf-winuser-registerclassexw)的呼叫創建的類名稱或類原子。

*lpszWindow*<br/>
指定視窗名稱(視窗標題)的 null 連接端的字串的指標。 如果此參數為 NULL,則所有視窗名稱都匹配。

### <a name="return-value"></a>傳回值

如果函數成功,則返回值是指向具有指定類和視窗名稱的視窗物件的指標。 如果函數失敗,則返回值為 NULL。

### <a name="remarks"></a>備註

此成員函數類比函數[FindWindowEx](/windows/win32/api/winuser/nf-winuser-findwindowexw)的功能,如 Windows SDK 中所述。

## <a name="cwndflashwindow"></a><a name="flashwindow"></a>CWnd::快閃記憶體視窗

閃爍給定視窗一次。

```
BOOL FlashWindow(BOOL bInvert);
```

### <a name="parameters"></a>參數

*b 反轉*<br/>
指定`CWnd`是閃爍還是返回到其原始狀態。 如果`CWnd` *binvert*為 TRUE,則從一種狀態閃爍到另一種狀態。 如果*bInvert*為 FALSE,則視窗將返回到其原始狀態(活動或非活動狀態)。

### <a name="return-value"></a>傳回值

如果視窗在調用`FlashWindow`成員函數之前處於活動狀態,則非零;否則 0。

### <a name="remarks"></a>備註

對於連續閃爍,建立一個系統計時器並重複`FlashWindow`呼叫 。 閃爍`CWnd`意味著更改其標題列的外觀`CWnd`, 就像從非活動狀態更改為活動狀態一樣,反之亦然。 (非活動標題列更改為活動標題列;活動標題列更改為非活動標題列。

通常,視窗會閃爍,以通知使用者它需要注意,但它當前沒有輸入焦點。

僅當視窗獲取輸入焦點且不再閃爍時 *,bInvert*參數應為 FALSE;在等待輸入焦點時,在連續調用時應為 TRUE。

對於最小化的視窗,此功能始終返回非零。 如果視窗最小化,`FlashWindow`只需閃爍視窗的圖示;*b 對*最小化的視窗忽略反轉。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#95](../../mfc/reference/codesnippet/cpp/cwnd-class_34.cpp)]

## <a name="cwndflashwindowex"></a><a name="flashwindowex"></a>CWnd::快閃記憶體視窗Ex

閃爍給定的視窗。

```
BOOL FlashWindowEx(
    DWORD dwFlags,
    UINT uCount,
    DWORD dwTimeout);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定快閃記憶體狀態。 有關值的完整清單,請參閱[FLASHWINFO](/windows/win32/api/winuser/ns-winuser-flashwinfo)結構。

*u( U) Count*<br/>
指定閃爍視窗的次數。

*dwTimeout*<br/>
指定視窗閃爍的速率(以毫秒為單位)。 如果*dwTimeout*為零,則函數使用預設游標閃爍速率。

### <a name="return-value"></a>傳回值

返回值指定視窗在調用`FlashWindowEx`函數之前的狀態。 如果在調用之前將視窗標題繪製為活動,則返回值為非零。 否則,返回值為零。

### <a name="remarks"></a>備註

此方法類比函數[FlashWindowEx](/windows/win32/api/winuser/nf-winuser-flashwindowex)的功能,如 Windows SDK 中所述。

## <a name="cwndfromhandle"></a><a name="fromhandle"></a>Cwnd::從手

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

```
static CWnd* PASCAL FromHandle(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
視窗的 HWND。

### <a name="return-value"></a>傳回值

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。

該指標可能是暫時性的，因此不應該儲存供日後使用。

## <a name="cwndfromhandlepermanent"></a><a name="fromhandlepermanent"></a>Cwnd::從處理永久

將控制代碼提供給視窗時，將指標傳回至 `CWnd` 物件。

```
static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
視窗的 HWND。

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。

### <a name="remarks"></a>備註

如果物件`CWnd`未附加到句柄,則傳回 NULL。

與[FromHandle](#fromhandle)不同,此函數不創建臨時物件。

## <a name="cwndget_accchild"></a><a name="get_accchild"></a>CWnd:get_accChild

由架構呼叫以擷取指定子系的 `IDispatch` 介面位址。

```
virtual HRESULT get_accChild(
    VARIANT varChild,
    IDispatch** ppdispChild);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
標識要檢索其`IDispatch`介面的子級。

*ppdispChild*<br/>
接收子物件的`IDispatch`介面的位址。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取」](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchild)中的**傳回值**::get_accChild在 Windows SDK 中。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::get_accChild。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchild)

## <a name="cwndget_accchildcount"></a><a name="get_accchildcount"></a>CWnd:get_accChildCount

由架構呼叫以擷取屬於此物件的子物件數目。

```
virtual HRESULT get_accChildCount(long* pcountChildren);
```

### <a name="parameters"></a>參數

*計數兒童*<br/>
接收子級數。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取:::get_accChildCount](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchildcount) Windows SDK 中的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。 呼叫基類版本,然後添加非視窗子元素。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::get_accChildCount。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accchildcount)

## <a name="cwndget_accdefaultaction"></a><a name="get_accdefaultaction"></a>CWnd:get_accDefaultAction

由架構呼叫以擷取具有物件預設動作描述的字串。

```
virtual HRESULT get_accDefaultAction(
    VARIANT varChild,
    BSTR* pszDefaultAction);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的預設操作是對象的預設操作還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*pszDefaultAction*<br/>
接收描述指定物件的預設操作的本地化字串的 BSTR 的位址,如果此物件沒有預設操作,則 NULL。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取」](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction)中的**傳回值**::get_accDefaultAction在 Windows SDK 中。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

重寫`CWnd`派生類中的此函數,以描述對象的預設操作。

有關詳細資訊,請參閱 Windows SDK 中的[I 可訪問:get_accDefaultAction。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdefaultaction)

## <a name="cwndget_accdescription"></a><a name="get_accdescription"></a>CWnd::get_accDescription

由架構呼叫以擷取含有指定物件的視覺外觀描述的字串。

```
virtual HRESULT get_accDescription(
    VARIANT varChild,
    BSTR* pszDescription);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的描述是對象的描述還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*psz描述*<br/>
接收描述指定物件的本地化字串的 BSTR 的位址,如果此物件沒有可用的描述,則 NULL。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取::::get_accDescription](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdescription) Windows SDK 中的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

重寫`CWnd`派生類中的此函數以描述物件。 調用基類版本並添加說明。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::get_accDescription。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accdescription)

## <a name="cwndget_accfocus"></a><a name="get_accfocus"></a>CWnd:get_accFocus

由架構呼叫以擷取具有鍵盤焦點的物件。

```
virtual HRESULT get_accFocus(VARIANT* pvarChild);
```

### <a name="parameters"></a>參數

*普瓦爾兒童*<br/>
接收有關具有焦點的物件的資訊。 請參閱[「可存取:::get_accFocus](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accfocus) Windows SDK 中的*pvarID。*

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::get_accFocus` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[I 可訪問::get_accFocus。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accfocus)

## <a name="cwndget_acchelp"></a><a name="get_acchelp"></a>CWnd::get_accHelp

由框架呼叫以檢索物件的**幫助**屬性字串。

```
virtual HRESULT get_accHelp(
    VARIANT varChild,
    BSTR* pszHelp);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的説明資訊是對象的幫助資訊還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*pszHelp*<br/>
接收包含指定物件的説明資訊的本地化字串的 BSTR 的位址,如果沒有可用的説明資訊,則 NULL。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取」](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelp)中的**傳回值**::get_accHelp在 Windows SDK 中。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

重寫`CWnd`派生類中的此函數,為物件提供幫助文本。

有關詳細資訊,請參閱 Windows SDK 中的[「不可存取:::get_accHelp。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelp)

## <a name="cwndget_acchelptopic"></a><a name="get_acchelptopic"></a>CWnd::get_accHelpTopic

由框架呼叫以檢索與指定物件關聯的**WinHelp**檔的完整路徑以及該檔中相應主題的識別碼。

```
virtual HRESULT get_accHelpTopic(
    BSTR* pszHelpFile,
    VARIANT varChild,
    long* pidTopic);
```

### <a name="parameters"></a>參數

*pszHelp檔案*<br/>
接收與指定物件關聯的`WinHelp`檔案的完整路徑(如果有)的 BSTR 的位址。

*瓦爾兒童*<br/>
指定要檢索的幫助主題是對象的主題還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取對象的説明主題)或子 ID(以獲取物件一個子元素的幫助主題)。

*pidTopic*<br/>
標識與指定物件關聯的幫助文件主題。 請參閱[「可存取點::get_accHelpTopic](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic)在 Windows SDK 中的*pidTopic。*

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::get_accHelpTopic` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

重寫`CWnd`派生類中的此函數,以提供有關對象的説明資訊。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問:::get_accHelpTopic。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acchelptopic)

## <a name="cwndget_acckeyboardshortcut"></a><a name="get_acckeyboardshortcut"></a>CWnd:get_accKeyboardShortcut

由架構呼叫以擷取指定物件的快速鍵或便捷鍵。

```
virtual HRESULT get_accKeyboardShortcut(
    VARIANT varChild,
    BSTR* pszKeyboardShortcut);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的鍵盤快捷方式是物件的快捷方式還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*psz鍵盤快捷鍵*<br/>
接收識別鍵盤快捷鍵的本地化字串的 BSTR 的位址,如果沒有與指定物件關聯的鍵盤快捷方式,則 NULL。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取:::get_accKeyboardShortcut](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut)在 Windows SDK 中的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

覆蓋`CWnd`派生類中的此函數,以標識物件的鍵盤快捷方式。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::get_accKeyboardShortcut。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_acckeyboardshortcut)

## <a name="cwndget_accname"></a><a name="get_accname"></a>CWnd::get_accName

由架構呼叫以擷取指定物件的名稱。

```
virtual HRESULT get_accName(
    VARIANT varChild,
    BSTR* pszName);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的名稱是對象的名稱還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*pszName*<br/>
接收包含指定物件名稱的字串的 BSTR 的位址。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取」](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accname)中的**傳回值**::get_accName在 Windows SDK 中。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

重寫`CWnd`派生類中的此函數以返回物件的名稱。

有關詳細資訊,請參閱 Windows SDK 中的[「不可存取::get_accName。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accname)

## <a name="cwndget_accparent"></a><a name="get_accparent"></a>CWnd:get_accParent

由架構呼叫以擷取物件之父代的 `IDispatch` 介面。

```
virtual HRESULT get_accParent(IDispatch** ppdispParent);
```

### <a name="parameters"></a>參數

*ppdisp 父級*<br/>
接收父物件的`IDispatch`介面的位址。 如果沒有父變數,或者子級無法訪問其父變數,則變數設置為 NULL。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考[「可存取::::get_accParent](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accparent)在 Windows SDK 中的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

在大多數情況下,您不必重寫此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::get_accParent。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accparent)

## <a name="cwndget_accrole"></a><a name="get_accrole"></a>CWnd::get_accRole

由架構呼叫以擷取含有指定物件的角色描述資訊。

```
virtual HRESULT get_accRole(
    VARIANT varChild,
    VARIANT* pvarRole);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的角色資訊是物件的角色信息還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*普瓦爾羅爾*<br/>
接收角色資訊。 請參閱[「可存取::::get_accRole](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accrole)在 Windows SDK 中的*pvarRole。*

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::get_accRole` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「可訪問::::get_accRole。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accrole)

## <a name="cwndget_accselection"></a><a name="get_accselection"></a>CWnd::get_accSelection

由架構呼叫以擷取此物件的選取子物件。

```
virtual HRESULT get_accSelection(VARIANT* pvarChildren);
```

### <a name="parameters"></a>參數

*普瓦爾兒童*<br/>
接收有關選擇哪些子級的資訊。 請參閱[「可存取:::get_accSelection](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accselection) Windows SDK 中的*pvar 兒童*。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::get_accSelection` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「I 可訪問:::get_accSelection」。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accselection)

## <a name="cwndget_accstate"></a><a name="get_accstate"></a>CWnd::get_accState

由架構呼叫以擷取指定物件的目前狀態。

```
virtual HRESULT get_accState(
    VARIANT varChild,
    VARIANT* pvarState);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的狀態資訊是物件的狀態資訊還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*普瓦爾邦*<br/>
接收有關物件狀態的資訊。 請參閱[「可存取點::get_accState](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accstate)中的*pvarState。*

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參考 Windows `IAccessible::get_accState` SDK 的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[I 可訪問:get_accState。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accstate)

## <a name="cwndget_accvalue"></a><a name="get_accvalue"></a>CWnd:get_accValue

由架構呼叫以擷取指定物件的值。

```
virtual HRESULT get_accValue(
    VARIANT varChild,
    BSTR* pszValue);
```

### <a name="parameters"></a>參數

*瓦爾兒童*<br/>
指定要檢索的值資訊是對象的值資訊還是物件的子元素之一。 此參數可以是CHILDID_SELF(獲取有關物件的資訊)或子 ID(以獲取有關物件的子元素的資訊)。

*pszValue*<br/>
接收包含物件的當前值的本地化字串的 BSTR 的位址。

### <a name="return-value"></a>傳回值

在成功時返回S_OK,在失敗時返回 COM 錯誤代碼。 請參閱[「可存取::::get_accValue](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accvalue) Windows SDK 中的**傳回值**。

### <a name="remarks"></a>備註

此功能是 MFC[活動輔助功能](/windows/win32/WinAuto/microsoft-active-accessibility)支援的一部分。

如果您有非視窗的用戶介面`CWnd`元素(MFC 處理的無視窗 ActiveX 控制件之外),則覆蓋派生類中的此函數。

有關詳細資訊,請參閱 Windows SDK 中的[「I 可訪問::get_accValue。](/windows/win32/api/oleacc/nf-oleacc-iaccessible-get_accvalue)

## <a name="cwndgetactivewindow"></a><a name="getactivewindow"></a>CWnd::取得活動視窗

檢索指向活動視窗的指標。

```
static CWnd* PASCAL GetActiveWindow();
```

### <a name="return-value"></a>傳回值

活動視窗或 NULL(如果在呼叫時沒有活動視窗)。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

活動視窗是具有當前輸入焦點的視窗,或者[由 SetActiveWindow](#setactivewindow)成員函數顯式激活的視窗。

## <a name="cwndgetancestor"></a><a name="getancestor"></a>CWnd:獲取祖先

擷取指定視窗的上階視窗物件。

```
CWnd* GetAncestor(UINT gaFlags) const;
```

### <a name="parameters"></a>參數

*加旗*<br/>
指定要檢索的祖先。 有關可能值的完整清單,請參閱[取祖先](/windows/win32/api/winuser/nf-winuser-getancestor)。

### <a name="return-value"></a>傳回值

如果函數成功,則返回值是指向祖先視窗物件的指標。 如果函數失敗,則返回值為 NULL。

### <a name="remarks"></a>備註

此成員函數類比函數[GetAncestor](/windows/win32/api/winuser/nf-winuser-getancestor)的功能,如Windows SDK中所述。

## <a name="cwndgetcapture"></a><a name="getcapture"></a>CWnd:取得捕獲

檢索具有滑鼠捕獲的視窗。

```
static CWnd* PASCAL GetCapture();
```

### <a name="return-value"></a>傳回值

標識具有滑鼠捕獲的視窗。 如果沒有視窗具有滑鼠捕獲,則為 NULL。

返回值可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

在任何給定時間,只有一個視窗具有滑鼠捕獲。 呼叫[SetCapture](#setcapture)成員函數時,視窗接收滑鼠捕獲。 無論游標是否在其邊界內,此窗口都會接收滑鼠輸入。

## <a name="cwndgetcaretpos"></a><a name="getcaretpos"></a>CWnd::獲取卡斯特波斯

檢索加斯特當前位置的客戶端座標,並將它們作為返回`CPoint`。

```
static CPoint PASCAL GetCaretPos();
```

### <a name="return-value"></a>傳回值

包含卡斯特位置座標的[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件。

### <a name="remarks"></a>備註

在`CWnd`視窗的用戶端座標中給出的護理位置。

## <a name="cwndgetcheckedradiobutton"></a><a name="getcheckedradiobutton"></a>CWnd::取得檢查無線電按鈕

檢索指定群組中目前選取的單選按鈕的 ID。

```
int GetCheckedRadioButton(
    int nIDFirstButton,
    int nIDLastButton);
```

### <a name="parameters"></a>參數

*nID 第一按鈕*<br/>
指定群組中第一個單選按鈕的整數識別碼。

*nIDLastButton*<br/>
指定群組中最後一個單選按鈕的整數識別碼。

### <a name="return-value"></a>傳回值

已檢查的單選按鈕的 ID,如果未選擇,則為 0。

## <a name="cwndgetclientrect"></a><a name="getclientrect"></a>CWnd::取得客戶

將用戶端區域的`CWnd`用戶端座標複製到*lpRect*指向的結構中。

```cpp
void GetClientRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向[RECT](/windows/win32/api/windef/ns-windef-rect)`CRect`結構 或 物件以接收用戶端座標。 `left`和`top`成員將為 0。 `right`和`bottom`成員將包含視窗的寬度和高度。

### <a name="remarks"></a>備註

用戶端座標指定工作區的左上角和右下角。 由於用戶端座標相對於`CWnd`工作區的左上角,因此左上角的座標為 (0,0)。

### <a name="example"></a>範例

  請參閱[CWnd 的範例::IsIconic](#isiconic)。

## <a name="cwndgetclipboardowner"></a><a name="getclipboardowner"></a>CWnd::獲取剪貼簿擁有者

檢索剪貼簿的當前擁有者。

```
static CWnd* PASCAL GetClipboardOwner();
```

### <a name="return-value"></a>傳回值

如果函數成功,則標識擁有剪貼簿的視窗。 否則,它為 NULL。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

剪貼簿仍可以包含數據,即使數據當前未擁有也是如此。

## <a name="cwndgetclipboardviewer"></a><a name="getclipboardviewer"></a>CWnd::取得剪貼簿檢視器

檢索剪貼簿檢視器鏈中的第一個視窗。

```
static CWnd* PASCAL GetClipboardViewer();
```

### <a name="return-value"></a>傳回值

標識當前負責顯示剪貼板的視窗(如果成功);否則 NULL(例如,如果沒有查看器)。

返回的指標可能是臨時的,不應存儲以供以後使用。

## <a name="cwndgetcontrolunknown"></a><a name="getcontrolunknown"></a>CWnd::取得控制未知

呼叫此成員函數以檢索指向未知 OLE 控制項的指標。

```
LPUNKNOWN GetControlUnknown();
```

### <a name="return-value"></a>傳回值

指向此`CWnd`物件表示的 OLE 控制的[I 未知](/windows/win32/api/unknwn/nn-unknwn-iunknown)介面的指標。 如果此物件不表示 OLE 控制項,則傳回值為 NULL。

### <a name="remarks"></a>備註

不應釋放此`IUnknown`指標。 通常,您將使用 來獲取控制項的特定介面。

返回的`GetControlUnknown`介面指標不計算引用。 不要調用[INots::釋放](/windows/win32/api/unknwn/nf-unknwn-iunknown-release)指標,除非您以前在指標上調用[INots::addRef。](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#96](../../mfc/reference/codesnippet/cpp/cwnd-class_35.cpp)]

## <a name="cwndgetcurrentmessage"></a><a name="getcurrentmessage"></a>CWnd:取得當前訊息

傳回此視窗目前正在處理的訊息指標。 僅當在**消息消息**<em>Message</em>傳遞者成員函數中時才應調用。

```
static const MSG* PASCAL GetCurrentMessage();
```

### <a name="return-value"></a>傳回值

返回指向[MSG](/windows/win32/api/winuser/ns-winuser-msg)結構的指標,其中包含視窗當前正在處理的消息。 僅當在<em>「打開消息」</em>處理**On**程式 中時才應呼叫。

### <a name="example"></a>範例

  請參閱[CMDIFrameWnd 的範例::MDICascade](../../mfc/reference/cmdiframewnd-class.md#mdicascade)。

## <a name="cwndgetdc"></a><a name="getdc"></a>CWnd:GetDC

檢索指向工作區的通用、類別或專用裝置上下文的指標,具體取決於為指定的類別式`CWnd`。

```
CDC* GetDC();
```

### <a name="return-value"></a>傳回值

如果成功,`CWnd`標識工作區的設備上下文;否則,返回值為 NULL。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

對於常見裝置上下文,`GetDC`每次檢索上下文時都會將默認屬性分配給上下文。 對於類和私有上下文,`GetDC`保留以前分配的屬性不變。 設備上下文可用於後續圖形設備介面 (GDI) 函數,以在工作區中繪製。

除非設備上下文屬於視窗類,否則必須調用[ReleaseDC](#releasedc)成員函數才能在繪製後釋放上下文。

如果CS_CLASSDC、CS_OWNDC或CS_PARENTDC`CWnd`在註冊類時`GetDC`指定 為`WNDCLASS`結構中的 樣式,則成員函數將返回屬於該類的設備上下文。

## <a name="cwndgetdcex"></a><a name="getdcex"></a>CWnd::獲取DCEx

檢索視窗的設備上下文的`CWnd`句柄。

```
CDC* GetDCEx(
    CRgn* prgnClip,
    DWORD flags);
```

### <a name="parameters"></a>參數

*prgnClip*<br/>
標識可能與用戶端視窗的可見區域組合的裁剪區域。

*flags*<br/>
可以具有以下預設值之一:

- DCX_CACHE從緩存返回設備上下文,而不是從 OWNDC 或 CLASSDC 視窗返回設備上下文。 覆蓋CS_OWNDC和CS_CLASSDC。

- DCX_CLIPCHILDREN 排除視窗下方所有子視窗`CWnd`的 可見區域。

- DCX_CLIPSIBLINGS 排除視窗上方所有同級視窗`CWnd`的 可見區域。

- DCX_EXCLUDERGN從返回的設備上下文的可見區域排除*prgnClip*標識的剪切區域。

- DCX_INTERSECTRGN 在返回的設備上下文的可見區域內與*prgnClip*標識的剪切區域相交。

- DCX_LOCKWINDOWUPDATE允許繪圖,即使有一個`LockWindowUpdate`有效的調用,否則將排除此視窗。 此值用於跟蹤期間的繪圖。

- DCX_PARENTCLIP 使用父視窗的可見區域並忽略父視窗WS_CLIPCHILDREN和WS_PARENTDC樣式位。 此值將設備上下文的原點設置到`CWnd`視窗的左上角。

- DCX_WINDOW返回對應於視窗矩形而不是用戶端矩形的設備上下文。

### <a name="return-value"></a>傳回值

如果函數成功,則指定視窗的設備上下文;否則 NULL。

### <a name="remarks"></a>備註

設備上下文可用於後續 GDI 函數中,以在工作區中繪製。

此函數是[GetDC](/windows/win32/api/winuser/nf-winuser-getdc)函數的擴展,它使應用程式能夠對視窗的設備上下文的剪切方式和是否進行更多控制。

除非設備上下文屬於視窗類,否則必須調用[ReleaseDC](/windows/win32/api/winuser/nf-winuser-releasedc)函數才能在繪製後釋放上下文。 由於在任何給定時間只有五個通用設備上下文可用,因此無法釋放設備上下文可能會阻止其他應用程式訪問設備上下文。

要取得快取的裝置中, 應用程式必須指定[DCX_CACHE](/windows/win32/api/winuser/nf-winuser-getdcex)。 如果未指定DCX_CACHE並且視窗既不CS_OWNDC也不[CS_CLASSDC,](/windows/win32/api/winuser/ns-winuser-wndclassw)則此函數將傳回 NULL。

如果註冊類時在[WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw)結構中指定了[CS_CLASSDC、CS_OWNDC](/windows/win32/api/winuser/ns-winuser-wndclassw)或[CS_PARENTDC](/windows/win32/api/winuser/ns-winuser-wndclassw)樣式,[則 GetDCEx](/windows/win32/api/winuser/nf-winuser-getdcex)函數會返回具有特殊特徵的設備上下文。

有關這些特徵的詳細資訊,請參閱 Windows SDK 中`WNDCLASS`結構的說明。

## <a name="cwndgetdcrendertarget"></a><a name="getdcrendertarget"></a>CWnd::獲取DCRender目標

擷取裝置內容 (DC) 會呈現 `CWnd` 視窗的目標。

```
CDCRenderTarget* GetDCRenderTarget();
```

### <a name="return-value"></a>傳回值

如果函式成功，裝置內容會呈現指定視窗的目標，否則為 NULL。

### <a name="remarks"></a>備註

## <a name="cwndgetdescendantwindow"></a><a name="getdescendantwindow"></a>Cwnd:抓取視窗

呼叫此成員函數以查找給定 ID 指定的子視窗。

```
CWnd* GetDescendantWindow(
    int nID,
    BOOL bOnlyPerm = FALSE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要檢索的控制項或子視窗的識別碼。

*b 只*<br/>
指定要返回的視窗是否可以是暫時的。 如果為 TRUE,則只能返回永久視窗;如果為 TRUE,則只能返回永久視窗。如果 FALSE,則函數可以返回臨時視窗。 有關臨時視窗的詳細資訊,請參閱[技術說明 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="return-value"></a>傳回值

指向`CWnd`物件的指標,如果沒有找到子視窗,則為 NULL。

### <a name="remarks"></a>備註

此成員函數搜索整個子視窗樹,而不僅僅是直接子視窗的視窗。

## <a name="cwndgetdesktopwindow"></a><a name="getdesktopwindow"></a>CWnd::取得桌面視窗

返回 Windows 桌面視窗。

```
static CWnd* PASCAL GetDesktopWindow();
```

### <a name="return-value"></a>傳回值

標識Windows桌面視窗。 此指標可能是臨時指標,不應存儲以供以後使用。

### <a name="remarks"></a>備註

桌面視窗覆蓋整個螢幕,是上面繪製所有圖示和其他視窗的區域。

## <a name="cwndgetdlgctrlid"></a><a name="getdlgctrlid"></a>CWnd::GetDlgCtrlID

返回任何子視窗的視窗或控件 ID 值,而不僅僅是對話方塊中控制件的視窗或控制項 ID 值。

```
int GetDlgCtrlID() const;
```

### <a name="return-value"></a>傳回值

如果函數成功,`CWnd`則子視窗的數字識別碼;否則 0。

### <a name="remarks"></a>備註

由於頂級視窗沒有 ID 值,因此`CWnd`,如果是頂級視窗,則此函數的返回值將無效。

### <a name="example"></a>範例

  請參考[CWnd 的範例:OnCtlColor](#onctlcolor)。

## <a name="cwndgetdlgitem"></a><a name="getdlgitem"></a>CWnd::GetDlgItem

在對話框或其他視窗中檢索指向指定控制項或子視窗的指標。

```
CWnd* GetDlgItem(int nID) const;

void GetDlgItem(
    int nID,
    HWND* phWnd) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要檢索的控制項或子視窗的識別碼。

*phwnd*<br/>
指向子視窗的指標。

### <a name="return-value"></a>傳回值

指向給定控制件或子視窗的指標。 如果不存在*nID*參數提供的整數 ID 控制項,則值為 NULL。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

返回的指標通常轉換為*nID*標識的控制項類型。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#97](../../mfc/reference/codesnippet/cpp/cwnd-class_36.cpp)]

## <a name="cwndgetdlgitemint"></a><a name="getdlgitemint"></a>Cwnd::GetDlgItemint

檢索*nID*標識的控制項的文字。

```
UINT GetDlgItemInt(
    int nID,
    BOOL* lpTrans = NULL,
    BOOL bSigned = TRUE) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要轉換的對話方塊控制件的整數識別碼。

*lpTrans*<br/>
指向要接收翻譯標誌的布爾變數。

*b簽章*<br/>
指定是否對要檢索的值進行簽名。

### <a name="return-value"></a>傳回值

指定對話框項目文字的已翻譯值。 由於 0 是有效的返回值,因此必須使用*lpTrans*來檢測錯誤。 如果需要簽名的返回值,則將其轉換為**int**類型。

如果翻譯的數位大於INT_MAX(對於簽名號碼)或UINT_MAX(對於未簽名的),則函數返回 0。

當發生錯誤(如遇到非數位字元並超過上述最大值)時,`GetDlgItemInt`將 0 複製到*lpTrans*指向的位置。 如果沒有錯誤 *,lpTrans*將收到非零值。 如果*lpTrans*為`GetDlgItemInt`NULL,則不警告錯誤。

### <a name="remarks"></a>備註

它通過剝離文本開頭的任何額外空格並轉換十進位數字,將給定對話方塊中指定控制項的文本轉換為整數值。 當它到達文本末尾或遇到任何非數字字元時,它將停止翻譯。

如果*bSign*為`GetDlgItemInt`TRUE,則檢查文本開頭的減號 (-),並將文本轉換為簽名編號。 否則,它將創建一個未簽名的值。

它將[WM_GETTEXT](/windows/win32/winmsg/wm-gettext)消息發送到控制項。

## <a name="cwndgetdlgitemtext"></a><a name="getdlgitemtext"></a>CWnd::GetDlgItemText

呼叫此成員函數以檢索與對話方塊中控制項關聯的標題或文本。

```
int GetDlgItemText(
    int nID,
    LPTSTR lpStr,
    int nMaxCount) const;

int GetDlgItemText(
    int nID,
    CString& rString) const;
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要檢索其標題的控制項的整數識別碼。

*lpStr*<br/>
指向緩衝區以接收控制項的標題或文本。

*nMax( N) Count*<br/>
指定要複製到*lpStr*的字串的最大長度(以字元形式)。 如果字串長於*nMaxCount,* 則將其截斷。

*rString*<br/>
對[CString](../../atl-mfc-shared/reference/cstringt-class.md)的引用。

### <a name="return-value"></a>傳回值

指定複製到緩衝區的實際字元數,不包括終止空字元。 如果未複製任何文本,則該值為 0。

### <a name="remarks"></a>備註

成員`GetDlgItemText`函數將文本複製到*lpStr*指向的位置,並返回它複製的位元組數的計數。

## <a name="cwndgetdsccursor"></a><a name="getdsccursor"></a>CWnd::取得Sccursor

調用此成員函數以檢索數據來源控制項的 DataSource、使用者名、密碼和 SQL 屬性定義的指向基礎游標的指標。

```
IUnknown* GetDSCCursor();
```

### <a name="return-value"></a>傳回值

指向由數據源控件定義的游標的指標。 MFC 負責調`AddRef`用 指標。

### <a name="remarks"></a>備註

使用返回的指標設定複雜數據綁定控制件(如資料綁定網格控制項)的ICursor屬性。 數據源控件不會變為活動狀態,直到第一個綁定控件請求其游標。 這可以通過 MFC 綁定`GetDSCCursor`管理器的 調用或隱式方式發生。 在這兩種情況下,都可以通過調用`GetDSCCursor``Release`返回 的指標`IUnknown`到 ,強制數據源控件變為活動狀態。 啟動將導致數據源控制件嘗試連接到基礎資料來源。 傳回的指標可能在以下上下文中使用:

### <a name="example"></a>範例

[!code-cpp[NVC_MFC_AxDataBinding#5](../../mfc/reference/codesnippet/cpp/cwnd-class_37.cpp)]

## <a name="cwndgetdynamiclayout"></a><a name="getdynamiclayout"></a>CWnd::獲取動態佈局

擷取動態配置管理員物件的指標。

```
CMFCDynamicLayout* GetDynamicLayout();
```

### <a name="return-value"></a>傳回值

動態配置管理員物件的指標，或是如果未啟用動態配置，則為 NULL。

### <a name="remarks"></a>備註

視窗物件擁有及管理傳回的指標存留期，因此它只應該用來存取物件；請勿永久刪除指標或儲存指標。

## <a name="cwndgetexstyle"></a><a name="getexstyle"></a>CWnd::獲取樣式

傳回視窗的延伸樣式。

```
DWORD GetExStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的擴展樣式。 關於 MFC 中使用的擴充視窗樣式的詳細資訊,請參閱[延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)。

## <a name="cwndgetfocus"></a><a name="getfocus"></a>CWnd:取得焦點

檢索指向`CWnd`當前具有輸入焦點的的指標。

```
static CWnd* PASCAL GetFocus();
```

### <a name="return-value"></a>傳回值

指向具有當前焦點的視窗的指標,如果沒有焦點視窗,則指向 NULL。

該指標可能是暫時性的，因此不應該儲存供日後使用。

## <a name="cwndgetfont"></a><a name="getfont"></a>CWnd::獲取字體

將WM_GETFONT訊息發送到視窗以檢索當前字體。

```
CFont* GetFont() const;
```

### <a name="return-value"></a>傳回值

指向附加到視窗的當前字體的[CFont](../../mfc/reference/cfont-class.md)物件的指標。

### <a name="remarks"></a>備註

除非窗口處理WM_GETFONT消息,否則此方法無效。 許多 MFC`CWnd`類從 處理此消息派生,因為它們附加到預定義的視窗類,其中包括WM_GETFONT消息的消息處理程式。 要使用此方法,派生自`CWnd`的類必須為WM_GETFONT消息定義方法處理程式。

## <a name="cwndgetforegroundwindow"></a><a name="getforegroundwindow"></a>CWnd::取得前景視窗

返回指向前景視窗(使用者當前正在使用的視窗)的指標。

```
static CWnd* PASCAL GetForegroundWindow();
```

### <a name="return-value"></a>傳回值

指向前景視窗的指標。 這可能是一個臨時`CWnd`物件。

### <a name="remarks"></a>備註

前景視窗僅適用於頂級視窗(框架視窗或對話框)。

## <a name="cwndgeticon"></a><a name="geticon"></a>CWnd::GetIcon

呼叫此成員函數,使句柄到大 (32x32) 或句柄到一個小 (16x16) 圖示, 如*bBigIcon*所示.

```
HICON GetIcon(BOOL bBigIcon) const;
```

### <a name="parameters"></a>參數

*bBigIcon*<br/>
如果為 TRUE,則指定 32 圖元 x 32 像素圖示;如果 FALSE,則指定 16 圖元 x 16 像素圖示。

### <a name="return-value"></a>傳回值

圖示的控制代碼。 如果不成功,則返回 NULL。

## <a name="cwndgetlastactivepopup"></a><a name="getlastactivepopup"></a>CWnd::獲取最後活動彈出

判斷 `CWnd` 擁有的快顯視窗哪一個是最近啟用的。

```
CWnd* GetLastActivePopup() const;
```

### <a name="return-value"></a>傳回值

標識最近處於活動狀態的彈出視窗。 如果滿足以下任何條件,返回值將是視窗本身:

- 視窗本身最近處於活動狀態。

- 該視窗不擁有任何彈出視窗。

- 該視窗不是頂級視窗,或由另一個窗口擁有。

該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="example"></a>範例

  請參閱[CWnd 的範例:尋找視窗](#findwindow)。

## <a name="cwndgetlayeredwindowattributes"></a><a name="getlayeredwindowattributes"></a>CWnd::取得分層視窗屬性

擷取分層視窗的不透明和透明色鍵。

```
BOOL GetLayeredWindowAttributes(
    COLORREF* pcrKey,
    BYTE* pbAlpha,
    DWORD* pdwFlags) const;
```

### <a name="parameters"></a>參數

*pcrKey*<br/>
指向 COLORREF 值的指標,該值接收在組成分層視窗時要使用的透明度顏色鍵。 此顏色的視窗繪製的所有圖元都將是透明的。 如果不需要參數,這可以為 NULL。

*pb阿爾法*<br/>
指向接收用於描述分層視窗的不向性的 Alpha 值的 BYTE 的指標。 當*pbAlpha*引用的變數為 0 時,視窗是完全透明的。 當*pbAlpha*引用的變數為 255 時,視窗是不透明的。 如果不需要參數,這可以為 NULL。

*pdwFlags*<br/>
指向接收分層標誌的 DWORD 的指標。 如果不需要參數,這可以為 NULL。 有關可能值的完整清單,請參閱[獲取分層視窗屬性](/windows/win32/api/winuser/nf-winuser-getlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[GetLayeredWindows 屬性](/windows/win32/api/winuser/nf-winuser-getlayeredwindowattributes)的功能,如 Windows SDK 中所述。

## <a name="cwndgetmenu"></a><a name="getmenu"></a>CWnd::獲取功能表

檢索指向此視窗的功能表的指標。

```
CMenu* GetMenu() const;
```

### <a name="return-value"></a>傳回值

標識功能表。 如果沒有`CWnd`選單,則該值為 NULL。 如果是`CWnd`子視窗,則返回值未定義。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

此功能不應用於子視窗,因為它們沒有功能表。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#98](../../mfc/reference/codesnippet/cpp/cwnd-class_38.cpp)]

## <a name="cwndgetmenubarinfo"></a><a name="getmenubarinfo"></a>CWnd::獲取功能表欄資訊

檢索有關指定功能表欄的資訊。

```
BOOL GetMenuBarInfo(
    LONG idObject,
    LONG idItem,
    PMENUBARINFO pmbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 有關可能值的清單,請參閱[GetMenuBarInfo](/windows/win32/api/winuser/nf-winuser-getmenubarinfo)。

*idItem*<br/>
指定要為其檢索資訊的項。 如果此參數為零,則函數將檢索有關功能表本身的資訊。 如果此參數為 1,則函數將檢索有關功能表上第一項的資訊,等等。

*pmbi*<br/>
指向接收資訊的[MENUBARINFO](/windows/win32/api/winuser/ns-winuser-menubarinfo)結構的指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[GetMenuBarInfo](/windows/win32/api/winuser/nf-winuser-getmenubarinfo)的功能,如Windows SDK中所述。

## <a name="cwndgetnextdlggroupitem"></a><a name="getnextdlggroupitem"></a>CWnd::獲取NextDlg集團專案

在對話框中的控制元件元件中搜索上一個或下一個控制項。

```
CWnd* GetNextDlgGroupItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgGroupItem(
    COleControlSiteOrWnd* pCurSiteOrWnd = NULL) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
標識要用作搜索起點的控制項。

*b 上一個*<br/>
指定函數在對話框中搜索控制元件元件的方式。 如果為 TRUE,則函數將搜索組中的上一個控制項;如果為 TRUE,則函數將搜索組中的上一個控制項。如果 FALSE,它將搜索組中的下一個控制項。

*pCurSiteOrwnd*<br/>
標識`COleControlSiteOrWnd`控件。 有關 的詳細`COleControlSiteOrWnd`資訊 ,請參閱**備註**。

### <a name="return-value"></a>傳回值

如果成員函數成功,則指向組中的上一個或下一個控件。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

控制項組從使用[WS_GROUP](styles-used-by-mfc.md#window-styles)樣式建立的控制項開始,最後以未使用WS_GROUP樣式創建的最後一個控制項結束。

預設情況下,`GetNextDlgGroupItem`成員函數傳回指向組中的下一個控制項的指標。 如果*pWndCtl*標識組中的第一個控制項,bLast 為`GetNextDlgGroupItem`TRUE,則返回指向組中最後一個控制件*bPrevious*的指標。

> [!NOTE]
> 由於 MFC 支援無視窗 ActiveX 控制件、標準 ActiveX 控制件和視窗,因此僅引用 HWND 的控制項已不足夠。 該`COleControlSiteOrWnd`物件包括將物件識別為視窗 ActiveX 控制項、無視窗 ActiveX 控制項或視窗的資訊,如下所示:

|控制項或視窗類型|識別資訊|
|----------------------------|-----------------------------|
|視窗啟動 X 控制項|包含 HWND 並將[COleControlSite](../../mfc/reference/colecontrolsite-class.md)物件與其關聯。 `COleControlSiteOrWnd`的成員`m_hWnd`設定為控制項的 HWND,`m_pSite`並且成員指向`COleControlSite`控制項 。|
|無窗動 X 控制項|不包含 HWND。 指向`m_pSite`控制項的`COleControlSiteOrWnd``COleControlSite`點的成員,`m_hWnd`並且成員為 NULL。|
|標準視窗|僅包含 HWND。 的成員`m_hWnd``COleControlSiteOrWnd`設定為視窗的 HWND,`m_pSite`並且該成員為 NULL。|

## <a name="cwndgetnextdlgtabitem"></a><a name="getnextdlgtabitem"></a>CWnd::獲取NextDlgTab專案

檢索指向使用[WS_TABSTOP](styles-used-by-mfc.md#window-styles)樣式創建並在指定控制項之前或遵循的第一個控制項的指標。

```
CWnd* GetNextDlgTabItem(
    CWnd* pWndCtl,
    BOOL bPrevious = FALSE) const;

COleControlSiteOrWnd* GetNextDlgTabItem(
    COleControlSiteOrWnd* pCurSiteOrWnd,
    BOOL bPrevious) const;
```

### <a name="parameters"></a>參數

*pWndCtl*<br/>
標識要用作搜索起點的控制項。

*pCurSiteOrwnd*<br/>
標識`COleControlSiteOrWnd`控件。 有關 的詳細`COleControlSiteOrWnd`資訊 ,請參閱[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)。

*b 上一個*<br/>
指定函數如何搜索對話方塊。 如果為 TRUE,則函數將在對話框中搜索上一個控制件;如果為 TRUE,則函數將搜索該控制件。如果 FALSE,它將搜索下一個控制項。

### <a name="return-value"></a>傳回值

如果成員函數成功,則指向具有WS_TABSTOP樣式的上一個或下一個控件的指標。

返回的指標可能是臨時的,不應存儲以供以後使用。

有關 的詳細`COleControlSiteOrWnd`資訊 ,請參閱[CWnd::GetNextDlgGroupItem](#getnextdlggroupitem)。

## <a name="cwndgetnextwindow"></a><a name="getnextwindow"></a>CWnd::取得下一個視窗

搜尋視窗管理員清單中的下一個(或上一個)視窗。

```
CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
```

### <a name="parameters"></a>參數

*nFlag*<br/>
指定函數是返回指向下一個視窗或上一個視窗的指標。 它可以是GW_HWNDNEXT,它返回視窗管理器清單中`CWnd`的物件後面的視窗,也可以是GW_HWNDPREV,它返回視窗管理器清單中的前一個視窗。

### <a name="return-value"></a>傳回值

如果成員函數成功,則標識視窗管理器清單中的下一個(或上一個)視窗。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

視窗管理員清單包含所有頂級視窗、其關聯的子視窗以及任何子視窗的子視窗的條目。

如果`CWnd`是頂級視窗,則函數將搜索下一個(或上一個)頂級視窗;如果是頂級視窗,則函數將搜索下一個(或上一個)頂級視窗。如果是`CWnd`子視窗,則函數將搜索下一個(或上一個)子視窗。

## <a name="cwndgetolecontrolsite"></a><a name="getolecontrolsite"></a>CWnd::取得 Ole 控制網站

擷取指定的 ActiveX 控制項的自訂網站。

```
COleControlSite* GetOleControlSite(UINT idControl) const;
```

### <a name="parameters"></a>參數

*idControl*<br/>
ActiveX 控制項的識別碼。

## <a name="cwndgetopenclipboardwindow"></a><a name="getopenclipboardwindow"></a>CWnd::取得開啟的剪貼簿視窗

檢索目前打開剪貼簿的視窗的句柄。

```
static CWnd* PASCAL GetOpenClipboardWindow();
```

### <a name="return-value"></a>傳回值

如果函數成功,當前打開剪貼簿的視窗的句柄;如果函數成功,則視窗的句柄。否則 NULL。

## <a name="cwndgetowner"></a><a name="getowner"></a>CWnd::獲取擁有者

檢索指向視窗擁有者的指標。

```
CWnd* GetOwner() const;
```

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。

### <a name="remarks"></a>備註

如果視窗沒有擁有者,則默認情況下將返回指向父視窗物件的指標。 請注意,擁有者和擁有的關係在幾個重要方面與父子關係不同。 例如,具有父視窗的視窗限制在其父視窗的工作區中。 擁有的視窗可以在桌面上的任何位置繪製。

該函數的所有權概念不同於[GetWindow](/windows/win32/api/winuser/nf-winuser-getwindow)的擁有權概念。

## <a name="cwndgetparent"></a><a name="getparent"></a>CWnd::獲取家長

呼叫此函數以獲取指向子視窗的父視窗(如果有)的指標。

```
CWnd* GetParent() const;
```

### <a name="return-value"></a>傳回值

請參閱 Windows SDK 中的[「獲取父級」](/windows/win32/api/winuser/nf-winuser-getparent)中的返回值部分。

### <a name="remarks"></a>備註

函數`GetParent`返回指向直接父級的指標(如果存在)。 相反[,GetParentOwner](#getparentowner)函數傳回指向不是子視窗(沒有WS_CHILD樣式)的最直接的父視窗或擁有者視窗的指標。 如果子視窗中有一個子視窗`GetParent`,`GetParentOwner`並返回不同的結果。

## <a name="cwndgetparentframe"></a><a name="getparentframe"></a>CWnd::獲取父系框架

調用此成員函數以檢索父幀視窗。

```
CFrameWnd* GetParentFrame() const;
```

### <a name="return-value"></a>傳回值

指向幀視窗的指標(如果成功);如果成功,則指向框架視窗的指標。否則 NULL。

### <a name="remarks"></a>備註

成員函數向上搜索父鏈,直到找到[CFrameWnd(](../../mfc/reference/cframewnd-class.md)或派生類)物件。

## <a name="cwndgetparentowner"></a><a name="getparentowner"></a>CWnd::獲取家長擁有者

呼叫此成員函數以獲取指向子視窗的父視窗或所有者視窗的指標。

```
CWnd* GetParentOwner() const;
```

### <a name="return-value"></a>傳回值

`CWnd` 物件的指標。 如果 `CWnd` 物件沒有附加至控制代碼，會建立並附加暫存 `CWnd` 物件。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`GetParentOwner`返回指向不是子視窗的最直接的父視窗或擁有者視窗的指標(沒有WS_CHILD樣式)。 當前擁有者視窗可以使用[SetOwner](#setowner)進行設置。 默認情況下,視窗的父級是其擁有者。

相反[,GetParent](#getparent)函數傳回指向正父級的指標,無論該指標是否是子視窗。 如果子視窗中有一個子視窗`GetParent`,`GetParentOwner`並返回不同的結果。

## <a name="cwndgetproperty"></a><a name="getproperty"></a>CWnd:獲取財產

調用此成員函數獲取*dwDispID*指定的 ActiveX 控件屬性。

```cpp
void GetProperty(
    DISPID dwDispID,
    VARTYPE vtProp,
    void* pvProp)const;
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
標識要檢索的屬性。

*vtProp*<br/>
指定要檢索的屬性的類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvProp*<br/>
將接收屬性值的變數的位址。 它必須匹配*vtProp*指定的類型。

### <a name="remarks"></a>備註

`GetProperty`通過*pvProp*返回值。

> [!NOTE]
> 此函數應僅在表示 ActiveX`CWnd`控制件的物件上調用。

有關將此成員函數與 ActiveX 控制容器一起使用的詳細資訊,請參閱文章[ActiveX 控制件容器:在 ActiveX 控制元件容器中程式設計 ActiveX 控制件](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndgetrendertarget"></a><a name="getrendertarget"></a>CWnd::取得渲染目標

取得與此視窗相關聯的呈現目標。

```
CHwndRenderTarget* GetRenderTarget();
```

### <a name="return-value"></a>傳回值

指向渲染目標或 NULL 的指標。

## <a name="cwndgetsafehwnd"></a><a name="getsafehwnd"></a>CWnd::獲取安全Hwnd

如果`m_hWnd`**此**指標為 NULL,則傳回或 NULL。

```
HWND GetSafeHwnd() const;
```

### <a name="return-value"></a>傳回值

返回視窗的視窗句柄。 如果`CWnd`未附加到視窗或將其與 NULL 指標一起使用,`CWnd`則傳回 NULL。

### <a name="example"></a>範例

  請參閱[CWnd::子類視窗](#subclasswindow)的範例。

## <a name="cwndgetsafeowner"></a><a name="getsafeowner"></a>CWnd::獲取安全擁有者

調用此成員函數以檢索應用於對話方塊或其他模式視窗的所有者視窗。

```
static CWnd* GetSafeOwner(
    CWnd* pParent = NULL,
    HWND* pWndTop = NULL);
```

### <a name="parameters"></a>參數

*pParent*<br/>
指向父`CWnd`視窗的指標。 可能是 NULL。

*pWndTop*<br/>
指向當前位於頂部的視窗的指標。 可能是 NULL。

### <a name="return-value"></a>傳回值

指向給定視窗的安全擁有者的指標。

### <a name="remarks"></a>備註

安全擁有者是*pParent*的第一個非子父視窗。 如果*pParent*為 NULL,則執行緒的主視窗(透過[AfxGetMainWnd](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)檢索)用於查找擁有者。

> [!NOTE]
> 框架本身使用此函數來確定對話框和屬性表的正確擁有者視窗,其中未指定擁有者。

## <a name="cwndgetscrollbarctrl"></a><a name="getscrollbarctrl"></a>CWnd::取得ScrollBarCtrl

呼叫此成員函數以獲取指向指定同級滾動條或拆分器視窗的指標。

```
virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲動條的類型。 參數可以採用以下值之一:

- SB_HORZ檢索水準滾動條的位置。

- SB_VERT檢索垂直滾動條的位置。

### <a name="return-value"></a>傳回值

同級滾動條控件,或 NULL(如果沒有)。

### <a name="remarks"></a>備註

此成員函數不會在創建視窗期間設置WS_HSCROLL或WS_VSCROLL位時創建的滾動條上工作。 此`CWnd`函數的實現僅返回 NULL。 派生類,如`CView`,實現描述的功能。

## <a name="cwndgetscrollbarinfo"></a><a name="getscrollbarinfo"></a>CWnd::取得ScrollbarInfo

擷取所指定之捲軸的相關資訊。

```
BOOL GetScrollBarInfo(
    LONG idObject,
    PSCROLLBARINFO psbi) const;
```

### <a name="parameters"></a>參數

*idObject*<br/>
指定功能表物件。 有關可能值的清單,請參閱[GetScrollBarInfo](/windows/win32/api/winuser/nf-winuser-getscrollbarinfo)。

*psbi*<br/>
指向接收資訊的[SCROLLBARINFO](/windows/win32/api/winuser/ns-winuser-scrollbarinfo)結構的指標。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[GetScrollBarInfo](/windows/win32/api/winuser/nf-winuser-getscrollbarinfo)的功能,如 Windows SDK 中所述。

## <a name="cwndgetscrollinfo"></a><a name="getscrollinfo"></a>CWnd::取得Scrollinfo

調用此成員函數以檢索`SCROLLINFO`結構維護的關於滾動條的資訊。

```
BOOL GetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    UINT nMask = SIF_ALL);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定滾動條是控件還是視窗的非工作區的一部分。 如果它是非工作區的一部分 *,nBar*還會指示滾動條是水準、垂直還是兩者兼而有之。 它必須是以下項之一:

- SB_CTL檢索滾動條控件的參數。 數據`m_hWnd`成員必須是滾動條控制的句柄。

- SB_HORZ檢索視窗的標準水準滾動條的參數。

- SB_VERT檢索視窗的標準垂直滾動條的參數。

*lpScrollInfo*<br/>
指向[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構的指標。 有關此結構的詳細資訊,請參閱 Windows SDK。

*nMask*<br/>
指定要檢索的滾動條參數。 默認值指定SIF_PAGE、SIF_POS、SIF_TRACKPOS和SIF_RANGE的組合。 有關`SCROLLINFO` *nMask*值的詳細資訊,請參閱。

### <a name="return-value"></a>傳回值

如果消息檢索了任何值,則返回為 TRUE。 否則,它是 FALSE。

### <a name="remarks"></a>備註

`GetScrollInfo`使應用程式能夠使用 32 位滾動位置。

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構包含有關滾動條的資訊,包括最小和最大滾動位置、頁面大小和滾動框(拇指)的位置。 有關更改`SCROLLINFO`結構預設值的詳細資訊,請參閱 Windows SDK 中的結構主題。

指示滾動條位置的 MFC Windows 消息處理程式[,CWnd:onHScroll](#onhscroll)和[CWnd::onVScroll,](#onvscroll)僅提供 16 位元位置數據。 `GetScrollInfo`並提供`SetScrollInfo`32 位滾動條位置數據。 因此,應用程式可以在處理或`GetScrollInfo``CWnd::OnHScroll``CWnd::OnVScroll`獲取 32 位滾動條位置數據時調用。

## <a name="cwndgetscrolllimit"></a><a name="getscrolllimit"></a>CWnd::獲取滾動限制

調用此成員函數以檢索滾動條的最大滾動位置。

```
int GetScrollLimit(int nBar);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定捲動條的類型。 參數可以採用以下值之一:

- SB_HORZ檢索水準滾動條的滾動限制。

- SB_VERT檢索垂直滾動條的滾動限制。

### <a name="return-value"></a>傳回值

指定滾動條的最大位置(如果成功);否則 0。

## <a name="cwndgetscrollpos"></a><a name="getscrollpos"></a>CWnd::獲取ScrollPos

檢索滾動條滾動框的當前位置。

```
int GetScrollPos(int nBar) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的滾動條。 參數可以採用以下值之一:

- SB_HORZ檢索水準滾動條的位置。

- SB_VERT檢索垂直滾動條的位置。

### <a name="return-value"></a>傳回值

如果成功,在滾動條中指定滾動框的當前位置;否則 0。

### <a name="remarks"></a>備註

當前位置是一個相對值,取決於當前滾動範圍。 例如,如果滾動範圍為 50 到 100,並且滾動框位於條形圖的中間,則當前位置為 75。

## <a name="cwndgetscrollrange"></a><a name="getscrollrange"></a>CWnd::獲取滾動

將給定滾動條的當前最小和最大滾動條位置複製到*lpMinPos*和*lpMaxPos*指定的位置。

```cpp
void GetScrollRange(
    int nBar,
    LPINT lpMinPos,
    LPINT lpMaxPos) const;
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要檢查的滾動條。 參數可以採用以下值之一:

- SB_HORZ檢索水準滾動條的位置。

- SB_VERT檢索垂直滾動條的位置。

*lpMinPos*<br/>
指向要接收最小位置的整數變數。

*lpMaxPos*<br/>
指向要接收最大位置的整數變數。

### <a name="remarks"></a>備註

如果沒有`CWnd`滾動條,`GetScrollRange`則 成員函數將 0 複製到*lpMinPos*和*lpMaxPos*。

標準滾動條的預設範圍為 0 到 100。 滾動條控件的預設範圍為空(兩個值均為 0)。

## <a name="cwndgetstyle"></a><a name="getstyle"></a>CWnd::獲取風格

傳回目前的視窗樣式。

```
DWORD GetStyle() const;
```

### <a name="return-value"></a>傳回值

視窗的風格。 關於 MFC 中使用的視窗樣式的詳細資訊,請參閱[視窗樣式](styles-used-by-mfc.md#window-styles)。

## <a name="cwndgetsystemmenu"></a><a name="getsystemmenu"></a>CWnd::獲取系統功能表

可讓應用程式存取控制功能表以進行複製和修改。

```
CMenu* GetSystemMenu(BOOL bRevert) const;
```

### <a name="parameters"></a>參數

*b 還原*<br/>
指定要執行的操作。 如果*bRevert*是`GetSystemMenu`FALSE,則將句柄返回到當前正在使用的"控制"功能表的副本。 此副本最初與"控制"功能表相同,但可以修改。 如果*bRevert*為`GetSystemMenu`TRUE,則將"控制"功能表重置回預設狀態。 上一個可能修改的"控制"功能表(如果有)將被銷毀。 在這種情況下,返回值未定義。

### <a name="return-value"></a>傳回值

如果*bRevert*是 FALSE,則識別"控制"功能表的副本。 如果*bRevert*為 TRUE,則返回值未定義。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

任何不用於`GetSystemMenu`製作自己的"控制"功能表副本的視窗都會收到標準"控制件"功能表。

成員函數返回`GetSystemMenu`的指標可與[CMenu::附加選單](../../mfc/reference/cmenu-class.md#appendmenu)[、CMenu::插入選單](../../mfc/reference/cmenu-class.md#insertmenu)或[CMenu::修改功能表](../../mfc/reference/cmenu-class.md#modifymenu)功能一起使用。這些函數可用於更改「控制」功能表。

控制"選單最初包含使用各種 ID 值(如SC_CLOSE、SC_MOVE和SC_SIZE)標識的項。 控制"選單上的專案將[生成WM_SYSCOMMAND](#onsyscommand)消息。 所有預定義的控制功能表項的 ID 編號大於 0xF000。 如果應用程式將項添加到"控制"功能表,則應使用小於 F000 的 ID 號。

Windows可能會自動使專案在標準控制件功能表中不可用。 `CWnd`可以通過回應在顯示任何功能表之前發送[的WM_INITMENU](#oninitmenu)消息來執行自己的選擇或不可用。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#99](../../mfc/reference/codesnippet/cpp/cwnd-class_39.cpp)]

## <a name="cwndgettitlebarinfo"></a><a name="gettitlebarinfo"></a>CWnd::取得TitlebarInfo

擷取指定之標題列的相關資訊。

```
BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;
```

### <a name="parameters"></a>參數

*Pti*<br/>
指向接收資訊的[TITLEBARINFO](/windows/win32/api/winuser/ns-winuser-titlebarinfo)結構的指標。

### <a name="remarks"></a>備註

此成員函數類比函數[GetTitleBarInfo](/windows/win32/api/winuser/nf-winuser-gettitlebarinfo)的功能,如 Windows SDK 中所述。

## <a name="cwndgettoplevelframe"></a><a name="gettoplevelframe"></a>CWnd::取得頂級框架

調用此成員函數以檢索視窗的頂層框架視窗(如果有)。

```
CFrameWnd* GetTopLevelFrame() const;
```

### <a name="return-value"></a>傳回值

標識視窗的頂層框架視窗。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

如果沒有`CWnd`附加視窗,或者其頂級父級不是[CFrameWnd](../../mfc/reference/cframewnd-class.md)派生物件,則此函數將返回 NULL。

## <a name="cwndgettoplevelowner"></a><a name="gettoplevelowner"></a>CWnd::獲取頂級級別擁有者

調用此成員函數以檢索頂級視窗。

```
CWnd* GetTopLevelOwner() const;
```

### <a name="return-value"></a>傳回值

標識頂層視窗。 返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

頂層視窗是桌面子視窗的視窗。 如果沒有`CWnd`附加視窗,此函數將返回 NULL。

## <a name="cwndgettoplevelparent"></a><a name="gettoplevelparent"></a>CWnd::獲取頂級家長

調用此成員函數以檢索視窗的頂級父級。

```
CWnd* GetTopLevelParent() const;
```

### <a name="return-value"></a>傳回值

標識視窗的頂層父視窗。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

`GetTopLevelParent`類似於[取得頂級框架](#gettoplevelframe)和[獲取頂級等級擁有者](#gettoplevelowner);但是,它忽略設置為當前所有者視窗的值。

## <a name="cwndgettopwindow"></a><a name="gettopwindow"></a>CWnd::獲取頂窗

搜索屬於`CWnd`的頂層子視窗。

```
CWnd* GetTopWindow() const;
```

### <a name="return-value"></a>傳回值

標識子視窗`CWnd`連結清單中的頂級子視窗。 如果不存在子視窗,則值為 NULL。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

如果沒有`CWnd`子級,此函數將返回 NULL。

## <a name="cwndgetupdaterect"></a><a name="getupdaterect"></a>CWnd::取得更新

檢索完全包含更新區域的最小矩形的座標。

```
BOOL GetUpdateRect(
    LPRECT lpRect,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向物件`CRect`或[RECT 結構](/windows/win32/api/windef/ns-windef-rect),該結構用於接收包含更新區域的更新的用戶端座標。

將此參數設定為 NULL 以確定`CWnd`更新區域是否存在於 。 如果*lpRect*為`GetUpdateRect`NULL,則成員函數將返回非零(如果存在更新區域),如果不存在,則返回 0。 這提供了一種確定WM_PAINT消息是否由無效區域產生的方法。 請勿在 Windows 版本 3.0 和更早版本中將此參數設置為 NULL。

*bErase*<br/>
指定是否應擦除更新區域中的背景。

### <a name="return-value"></a>傳回值

指定更新區域的狀態。 如果更新區域不為空,則該值為非零;否則 0。

如果*lpRect*參數設定為 NULL,則如果存在更新區域,則返回值為非零;否則 0。

### <a name="remarks"></a>備註

如果使用`CWnd`CS_OWNDC 樣式創建,並且映射模式未MM_TEXT,則`GetUpdateRect`成員函數在邏輯座標中提供矩形。 否則,`GetUpdateRect`在客戶端座標中給出矩形。 如果沒有更新區域,則`GetUpdateRect`將矩形設置為空(將所有座標設置為 0)。

*bErase*參數指定是否`GetUpdateRect`應擦除更新區域的背景。 如果*bErase*為 TRUE,並且更新區域不為空,則刪除背景。 要擦除背景,WM_ERASEBKGND`GetUpdateRect`消息[WM_ERASEBKGND](#onerasebkgnd)。

[BeginPaint](#beginpaint)成員函數檢索的更新矩形`GetUpdateRect`與 成員函數檢索的更新矩形相同。

成員`BeginPaint`函數會自動驗證更新區域,因此`GetUpdateRect`在調`BeginPaint`用 以檢索空更新區域后立即對所做的任何調用都會進行。

## <a name="cwndgetupdatergn"></a><a name="getupdatergn"></a>CWnd::取得更新Rgn

將更新區域檢索到*pRgn*標識的區域。

```
int GetUpdateRgn(
    CRgn* pRgn,
    BOOL bErase = FALSE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
標識更新區域。

*bErase*<br/>
指定是否擦除背景,是否繪製子視窗的非工作區。 如果值為 FALSE,則不執行任何繪圖。

### <a name="return-value"></a>傳回值

指定指示結果區域類型的短整數標誌。 該值可以採用以下任一值:

- 區域沒有重疊邊框。

- 區域具有重疊邊框。

- NULL 區域為空。

- 未創建任何區域。

### <a name="remarks"></a>備註

此區域的座標相對於左上角(用戶端座標)。

[BeginPaint](#beginpaint)成員函數會自動驗證更新區域,因此`GetUpdateRgn`在調`BeginPaint`用 以檢索空更新區域後立即對所做的任何調用都會進行。

## <a name="cwndgetwindow"></a><a name="getwindow"></a>CWnd::取得視窗

返回指向請求的視窗的指標,如果沒有,則返回 NULL。

```
CWnd* GetWindow(UINT nCmd) const;
```

### <a name="parameters"></a>參數

*nCmd*<br/>
指定視窗與返回`CWnd`視窗之間的關係。 它可以採取以下值之一:

- GW_CHILD 標識`CWnd`第 一個子視窗。

- GW_HWNDFIRST`CWnd`如果是子視窗,則返回第一個同級視窗。 否則,它將返回清單中的第一個頂級視窗。

- GW_HWNDLAST`CWnd`如果是子視窗,則返回最後一個同級視窗。 否則,它將返回清單中的最後一個頂級視窗。

- GW_HWNDNEXT 返回視窗管理員清單中的下一個視窗。

- GW_HWNDPREV返回視窗管理員清單中的上一個視窗。

- GW_OWNER`CWnd`標識擁有者。

### <a name="return-value"></a>傳回值

返回的指標可能是臨時的,不應存儲以供以後使用。

## <a name="cwndgetwindowcontexthelpid"></a><a name="getwindowcontexthelpid"></a>CWnd::取得視窗上下文幫助Id

呼叫此成員函數以檢索與視窗關聯的説明上下文標識符(如果有)。

```
DWORD GetWindowContextHelpId() const;
```

### <a name="return-value"></a>傳回值

説明上下文標識碼。 如果窗口沒有,則返回 0。

## <a name="cwndgetwindowedchildcount"></a><a name="getwindowedchildcount"></a>CWnd::獲取視窗兒童計數

調用此成員函數以檢索關聯的子視窗數。

```
long GetWindowedChildCount();
```

### <a name="return-value"></a>傳回值

與`CWnd`物件關聯的子視窗數。

## <a name="cwndgetwindowdc"></a><a name="getwindowdc"></a>CWnd::取得視窗DC

檢索整個視窗的顯示上下文,包括標題列、功能表和滾動條。

```
CDC* GetWindowDC();
```

### <a name="return-value"></a>傳回值

如果函數成功,則標識給定視窗的顯示上下文;否則 NULL。

返回的指標可能是臨時的,不應存儲以供以後使用。 [ReleaseDC](#releasedc)對於每次`GetWindowDC`成功調用 時,應調用釋放 DC 一次。

### <a name="remarks"></a>備註

視窗顯示上下文允許在`CWnd`中的任意位置進行繪製,因為上下文的原點是工作區`CWnd`的 左上角,而不是工作區。

每次檢索上下文時,默認屬性都會分配給顯示上下文。 以前的屬性將丟失。

`GetWindowDC`用於`CWnd`非客戶區域內的特殊繪畫效果。 不建議在任何視窗的非用戶端區域進行繪畫。

[GetSystemMetrics](/windows/win32/api/winuser/nf-winuser-getsystemmetrics) Windows 功能可用於檢索非工作區各個部分的尺寸,如標題列、功能表和滾動條。

繪製完成後,必須調用[ReleaseDC](#releasedc)成員函數以釋放顯示上下文。 由於同時打開的設備上下文數受到限制,未能釋放顯示上下文將嚴重影響應用程式請求的繪製。

## <a name="cwndgetwindowinfo"></a><a name="getwindowinfo"></a>CWnd::取得視窗資訊

檢索有關視窗的資訊。

```
BOOL GetWindowInfo(PWINDOWINFO pwi) const;
```

### <a name="parameters"></a>參數

*普基*<br/>
指向[WINDOWINFO](/windows/win32/api/winuser/ns-winuser-windowinfo)結構的指標。

### <a name="remarks"></a>備註

此成員函數類比函數[GetWindowInfo](/windows/win32/api/winuser/nf-winuser-getwindowinfo)的功能,如 Windows SDK 中所述。

## <a name="cwndgetwindowlesschildcount"></a><a name="getwindowlesschildcount"></a>CWnd::獲取無視窗兒童計數

檢索關聯的無視窗子視窗數。

```
long GetWindowlessChildCount();
```

### <a name="return-value"></a>傳回值

與`CWnd`物件關聯的無視窗子視窗數。

## <a name="cwndgetwindowplacement"></a><a name="getwindowplacement"></a>CWnd::抓取視窗放置

擷取視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
```

### <a name="parameters"></a>參數

*普爾溫德普爾*<br/>
指向接收顯示`WINDOWPLACEMENT`狀態和位置資訊的結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

此`flags`函數檢索的[WINDOW 放置](/windows/win32/api/winuser/ns-winuser-windowplacement)結構的成員始終為 0。 如果`CWnd`最大化,則`showCmd`的成員`WINDOWPLACEMENT`SW_SHOWMAXIMIZED。 如果視窗最小化,則SW_SHOWMINIMIZED。 否則SW_SHOWNORMAL。

## <a name="cwndgetwindowrect"></a><a name="getwindowrect"></a>CWnd::取得視窗Rect

將`CWnd`物件邊界矩形的尺寸複製到*lpRect*指向的結構。

```cpp
void GetWindowRect(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpRect*<br/>
指向將接收`CRect`左上角與右下角螢幕座標的物件或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。

### <a name="remarks"></a>備註

尺寸在螢幕座標中相對於顯示幕的左上角給出。 包括標題、邊框和滾動條(如果存在)的尺寸。

## <a name="cwndgetwindowrgn"></a><a name="getwindowrgn"></a>CWnd::取得視窗Rgn

調用此成員函數以獲取視窗的視窗區域。

```
int GetWindowRgn(HRGN hRgn)const;
```

### <a name="parameters"></a>參數

*hRgn*<br/>
視窗區域的句柄。

### <a name="return-value"></a>傳回值

返回值指定函數獲取的區域的類型。 它可能是下列其中一個值：

- NULL 區域為空。

- 區域是單個矩形。

- 區域是多個矩形。

- 錯誤 發生錯誤;該區域不受影響。

### <a name="remarks"></a>備註

視窗區域確定操作系統允許繪圖的視窗內的區域。 作業系統不顯示視窗區域外部的視窗的任何部分。

視窗視窗區域的座標相對於視窗的左上角,而不是視窗的工作區。

要設定視窗的視窗區域,請呼叫[CWnd::setWindowRgn](#setwindowrgn)。

## <a name="cwndgetwindowtext"></a><a name="getwindowtext"></a>CWnd::取得視窗文字

將`CWnd`標題標題(如果有)複製到*lpszStringBuf*指向的緩衝區或目標字串*rString*中。

```
int GetWindowText(
    LPTSTR lpszStringBuf,
    int nMaxCount) const;

void GetWindowText(
    CString& rString) const;
```

### <a name="parameters"></a>參數

*lpszStringBuf*<br/>
指向要接收視窗標題的複製字串的緩衝區。

*nMax( N) Count*<br/>
指定要複製到緩衝區的最大字元數,包括終止空字元。 如果字串長於*nMaxCount*中指定的字元數,則該字串將被截斷。

*rString*<br/>
接收視窗標題的複製字串的[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件。

### <a name="return-value"></a>傳回值

指定複製字串的長度(以字元形式表示),不包括終止空字元。 如果沒有`CWnd`標題或標題為空,則為 0。

### <a name="remarks"></a>備註

如果`CWnd`對像是控制項,`GetWindowText`則成員函數將複製控制項中的文本,而不是複製標題。

此成員函數會導致[將WM_GETTEXT](/windows/win32/winmsg/wm-gettext)訊息發送到`CWnd`物件。

### <a name="example"></a>範例

  請參考[CWnd 範例::設定視窗文字](#setwindowtext)。

## <a name="cwndgetwindowtextlength"></a><a name="getwindowtextlength"></a>CWnd::取得視窗文字長度

返回`CWnd`物件標題標題的長度。

```
int GetWindowTextLength() const;
```

### <a name="return-value"></a>傳回值

以字元指定文本長度,不包括任何空終止字元。 如果沒有此類文本,則該值為 0。

### <a name="remarks"></a>備註

如果是`CWnd`控制項,則`GetWindowTextLength`成員函數返回控制項中文本的長度,而不是標題。

此成員函數會會將[WM_GETTEXTLENGTH](/windows/win32/winmsg/wm-gettextlength)訊息傳送`CWnd`到物件 。

### <a name="example"></a>範例

  請參考[CWnd 範例::設定視窗文字](#setwindowtext)。

## <a name="cwndhidecaret"></a><a name="hidecaret"></a>CWnd::隱藏卡斯特

藉由從顯示畫面移除插入號來隱藏該插入號。

```cpp
void HideCaret();
```

### <a name="remarks"></a>備註

儘管 caret 不再可見,但可以使用[ShowCaret](#showcaret)成員函數再次顯示它。 隱藏 caret 不會破壞其當前形狀。

隱藏是累積的。 如果`HideCaret`連續調用了五次`ShowCaret`, 則必須對成員函數調用五次,然後才能顯示該 caret。

## <a name="cwndhilitemenuitem"></a><a name="hilitemenuitem"></a>CWnd::HiliteMenu專案

從頂級(功能表欄)功能表項中突出顯示或刪除高光。

```
BOOL HiliteMenuItem(
    CMenu* pMenu,
    UINT nIDHiliteItem,
    UINT nHilite);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
標識包含要突出顯示的項目的頂級功能表。

*nIDHilite 專案*<br/>
指定要突出顯示的功能表項,具體取決於*nHilite*參數的值。

*nHilite*<br/>
指定選單項是突出顯示還是刪除高光。 它可以是MF_HILITE或MF_UNHILITE與MF_BYCOMMAND或MF_BYPOSITION的組合。 可以使用位或運算符組合這些值。 這些值具有以下意義：

- MF_BYCOMMAND將*nIDHiliteItem*解釋為功能表項 ID(預設解釋)。

- MF_BYPOSITION將*nIDHiliteItem*解釋為功能表項的零偏移量。

- MF_HILITE突出顯示該專案。 如果未給出此值,則從項中刪除高光。

- MF_UNHILITE從項目中刪除高光。

### <a name="return-value"></a>傳回值

指定選單項目是否突出顯示。 如果項目突出顯示,則非零;否則 0。

### <a name="remarks"></a>備註

MF_HILITE和MF_UNHILITE標誌只能用於此成員函數;因此,這些標誌只能用於此成員函數。它們不能與[CMenu::修改功能表](../../mfc/reference/cmenu-class.md#modifymenu)成員函數一起使用。

## <a name="cwndhtmlhelp"></a><a name="htmlhelp"></a>CWnd::Html說明

呼叫此成員函數以呼叫 HTMLHelp 應用程式。

```
virtual void HtmlHelp(
    DWORD_PTR dwData,
    UINT nCmd = 0x000F);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他數據。 使用的值取決於*nCmd*參數的值。

*nCmd*<br/>
指定要求的說明類型。 有關可能值的清單及其如何影響*dwData*參數,請參閱 Windows SDK 中的 HTML 説明 API 參考中描述的*uCommand*參數。

### <a name="remarks"></a>備註

有關詳細資訊[,請參閱 CWinApp:html 説明](../../mfc/reference/cwinapp-class.md#htmlhelp)。

## <a name="cwndinitdynamiclayout"></a><a name="initdynamiclayout"></a>Cwnd::動態佈局

由架構呼叫以初始化視窗的動態配置。

```cpp
void InitDynamicLayout();
```

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

## <a name="cwndinvalidate"></a><a name="invalidate"></a>Cwnd:無效

將整個工作區無效`CWnd`。

```cpp
void Invalidate(BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*bErase*<br/>
指定是否擦除更新區域中的背景。

### <a name="remarks"></a>備註

當下一[個WM_PAINT](#onpaint)消息發生時,將標記工作區以進行繪製。 在[驗證 Rect](#validaterect)或[ValidateRgn](#validatergn)成員函數發生WM_PAINT消息之前,還可以驗證該區域。

*bErase*參數指定在處理更新區域時是否擦除更新區域中的背景。 如果 bErase 為 TRUE,則在調用 BeginPaint 成員函數時擦除背景;如果*bErase*為 TRUE,則在調用[BeginPaint](#beginpaint)成員函數時,將擦除背景。如果*bErase*是 FALSE,則背景保持不變。 如果*bErase*對於更新區域的任何部分都為 TRUE,則整個區域(而不僅僅是給定部分)的背景將被刪除。

每當更新區域[WM_PAINT](#onpaint)不為空且`CWnd`該視窗的應用程式佇列中沒有其他消息時,Windows 都會發送WM_PAINT消息。

### <a name="example"></a>範例

  請參考[CWnd 範例::更新視窗](#updatewindow)。

## <a name="cwndinvalidaterect"></a><a name="invalidaterect"></a>Cwnd::無效重

通過將該矩形添加到`CWnd`更新區域,使給定矩形中的工作區失效。

```cpp
void InvalidateRect(
    LPCRECT lpRect,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
包含要`CRect`新增到更新區域的矩形(在客戶端座標中)的物件或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。 如果*lpRect*為 NULL,則整個工作區將添加到該區域。

*bErase*<br/>
指定是否擦除更新區域中的背景。

### <a name="remarks"></a>備註

在發送下一[WM_PAINT](#onpaint)消息時,將標記無效矩形以及更新區域中的所有其他區域進行繪製。 無效區域在更新區域中累積,直到在下一個WM_PAINT調用發生時處理該區域,或直到[驗證雷Ct](#validaterect)或[ValidateRgn](#validatergn)成員函數驗證該區域。

*bErase*參數指定在處理更新區域時是否擦除更新區域中的背景。 如果 bErase 為 TRUE,則在調用 BeginPaint 成員函數時擦除背景;如果*bErase*為 TRUE,則在調用[BeginPaint](#beginpaint)成員函數時,將擦除背景。如果*bErase*是 FALSE,則背景保持不變。 如果*bErase*對於更新區域的任何部分都為 TRUE,則整個區域的背景將被刪除,而不僅僅是在給定部分中。

每當更新區域[WM_PAINT](#onpaint)不為空且`CWnd`該視窗的應用程式佇列中沒有其他消息時,Windows 都會發送WM_PAINT消息。

## <a name="cwndinvalidatergn"></a><a name="invalidatergn"></a>Cwnd:無效

通過將給定區域中的工作區添加到`CWnd`的當前更新區域,使該工作區無效。

```cpp
void InvalidateRgn(
    CRgn* pRgn,
    BOOL bErase = TRUE);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
指向[CRgn](../../mfc/reference/crgn-class.md)物件的指標,用於標識要添加到更新區域的區域。 假定該區域具有客戶端座標。 如果此參數為 NULL,則整個工作區將添加到更新區域。

*bErase*<br/>
指定是否擦除更新區域中的背景。

### <a name="remarks"></a>備註

在下次發送[WM_PAINT](#onpaint)訊息時,將標記無效區域以及更新區域中的所有其他區域進行繪製。 無效區域在更新區域中累積,直到下次發送WM_PAINT消息時處理該區域,或直到[驗證雷訊](#validaterect)或[驗證 Rgn](#validatergn)成員函數驗證該區域。

*bErase*參數指定在處理更新區域時是否擦除更新區域中的背景。 如果 bErase 為 TRUE,則在調用 BeginPaint 成員函數時擦除背景;如果*bErase*為 TRUE,則在調用[BeginPaint](#beginpaint)成員函數時,將擦除背景。如果*bErase*是 FALSE,則背景保持不變。 如果*bErase*對於更新區域的任何部分都為 TRUE,則整個區域(而不僅僅是給定部分)的背景將被刪除。

每當更新區域[WM_PAINT](#onpaint)不為空且`CWnd`該視窗的應用程式佇列中沒有其他消息時,Windows 都會發送WM_PAINT消息。

給定區域以前必須由區域函數之一創建。

## <a name="cwndinvokehelper"></a><a name="invokehelper"></a>CWnd::InvokeHelper

呼叫此成員函數以呼叫*dwDispID*指定的 ActiveX 控制方法或屬性,該上下文中由*wFlags*指定。

```cpp
void AFX_CDECL InvokeHelper(
    DISPID dwDispID,
    WORD wFlags,
    VARTYPE vtRet,
    void* pvRet,
    const BYTE* pbParamInfo,
    ... );
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
指定所要叫用的屬性或方法。

*wFlags*<br/>
描述對`IDispatch::Invoke`的調用上下文的標誌。

*弗特雷特*<br/>
指定傳回值的類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*pvRet*<br/>
將接收屬性值或返回值的變數的位址。 它必須與*vtRet*指定的類型匹配。

*pbParamInfo*<br/>
指向 null 連接端的位元串的指標,指定*pbParamInfo*之後的參數類型。 有關可能的值,請參閱`COleDispatchDriver::InvokeHelper`的備註部分。

*...*<br/>
參數的變數清單,在*pbParamInfo*中指定的類型。

### <a name="remarks"></a>備註

*pbParamInfo*參數指定傳遞給方法或屬性的參數的類型。 引數的變數清單會以 *...* 語法宣告代表。

此函數將參數轉換為 VARIANTARG 值,然後在`IDispatch::Invoke`ActiveX 控件上調用方法。 若呼叫 `IDispatch::Invoke` 失敗，此函式會擲回例外狀況。 如果傳`IDispatch::Invoke`回的 SCODE(狀態代碼)DISP_E_EXCEPTION,則此函數將引發[一個 COleException](../../mfc/reference/coleexception-class.md)物件,否則將引發[COleDispatchException](../../mfc/reference/coledispatchexception-class.md)。

> [!NOTE]
> 此函數應僅在表示 ActiveX`CWnd`控制件的物件上調用。

有關將此成員函數與 ActiveX 控制容器一起使用的詳細資訊,請參閱文章[ActiveX 控制件容器:在 ActiveX 控制元件容器中程式設計 ActiveX 控制件](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndischild"></a><a name="ischild"></a>CWnd::是兒童

指示*pWnd*指定的視窗是子`CWnd`視窗還是的其他直接後代。

```
BOOL IsChild(const CWnd* pWnd) const;
```

### <a name="parameters"></a>參數

*pwnd*<br/>
標識要測試的視窗。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果*pWnd*標識的`CWnd`視窗是 中的子視窗,則該值為非零。否則 0。

### <a name="remarks"></a>備註

子視窗是`CWnd`對象位於父視窗`CWnd`鏈中的 直接後代,該鏈從原始彈出視窗到子視窗。

## <a name="cwndisd2dsupportenabled"></a><a name="isd2dsupportenabled"></a>CWnd:isD2D 支援啟用

確定是否啟用了 D2D 支援。

```
BOOL IsD2DSupportEnabled();
```

### <a name="return-value"></a>傳回值

如果啟用了該功能,則為 TRUE;如果啟用了該功能,則為 TRUE。否則 FALSE。

## <a name="cwndisdialogmessage"></a><a name="isdialogmessage"></a>Cwnd::對話訊息

調用此成員函數以確定給定的消息是否用於無模式對話方塊;請調用此成員函數,以確定給定消息是否用於無模式對話方塊;如果是,此函數將處理消息。

```
BOOL IsDialogMessage(LPMSG lpMsg);
```

### <a name="parameters"></a>參數

*lpMsg*<br/>
指向包含要檢查的消息的[MSG](/windows/win32/api/winuser/ns-winuser-msg)結構。

### <a name="return-value"></a>傳回值

指定成員函數是否已處理給定的消息。 如果已處理消息,則為非零;否則 0。 如果返回為 0,請致電基類的[CWnd::P重新翻譯消息](#pretranslatemessage)成員函數來處理消息。 在成員函數的重寫`CWnd::PreTranslateMessage`中,代碼如下所示:

[!code-cpp[NVC_MFCWindowing#100](../../mfc/reference/codesnippet/cpp/cwnd-class_40.cpp)]

### <a name="remarks"></a>備註

當`IsDialogMessage`函數處理消息時,它會檢查鍵盤消息並將其轉換為相應對話框的選擇命令。 例如,TAB 鍵選擇下一個控制項或控制元件,向下箭頭鍵選擇組中的下一個控制項。

您不得將處理`IsDialogMessage`的消息傳遞給[翻譯訊息](/windows/win32/api/winuser/nf-winuser-translatemessage)或[調度訊息](/windows/win32/api/winuser/nf-winuser-dispatchmessage)視窗功能,因為它已處理。

## <a name="cwndisdlgbuttonchecked"></a><a name="isdlgbuttonchecked"></a>CWnd::IsDlgButtonChecked

確定按鈕控件旁邊是否有複選標記。

```
UINT IsDlgButtonChecked(int nIDButton) const;
```

### <a name="parameters"></a>參數

*nIDButton*<br/>
指定按鈕控制項的整數識別碼。

### <a name="return-value"></a>傳回值

如果選中給定控件,則為非零;如果未選中則為 0。 只能選中單選按鈕和複選框。 對於三狀態按鈕,如果按鈕不確定,則返回值可以是 2。 此成員函數返回 0 的按鈕。

### <a name="remarks"></a>備註

如果按鈕是三狀態控件,則成員函數將確定該按鈕是變暗、選中還是兩者均未調暗。

## <a name="cwndisdynamiclayoutenabled"></a><a name="isdynamiclayoutenabled"></a>CWnd::動態佈局啟用

決定是否在這個視窗上啟用動態配置。 如果啟用動態配置時，則使用者可在調整父視窗大小時變更子視窗的位置與大小。

```
BOOL IsDynamicLayoutEnabled() const;
```

### <a name="return-value"></a>傳回值

如果啟用動態配置則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndisiconic"></a><a name="isiconic"></a>CWnd::圖示

指定是否`CWnd`最小化(圖示)。

```
BOOL IsIconic() const;
```

### <a name="return-value"></a>傳回值

如果最小化`CWnd`,則非零;否則 0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

## <a name="cwndistouchwindow"></a><a name="istouchwindow"></a>CWnd::是觸摸視窗

指定 `CWnd` 是否有觸控支援。

```
BOOL IsTouchWindow() const;
```

### <a name="return-value"></a>傳回值

TRUE,`CWnd`如果有觸摸支援;否則 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndiswindowenabled"></a><a name="iswindowenabled"></a>CWnd::已啟用視窗

指定是否`CWnd`為滑鼠和鍵盤輸入啟用。

```
BOOL IsWindowEnabled() const;
```

### <a name="return-value"></a>傳回值

未歸零`CWnd`(如果啟用);否則 0。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#102](../../mfc/reference/codesnippet/cpp/cwnd-class_42.cpp)]

## <a name="cwndiswindowvisible"></a><a name="iswindowvisible"></a>CWnd::視窗可見

確定給定視窗的可見性狀態。

```
BOOL IsWindowVisible() const;
```

### <a name="return-value"></a>傳回值

如果`CWnd`為不可見,則非零(設置[WS_VISIBLE](styles-used-by-mfc.md#window-styles)樣式位,並且父窗口可見)。 由於返回值反映WS_VISIBLE樣式位的狀態,因此返回值可能是非零的,即使`CWnd`其他視窗完全模糊了返回值。

### <a name="remarks"></a>備註

視窗具有WS_VISIBLE樣式位指示的可見性狀態。 當使用對[ShowWindow](#showwindow)成員函數的調用設定此樣式位時,將顯示視窗,只要視窗設置了樣式位,將顯示視窗的後續圖形。

如果視窗被其他窗口覆蓋或由其父視窗剪切,則不會顯示具有WS_VISIBLE樣式的視窗的任何繪圖。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#103](../../mfc/reference/codesnippet/cpp/cwnd-class_43.cpp)]

## <a name="cwndiszoomed"></a><a name="iszoomed"></a>Cwnd::放大縮小字體功能 放大縮小字體功能

確定是否已`CWnd`最大化。

```
BOOL IsZoomed() const;
```

### <a name="return-value"></a>傳回值

如果最大化`CWnd`,則非零;否則 0。

## <a name="cwndkilltimer"></a><a name="killtimer"></a>CWnd::基爾蒂默

從之前對`SetTimer`的調用中終止*nIDEvent*標識的計時器事件。

```
BOOL KillTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
傳遞給[SetTimer](#settimer)的計時器事件的值。

### <a name="return-value"></a>傳回值

指定函數的結果。 如果事件已終止,則該值為非零。 如果成員函數找不到指定的`KillTimer`計時器事件,則為 0。

### <a name="remarks"></a>備註

與計時器關聯的[掛起WM_TIMER](#ontimer)消息不會從消息佇列中刪除。

### <a name="example"></a>範例

  請參閱[CWnd::SetTimer](#settimer)的範例。

## <a name="cwndloaddynamiclayoutresource"></a><a name="loaddynamiclayoutresource"></a>CWnd::載入動態佈局資源

由架構呼叫以從資源檔載入動態配置資訊。

```
BOOL LoadDynamicLayoutResource(LPCTSTR lpszResourceName);
```

### <a name="parameters"></a>參數

*lpsz 資源名稱*<br/>
包含此視窗所需之動態配置資訊的資源名稱。

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 如果發生失敗，則為 0。

### <a name="remarks"></a>備註

請勿直接呼叫這個方法。

## <a name="cwndlockwindowupdate"></a><a name="lockwindowupdate"></a>CWnd::鎖視窗更新

禁用給定視窗中的繪圖。

```
BOOL LockWindowUpdate();
```

### <a name="return-value"></a>傳回值

如果函式成功，則為非零。 如果發生故障或函數已用於鎖定另一個`LockWindowUpdate`視窗,則為 0。

### <a name="remarks"></a>備註

無法移動鎖定的視窗。 一次只能鎖定一個視窗。 要解鎖鎖定的視窗,`LockWindowUpdate`請呼叫[解鎖視窗更新](#unlockwindowupdate)。

如果具有鎖定視窗(或任何鎖定的子視窗)的應用程式調用[GetDC、GetDCEx](/windows/win32/api/winuser/nf-winuser-getdc)[GetDCEx,](/windows/win32/api/winuser/nf-winuser-getdcex)或[BeginPaint](/windows/win32/api/winuser/nf-winuser-beginpaint) Windows 函數,則被調用的函數將返回其可見區域為空的設備上下文。 這將發生,直到應用程式通過調用`UnlockWindowUpdate`成員函數解鎖視窗。

當視窗更新被鎖定時,系統會跟蹤與鎖定視窗關聯的設備上下文的任何繪圖操作的邊界矩形。 重新啟用繪圖時,此邊界矩形在鎖定的視窗及其子視窗中失效,以強制最終[WM_PAINT](/windows/win32/gdi/wm-paint)消息更新螢幕。 如果在視窗更新鎖定時未發生繪圖,則沒有區域無效。

成員`LockWindowUpdate`函數不會使給定視窗不可見,也不會清除[WS_VISIBLE](styles-used-by-mfc.md#window-styles)樣式位。

## <a name="cwndm_hwnd"></a><a name="m_hwnd"></a>CWnd::m_hWnd

附加到此`CWnd`的 Windows 視窗的句柄。

```
HWND m_hWnd;
```

### <a name="remarks"></a>備註

數據`m_hWnd`成員是HWND類型的公共變數。

## <a name="cwndmapwindowpoints"></a><a name="mapwindowpoints"></a>CWnd::地圖視窗點

將一組點從 `CWnd` 的座標空間轉換 (對應) 至另一個視窗的座標空間。

```cpp
void MapWindowPoints(
    CWnd* pwndTo,
    LPRECT lpRect) const;

void MapWindowPoints(
    CWnd* pwndTo,
    LPPOINT lpPoint,
    UINT nCount) const;
```

### <a name="parameters"></a>參數

*普恩托*<br/>
標識將點轉換為的視窗。 如果此參數為 NULL,則點將轉換為螢幕座標。

*lpRect*<br/>
指定要轉換其點的矩形。 此功能的第一個版本僅適用於 Windows 3.1 及更高版本。

*lpPoint*<br/>
指向[POINT 結構](/windows/win32/api/windef/ns-windef-point)陣列的指標,其中包含要轉換的點集。

*n( N) Count*<br/>
指定`POINT`*lpPoint*指向的陣列中的結構數。

## <a name="cwndmessagebox"></a><a name="messagebox"></a>CWnd::消息框

創建並顯示包含應用程式提供的消息和標題的視窗,以及[消息框樣式](../../mfc/reference/styles-used-by-mfc.md#message-box-styles)清單中所述的預定義圖示和按鈕的組合。

```
int MessageBox(
    LPCTSTR lpszText,
    LPCTSTR lpszCaption = NULL,
    UINT nType = MB_OK);
```

### <a name="parameters"></a>參數

*lpszText*<br/>
指向包含`CString`要顯示的消息的物件或空端接字串。

*lpszCaption*<br/>
指向要用於`CString`訊息框標題的物件或空端接字串。 如果*lpszCaption*為 NULL,則使用預設標題"

*nType*<br/>
指定消息框的內容和行為。

### <a name="return-value"></a>傳回值

此方法利用 Windows SDK 中定義的[MessageBox](/windows/win32/api/winuser/nf-winuser-messagebox)函數。 此方法返回調用此函數的結果。

### <a name="remarks"></a>備註

使用全域函數[AfxMessageBox](../../mfc/reference/cstring-formatting-and-message-box-display.md#afxmessagebox)而不是此成員函數在應用程式中實現消息框。

下面顯示了可在訊息框中使用的各種系統圖示:

|||
|-|-|
|![停止&#40;x&#41;图标](../../mfc/reference/media/vc364f1.gif "停止&#40;x&#41;图标")|MB_ICONHAND、MB_ICONSTOP和MB_ICONERROR|
|![說明&#40;&#41;圖示](../../mfc/reference/media/vc364f2.gif "說明&#40;&#41;圖示")|MB_ICONQUESTION|
|![重要 &#40;&#33;&#41; 圖示](../../mfc/reference/media/vc364f3.gif "重要 &#40;&#33;&#41; 圖示")|MB_ICONEXCLAMATION和MB_ICONWARNING|
|![資訊&#40;i&#41;图标](../../mfc/reference/media/vc364f4.gif "資訊&#40;i&#41;图标")|MB_ICONASTERISK和MB_ICONINFORMATION|

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#104](../../mfc/reference/codesnippet/cpp/cwnd-class_44.cpp)]

## <a name="cwndmodifystyle"></a><a name="modifystyle"></a>CWnd::修改樣式

調用此成員函數以修改視窗的樣式。

```
BOOL ModifyStyle(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定要在樣式修改期間刪除的視窗樣式。

*dwAdd*<br/>
指定要在樣式修改期間添加的視窗樣式。

*nFlags*<br/>
要傳遞給[SetWindowPos](#setwindowpos)的標記`SetWindowPos`,如果 不應調用,則為零。 預設值為 0。 有關預設標誌的清單,請參閱備註部分。

### <a name="return-value"></a>傳回值

如果樣式已成功修改,則非零;否則,0。

### <a name="remarks"></a>備註

可以使用位或(&#124;)運算符組合要添加或刪除的樣式。 有關可用視窗樣式的資訊,請參閱 Windows SDK 中的主題[「視窗樣式](/windows/win32/winmsg/window-styles)」和[「創建視窗](/windows/win32/api/winuser/nf-winuser-createwindoww)」 。。

如果*nFlags*是`ModifyStyle`非零 ,請呼叫 Windows API 函數[SetWindowPos,](/windows/win32/api/winuser/nf-winuser-setwindowpos)並透過*nFlags*與以下四個預設標誌組合來重繪視窗:

- SWP_NOSIZE 保留當前大小。

- SWP_NOMOVE 保留當前位置。

- SWP_NOZORDER保留當前 Z 訂單。

- SWP_NOACTIVATE不激活視窗。

要修改視窗的擴展樣式,請參閱[修改樣式Ex。](#modifystyleex)

> [!NOTE]
> 對於某些控制檔中的某些樣式(例如,編輯控制項中的ES_READONLY樣式),`ModifyStyle`可能無法正確更改樣式,因為控制項可能需要執行特殊的內部處理。 在這些情況下,將顯示一條相應的消息來更改樣式(EM_SETREADONLY上述示例中)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#105](../../mfc/reference/codesnippet/cpp/cwnd-class_45.cpp)]

## <a name="cwndmodifystyleex"></a><a name="modifystyleex"></a>CWnd::修改風格

呼叫此成員函數以修改視窗的擴展樣式。

```
BOOL ModifyStyleEx(
    DWORD dwRemove,
    DWORD dwAdd,
    UINT nFlags = 0);
```

### <a name="parameters"></a>參數

*dwRemove*<br/>
指定在樣式修改期間要刪除的擴展樣式。

*dwAdd*<br/>
指定樣式修改期間要添加的擴展樣式。

*nFlags*<br/>
要傳遞給[SetWindowPos](#setwindowpos)的標記`SetWindowPos`,如果 不應調用,則為零。 預設值為 0。 有關預設標誌的清單,請參閱備註部分。

### <a name="return-value"></a>傳回值

如果樣式已成功修改,則非零;否則,0。

### <a name="remarks"></a>備註

可以使用位或(&#124;)運算符組合要添加或刪除的樣式。 有關可用延伸樣式的資訊,請參閱本書中的[「延伸視窗樣式](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)」與 Windows SDK 中的[「建立 WindowEx」](/windows/win32/api/winuser/nf-winuser-createwindowexw)主題

如果*nFlags*是`ModifyStyleEx`非零 ,請呼叫 Windows API 函數[SetWindowPos,](/windows/win32/api/winuser/nf-winuser-setwindowpos)並透過*nFlags*與以下四個預設標誌組合來重繪視窗:

- SWP_NOSIZE 保留當前大小。

- SWP_NOMOVE 保留當前位置。

- SWP_NOZORDER保留當前 Z 訂單。

- SWP_NOACTIVATE不激活視窗。

要使用一般視窗樣式修改視窗,請參閱[修改樣式](#modifystyle)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#106](../../mfc/reference/codesnippet/cpp/cwnd-class_46.cpp)]

## <a name="cwndmovewindow"></a><a name="movewindow"></a>CWnd::移動視窗

更改位置和尺寸。

```cpp
void MoveWindow(
    int x,
    int y,
    int nWidth,
    int nHeight,
    BOOL bRepaint = TRUE);

void MoveWindow(
    LPCRECT lpRect,
    BOOL bRepaint = TRUE);
```

### <a name="parameters"></a>參數

*x*<br/>
指定 左方`CWnd`的左方的位置 。

*Y*<br/>
指定 頂端`CWnd`的新位置 。

*n 寬度*<br/>
指定的新`CWnd`寬度。

*nHeight*<br/>
指定的新`CWnd`高度。

*bRepaint*<br/>
指定是否`CWnd`重新繪製。 如果為`CWnd`TRUE,則像往常一樣在其[OnPaint](#onpaint)消息處理程式中接收[WM_PAINT](/windows/win32/gdi/wm-paint)消息。 如果此參數為 FALSE,則不進行任何重新繪製。 這適用於工作區、非工作區(包括標題和滾動條)以及因移動而顯示的`CWnd`父視窗的任何部分。 當此參數為 FALSE 時,應用程式必須顯式無效或重繪必須`CWnd`重繪 的和父視窗的任何部分。

*lpRect*<br/>
指定新大小與位置的[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。

### <a name="remarks"></a>備註

對於頂級`CWnd`物件 *,x*和*y*參數相對於螢幕的左上角。 對於子`CWnd`物件,它們相對於父視窗工作區的左上角。

函數`MoveWindow`傳送[WM_GETMINMAXINFO](#ongetminmaxinfo)訊息。 處理此消息提供了`CWnd`修改最大和最小視窗的預設值的機會。 如果成員函數的`MoveWindow`參數超過這些值,則可以將值替換為WM_GETMINMAXINFO處理程式中的最小值或最大值。

### <a name="example"></a>範例

  請參閱[CWnd::用戶端螢幕](#clienttoscreen)的範例。

## <a name="cwndnotifywinevent"></a><a name="notifywinevent"></a>CWnd::通知溫事件

表示發生預先定義之事件的系統。 如果任何用戶端應用程式已註冊事件的挂鉤函數,系統將調用用戶端的挂鉤函數。

```cpp
void NotifyWinEvent(
    DWORD event,
    LONG idObjectType,
    LONG idObject);
```

### <a name="parameters"></a>參數

*event*<br/>
指定發生的事件。 此值必須是[事件常量](/windows/win32/WinAuto/event-constants)之一。

*識別物件類型*<br/>
標識生成事件的物件類型。 此值是預定義[物件識別碼](/windows/win32/WinAuto/object-identifiers)或自定義物件 ID 值之一。

*idObject*<br/>
標識事件是由對象還是物件的子元素生成的。 如果此值CHILDID_SELF,則事件由物件本身生成。 如果不是,此值是生成事件的元素的子 ID。

### <a name="remarks"></a>備註

此成員函數類比函數[NotifyWinEvent](/windows/win32/api/winuser/nf-winuser-notifywinevent)的功能,如 Windows SDK 中所述。

## <a name="cwndonactivate"></a><a name="onactivate"></a>Cwnd::打開啟動

當物件被啟動或停用時,`CWnd`框架將呼叫此成員函數。

```
afx_msg void OnActivate(
    UINT nState,
    CWnd* pWndOther,
    BOOL bMinimized);
```

### <a name="parameters"></a>參數

*n州*<br/>
指定`CWnd`要啟動中還是停用 。 它可能是下列其中一個值：

- WA_INACTIVE 視窗正在停用。

- WA_ACTIVE視窗正在通過按下滑鼠以外的方法啟動(例如,透過使用鍵盤介面選擇視窗)。

- WA_CLICKACTIVE滑鼠按一下啟動視窗。

*pWnd 其他*<br/>
指向`CWnd`正在啟動或停用的指標。 指標可以是 NULL,並且可能是臨時的。

*b 最小化*<br/>
指定正在啟動或停用的`CWnd`最小化狀態。 TRUE 值表示視窗最小化。

如果為 TRUE,則正在啟動`CWnd`;否則已停用。

### <a name="remarks"></a>備註

如果通過`CWnd`滑鼠按一下啟動物件,它還將收到[OnMouseActivate](#onmouseactivate)成員函數調用。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonactivateapp"></a><a name="onactivateapp"></a>Cwnd::在啟動應用上

該框架將此成員函數調用要啟動的任務的所有頂級視窗以及要停用的任務的所有頂級視窗。

```
afx_msg void OnActivateApp(
    BOOL bActive,
    DWORD dwThreadID);
```

### <a name="parameters"></a>參數

*b 活動*<br/>
指定`CWnd`要啟動中還是停用 。 TRUE`CWnd`表示啟動 。 FALSE`CWnd`表示正在停用 。

*dwThreadID*<br/>
指定線程 ID 的值。 如果*bActive*為 TRUE,dwThreadID`CWnd`標識擁有已 停*dwThreadID*用的線程。 如果*bActive*是 FALSE,dwThreadID`CWnd`標識擁有被*dwThreadID*啟動的線程。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonambientproperty"></a><a name="onambientproperty"></a>Cwnd::環境物業

框架呼叫此成員函數以獲取包含 OLE 控制項的視窗的環境屬性值。

```
virtual BOOL OnAmbientProperty(
    COleControlSite* pSite,
    DISPID dispid,
    VARIANT* pvar);
```

### <a name="parameters"></a>參數

*pSite*<br/>
指向請求環境屬性的控制件的網站。

*不一部分*<br/>
請求的環境屬性的調度 ID。

*普瓦爾*<br/>
指向調用方分配`VARIANT`結構的指標,通過該結構將返回環境屬性的值。

### <a name="return-value"></a>傳回值

如果環境屬性受支援,則為 TRUE;如果沒有,則進行偽造。

### <a name="remarks"></a>備註

重寫此函數以更改 OLE 控制件容器傳回到其控制項的預設環境屬性值。 任何未由重寫函數處理的環境屬性請求都應轉發到基類實現。

## <a name="cwndonappcommand"></a><a name="onappcommand"></a>Cwnd::OnApp命令

當使用者生成應用程式命令事件時,框架將調用此成員函數。 當用戶按一下應用程式命令按鈕或鍵入應用程式命令鍵時,會發生此類事件。

```
afx_msg void OnAppCommand(
    CWnd* pWnd,
    UINT nCmd,
    UINT nDevice,
    UINT nKey);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pwnd*|[在]指向`CWnd`表示使用者按下命令按鈕或按下命令鍵的視窗的物件的指標。 此視窗可以是接收消息的視窗的子視窗。|
|*nCmd*|[在]指示應用程式命令。 有關可能值的清單,請參閱[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand) *lParam*參數的*cmd*部分下的命令。|
|*n 裝置*|[在]生成輸入事件的輸入設備。 有關可能值的清單,請參閱[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand) *lParam*參數的*uDevice*部分下的設備。|
|*N 鍵*|[在]指示任何向下的虛擬鍵,如 CTRL 鍵或滑鼠左鍵。 有關可能值的清單,請參閱[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand) *lParam*參數的*dwKeys*部分下的鍵。 有關詳細資訊,請參閱[有關滑鼠輸入](/windows/win32/inputdev/about-mouse-input)中的"消息參數"副標題。|

### <a name="remarks"></a>備註

此方法接收[WM_APPCOMMAND](/windows/win32/inputdev/wm-appcommand)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonaskcbformatname"></a><a name="onaskcbformatname"></a>Cwnd::在AskCb格式名稱

當剪貼簿包含CF_OWNERDISPLAY格式的數據句柄(即剪貼簿擁有者將顯示剪貼板內容時),框架將調用此成員函數。

```
afx_msg void OnAskCbFormatName(
    UINT nMaxCount,
    LPTSTR lpszString);
```

### <a name="parameters"></a>參數

*nMax( N) Count*<br/>
指定要複製的最大位元組數。

*lpszString*<br/>
指向要儲存格式名稱副本的緩衝區。

### <a name="remarks"></a>備註

剪貼簿擁有者應提供其格式的名稱。

重寫此成員函數,並將CF_OWNERDISPLAY格式的名稱複製到指定的緩衝區中,不超過指定的最大位元組數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncancelmode"></a><a name="oncancelmode"></a>Cwnd::打開取消模式

框架調用此成員函數以通知`CWnd`取消任何內部模式。

```
afx_msg void OnCancelMode();
```

### <a name="remarks"></a>備註

如果`CWnd`物件具有焦點,則在`OnCancelMode`顯示 對話框或消息框時調用其成員函數。 這就有機會`CWnd`取消滑鼠捕獲等模式。

默認實現通過調用[發佈捕獲](/windows/win32/api/winuser/nf-winuser-releasecapture)Windows 功能進行回應。 重寫派生類中的此成員函數以處理其他模式。

## <a name="cwndoncapturechanged"></a><a name="oncapturechanged"></a>Cwnd::在捕獲上

框架調用此成員函數以通知丟失滑鼠捕獲的視窗。

```
afx_msg void OnCaptureChanged(CWnd* pWnd);
```

### <a name="parameters"></a>參數

*pwnd*<br/>
指向視窗的指標,以取得滑鼠擷取

### <a name="remarks"></a>備註

視窗接收此消息,即使它調用[發佈捕獲](/windows/win32/api/winuser/nf-winuser-releasecapture)本身。 應用程式不應嘗試設置滑鼠捕獲以回應此消息。 收到此消息時,視窗應在必要時重新繪製自身以反映新的滑鼠捕獲狀態。

有關 Windows 功能`ReleaseCapture`的資訊, 請參閱 Windows SDK。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchangecbchain"></a><a name="onchangecbchain"></a>Cwnd::在轉換Cb鏈

框架為剪貼簿-查看器鏈中的每個視窗調用此成員函數,以通知其正在從鏈中刪除視窗。

```
afx_msg void OnChangeCbChain(
    HWND hWndRemove,
    HWND hWndAfter);
```

### <a name="parameters"></a>參數

*hWndRemove*<br/>
指定從剪貼簿檢視器鍊中刪除的視窗句柄。

*hWnd 後*<br/>
指定從剪貼簿檢視器鍊中刪除的視窗後面的視窗句柄。

### <a name="remarks"></a>備註

接收`CWnd``OnChangeCbChain`呼叫的每個物件都應使用[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函數將[WM_CHANGECBCHAIN](/windows/win32/dataxchg/wm-changecbchain)訊息發送到剪貼簿檢視器鍊中的下一`SetClipboardViewer`個視窗(由返回的句柄)。 如果*hWndRemove*是鏈中的下一個視窗,則*hWnd 後指定的*視窗將成為下一個視窗,剪貼簿消息將傳遞給它。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchangeuistate"></a><a name="onchangeuistate"></a>Cwnd::在改變狀態

應變更使用者介面 (UI) 狀態時呼叫。

```
afx_msg void OnChangeUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要執行的操作。 可以是下列其中一個值：

- UIS_CLEAR應隱藏 UI 狀態元素(由*nUIElement*指定)。

- UIS_INITIALIZE應基於最後一個輸入事件更改 UI 狀態元素(由*nUIElement*指定)。 有關詳細資訊,請參閱[WM_CHANGEUISTATE](/windows/win32/menurc/wm-changeuistate)的**備註**部分。

- UIS_SET UI 狀態元素(由*nUIElement*指定)應可見。

*nUI元素*<br/>
指定受影響的 UI 狀態元素或控制項的樣式。 可以是下列其中一個值：

- UISF_HIDEACCEL鍵盤加速器。

- UISF_HIDEFOCUS焦點指標。

- UISF_ACTIVE Windows XP:控件應以用於活動控制件的樣式繪製。

### <a name="remarks"></a>備註

此成員函數類比[WM_CHANGEUISTATE](/windows/win32/menurc/wm-changeuistate)消息的功能,如 Windows SDK 中所述。

## <a name="cwndonchar"></a><a name="onchar"></a>Cwnd::OnChar

當擊鍵轉換為非系統字元時,框架將調用此成員函數。

```
afx_msg void OnChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
包含鍵的字元代碼值。

*恩雷普森特*<br/>
包含重複計數,當使用者關閉鍵時重複擊鍵的次數。

*nFlags*<br/>
包含掃描代碼、金鑰轉換代碼、以前的金鑰狀態和上下文代碼,如以下清單所示:

|值|意義|
|-----------|-------------|
|0-15|指定重複計數。 該值是使用者按住鍵而重複擊鍵的次數。|
|16-23|指定掃描代碼。 該值取決於原始裝置製造商 (OEM)|
|24|指定該鍵是否是擴展鍵,例如顯示在增強型 101 鍵或 102 鍵鍵盤上的右側 ALT 和 CTRL 鍵。 如果值是擴展鍵,則值為 1;如果該值是擴展鍵,則該值為 1。否則,它是 0。|
|25-28|Windows 在內部使用。|
|29|指定上下文代碼。 按鍵按住 ALT 鍵,則該值為 1;否則,該值為 0。|
|30|指定以前的鍵狀態。 如果鍵在發送消息之前向下,則值為 1;如果鍵向上,則值為 0。|
|31|指定轉換狀態。 如果釋放鍵,則值為 1;如果按下該鍵,則該值為 0。|

### <a name="remarks"></a>備註

此函數在[OnKeyUp](#onkeyup)成員函數之前和調用[OnKeyDown](#onkeydown)成員函數之前調用。 `OnChar`包含要按下或釋放的鍵盤鍵的值。

由於按下的密鑰和`OnChar`生成的調用之間不一定存在一對一的對應關係,因此*nFlags*中的資訊通常對應用程式沒有用處。 *nFlags*中的資訊僅適用於`OnKeyUp`對成員函數或調`OnKeyDown``OnChar`用 之前的成員函數的最新調用。

對於 IBM 增強型 101 鍵和 102 鍵鍵盤,增強鍵是鍵盤主部分的正確 ALT 和正確的 CTRL 鍵;數位鍵盤左側的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭頭鍵;和數位鍵盤中的斜杠 (/) 和 ENTER 鍵。 其他一些鍵盤可能支援*nFlags*中的擴展鍵位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchartoitem"></a><a name="onchartoitem"></a>Cwnd::在查托專案

當具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式的清單框向其擁有者發送[WM_CHARTOITEM](/windows/win32/Controls/wm-chartoitem)消息以回應[WM_CHAR](#onchar)消息時調用。

```
afx_msg int OnCharToItem(
    UINT nChar,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定使用者按下的鍵的值。

*pListBox*<br/>
指定指向清單框的指標。 它可能是暫時的。

*nIndex*<br/>
指定目前位置。

### <a name="return-value"></a>傳回值

框架調用此成員函數以指定應用程式為回應呼叫執行的操作。 返回值 -2 表示應用程式處理了選擇項的所有方面,並且不希望列表框執行進一步操作。 返回值 -1 表示列表框應執行預設操作以回應擊鍵。 返回值 0 或更高指定清單框中項的零基索引,並指示列表框應對給定項執行擊鍵的預設操作。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonchildactivate"></a><a name="onchildactivate"></a>Cwnd::在兒童啟動

如果`CWnd`物件是多個文檔介面 (MDI)`OnChildActivate`子視窗, 則當使用者按一下視窗的標題列或視窗啟動、移動或調整大小時,框架將調用該物件。

```
afx_msg void OnChildActivate();
```

## <a name="cwndonchildnotify"></a><a name="onchildnotify"></a>Cwnd::在兒童通知

當此視窗的父視窗收到應用於此視窗的通知消息時,此成員函數將調用它。

```
virtual BOOL OnChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
發送到父視窗的 Windows 訊息編號。

*wParam*<br/>
與消息關聯的*wparam。*

*lParam*<br/>
與消息關聯的*lparam。*

*pLResult*<br/>
指向要從父視窗過程返回的值的指標。 如果沒有返回值,此指標將為 NULL。

### <a name="return-value"></a>傳回值

如果此窗口負責處理發送到其父級的消息,則非零;否則 0。

### <a name="remarks"></a>備註

切勿直接調用此成員函數。

此成員函數的預設實現返回 0,這意味著父函數應處理消息。

重寫此成員函數以擴展控制項回應通知訊息的方式。

## <a name="cwndonclipboardupdate"></a><a name="onclipboardupdate"></a>Cwnd::在剪貼簿更新

當剪貼簿的內容發生更改時,框架將調用此成員函數。

```
afx_msg void OnClipboardUpdate();
```

## <a name="cwndonclose"></a><a name="onclose"></a>Cwnd::關閉

框架將此成員函數稱為`CWnd`或應用程式要終止的信號。

```
afx_msg void OnClose();
```

### <a name="remarks"></a>備註

預設執行呼叫`DestroyWindow`。

## <a name="cwndoncolorizationcolorchanged"></a><a name="oncolorizationcolorchanged"></a>Cwnd::在顏色顏色改變

當非工作區的呈現策略發生更改時,框架將調用此成員。

```
afx_msg void OnColorizationColorChanged(
    DWORD dwColorizationColor,
    BOOL bOpacity);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*dwColor 顏色*|[在]指定新的著色顏色。<br /><br /> 顏色格式是窗體 0xAARRGGBB 的十六進位數位,其中四個元件的範圍從 0x00 到 0xFF。 AA 分量為 alpha 值,RR 為紅色,GG 為綠色,BB 為藍色。|
|*bOpacity*|[在]如果新顏色與不相加性混合,則為 TRUE;假,如果不是。|

### <a name="remarks"></a>備註

此方法接收[WM_DWMNCRENDERINGCHANGED](/windows/win32/dwm/wm-dwmcolorizationcolorchanged)通知消息,這在Windows SDK中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncommand"></a><a name="oncommand"></a>Cwnd:OnCommand

當使用者從功能表中選擇專案、子控制件發送通知訊息或翻譯快速鍵時,框架將調用此成員函數。

```
virtual BOOL OnCommand(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
*wParam*的低階單詞識別功能表項、控制項或加速器的命令 ID。 如果消息來自控件,*則 wParam*的高階單詞指定通知訊息。 如果消息來自加速器,則高階單詞為 1。 如果消息來自功能表,則高階單詞為 0。

*lParam*<br/>
標識消息來自控件時發送消息的控制項。 否則 *,lParam*為 0。

### <a name="return-value"></a>傳回值

如果應用程式處理此消息,則返回非零;否則 0。

### <a name="remarks"></a>備註

`OnCommand`處理控制通知和ON_COMMAND條目的消息映射,並調用相應的成員函數。

重寫派生類中的此成員函數以處理[WM_COMMAND](/windows/win32/menurc/wm-command)消息。 除非調用基類`OnCommand`,否則重寫將不會處理消息映射。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncompacting"></a><a name="oncompacting"></a>Cwnd::在壓縮

當 Windows 檢測到在 30 到 60 秒的間隔內超過 12.5% 的系統時間用於壓縮記憶體時,該框架會為所有頂級視窗調用此成員函數。

```
afx_msg void OnCompacting(UINT nCpuTime);
```

### <a name="parameters"></a>參數

*nCpuTime*<br/>
指定 Windows 壓縮記憶體目前花費的 CPU 時間與執行其他操作的 CPU 時間的比率。 例如,8000h 表示壓縮記憶體的 CPU 時間的 50%。

### <a name="remarks"></a>備註

這表示系統記憶體不足。

當物件`CWnd`收到此調用時,它應該釋放盡可能多的記憶體,同時考慮到應用程式的當前活動級別和在 Windows 中運行的應用程式總數。 應用程式可以調用 Windows 函數來確定正在運行的應用程式數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncompareitem"></a><a name="oncompareitem"></a>Cwnd::上比較專案

框架數據以指定新專案在子排序的所有者繪製組合或清單框中的相對位置。

```
afx_msg int OnCompareItem(
    int nIDCtl,
    LPCOMPAREITEMSTRUCT lpCompareItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
發送WM_COMPAREITEM消息的控制項的標識碼。

*lp比較項目結構*<br/>
包含指向[COMPAREITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-compareitemstruct)資料結構的長指標,其中包含組合或清單框中兩個項目的標識符和應用程式提供的數據。

### <a name="return-value"></a>傳回值

指示兩個項的相對位置。 它可能是以下任何值:

|值|意義|
|-----------|-------------|
|-1|專案 1 在專案 2 之前排序。|
|0|專案 1 和專案 2 排序相同。|
|1|專案 1 在專案 2 之後排序。|

### <a name="remarks"></a>備註

如果使用[CBS_SORT](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)或[LBS_SORT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式創建組合或清單框,則每當應用程式添加新項時,Windows都會向組合框或清單框擁有者發送WM_COMPAREITEM消息。

組合或清單框中的兩個專案在`COMPAREITEMSTRUCT`*lpCompareItemTruct*指向的結構中進行了改革。 `OnCompareItem`應返回一個值,指示哪些項應出現在其他項之前。 通常,Windows 多次進行此調用,直到它確定新項目的確切位置。

如果`COMPAREITEMSTRUCT`結構`hwndItem`的成員屬於[CListBox](../../mfc/reference/clistbox-class.md)或[CComboBox](../../mfc/reference/ccombobox-class.md)物件,`CompareItem`則調用相應 類的虛擬函數。 重寫`CComboBox::CompareItem``CListBox::CompareItem`或`CListBox`派`CComboBox`生 或 類中執行項比較。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncompositionchanged"></a><a name="oncompositionchanged"></a>Cwnd::在作文上

啟用或禁用桌面視窗管理員 (DWM) 組合時,框架會為所有頂級視窗呼叫此成員函數。

```
afx_msg void OnCompositionChanged();
```

### <a name="remarks"></a>備註

此方法接收[WM_DWMCOMPOSITIONCHANGED](/windows/win32/dwm/wm-dwmcompositionchanged)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncontextmenu"></a><a name="oncontextmenu"></a>Cwnd::在上下文菜單上

當用戶按下視窗中的滑鼠右鍵(右鍵按一下)時,由框架調用。

```
afx_msg void OnContextMenu(
    CWnd* pWnd,
    CPoint pos);
```

### <a name="parameters"></a>參數

*pwnd*<br/>
處理用戶右鍵按一下滑鼠的視窗。 這可以是接收消息的視窗的子視窗。 有關處理此消息的詳細資訊,請參閱備註部分。

*Pos*<br/>
游標的位置,在螢幕座標中,在滑鼠按一下時。

### <a name="remarks"></a>備註

您可以使用[TrackPopupMenu](../../mfc/reference/cmenu-class.md#trackpopupmenu)顯示上下文選單來處理此消息。

如果不顯示上下文菜單,則應將此消息傳遞到[DefWindowProc](#defwindowproc)函數。 如果視窗是子視窗,`DefWindowProc`則將訊息發送給父視窗。 否則,`DefWindowProc`如果指定位置位於視窗的標題中,則顯示預設上下文菜單。

## <a name="cwndoncopydata"></a><a name="oncopydata"></a>Cwnd::開啟複製資料

框架調用此成員函數將數據從一個應用程式複製到另一個應用程式。

```
afx_msg BOOL OnCopyData(
    CWnd* pWnd,
    COPYDATASTRUCT* pCopyDataStruct);
```

### <a name="parameters"></a>參數

*pwnd*<br/>
指向發送數據的`CWnd`物件的指標。

*pCopy 資料結構*<br/>
指向包含所發送數據的[COPYDATASTRUCT](/windows/win32/api/winuser/ns-winuser-copydatastruct)結構的指標。

### <a name="return-value"></a>傳回值

如果接收應用程式成功接受資料,則返回 TRUE。 否則,返回 FALSE。

### <a name="remarks"></a>備註

傳遞的數據不能包含對接收數據的應用程式無法訪問的物件的指標或其他引用。

複製數據時,發送過程的另一個線程不得更改數據。

接收應用程式應考慮數據唯讀。 參數*pCopyDataTruct*指向的結構僅在資料傳輸期間有效;但是,接收應用程式不應釋放與結構關聯的記憶體。

如果接收應用程式需要在此函數返回後訪問數據,則必須將接收到的數據複製到本地緩衝區。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoncreate"></a><a name="oncreate"></a>Cwnd::開啟建立

當應用程式請求透過調用[Create](#create)或[CreateEx](#createex)成員函數創建 Windows 視窗時,架構將調用此成員函數。

```
afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreatestruct*<br/>
指向包含所創建物件的資訊`CWnd`的[CREATESTRUCT](/windows/win32/api/winuser/ns-winuser-createstructw)結構。

### <a name="return-value"></a>傳回值

`OnCreate`必須返回 0 才能`CWnd`繼續創建 物件。 如果應用程式返回 -1,視窗將被銷毀。

### <a name="remarks"></a>備註

對`CWnd`象 在創建視窗后,但在其變得可見之前收到此調用。 `OnCreate`在`Create`返回或`CreateEx`成員函數之前調用。

重寫此成員函數以執行派生類所需的任何初始化。

結構`CREATESTRUCT`包含用於創建視窗的參數的複本。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonctlcolor"></a><a name="onctlcolor"></a>Cwnd::OnCtlColor

當即將繪製子控制件時,框架將調用此成員函數。

```
afx_msg HBRUSH OnCtlColor(
    CDC* pDC,
    CWnd* pWnd,
    UINT nCtlColor);
```

### <a name="parameters"></a>參數

*pDC*<br/>
包含指向子視窗的顯示上下文的指標。 可能是暫時的。

*pwnd*<br/>
包含指向要求顏色的控件的指標。 可能是暫時的。

*nCtlColor*<br/>
包含以下值之一,指定控制項的類型:

- CTLCOLOR_BTN按鈕控制項

- CTLCOLOR_DLG對話框

- CTLCOLOR_EDIT編輯控制項

- CTLCOLOR_LISTBOX清單框控制項

- CTLCOLOR_MSGBOX訊息框

- CTLCOLOR_SCROLLBAR捲動條控制項

- CTLCOLOR_STATIC靜態控制項

### <a name="return-value"></a>傳回值

`OnCtlColor`必須將用於繪製控制背景的控點返回到畫筆。

### <a name="remarks"></a>備註

大多數控制項將此訊息發送到其父級(通常是對話方塊),以準備*pDC*使用正確的顏色繪製控制件。

要更改文字顏色,請使用所需的`SetTextColor`紅色、綠色和藍色 (RGB) 值調用成員函數。

要更改單行編輯控制項的背景顏色,請在CTLCOLOR_EDIT和CTLCOLOR_MSGBOX訊息代碼中設置畫筆句柄,並調用[CDC::SetBkColor](../../mfc/reference/cdc-class.md#setbkcolor)函數以回應CTLCOLOR_EDIT程式碼。

`OnCtlColor`不會為下拉組合框的列表框調用,因為下拉列表框實際上是組合框的子級,而不是視窗的子級。 要更改下拉清單框的顏色,請建立`CComboBox`具有該檢查`OnCtlColor`的 覆蓋在參數中`nCtlColor`CTLCOLOR_LISTBOX。 在此處理程式中,`SetBkColor`必須使用成員函數來設定文字的背景顏色。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。 要將以下方法添加到對話方塊類,請使用 Visual Studio 屬性窗格為WM_CTLCOLOR添加消息處理程式。 或者,您可以手動向消息映射添加ON_WM_CTLCOLOR()條目。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#107](../../mfc/reference/codesnippet/cpp/cwnd-class_47.cpp)]

## <a name="cwndondeadchar"></a><a name="ondeadchar"></a>Cwnd::在死神上

當調用[OnKeyUp](#onkeyup)成員函數和[OnKeyDown](#onkeydown)成員函數時,框架將調用此成員函數。

```
afx_msg void OnDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定死鍵字元值。

*恩雷普森特*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描代碼、金鑰轉換代碼、以前的金鑰狀態和上下文代碼,如以下清單所示:

|值|描述|
|-----------|-----------------|
|0-7|掃描代碼(與 OEM 相關的值)。 高階字的低位元組。|
|8|擴展鍵,如功能鍵或數位鍵盤上的鍵(1,如果它是擴展鍵;否則為 0)。|
|9-10|未使用。|
|11-12|Windows 在內部使用。|
|13|上下文代碼(如果按下鍵時按住 ALT 鍵,則為 1;否則為 0)。|
|14|上一個鍵狀態(如果鍵在調用之前關閉,則為 0,如果鍵已打開,則為 0)。|
|15|轉換狀態(如果釋放鍵,為 1,則為 0,如果按下鍵,則為 0)。|

### <a name="remarks"></a>備註

此成員函數可用於指定死密鑰的字元值。 死鍵是一個鍵,如 umlaut(雙點)字元,與其他字元組合以形成複合字元。 例如,umlaut-O 字元由死鍵、umlaut 和 O 鍵組成。

應用程式通常用於`OnDeadChar`向使用者提供有關按下的每個密鑰的反饋。 例如,應用程式可以在不移動圖斯特的情況下在當前字元位置顯示重音。

由於按下的密鑰和`OnDeadChar`調用之間不一定存在一對一的對應關係,因此*nFlags*中的資訊通常對應用程式沒有用處。 *nFlags*中的資訊僅適用於對[OnKeyUp](#onkeyup)成員`OnDeadChar`函數或調用前面的[OnKeyDown](#onkeydown)成員函數的最新調用。

對於 IBM 增強型 101 鍵和 102 鍵鍵盤,增強鍵是鍵盤主部分的正確 ALT 和正確的 CTRL 鍵;數位鍵盤左側的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭頭鍵;和數位鍵盤中的斜杠 (/) 和 ENTER 鍵。 其他一些鍵盤可能支援*nFlags*中的擴展鍵位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondeleteitem"></a><a name="ondeleteitem"></a>Cwnd::打開刪除專案

該框架調用此成員函數,以通知擁有者繪製清單框或組合框的所有者清單框已銷毀清單框或組合框,或者 CComboBox::DeleteString、CListBox::DeleteString、CComboBox:[重置內容](../../mfc/reference/ccombobox-class.md#resetcontent)或[CListBox:重置內容](../../mfc/reference/clistbox-class.md#resetcontent) [CComboBox::DeleteString](../../mfc/reference/ccombobox-class.md#deletestring) [CListBox::DeleteString](../../mfc/reference/clistbox-class.md#deletestring) )已刪除專案。

```
afx_msg void OnDeleteItem(
    int nIDCtl,
    LPDELETEITEMSTRUCT lpDeleteItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
發送WM_DELETEITEM消息的控制項的標識碼。

*lp 刪除項目已移除*<br/>
指定指向[DELETEITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-deleteitemstruct)資料結構的長指標,其中包含有關已刪除清單框項的資訊。

### <a name="remarks"></a>備註

如果`hwndItem``DELETEITEMSTRUCT`結構的成員屬於組合框或列表框,則調用相應類`DeleteItem`的虛擬函數。 重寫相應`DeleteItem`控制項類的成員函數以刪除特定於項的數據。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondestroy"></a><a name="ondestroy"></a>Cwnd::On銷毀

框架調用此成員函數以通知`CWnd`物件它正在被銷毀。

```
afx_msg void OnDestroy();
```

### <a name="remarks"></a>備註

`OnDestroy`在從螢幕中刪除`CWnd`物件後調用。

`OnDestroy`首先被稱為被破壞,`CWnd`然後為兒童視窗`CWnd`, 因為他們被摧毀。 可以假定所有子視窗在`OnDestroy`運行時仍然存在。

如果被`CWnd`銷毀的對像是剪貼簿-查看器鏈的一部分(通過呼叫[SetClipboardViewer](#setclipboardviewer)成員函數`CWnd`設置),`OnDestroy`則必須在從函數返回之前調用[ChangeClipboard 鏈](#changeclipboardchain)成員函數,從剪貼板-查看器鏈中刪除自身。

## <a name="cwndondestroyclipboard"></a><a name="ondestroyclipboard"></a>Cwnd::在毀滅夾板上

當剪貼簿通過調用[「空剪簿](/windows/win32/api/winuser/nf-winuser-emptyclipboard)」Windows 功能清空時,框架將此成員功能稱為剪貼簿擁有者。

```
afx_msg void OnDestroyClipboard();
```

## <a name="cwndondevicechange"></a><a name="ondevicechange"></a>Cwnd::打開裝置變更

框架調用此成員函數以通知應用程式或設備驅動程式設備或電腦的硬體配置的更改。

```
afx_msg BOOL OnDeviceChange(
    UINT nEventType,
    DWORD_PTR dwData);
```

### <a name="parameters"></a>參數

*n 事件型態*<br/>
事件類型。 有關可用值的說明,請參閱備註部分

*dwData*<br/>
包含事件特定數據的結構的位址。 其含義取決於給定的事件。

### <a name="remarks"></a>備註

對於提供軟體可控制功能(如彈出和鎖定)的設備,操作系統通常會發送DBT_DEVICEREMOVEPENDING消息,讓應用程式和設備驅動程式正常地結束對設備的使用。

如果操作系統強制刪除設備,則在執行此操作之前可能不會發送DBT_DEVICEQUERYREMOVE消息。

*nEvent*參數可以是以下值之一:

- [DBT_DEVICEARRIVAL](/windows/win32/DevIO/dbt-devicearrival)設備已插入,現在可用。

- [DBT_DEVICEQUERYREMOVE](/windows/win32/DevIO/dbt-devicequeryremove)請求刪除設備的許可權。 任何應用程式都可以拒絕此請求並取消刪除。

- [DBT_DEVICEQUERYREMOVEFAILED](/windows/win32/DevIO/dbt-devicequeryremovefailed)刪除設備的請求已被取消。

- [DBT_DEVICEREMOVEPENDING](/windows/win32/DevIO/dbt-deviceremovepending)設備即將被刪除。 無法拒絕。

- [DBT_DEVICEREMOVECOMPLETE](/windows/win32/DevIO/dbt-deviceremovecomplete)設備已被刪除。

- [DBT_DEVICETYPESPECIFIC](/windows/win32/DevIO/dbt-devicetypespecific)特定於設備的事件。

- [DBT_CONFIGCHANGED](/windows/win32/DevIO/dbt-configchanged)當前配置已更改。

- DBT_DEVNODES_CHANGED設備節點已更改。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondevmodechange"></a><a name="ondevmodechange"></a>Cwnd::在開發模式更改

當使用者更改設備模式設置時,框架會為所有頂級`CWnd`物件調用此成員函數。

```
afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
```

### <a name="parameters"></a>參數

*lpDevice 名稱*<br/>
指向 Windows 初始化檔 WIN 中指定的設備名稱。Ini。

### <a name="remarks"></a>備註

處理WM_DEVMODECHANGE消息的應用程式可能會重新初始化其設備模式設置。 使用 Windows`ExtDeviceMode`功能保存和恢復裝置設定的應用程式通常不會處理此功能。

當使用者從「控制面板」更改預設印表機時,不會調用此功能。 在這種情況下,呼叫函數`OnWinIniChange`。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondrawclipboard"></a><a name="ondrawclipboard"></a>Cwnd::在畫夾板上

當剪貼簿的內容發生更改時,框架會為剪貼簿-查看器鏈中的每個視窗調用此成員函數。

```
afx_msg void OnDrawClipboard();
```

### <a name="remarks"></a>備註

只有通過調用[SetClipboardViewer](#setclipboardviewer)成員函數加入剪貼簿查看器鏈的應用程式才能回應此調用。

每個收到`OnDrawClipboard`呼叫的視窗都應呼叫[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函數,將[WM_DRAWCLIPBOARD](/windows/win32/dataxchg/wm-drawclipboard)訊息傳遞到剪貼簿-查看器鏈中的下一個視窗。 下一個視窗的句柄由[SetClipboardViewer](#setclipboardviewer)成員函數返回;可以修改它以回應[OnChangeCbChain](#onchangecbchain)成員函數調用。

## <a name="cwndondrawiconicthumbnailorlivepreview"></a><a name="ondrawiconicthumbnailorlivepreview"></a>Cwnd::在DrawIconic或生活預覽

需要取得點陣圖，在 Windows 7 索引標籤上顯示為縮圖時，或顯示在用戶端上以查看應用程式時，由架構呼叫。

```
virtual void OnDrawIconicThumbnailOrLivePreview(
    CDC& dc,
    CRect rect,
    CSize szRequiredThumbnailSize,
    BOOL bIsThumbnail,
    BOOL& bAlphaChannelSet);
```

### <a name="parameters"></a>參數

*直流*<br/>
指定設備上下文。

*矩形*<br/>
指定要渲染的區域的邊界矩形。

*sz必需縮圖*<br/>
指定目標縮圖的大小。 如果*bIs縮略是 FALSE,* 則應忽略。

*bIs縮圖*<br/>
指定是為標誌性縮略圖或即時預覽(peek)調用此方法。

*bAlpha通道集*<br/>
[出]如果您的實現初始化了在*dc*中選擇的位圖的 Alpha 通道,請將其設定為 TRUE。

### <a name="remarks"></a>備註

在派生類中重寫此方法,並在指定的設備上下文中繪製,以便自定義縮略圖和透視。 如果*b縮圖*為 TRUE,則可以忽略*sz"必需縮略器大小*" 在這種情況下,您應該注意繪製全尺寸位圖(即覆蓋整個工作區的位圖)。 裝置內容( *dc*) 附帶選擇的 32 位元圖. 預設實現使用PRF_CLIENT、PRF_CHILDREN和PRF_NONCLIENT標誌向此視窗發送WM_PRINT。

## <a name="cwndondrawitem"></a><a name="ondrawitem"></a>Cwnd::在畫專案

當控件或功能表的可視方面發生更改時,框架為擁有者繪製按鈕控制件、組合框控制項、清單框控制項或功能表的所有者調用此成員函數。

```
afx_msg void OnDrawItem(
    int nIDCtl,
    LPDRAWITEMSTRUCT lpDrawItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
包含發送WM_DRAWITEM消息的控制項的標識符。 如果功能表發送了該消息 *,nIDCtl*包含 0。

*lpDraw 專案已結*<br/>
指定指向`DRAWITEMSTRUCT`資料結構的長指標,其中包含有關要繪製的項和所需繪圖類型的資訊。

### <a name="remarks"></a>備註

`itemAction` [DRAWITEMSTRUCT](/windows/win32/api/winuser/ns-winuser-drawitemstruct)結構的成員定義要執行的繪圖操作。 此成員中的數據允許控件的所有者確定需要什麼繪製操作。

在從處理此消息返回之前,應用程式應確保`DRAWITEMSTRUCT`結構的*hDC*成員標識的設備上下文還原為默認狀態。

如果`hwndItem`成員屬於 CButton、CMenu、CListBox 或[CComboBox](../../mfc/reference/ccombobox-class.md)物件`DrawItem`,則調用 相應類[CButton](../../mfc/reference/cbutton-class.md)[CMenu](../../mfc/reference/cmenu-class.md)[CListBox](../../mfc/reference/clistbox-class.md)的虛擬函數。 重寫相應`DrawItem`控件類的成員函數以繪製項。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndondropfiles"></a><a name="ondropfiles"></a>Cwnd::OnDrop檔

當用戶將滑鼠左鍵釋放到已註冊為已刪除檔的收件人的視窗上時,框架將調用此成員函數。

```
afx_msg void OnDropFiles(HDROP hDropInfo);
```

### <a name="parameters"></a>參數

*hDropInfo*<br/>
指向描述丟棄檔的內部數據結構的指標。 此句柄由`DragFinish`和`DragQueryFile`和`DragQueryPoint`Windows 函數用於檢索有關刪除檔的資訊。

### <a name="remarks"></a>備註

通常,派生類將設計為支援丟棄的檔,並在視窗構造期間自行註冊。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonenable"></a><a name="onenable"></a>Cwnd:啟用

當應用程式更改`CWnd`物件的啟用狀態時,框架將調用此成員函數。

```
afx_msg void OnEnable(BOOL bEnable);
```

### <a name="parameters"></a>參數

*b 啟用*<br/>
指定`CWnd`對象是已啟用還是禁用。 如果已啟用 ,`CWnd`則 此參數為 TRUE;如果已啟用 ,則此參數為 TRUE。如果已禁用,`CWnd`則為 FALSE。

### <a name="remarks"></a>備註

`OnEnable`在[啟用視窗](#enablewindow)成員函數返回之前調用,但在窗口啟用狀態[(WS_DISABLED](styles-used-by-mfc.md#window-styles)樣式位)更改後。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonendsession"></a><a name="onendsession"></a>Cwnd::結束會話

該框架在`CWnd`物件從[OnQueryEndSession](#onqueryendsession)成員函數調用返回非零值後調用此成員函數。

```
afx_msg void OnEndSession(BOOL bEnding);
```

### <a name="parameters"></a>參數

*彎曲*<br/>
指定工作階段是否結束。 如果會話正在結束,則為 TRUE;如果會話已結束,則為 TRUE。否則 FALSE。

### <a name="remarks"></a>備註

`OnEndSession`調用通知`CWnd`對象會話是否實際結束。

如果*bEnding*為 TRUE,則 Windows 可以在處理此調用後的任何時間終止。 因此,讓應用程式在中`OnEndSession`執行終止所需的所有任務。

工作階段結束時,您無需呼叫[毀視窗](#destroywindow)成員函數或[PostQuitMessage](/windows/win32/api/winuser/nf-winuser-postquitmessage) Windows 功能。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonenteridle"></a><a name="onenteridle"></a>Cwnd::OnEnteridle

框架調用此成員函數以通知應用程式的主視窗過程模式對話方塊或功能表正在進入空閒狀態。

```
afx_msg void OnEnterIdle(
    UINT nWhy,
    CWnd* pWho);
```

### <a name="parameters"></a>參數

*n為什麼*<br/>
指定消息是對話框還是顯示菜單的結果。 這裡可以是以下值之一:

- MSGF_DIALOGBOX系統處於空閒狀態,因為正在顯示一個對話框。

- MSGF_MENU系統處於空閒狀態,因為正在顯示功能表。

*p誰*<br/>
指定指向對話框的指標(如果*MSGF_DIALOGBOX nWhy))* 或包含顯示選單的視窗(如果*nWhy* MSGF_MENU)。 此指標可能是臨時指標,不應存儲以供以後使用。

### <a name="remarks"></a>備註

當佇列中沒有消息處理過一個或多個以前的消息后等待時,模式對話框或功能表將進入空閒狀態。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonentermenuloop"></a><a name="onentermenuloop"></a>Cwnd::打開門菜單環線

當輸入功能表模式迴圈時,框架將調用此成員函數。

```
afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定所涉及的功能表是否為彈出式功能表。 如果函數成功,則具有非零值;否則 0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonentersizemove"></a><a name="onentersizemove"></a>Cwnd::打開"移動"

在受影響的視窗進入移動或調整模式循環的移動或大小調整迴圈后,框架調用此成員函數一次。

```
afx_msg void OnEnterSizeMove();
```

### <a name="remarks"></a>備註

此方法接收[WM_ENTERSIZEMOVE](/windows/win32/winmsg/wm-entersizemove)通知,這在 Windows SDK 中介紹。

當使用者按一下視窗的標題列或大小邊框時,或者當視窗將[WM_SYSCOMMAND](/windows/win32/menurc/wm-syscommand)訊息傳遞到[CWnd::DWindowProc](#defwindowproc)函數以及該消息的*wParam*參數指定SC_MOVE或SC_SIZE時,視窗將進入行動或調整大小模式迴圈。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonerasebkgnd"></a><a name="onerasebkgnd"></a>Cwnd::OnEraseBkgnd

當`CWnd`物件背景需要正在定義時(例如,調整大小時),框架將調用此成員函數。

```
afx_msg BOOL OnEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
指定設備上下文物件。

### <a name="return-value"></a>傳回值

如果擦除背景,則非零;否則 0。

### <a name="remarks"></a>備註

它被調用為繪畫準備一個無效的區域。

預設實現使用視窗類結構`hbrBackground`成員指定的視窗類背景畫筆擦除背景。

如果`hbrBackground`成員為 NULL,則重寫的`OnEraseBkgnd`版本 應擦除背景顏色。 您的版本還應通過首先為畫筆調用`CWnd`[UnunObject,](/windows/win32/api/wingdi/nf-wingdi-unrealizeobject)然後選擇畫筆,將預期畫筆的原點與座標對齊。

重寫`OnEraseBkgnd`時應返回非零以回應WM_ERASEBKGND,如果它處理消息並擦除背景;如果重寫時,應返回非零。"則為回應"未歸零"。這表明不需要進一步進行複製。 如果返回 0,視窗將保持標記為需要擦除。 (通常,這意味著`fErase``PAINTSTRUCT`結構的成員將為 TRUE。

Windows 假定使用MM_TEXT映射模式計算背景。 如果設備上下文使用任何其他映射模式,則擦除的區域可能不在工作區的可見部分內。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonexitmenuloop"></a><a name="onexitmenuloop"></a>Cwnd::打開選單環線

退出功能表模式迴圈時,框架將調用此成員函數。

```
afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
```

### <a name="parameters"></a>參數

*bIsTrackPopupMenu*<br/>
指定所涉及的功能表是否為彈出式功能表。 如果函數成功,則具有非零值;否則 0。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonexitsizemove"></a><a name="onexitsizemove"></a>Cwnd::打開"退出大小移動"

在受影響的視窗退出移動或調整模式迴圈大小后,框架會調用此成員函數一次。

```
afx_msg void OnExitSizeMove();
```

### <a name="remarks"></a>備註

此方法接收[WM_EXITSIZEMOVE](/windows/win32/winmsg/wm-exitsizemove)通知,這在 Windows SDK 中介紹。

當使用者按一下視窗的標題列或大小邊框時,或者當視窗將[WM_SYSCOMMAND](/windows/win32/menurc/wm-syscommand)訊息傳遞到[CWnd::DWindowProc](#defwindowproc)函數以及該消息的*wParam*參數指定SC_MOVE或SC_SIZE時,視窗將進入行動或調整大小模式迴圈。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonfontchange"></a><a name="onfontchange"></a>Cwnd::OnFontChange

應用程式更改字型資源池後,系統中的所有頂級`OnFontChange`視窗都會收到來自框架的呼叫。

```
afx_msg void OnFontChange();
```

### <a name="remarks"></a>備註

從系統添加或刪除字型的應用程式(例如,透過[AddFontResource](/windows/win32/api/wingdi/nf-wingdi-addfontresourcew)或[RemoveFontResource](/windows/win32/api/wingdi/nf-wingdi-removefontresourcew) Windows 功能)應將[WM_FONTCHANGE](/windows/win32/gdi/wm-fontchange)訊息發送到所有頂級視窗。

要送出此消息,請使用[「發送消息視窗」](/windows/win32/api/winuser/nf-winuser-sendmessage)功能,將*hWnd*參數設置為HWND_BROADCAST。

## <a name="cwndongetdlgcode"></a><a name="ongetdlgcode"></a>Cwnd::OnGetDlgCode

呼叫控制項，讓控制項可以處理方向鍵和 TAB 鍵輸入本身。

```
afx_msg UINT OnGetDlgCode();
```

### <a name="return-value"></a>傳回值

以下一個或多個值,指示應用程式處理的輸入類型:

- DLGC_BUTTON按鈕(通用)。

- DLGC_DEFPUSHBUTTON默認按鈕。

- DLGC_HASSETSELEM_SETSEL消息。

- DLGC_UNDEFPUSHBUTTON 沒有默認按鈕處理。 (應用程式可以使用帶有DLGC_BUTTON的標誌來指示它處理按鈕輸入,但依賴於系統進行默認按鈕處理。

- DLGC_RADIOBUTTON單選按鈕。

- DLGC_STATIC靜態控件。

- DLGC_WANTALLKEYS所有鍵盤輸入。

- DLGC_WANTARROWS箭頭鍵。

- DLGC_WANTCHARS消息WM_CHAR。

- DLGC_WANTMESSAGE所有鍵盤輸入。 應用程式將此消息傳遞到控制項。

- DLGC_WANTTAB選項卡鍵。

### <a name="remarks"></a>備註

通常,Windows 會`CWnd`處理 控制件的所有箭頭鍵和TAB鍵輸入。 通過重寫`OnGetDlgCode``CWnd`, 控制項可以選擇特定類型的輸入來處理自身。

預定義的`OnGetDlgCode`控制類的預設函數返回適合每個類的代碼。

## <a name="cwndongetminmaxinfo"></a><a name="ongetminmaxinfo"></a>Cwnd::OnGetMinMaxinfo

每當 Windows 需要知道最大化位置或維度或最小或最大跟蹤大小時,框架都會調用此成員函數。

```
afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
```

### <a name="parameters"></a>參數

*lpMMI*<br/>
指向包含有關`MINMAXINFO`視窗最大大小和位置及其最小和最大跟蹤大小的資訊。 有關此結構的詳細資訊,請參閱[MINMAXINFO](/windows/win32/api/winuser/ns-winuser-minmaxinfo)結構。

### <a name="remarks"></a>備註

最大化大小是窗口邊界完全擴展時的大小。 視窗的最大追蹤大小是可以使用邊框調整視窗大小可以達到的最大視窗大小。 視窗的最小跟蹤大小是透過使用邊框調整視窗大小可以達到的最小視窗大小。

Windows 填充指定各種位置和維度的預設值的點陣列。 應用程式可能會更改中的`OnGetMinMaxInfo`這些值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonhelp"></a><a name="onhelp"></a>Cwnd::上説明

在應用程式 (使用目前的內容) 中處理 F1 說明。

```
afx_msg void OnHelp();
```

### <a name="remarks"></a>備註

有關詳細資訊[,請參閱 CWinApp:OnHelp。](../../mfc/reference/cwinapp-class.md#onhelp)

## <a name="cwndonhelpfinder"></a><a name="onhelpfinder"></a>Cwnd::OnHelpFinder

處理ID_HELP_FINDER和ID_DEFAULT_HELP命令。

```
afx_msg void OnHelpFinder();
```

### <a name="remarks"></a>備註

有關詳細資訊,請參閱[CWinApp:OnHelpFinder。](../../mfc/reference/cwinapp-class.md#onhelpfinder)

## <a name="cwndonhelpindex"></a><a name="onhelpindex"></a>Cwnd::OnHelpIndex

處理ID_HELP_INDEX命令並提供默認幫助主題。

```
afx_msg void OnHelpIndex();
```

### <a name="remarks"></a>備註

有關詳細資訊,請參閱[CWinApp:OnHelpIndex。](../../mfc/reference/cwinapp-class.md#onhelpindex)

## <a name="cwndonhelpinfo"></a><a name="onhelpinfo"></a>Cwnd::OnHelpInfo

當使用者按下 F1 鍵時，由架構呼叫。

```
afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
```

### <a name="parameters"></a>參數

*lpHelpInfo*<br/>
指向[HELPINFO](/windows/win32/api/winuser/ns-winuser-helpinfo)結構的指標,該結構包含有關請求幫助的功能表項、控制件、對話框或視窗的資訊。

### <a name="return-value"></a>傳回值

如果視窗具有鍵盤焦點或功能表在視窗中處於活動狀態,則返回 TRUE。 如果沒有視窗具有鍵盤焦點,請返回 FALSE。

### <a name="remarks"></a>備註

如果按下 F1 時功能表處於活動狀態,WM_HELP發送到與功能表關聯的視窗;如果選單在按下 F1 時處於活動狀態,則將WM_HELP發送到與功能表關聯的視窗。否則,WM_HELP發送到具有鍵盤焦點的視窗。 如果沒有視窗具有鍵盤焦點,WM_HELP將發送到當前活動視窗。

## <a name="cwndonhelpusing"></a><a name="onhelpusing"></a>Cwnd::OnHelpUsing

處理ID_HELP_USING命令。

```
afx_msg void OnHelpUsing();
```

### <a name="remarks"></a>備註

有關詳細資訊,請參閱[CWinApp:OnHelpUsing。](../../mfc/reference/cwinapp-class.md#onhelpusing)

## <a name="cwndonhotkey"></a><a name="onhotkey"></a>Cwnd::上HotKey

當使用者按下系統範圍的熱鍵時,框架將調用此成員函數。

```
afx_msg void OnHotKey(
    UINT nHotKeyId,
    UINT nKey1,
    UINT nKey2);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHotKeyId*|[在]生成消息的熱鍵的標識符。 如果消息由系統定義的熱鍵生成,則此參數將是以下值之一:<br /><br /> - IDHOT_SNAPDESKTOP - 按下了捕捉桌面熱鍵。<br />- IDHOT_SNAPWINDOW - 按下卡扣視窗熱鍵。|
|*nKey1*|[在]標誌的位元組合 (OR),指示與*nKey2*參數指定的鍵結合按下的鍵。 可能的值包括：<br /><br /> - MOD_ALT - 任一 ALT 鍵被關閉。<br />- MOD_CONTROL - 任一 CTRL 金鑰被關閉。<br />- MOD_SHIFT - 任一 SHIFT 鍵被關閉。<br />- MOD_WIN - 任一 WINDOWS 金鑰被關閉。 這些金鑰標有Microsoft Windows徽標。|
|*nKey2*|[在]熱鍵的虛擬金鑰代碼。|

### <a name="remarks"></a>備註

此方法接收[WM_HOTKEY](/windows/win32/inputdev/wm-hotkey)通知,這在 Windows SDK 中介紹。 此消息放置在與註冊熱鍵的線程關聯的消息佇列的頂部。 使用[RegisterHotKey](/windows/win32/api/winuser/nf-winuser-registerhotkey)功能註冊系統範圍的熱鍵。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonhscroll"></a><a name="onhscroll"></a>Cwnd::OnHScroll

當用戶單擊視窗的水準滾動條時,框架將調用此成員函數。

```
afx_msg void OnHScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSB代碼*<br/>
指定指示使用者滾動請求的滾動條代碼。 此參數可以是下列其中一項：

- SB_LEFT向左滾動。

- SB_ENDSCROLL 結束滾動。

- SB_LINELEFT向左滾動。

- SB_LINERIGHT向右滾動。

- SB_PAGELEFT向左滾動一頁。

- SB_PAGERIGHT向右滾動一頁。

- SB_RIGHT向右滾動。

- SB_THUMBPOSITION滾動到絕對位置。 當前位置由*nPos*參數指定。

- SB_THUMBTRACK將滾動框拖動到指定位置。 當前位置由*nPos*參數指定。

*nPos*<br/>
如果滾動條代碼為SB_THUMBPOSITION或SB_THUMBTRACK,則指定滾動框位置;否則,不使用。 根據初始滾動範圍 *,nPos*可能是負的,如有必要,應強制轉換為**int。**

*pScrollBar*<br/>
如果滾動消息來自滾動條控件,則包含指向該控件的指標。 如果使用者按下視窗的滾動條,則此參數為 NULL。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

SB_THUMBTRACK滾動條代碼通常由在拖動滾動框時提供一些反饋的應用程式使用。

如果應用程式滾動滾動條控制的內容,則還必須使用[SetScrollPos](#setscrollpos)成員函數重置滾動框的位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#108](../../mfc/reference/codesnippet/cpp/cwnd-class_48.cpp)]

## <a name="cwndonhscrollclipboard"></a><a name="onhscrollclipboard"></a>Cwnd::OnHScroll剪貼簿

當剪貼簿數據具有`OnHScrollClipboard``CF_OWNERDISPLAY`格式且剪貼簿檢視器的水準滾動欄中有事件時,剪貼簿所有者的成員函數由剪貼簿查看器調用。

```
afx_msg void OnHScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppwnd*<br/>
指定指向剪貼簿-查看器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSB代碼*<br/>
在低階單詞中指定以下滾動條代碼之一:

- SB_BOTTOM向右滾動。

- SB_ENDSCROLL 結束滾動。

- SB_LINEDOWN向下滾動一行。

- SB_LINEUP向上滾動一行。

- SB_PAGEDOWN向下滾動一頁。

- SB_PAGEUP向上滾動一頁。

- SB_THUMBPOSITION滾動到絕對位置。 當前位置以*nPos*提供。

- SB_TOP向左滾動。

*nPos*<br/>
如果滾動條代碼為SB_THUMBPOSITION,則包含滾動框位置;否則未使用。

### <a name="remarks"></a>備註

擁有者應滾動剪貼簿圖像,使相應部分無效,並更新滾動條值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoniconerasebkgnd"></a><a name="oniconerasebkgnd"></a>Cwnd::OnIconEraseBkgnd

在繪製圖示之前必須填充圖示的背景時,框架將此`CWnd`成員函數稱為最小化(標誌性)物件。

```
afx_msg void OnIconEraseBkgnd(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
指定圖示的設備上下文物件。 可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

`CWnd`僅當為視窗默認實現定義了類圖示時,才接收此調用;否則,將調用[OneraseBkgnd。](#onerasebkgnd)

[DefWindowProc](#defwindowproc)成員函數使用父視窗的背景畫筆填充圖示背景。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninitmenu"></a><a name="oninitmenu"></a>Cwnd::Oninitmenu

當功能表即將變為活動時,框架將調用此成員函數。

```
afx_msg void OnInitMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
指定要初始化的功能表。 可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

`OnInitMenu`當用戶單擊功能表欄上的專案或按功能表鍵時,將調用。 在顯示功能表之前,重寫此成員函數以修改功能表。

`OnInitMenu`首次訪問功能表時僅調用一次(例如,當用戶單擊功能表欄上的專案時)。 此方法不提供有關功能表項的資訊。 當使用者移動到功能表中的項時(例如,通過跨多個功能表項移動滑鼠),不會再次調用該函數。 使用者退出功能表(例如,通過單擊應用程式工作區)並隨後單擊功能表欄上的項後,將再次調用該函數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninitmenupopup"></a><a name="oninitmenupopup"></a>Cwnd::OninitMenuPopup

當彈出功能表即將變為活動時,框架將調用此成員函數。

```
afx_msg void OnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nIndex,
    BOOL bSysMenu);
```

### <a name="parameters"></a>參數

*pPopupMenu*<br/>
指定彈出式功能表的功能表物件。 可能是臨時的,不應存儲以供以後使用。

*nIndex*<br/>
指定主菜單中的彈出式功能表的索引。

*bSysMenu*<br/>
如果彈出式功能表是「控制」功能表,則為 TRUE;否則 FALSE。

### <a name="remarks"></a>備註

這允許應用程式在顯示彈出式功能表之前對其進行修改,而無需更改整個功能表。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninputdevicechange"></a><a name="oninputdevicechange"></a>Cwnd::輸入裝置變更

當從系統添加或刪除 I/O 設備時,框架將調用此成員函數。

```
afx_msg void OnInputDeviceChange(unsigned short uFlag);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*uFlag*|[在]這個旗標可以包含以下值:<br /><br /> - GIDC_ARRIVAL - 系統已添加新設備。<br />- GIDC_REMOVAL - 設備已從系統中刪除。|

### <a name="remarks"></a>備註

此方法接收[WM_INPUT_DEVICE_CHANGE](/windows/win32/inputdev/wm-input-device-change)通知,這在 Windows SDK 中介紹。 是通用輸入設備消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninputlangchange"></a><a name="oninputlangchange"></a>Cwnd::在輸入朗轉換

更改應用程式的輸入語言後,框架將此成員稱為受影響最大的視窗。

```
afx_msg void OnInputLangChange(
    UINT nCharSet,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nCharSet*|[在]新區域設置的字元集。 有關詳細資訊,請參閱[LOGFONT](/windows/win32/api/wingdi/ns-wingdi-logfontw)結構的*lfCharSet*參數。|
|*nLocaleId*|[在]輸入區域設置標識碼。 有關詳細資訊,請參閱[語言識別碼常量和字串](/windows/win32/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>備註

此方法接收[WM_INPUTLANGCHANGE](/windows/win32/winmsg/wm-inputlangchange)通知消息,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndoninputlangchangerequest"></a><a name="oninputlangchangerequest"></a>Cwnd::在輸入朗更改請求

當使用者選擇新的輸入語言時,框架將此成員稱為具有焦點的視窗。

```
afx_msg void OnInputLangChangeRequest(
    UINT nFlags,
    UINT nLocaleId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[在]指示新區域設置是從已安裝區域設置清單中的上一個或下一個區域設置中選擇的符號(OR)組合,或者新輸入區域設置的鍵盤佈局可與系統字元集一起使用。<br /><br /> 可能的值是INPUTLANGCHANGE_BACKWARD、INPUTLANGCHANGE_FORWARD和INPUTLANGCHANGE_SYSCHARSET。|
|*nLocaleId*|[在]輸入區域設置標識碼。 有關詳細資訊,請參閱[語言識別碼常量和字串](/windows/win32/Intl/language-identifier-constants-and-strings)。|

### <a name="remarks"></a>備註

此方法接收[WM_INPUTLANGCHANGEREQUEST](/windows/win32/winmsg/wm-inputlangchangerequest)通知消息,這在 Windows SDK 中介紹。 當使用者選擇使用鍵盤控制面板應用程式中指定的熱鍵或從系統任務列上的指示器指定的熱鍵的新輸入語言時,將發佈此消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonkeydown"></a><a name="onkeydown"></a>Cwnd::打開鍵

按下非系統金鑰時,框架將調用此成員函數。

```
afx_msg void OnKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定給定金鑰的虛擬金鑰代碼。 有關標準虛擬金鑰代碼的清單,請參閱 Winuser.h

*恩雷普森特*<br/>
重複計數(由於使用者按住鍵而重複擊鍵的次數)。

*nFlags*<br/>
指定掃描代碼、金鑰轉換代碼、以前的金鑰狀態和上下文代碼,如以下清單所示:

|值|描述|
|-----------|-----------------|
|0-7|掃描代碼(與 OEM 相關的值)。|
|8|擴展鍵,如功能鍵或數位鍵盤上的鍵(如果是擴展鍵,為 1)。|
|9-10|未使用。|
|11-12|Windows 在內部使用。|
|13|上下文代碼(如果按下鍵時按住 ALT 鍵,則為 1;否則為 0)。|
|14|上一個鍵狀態(如果鍵在調用之前關閉,則為 0,如果鍵已打開,則為 0)。|
|15|轉換狀態(如果釋放鍵,為 1,則為 0,如果按下鍵,則為 0)。|

對於WM_KEYDOWN消息,金鑰轉換位(位元 15)為 0,上下文代碼位(位 13)為 0。

### <a name="remarks"></a>備註

非系統鍵是在未按下 ALT 鍵時按下的鍵盤鍵,或者在具有輸入`CWnd`焦點時 按下的鍵盤鍵。

由於自動重複,在進行`OnKeyDown`[OnKeyUp](#onkeyup)成員函數調用之前,可能會發生多個調用。 指示前一個鍵狀態的位可用於確定`OnKeyDown`調用是第一個向下轉換還是重複向下轉換。

對於 IBM 增強型 101 鍵和 102 鍵鍵盤,增強鍵是鍵盤主部分的正確 ALT 和正確的 CTRL 鍵;數位鍵盤左側的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭頭鍵;和數位鍵盤中的斜杠 (/) 和 ENTER 鍵。 其他一些鍵盤可能支援*nFlags*中的擴展鍵位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonkeyup"></a><a name="onkeyup"></a>Cwnd::打開

釋放非系統金鑰時,框架將調用此成員函數。

```
afx_msg void OnKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定給定金鑰的虛擬金鑰代碼。 有關標準虛擬金鑰代碼的清單,請參閱 Winuser.h

*恩雷普森特*<br/>
重複計數(由於使用者按住鍵而重複擊鍵的次數)。

*nFlags*<br/>
指定掃描代碼、金鑰轉換代碼、以前的金鑰狀態和上下文代碼,如以下清單所示:

|值|描述|
|-----------|-----------------|
|0-7|掃描代碼(與 OEM 相關的值)。 高階字的低位元組。|
|8|擴展鍵,如功能鍵或數位鍵盤上的鍵(1,如果它是擴展鍵;否則為 0)。|
|9-10|未使用。|
|11-12|Windows 在內部使用。|
|13|上下文代碼(如果按下鍵時按住 ALT 鍵,則為 1;否則為 0)。|
|14|上一個鍵狀態(如果鍵在調用之前關閉,則為 0,如果鍵已打開,則為 0)。|
|15|轉換狀態(如果釋放鍵,為 1,則為 0,如果按下鍵,則為 0)。|

對於WM_KEYUP消息,金鑰轉換位(位元 15)為 1,上下文代碼位(位 13)為 0。

### <a name="remarks"></a>備註

非系統鍵是在未按下 ALT 鍵時按下的鍵盤鍵,或當具有輸入焦點時按`CWnd`下的 鍵盤鍵。

對於 IBM 增強型 101 鍵和 102 鍵鍵盤,增強鍵是鍵盤主部分的正確 ALT 和正確的 CTRL 鍵;數位鍵盤左側的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭頭鍵;和數位鍵盤中的斜杠 (/) 和 ENTER 鍵。 其他一些鍵盤可能支援*nFlags*中的擴展鍵位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonkillfocus"></a><a name="onkillfocus"></a>Cwnd::在基爾焦點

框架在失去輸入焦點之前立即調用此成員函數。

```
afx_msg void OnKillFocus(CWnd* pNewWnd);
```

### <a name="parameters"></a>參數

*pNewwnd*<br/>
指定指向接收輸入焦點的視窗的指標(可能是 NULL 或可能是臨時的)。

### <a name="remarks"></a>備註

如果`CWnd`物件顯示一個 care,此時應銷毀該 care。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonlbuttondblclk"></a><a name="onlbuttondblclk"></a>克隆::在LButtonDblClk

當用戶雙擊滑鼠左鍵時,框架將調用此成員函數。

```
afx_msg void OnLButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,請設置。

- MK_MBUTTON 如果滑鼠中鍵已關閉,則"設置"。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有[CS_DBLCLKSWNDCLASS樣式](/windows/win32/api/winuser/ns-winuser-wndclassw)的視窗才會`OnLButtonDblClk`收到呼叫。 這是微軟基礎類視窗的預設值。 當使用者在`OnLButtonDblClk`系統的雙擊時間限制內再次按下滑鼠左鍵時,Windows 會調用。 按兩下滑鼠左鍵實際上生成四個事件[:WM_LBUTTONDOWN、WM_LBUTTONUP](#onlbuttondown)消息、WM_LBUTTONDBLCLK調用,以及釋放按鈕時的另一個[WM_LBUTTONUP](#onlbuttonup)WM_LBUTTONUP消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonlbuttondown"></a><a name="onlbuttondown"></a>Cwnd::OnLButtonDown

當使用者按下滑鼠左鍵時,框架將調用此成員函數。

```
afx_msg void OnLButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,請設置。

- MK_MBUTTON 如果滑鼠中鍵已關閉,則"設置"。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonlbuttonup"></a><a name="onlbuttonup"></a>Cwnd::OnLButtonUp

當使用者釋放滑鼠左鍵時,框架將調用此成員函數。

```
afx_msg void OnLButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_MBUTTON 如果滑鼠中鍵已關閉,則"設置"。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmbuttondblclk"></a><a name="onmbuttondblclk"></a>Cwnd::OnMButtonDblClk

當用戶雙擊滑鼠中間鍵時,框架將調用此成員函數。

```
afx_msg void OnMButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,請設置。

- MK_MBUTTON 如果滑鼠中鍵已關閉,則"設置"。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有[CS_DBLCLKSWNDCLASS樣式](/windows/win32/api/winuser/ns-winuser-wndclassw)的視窗才會`OnMButtonDblClk`收到呼叫。 這是所有 Microsoft 基礎類視窗的預設值。 當使用者在系統的`OnMButtonDblClk`按兩下時間限制內再次按下滑鼠中間鍵時,Windows 將生成呼叫。 按兩下滑鼠中間鍵實際上會生成四個事件[:WM_MBUTTONDOWN](#onmbuttondown)和[WM_MBUTTONUP](#onmbuttonup)消息、WM_MBUTTONDBLCLK調用和另一個WM_MBUTTONUP消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmbuttondown"></a><a name="onmbuttondown"></a>Cwnd::打開按鈕

當使用者按下滑鼠中間鍵時,框架將調用此成員函數。

```
afx_msg void OnMButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,請設置。

- MK_MBUTTON 如果滑鼠中鍵已關閉,則"設置"。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmbuttonup"></a><a name="onmbuttonup"></a>Cwnd::OnMButtonUp

當使用者釋放滑鼠中間鍵時,框架將調用此成員函數。

```
afx_msg void OnMButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,請設置。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmdiactivate"></a><a name="onmdiactivate"></a>Cwnd::OnMDI啟動

框架為正在停用的子視窗和正在啟動的子窗口調用此成員函數。

```
afx_msg void OnMDIActivate(
    BOOL bActivate,
    CWnd* pActivateWnd,
    CWnd* pDeactivateWnd);
```

### <a name="parameters"></a>參數

*b 啟動*<br/>
如果孩子正在啟動,則為 TRUE,如果孩子正在停用,則為 FALSE。

*pActivateWnd*<br/>
包含指向要啟動的 MDI 子視窗的指標。 當 MDI 子視窗收到時 *,pActivateWnd*包含指向正在啟動的子視窗的指標。 此指標可能是臨時指標,不應存儲以供以後使用。

*pDeactivateWnd*<br/>
包含指向要停用的 MDI 子視窗的指標。 此指標可能是臨時指標,不應存儲以供以後使用。

### <a name="remarks"></a>備註

獨立於 MDI 框架視窗啟動 MDI 子視窗。 當幀變為活動狀態時,上次使用`OnMDIActivate`呼叫啟動的子視窗會收到一條[WM_NCACTIVATE](#onncactivate)消息以繪製活動視窗框和標題列,但不會收到`OnMDIActivate`另一個 呼叫。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmeasureitem"></a><a name="onmeasureitem"></a>Cwnd::在測量專案上

框架在創建控制項時,透過擁有者繪製按鈕、組合框、清單框或功能表項的所有者的框架調用此成員函數。

```
afx_msg void OnMeasureItem(
    int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
```

### <a name="parameters"></a>參數

*nIDCtl*<br/>
控制項的識別碼。

*lp 測量項目結構*<br/>
指向包含擁有者繪製控制件維度的[「測量專案」](/windows/win32/api/winuser/ns-winuser-measureitemstruct)資料結構。

### <a name="remarks"></a>備註

重寫此成員函數並填寫`MEASUREITEMSTRUCT`*lpMeasure ItemStruct*和傳回指向的資料結構;這將通知 Windows 控件的維度,並允許 Windows 正確處理使用者與控制項的互動。

如果使用LBS_OWNERDRAWVARIABLE或CBS_OWNERDRAWVARIABLE樣式創建清單框或組合框,則框架將針對控制項中的每個項的所有者調用此函數;如果使用[LBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)或[CBS_OWNERDRAWVARIABLE](../../mfc/reference/styles-used-by-mfc.md#combo-box-styles)樣式創建清單框或組合框,則框架將針對控制項中的每個項的擁有者調用此函數。否則,此函數調用一次。

在發送`OnMeasureItem`[WM_INITDIALOG](/windows/win32/dlgbox/wm-initdialog)訊息之前,Windows 會啟動使用 OWNERDRAWFIXED 樣式創建的組合框和清單框的所有者的調用。 因此,當擁有者收到此呼叫時,Windows 尚未確定控制項中使用的字體的高度和寬度;因此,Windows 尚未確定控制項中使用的字型的高度和寬度。需要這些值的函數調用和計算應出現在應用程式或庫的主要函數中。

如果要測量的項是`CMenu``CListBox``CComboBox`或 物件,則`MeasureItem`調用 相應類的虛擬函數。 重寫相應`MeasureItem`控制項類的成員函數,以計算和設置每個項的大小。

`OnMeasureItem`僅當在運行時創建控制件的類,或者使用LBS_OWNERDRAWVARIABLE或CBS_OWNERDRAWVARIABLE樣式創建控制項的類時,才會調用該類。 如果控制項由對話框編輯器建立,`OnMeasureItem`則不會呼叫。 這是因為[WM_MEASUREITEM](/windows/win32/Controls/wm-measureitem)消息在控件的創建過程的早期發送。 如果使用、`DDX_Control``SubclassDlgItem``SubclassWindow`或的子類通常發生在創建過程之後。 因此,在控件`OnChildNotify`的功能中無法處理[WM_MEASUREITEM](/windows/win32/Controls/wm-measureitem)消息,這是 MFC 用於實現ON_WM_MEASUREITEM_REFLECT的機制。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenuchar"></a><a name="onmenuchar"></a>Cwnd::OnMenuChar

當使用者按下與當前功能表中的任何預定義的助記符不匹配的功能表助記符時,框架將調用此成員函數。

```
afx_msg LRESULT OnMenuChar(
    UINT nChar,
    UINT nFlags,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
根據生成設定,指定使用者按下的 ANSI 或 Unicode 字元。

*nFlags*<br/>
如果功能表是彈出式功能表,則包含MF_POPUP標誌。 如果功能表是「控件」功能表,則它包含MF_SYSMENU標誌。

*pMenu*<br/>
包含指向所選`CMenu`的 的指標。 指標可能是臨時的,不應存儲。

### <a name="return-value"></a>傳回值

傳回值的高階單詞應包含以下命令代碼之一:

|值|描述|
|-----------|-----------------|
|0|告訴 Windows 放棄使用者按下的字元,並在系統揚聲器上創建短促的蜂鳴音。|
|1|告訴 Windows 關閉當前功能表。|
|2|通知 Windows 返回值的低階字包含特定物料的物料編號。 此專案由 Windows 選擇。|

如果高階單詞包含 0 或 1,則忽略低階單詞。 當使用快速鍵(快捷方式)鍵選擇放置在功能表中的位圖時,應用程式應處理此消息。

### <a name="remarks"></a>備註

傳送到擁有選單的`CWnd`。 `OnMenuChar`當使用者按下 ALT 和任何其他鍵時,也稱為,即使該鍵與助記符不對應也是如此。 在這種情況下 *,pMenu*指向 擁有`CWnd`的功能表 *,nFlags*為 0。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenudrag"></a><a name="onmenudrag"></a>Cwnd::上功能表拖動

當用戶開始拖動功能表項時,框架將調用當前拖放功能表的此成員函數。

```
afx_msg UINT OnMenuDrag(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nPos*|[在]拖動操作開始時功能表項的索引位置。|
|*pMenu*|[在]指向包含功能表項的[CMenu](../../mfc/reference/cmenu-class.md)物件的指標。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MND_CONTINUE|功能表應保持活動狀態。 如果釋放滑鼠,則應忽略它。|
|MND_ENDMENU|功能表應結束。|

### <a name="remarks"></a>備註

此方法接收[WM_MENUDRAG](/windows/win32/menurc/wm-menudrag)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenugetobject"></a><a name="onmenugetobject"></a>Cwnd::在MenugetObject

當滑鼠游標進入功能表項或從項的中心移動到項的頂部或底部時,框架將調用當前拖放菜單的此成員函數。

```
afx_msg UINT OnMenuGetObject(MENUGETOBJECTINFO* pMenuGetObjectInfo);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pMenu*|[在]指向[MENUGETOBJECTINFO](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo)結構的指標,該結構包含有關滑鼠游標打開的拖放功能表的資訊。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|MNGO_NOERROR|支援拖放和拖動操作的介面指標將返回在`pvObj`[MENUGETOBJECTINFO](/windows/win32/api/winuser/ns-winuser-menugetobjectinfo)結構的成員中。 目前,僅支援[IDropTarget](/windows/win32/api/oleidl/nn-oleidl-idroptarget)介面。|
|MNGO_NOINTERFACE|不支援拖放介面。|

### <a name="remarks"></a>備註

此方法接收[WM_MENUGETOBJECT](/windows/win32/menurc/wm-menugetobject)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenurbuttonup"></a><a name="onmenurbuttonup"></a>Cwnd::OnMenurButtonUp

當用戶在游標位於功能表項上時釋放滑鼠右鍵時,框架將調用此成員函數。

```
afx_msg void OnMenuRButtonUp(
    UINT nPos,
    CMenu* pMenu);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nPos*|[在]釋放滑鼠右鍵時功能表項的索引位置。|
|*pMenu*|[在]指向包含功能表項的[CMenu](../../mfc/reference/cmenu-class.md)物件的指標。|

### <a name="remarks"></a>備註

此方法接收[WM_MENURBUTTONUP](/windows/win32/menurc/wm-menurbuttonup)通知,這在 Windows SDK 中介紹。 [WM_MENURBUTTONUP](/windows/win32/menurc/wm-menurbuttonup)消息使應用程式能夠為消息中指定的功能表項提供上下文相關的功能表。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmenuselect"></a><a name="onmenuselect"></a>Cwnd::在Menu選擇

如果`CWnd`物件與功能表關聯`OnMenuSelect`, 則當使用者選擇功能表項時,框架將調用該物件。

```
afx_msg void OnMenuSelect(
    UINT nItemID,
    UINT nFlags,
    HMENU hSysMenu);
```

### <a name="parameters"></a>參數

*nItemID*<br/>
標識所選專案。 如果選取項目是功能表項,則*nItemID*包含功能表項 ID。 如果選取項目包含彈出式選單,*則 nItemID*包含彈出式選單索引 *,hSysMenu*包含主(單擊)功能表的句柄。

*nFlags*<br/>
包含以下選單旗標的組合:

- MF_BITMAP專案是位圖。

- MF_CHECKED專案已選中。

- MF_DISABLED專案已禁用。

- MF_GRAYED專案變暗。

- MF_MOUSESELECT使用滑鼠選擇了專案。

- MF_OWNERDRAW專案是擁有者繪製專案。

- MF_POPUP專案包含一個彈出式功能表。

- MF_SEPARATOR專案是功能表分隔符。

- MF_SYSMENU項包含在"控制"功能表中。

*hSysMenu*<br/>
如果*nFlags*包含MF_SYSMENU,則標識與消息關聯的功能表。 如果*nFlags*包含MF_POPUP,則標識主功能表的句柄。 如果*nFlags*既不包含MF_SYSMENU也不MF_POPUP,則它未使用。

### <a name="remarks"></a>備註

如果*nFlags*包含 0xFFFF,hSysMenu 包含 0,則 Windows 已關閉功能表,因為使用者按下 ESC*hSysMenu*鍵或在功能表外單擊。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmouseactivate"></a><a name="onmouseactivate"></a>Cwnd::滑鼠啟動

當游標處於非活動視窗中且使用者按下滑鼠按鈕時,框架將調用此成員函數。

```
afx_msg int OnMouseActivate(
    CWnd* pDesktopWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pDesktopwnd*<br/>
指定指向要啟動的視窗的頂層父視窗的指標。 指標可能是臨時的,不應存儲。

*nHitTest*<br/>
指定[測試](#onnchittest)區域代碼。 命中測試是確定游標位置的測試。

*message*<br/>
指定滑鼠訊息編號。

### <a name="return-value"></a>傳回值

指定是否啟動`CWnd`與是否放棄滑鼠事件。 它必須是以下值之一:

- MA_ACTIVATE啟動`CWnd`物件。

- MA_NOACTIVATE不要啟動`CWnd`物件。

- MA_ACTIVATEANDEAT啟動`CWnd`物件並丟棄滑鼠事件。

- MA_NOACTIVATEANDEAT不要激活`CWnd`物件並丟棄滑鼠事件。

### <a name="remarks"></a>備註

在進行任何處理之前,默認實現將此消息傳遞給父視窗。 如果父視窗返回 TRUE,則處理將停止。

有關各個命中測試區域代碼的說明,請參閱[OnNcHitTest](#onnchittest)成員函數

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCAxCtl#9](../../mfc/reference/codesnippet/cpp/cwnd-class_49.cpp)]

## <a name="cwndonmousehover"></a><a name="onmousehover"></a>Cwnd::滑鼠懸停

當游標懸停在視窗的工作區上,在之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的時間段時,框架將調用此成員函數。

```
afx_msg void OnMouseHover(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改鍵的標誌的位組合 (OR)。 例如,MK_CONTROL標誌指示按下 CTRL 鍵。|
|*點*|[在]一個[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於工作區左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_MOUSEHOVER](/windows/win32/inputdev/wm-mousehover)通知,這在 Windows SDK 中介紹。

*nFlags*參數可以是下表中列出的修改器鍵的組合。 有關詳細資訊,請參閱[有關滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|變更器鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|按下微軟智慧滑鼠的 XBUTTON1 滑鼠按鈕。|
|MK_XBUTTON2|按下微軟智慧滑鼠的 XBUTTON2 滑鼠按鈕。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmousehwheel"></a><a name="onmousehwheel"></a>Cwnd::在滑鼠上

當目前的視窗由桌面視窗管理員 (DWM) 組成且該視窗最大化時,框架將呼叫此成員。

```
afx_msg void OnMouseHWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改鍵的標誌的位組合 (OR)。 例如,MK_CONTROL標誌指示按下 CTRL 鍵。<br /><br /> 有關標誌清單,請參閱[「關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)」中的「訊息參數」副標題。|
|*ZDelta*|[在]指示車輪旋轉的距離,以 WHEEL_DELTA的倍數或分數表示,即 120。 正值表示車輪向右旋轉;負值表示車輪向左旋轉。|
|*pt*|[在]一個[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於工作區左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_MOUSEHWHEEL](/windows/win32/inputdev/wm-mousehwheel)通知消息,這在 Windows SDK 中介紹。 當滑鼠的水準滾輪傾斜或旋轉時,此消息將發送到具有焦點的視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmouseleave"></a><a name="onmouseleave"></a>Cwnd::滑鼠離開

當游標離開之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的視窗的工作區時,框架將調用此成員函數。

```
afx_msg void OnMouseLeave();
```

### <a name="remarks"></a>備註

此方法接收[WM_MOUSELEAVE](/windows/win32/inputdev/wm-mouseleave)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmousemove"></a><a name="onmousemove"></a>Cwnd::滑鼠移動

當滑鼠游標移動時,框架將調用此成員函數。

```
afx_msg void OnMouseMove(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,請設置。

- MK_MBUTTON 如果滑鼠中鍵已關閉,則"設置"。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

如果未捕獲滑鼠,滑鼠游標下方`CWnd`的物件將接收WM_MOUSEMOVE消息;否則,消息將轉到捕獲滑鼠的視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmousewheel"></a><a name="onmousewheel"></a>Cwnd::滑鼠輪上

當使用者旋轉滑鼠滾輪並遇到車輪的下一個切口時,框架將調用此成員函數。

```
afx_msg BOOL OnMouseWheel(
    UINT nFlags,
    short zDelta,
    CPoint pt);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,請設置。

- MK_MBUTTON 如果滑鼠中鍵已關閉,則"設置"。

- MK_RBUTTON 如果滑鼠右鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*ZDelta*<br/>
指示旋轉的距離。 *zDelta*值以WHEEL_DELTA的倍數或分表示,即120。 小於零的值表示旋轉回(向使用者),而大於零的值表示向前旋轉(遠離使用者)。 用戶可以通過更改滑鼠軟體中的「滾輪」設置來反轉此回應。 有關此參數的詳細資訊,請參閱備註。

*pt*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於螢幕的左上角。

### <a name="return-value"></a>傳回值

啟用滑鼠滾輪時非零;否則 0。

### <a name="remarks"></a>備註

除非重寫,否則`OnMouseWheel`呼叫預設值[WM_MOUSEWHEEL](/windows/win32/inputdev/wm-mousewheel)。 Windows 會自動將消息路由到具有焦點的控制項或子視窗。 Win32 函數[DefWindowProc](/windows/win32/api/winuser/nf-winuser-defwindowprocw)將消息向上傳播到處理該消息的視窗。

*zDelta*參數是 WHEEL_DELTA的倍數,設置為 120。 此值是要執行的操作的閾值,每個增量應執行一個此類操作(例如,向前滾動一個凹槽)。

WHEEL_DELTA設置為 120,允許更精細的車輪,如無凹口的自由旋轉車輪。 更精細的輪輪每次旋轉發送更多消息,但每條消息的增量值較小。 要使用此類滾輪,請添加傳入*的 zDelta*值,直到達到WHEEL_DELTA(以便獲得給定增量旋轉的相同回應),或滾動部分行以回應更頻繁的消息。 您還可以選擇滾動粒度並累積增量,直到達到WHEEL_DELTA。

重寫此成員函數以提供您自己的滑鼠滾輪滾動行為。

> [!NOTE]
> `OnMouseWheel`處理 Windows NT 4.0 和更高版本的消息。 對於 Windows 95/98 或 Windows NT 3.51 訊息處理,請使用[註冊滑鼠滾輪](#onregisteredmousewheel)。

## <a name="cwndonmove"></a><a name="onmove"></a>Cwnd::移動

移動物件後,`CWnd`框架將調用此成員函數。

```
afx_msg void OnMove(
    int x,
    int y);
```

### <a name="parameters"></a>參數

*x*<br/>
指定工作區左上角的新 x 座標位置。 此新位置在重疊視窗和彈出視窗的螢幕座標中提供,以及子視窗的父客戶端座標。

*Y*<br/>
指定工作區左上角的新 y 座標位置。 此新位置在重疊視窗和彈出視窗的螢幕座標中提供,以及子視窗的父客戶端座標。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonmoving"></a><a name="onmoving"></a>Cwnd::移動

當使用者移動`CWnd`物件時,框架將調用此成員函數。

```
afx_msg void OnMoving(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*n側*<br/>
要移動的視窗的邊緣。

*lpRect*<br/>
包含項座標的[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)的位址。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncactivate"></a><a name="onncactivate"></a>Cwnd::打開NcActivate

當需要更改非工作區以指示活動或非活動狀態時,框架將調用此成員函數。

```
afx_msg BOOL OnNcActivate(BOOL bActive);
```

### <a name="parameters"></a>參數

*b 活動*<br/>
指定何時需要更改標題列或圖示以指示活動或非活動狀態。 如果要繪製活動標題或圖示,*則 bActive*參數為 TRUE。 對於非活動標題或圖示,它是FALSE。

### <a name="return-value"></a>傳回值

如果 Windows 應繼續默認處理,則非零;0 以防止標題列或圖示停用。

### <a name="remarks"></a>備註

如果*bActive*為 TRUE,則預設實現以其活動顏色繪製標題列和標題欄文本,如果*bActive*為 FALSE,則以非活動顏色繪製標題列和標題欄文本。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnccalcsize"></a><a name="onnccalcsize"></a>Cwnd::在NcCalcsize上

當需要計算工作區的大小和位置時,框架將調用此成員函數。

```
afx_msg void OnNcCalcSize(
    BOOL bCalcValidRects,
    NCCALCSIZE_PARAMS* lpncsp);
```

### <a name="parameters"></a>參數

*bCalcValidrects*<br/>
指定應用程式是否應指定工作區的哪個部分包含有效資訊。 Windows 將有效資訊複製到新工作區中的指定區域。 如果此參數為 TRUE,則應用程式應指定工作區的哪個部分有效。

*lpncsp*<br/>
指向[包含](/windows/win32/api/winuser/ns-winuser-nccalcsize_params)應用程式可用於`CWnd`計算 矩形的新大小和位置(包括工作區、邊框、標題、滾動條等)的資訊NCCALCSIZE_PARAMS數據結構。

### <a name="remarks"></a>備註

通過處理此消息,當視窗的大小或位置發生變化時,應用程式可以控制視窗工作區的內容。

無論*bCalcValidRects*的值`rgrc``NCCALCSIZE_PARAMS`如何, 結構結構成員指定的陣列中的第一個矩形都包含視窗的座標。 對於子視窗,坐標相對於父視窗的工作區。 對於頂級視窗,坐標是螢幕座標。 應用程式應修改`rgrc[0]`矩形以反映工作區的大小和位置。

`rgrc[1]`僅當`rgrc[2]`*bCalcValidRects*為 TRUE 時,和矩形才有效。 在這種情況下,`rgrc[1]`矩形在移動或調整視窗大小之前包含視窗的座標。 該`rgrc[2]`矩形包含視窗在移動視窗之前工作區的座標。 所有座標都相對於父視窗或螢幕。

預設實現根據視窗特徵(存在滾動條、功能表等)計算工作區的大小,並將結果放在*lpncsp*中。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnccreate"></a><a name="onnccreate"></a>Cwnd::OnNcCreate

首次創建`CWnd`物件時,該框架在[WM_CREATE](#oncreate)消息之前調用此成員函數。

```
afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
```

### <a name="parameters"></a>參數

*lpCreatestruct*<br/>
指向的[CREATESTRUCT](/windows/win32/api/winuser/ns-winuser-createstructw)資料`CWnd`結構。

### <a name="return-value"></a>傳回值

如果創建了非工作區,則為非零。 如果發生錯誤,為 0;如果發生錯誤,則為 0。在這種情況下`Create`,函數會傳回**故障**。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncdestroy"></a><a name="onncdestroy"></a>Cwnd::OnNc銷毀

在銷毀非工作區時由框架調用,是銷毀 Windows 視窗時調用的最後一個成員函數。

```
afx_msg void OnNcDestroy();
```

### <a name="remarks"></a>備註

預設執行一些清理,然後呼叫虛擬成員函數[PostNc 銷毀](#postncdestroy)。

如果要`PostNcDestroy`執行自己的清理(如**刪除此操作**)。請覆蓋。 如果重寫`OnNcDestroy`,則必須在`OnNcDestroy`基 類中調用 以確保釋放為視窗在內部分配的任何記憶體。

## <a name="cwndonnchittest"></a><a name="onnchittest"></a>Cwnd::OnNcHitTest

框架為每次移動滑鼠時包含游`CWnd`標(或使用[SetCapture](#setcapture)`CWnd`成員函數 捕獲滑鼠輸入的物件)調用此成員函數。

```
afx_msg LRESULT OnNcHitTest(CPoint point);
```

### <a name="parameters"></a>參數

*點*<br/>
包含游標的 x 座標和 y 座標。 這些座標始終是螢幕座標。

### <a name="return-value"></a>傳回值

滑鼠命中測試枚舉值之一。 有關值清單,請參閱[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnclbuttondblclk"></a><a name="onnclbuttondblclk"></a>Cwnd::OnNcLButtonDblClk

當使用者按兩下滑鼠左鍵,而游標位於的非用戶端區域中時,框架將呼叫此成員函`CWnd`數 。

```
afx_msg void OnNcLButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。 有關值清單,請參閱[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果合適,將發送[WM_SYSCOMMAND](#onsyscommand)消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnclbuttondown"></a><a name="onnclbuttondown"></a>Cwnd::OnNcLButtonDown

當使用者按下滑鼠左鍵,而游標位於`CWnd`物件的非工作區中時,框架將調用此成員函數。

```
afx_msg void OnNcLButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。 有關值清單,請參閱[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果合適,將發送[WM_SYSCOMMAND。](#onsyscommand)

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞給函數的參數反映收到消息時框架收到的參數。如果調用此函數的基類實現,則該實現將使用最初隨消息傳遞的參數,而不是向函數供電的參數。

## <a name="cwndonnclbuttonup"></a><a name="onnclbuttonup"></a>Cwnd::OnNcLButtonUp

當使用者釋放滑鼠左鍵,而游標位於非工作區中時,框架將調用此成員函數。

```
afx_msg void OnNcLButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。 有關值清單,請參閱[WM_NCHITTEST。](/windows/win32/inputdev/wm-nchittest)

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果合適,將發送[WM_SYSCOMMAND。](#onsyscommand)

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmbuttondblclk"></a><a name="onncmbuttondblclk"></a>Cwnd::OnNcMButtonDblClk

當用戶雙擊滑鼠中間鍵,而游標位於非工作區中時,框架將調用此成員函數。

```
afx_msg void OnNcMButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmbuttondown"></a><a name="onncmbuttondown"></a>Cwnd::打開按鈕

當用戶在游標位於非工作區內時按下滑鼠中間按鈕時,框架將調用此成員函數。

```
afx_msg void OnNcMButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmbuttonup"></a><a name="onncmbuttonup"></a>Cwnd::OnNcMButtonUp

當使用者釋放滑鼠中間鍵,而游標位於非工作區中時,框架將調用此成員函數。

```
afx_msg void OnNcMButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmousehover"></a><a name="onncmousehover"></a>Cwnd::在NcMouse懸停

當游標懸停在視窗的非工作區上,在之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的時間段時,框架將調用此成員函數。

```
afx_msg void OnNcMouseHover(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|[在][CWnd::DefWindowProc](#defwindowproc)函數在處理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息時返回的命中測試值。|
|*點*|[在]CPoint[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於螢幕左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_NCMOUSEHOVER](/windows/win32/inputdev/wm-ncmousehover)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmouseleave"></a><a name="onncmouseleave"></a>Cwnd::在NcMouseLeave

當游標離開之前調用[TrackMouseEvent](/windows/win32/api/winuser/nf-winuser-trackmouseevent)中指定的視窗的非工作區時,框架將調用此成員函數。

```
afx_msg void OnNcMouseLeave();
```

### <a name="remarks"></a>備註

此方法接收[WM_NCMOUSELEAVE](/windows/win32/inputdev/wm-ncmouseleave)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncmousemove"></a><a name="onncmousemove"></a>Cwnd::在NcMouseMove

當游標在非工作區中移動時,框架將調用此成員函數。

```
afx_msg void OnNcMouseMove(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

如果合適,將發送[WM_SYSCOMMAND](#onsyscommand)消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncpaint"></a><a name="onncpaint"></a>Cwnd:onNcPaint

當需要繪製非工作區時,框架將調用此成員函數。

```
afx_msg void OnNcPaint();
```

### <a name="remarks"></a>備註

預設實現繪製視窗框架。

應用程式可以重寫此調用並繪製自己的自定義視窗框架。 裁剪區域始終為矩形,即使框架的形狀已更改也是如此。

## <a name="cwndonncrbuttondblclk"></a><a name="onncrbuttondblclk"></a>Cwnd::OnNcRButtonDblClk

當使用者按下滑鼠右鍵時,當游標位於的非用戶端區域中時,框架將呼叫此成員函數`CWnd`。

```
afx_msg void OnNcRButtonDblClk(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncrbuttondown"></a><a name="onncrbuttondown"></a>Cwnd::OnNcRButtonDown

當使用者在游標位於非工作區內時按下滑鼠右鍵時,框架將調用此成員函數。

```
afx_msg void OnNcRButtonDown(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncrbuttonup"></a><a name="onncrbuttonup"></a>Cwnd::OnNcRButtonUp

當使用者釋放滑鼠右鍵時,當游標位於非工作區中時,框架將調用此成員函數。

```
afx_msg void OnNcRButtonUp(
    UINT nHitTest,
    CPoint point);
```

### <a name="parameters"></a>參數

*nHitTest*<br/>
指定[測試代碼](#onnchittest)。 命中測試是確定游標位置的測試。

*點*<br/>
指定包含`CPoint`游標位置的 x 和 y 螢幕座標的物件。 這些座標始終相對於螢幕的左上角。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncrenderingchanged"></a><a name="onncrenderingchanged"></a>Cwnd::打開呈現

當非工作區的呈現策略發生更改時,框架將調用此成員。

```
afx_msg void OnNcRenderingChanged(BOOL bIsRendering);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*bIs渲染*|[在]如果為視窗的非工作區啟用桌面視窗管理員 (DWM) 呈現,則為 TRUE;如果禁用渲染,則 FALSE。|

### <a name="remarks"></a>備註

此方法接收[WM_DWMNCRENDERINGCHANGED](/windows/win32/dwm/wm-dwmncrenderingchanged)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncxbuttondblclk"></a><a name="onncxbuttondblclk"></a>Cwnd::OnNcXButtonDblClk

當用戶雙擊 XBUTTON1 或 XBUTTON2 時,當使用者按兩下 XBUTTON1 或 XBUTTON2 時,當使用者在視窗的非工作區中時,框架將調用此成員函數。

```cpp
void OnNcXButtonDblClk(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|[在][CWnd::DefWindowProc](#defwindowproc)函數在處理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息時返回的命中測試值。|
|*nButton*|[在]如果按一個 Microsoft 智慧滑鼠 X 按鈕,則值為 XBUTTON1;如果按兩下第二個 X 按鈕,則為 XBUTTON2。|
|*點*|[在]一個[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於工作區左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_XBUTTONDBLCLK](/windows/win32/inputdev/wm-xbuttondblclk)通知,這在 Windows SDK 中介紹。 此消息將發佈到包含游標的視窗。 如果視窗捕獲了滑鼠,則不會發佈此消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncxbuttondown"></a><a name="onncxbuttondown"></a>Cwnd::OnNcX按鈕向下

當使用者按下滑鼠的 XBUTTON1 或 XBUTTON2 時,當游標位於視窗的非工作區中時,框架將調用此成員函數。

```
afx_msg void OnNcXButtonDown(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|[在][CWnd::DefWindowProc](#defwindowproc)函數在處理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息時返回的命中測試值。|
|*nButton*|[在]如果按下第一個滑鼠 X 按鈕,則為 XBUTTON1 的值;如果按下第二個 X 按鈕,則為 XBUTTON2。|
|*點*|[在]CPoint[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於螢幕左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_NCXBUTTONDOWN](/windows/win32/inputdev/wm-ncxbuttondown)通知,這在 Windows SDK 中介紹。 此消息將發佈到包含游標的視窗。 如果視窗捕獲了滑鼠,則不會發佈此消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonncxbuttonup"></a><a name="onncxbuttonup"></a>Cwnd::OnNcXButtonUp

當使用者釋放滑鼠的 XBUTTON1 或 XBUTTON2 時,當游標位於視窗的非工作區中時,框架將調用此成員函數。

```
afx_msg void OnNcXButtonUp(
    short nHitTest,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nHitTest*|[在][CWnd::DefWindowProc](#defwindowproc)函數在處理[WM_NCHITTEST](/windows/win32/inputdev/wm-nchittest)消息時返回的命中測試值。|
|*nButton*|[在]如果釋放第一個滑鼠 X 按鈕,則為 XBUTTON1 的值;如果釋放第二個 X 按鈕,則為 XBUTTON2。|
|*點*|[在]CPoint[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於螢幕左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_NCXBUTTONUP](/windows/win32/inputdev/wm-ncxbuttonup)通知,這在 Windows SDK 中介紹。 此消息將發佈到包含游標的視窗。 如果視窗捕獲了滑鼠,則不會發佈此消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnextmenu"></a><a name="onnextmenu"></a>Cwnd::上一個功能表

當使用右箭頭或左箭頭鍵在功能表欄和系統功能表之間切換時,框架將調用此成員函數。

```
afx_msg void OnNextMenu(
    UINT nKey,
    LPMDINEXTMENU lpMdiNextMenu);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*N 鍵*|[在]指示按下哪些修改鍵的標誌的位組合 (OR)。 例如,MK_CONTROL標誌指示按下 CTRL 鍵。<br /><br /> 有關標誌清單,請參閱[「關於滑鼠輸入](/windows/win32/inputdev/about-mouse-input)」中的「訊息參數」副標題。|
|*lpMdiNextMenu*|[在]指向包含要啟動的功能表資訊的[MDINEXTMENU](/windows/win32/api/winuser/ns-winuser-mdinextmenu)結構的指標。|

### <a name="remarks"></a>備註

此方法接收[WM_UNINITMENUPOPUP](/windows/win32/menurc/wm-uninitmenupopup)通知,這在Windows SDK中介紹。 為了回應此消息,應用程式可以設置`hmenuNext`[MDINEXTMENU](/windows/win32/api/winuser/ns-winuser-mdinextmenu)結構的成員以指定要切換到的功能表,以及指定視窗以接收選`hwndNext`單通知 消息的成員。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonnotify"></a><a name="onnotify"></a>Cwnd::打開通知

框架調用此成員函數以通知控制項的父視窗控制項中發生了事件或該控制項需要某種資訊。

```
virtual BOOL OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*wParam*<br/>
標識消息來自控件時發送消息的控制項。 否則 *,wParam*為 0。

*lParam*<br/>
指向包含通知代碼和其他資訊`NMHDR`的通知訊息( ) 結構的指標。 對於某些通知消息,此參數指向具有`NMHDR`結構作為其第一個成員的較大結構。

*pResult*<br/>
指向 LRESULT 變數的指標,在其中存儲結果代碼(如果消息已處理)。

### <a name="return-value"></a>傳回值

如果應用程式處理此消息,則返回非零;否則 0。

### <a name="remarks"></a>備註

`OnNotify`處理消息映射以進行控制通知。

重寫派生類中的此成員函數以處理WM_NOTIFY消息。 除非調用基類`OnNotify`,否則重寫將不會處理消息映射。

有關WM_NOTIFY消息的詳細資訊,請參閱技術說明 61 (TN061)、ON_NOTIFY[和WM_NOTIFY消息](../../mfc/tn061-on-notify-and-wm-notify-messages.md)。 您可能還對[控件主題](../../mfc/controls-mfc.md)和 TN062"Windows[控件的消息反射"](../../mfc/tn062-message-reflection-for-windows-controls.md)中描述的相關主題感興趣。

## <a name="cwndonnotifyformat"></a><a name="onnotifyformat"></a>Cwnd::打開Notify格式

框架調用此成員函數以確定當前視窗是否接受WM_NOTIFY通知消息中的 ANSI 或 Unicode 結構。

```
afx_msg UINT OnNotifyFormat(
    CWnd* pWnd,
    UINT nCommand);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pwnd*|[在]指向表示發送`CWnd`[WM_NOTIFY](/windows/win32/controls/wm-notify)消息的視窗的物件的指標。<br /><br /> 如果*nCommand*參數NF_QUERY,則此參數是指向控制項的指標,或者指向控制項的父視窗(如果*nCommand* NF_REQUERY則指向控制項的父視窗的指標)。|
|*nCommand*|[在]專門化WM_NOTIFY消息的命令值。 可能的值包括：<br /><br /> - NF_QUERY -<br />     該消息是確定是否應在WM_NOTIFY消息中使用 ANSI 或 Unicode 結構的查詢。 在創建控制項期間,此消息從控制件發送到其父視窗,並回應此消息的NF_REQUERY形式。<br />- NF_REQUERY -<br />     該消息是控制項向其父視窗發送此消息NF_QUERY形式的請求。 此請求從父窗口發送,並要求控制項重新查詢父級WM_NOTIFY消息中要使用的結構類型。 如果*nCommand*參數NF_REQUERY,則返回值是重新查詢操作的結果。|

### <a name="return-value"></a>傳回值

|傳回值|意義|
|------------------|-------------|
|NFR_ANSI|ANSI 結構應用於控制郵件郵件傳送WM_NOTIFY消息。|
|NFR_UNICODE|Unicode 結構應用於控制檔發送WM_NOTIFY消息。|
|0|發生錯誤。|

### <a name="remarks"></a>備註

此方法接收[WM_NOTIFYFORMAT](/windows/win32/Controls/wm-notifyformat)通知,這在 Windows SDK 中介紹。 WM_NOTIFY消息從公共控制件發送到其父視窗,從父視窗發送到公共控制項。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpaint"></a><a name="onpaint"></a>Cwnd::上漆

當 Windows 或應用程式發出重新繪製應用程式視窗的一部分的請求時,框架將調用此成員函數。

```
afx_msg void OnPaint();
```

### <a name="remarks"></a>備註

呼叫[「更新視窗](#updatewindow)」或[「重繪視窗](#redrawwindow)」成員函數時,將發送[WM_PAINT](/windows/win32/gdi/the-wm-paint-message)訊息。

視窗可能會接收內部繪製消息,因為使用RDW_INTERNALPAINT標誌集調用`RedrawWindow`成員函數。 在這種情況下,視窗可能沒有更新區域。 應用程式應調用[GetUpdateRect](#getupdaterect)成員函數以確定視窗是否具有更新區域。 如果`GetUpdateRect`返回 0,則應用程式不應呼叫[BeginPaint](#beginpaint)和[EndPaint](#endpaint)成員函數。

應用程式有責任通過查看每個WM_PAINT消息的內部數據結構來檢查任何必要的內部重新繪製或更新,因為WM_PAINT消息可能是由無效區域和使用RDW_INTERNALPAINT標誌集的成員`RedrawWindow`函數調用引起的。

內部WM_PAINT消息僅由 Windows 發送一次。 在`UpdateWindow`成員函數將內部WM_PAINT消息發送到視窗後,在視窗失效或使用RDW_INTERNALPAINT標誌集再次調用`RedrawWindow`成員函數之前,不會再發送或發佈任何WM_PAINT消息。

有關在文件/檢視應用程式中渲染影像的資訊,請參閱[CView::: OnDraw](../../mfc/reference/cview-class.md#ondraw)。

有關使用`WM_Paint`的詳細資訊,請參閱 Windows SDK 中的以下主題:

- [WM_PAINT訊息](/windows/win32/gdi/the-wm-paint-message)

- [使用WM_PAINT訊息](/windows/win32/gdi/using-the-wm-paint-message)

## <a name="cwndonpaintclipboard"></a><a name="onpaintclipboard"></a>Cwnd::在畫夾板上

當剪貼簿擁有者以`OnPaintClipboard`CF_OWNERDISPLAY格式在剪貼簿上放置數據且剪貼簿查看器的工作區需要重新繪製時,剪貼板擁有者的成員函數由剪貼簿查看器呼叫。

```
afx_msg void OnPaintClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hPaintStruct);
```

### <a name="parameters"></a>參數

*pClipAppwnd*<br/>
指定 [剪貼簿] 應用程式視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*hPaintStruct*<br/>
識別 [PAINTSTRUCT](/windows/win32/api/winuser/ns-winuser-paintstruct) 資料結構，其定義要繪製工作區的哪一部分。

### <a name="remarks"></a>備註

要確定整個工作區或其中的一部分是否需要重新繪製,剪貼簿擁有者必須將`rcpaint``PAINTSTRUCT`結構成員中給出的繪圖區域的尺寸與最近的[OnSizeClipboard](#onsizeclipboard)成員函數調用中給出的尺寸進行比較。

`OnPaintClipboard`應使用[GlobalLock](/windows/win32/api/winbase/nf-winbase-globallock) Windows 函`PAINTSTRUCT`數鎖定包含 資料結構的記憶體,並在該記憶體退出之前使用[全域解鎖](/windows/win32/api/winbase/nf-winbase-globalunlock)Windows 功能解鎖該記憶體。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpalettechanged"></a><a name="onpalettechanged"></a>Cwnd::打開調色板

在具有輸入焦點的視窗實現其邏輯調色板後,框架將此成員函數調用所有頂級窗口,從而更改系統調色板。

```
afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
```

### <a name="parameters"></a>參數

*pFocusWnd*<br/>
指定指向導致系統調色板更改的視窗的指標。 指標可能是臨時的,不應存儲。

### <a name="remarks"></a>備註

此調用允許沒有使用調色板的輸入焦點的視窗來實現其邏輯調色板並更新其工作區。

對於`OnPaletteChanged`所有頂級和重疊視窗(包括更改系統調色板並導致發送WM_PALETTECHANGED消息的視窗,將調用成員函數。 如果任何子視窗使用調色板,則必須將此消息傳遞給它。

為了避免無限迴圈,視窗不應實現其調色板,除非它確定*pFocusWnd*不包含指向自身的指標。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpaletteischanging"></a><a name="onpaletteischanging"></a>Cwnd::在Paletteis改變

該框架調用此成員函數,通知應用程式將實現其邏輯調色板。

```
afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
```

### <a name="parameters"></a>參數

*p實作*<br/>
指定即將實現其邏輯調色板的視窗。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonparentnotify"></a><a name="onparentnotify"></a>Cwnd::在家長通知

當創建或銷毀`OnParentNotify`父成員視窗時,或者當用戶單擊滑鼠按鈕時光標位於子視窗上時,框架將調用父成員函數。

```
afx_msg void OnParentNotify(
    UINT message,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定通知父級的事件以及子視窗的標識碼。 該事件是低階*消息*詞。 如果事件是WM_CREATE或WM_DESTROY,則高階*消息*詞是子視窗的標識符;如果事件是WM_DESTROY,則消息的顯示值是子窗口的標識符。否則,高階單詞未定義。 事件(低階*訊息*)可以是以下任一值:

- WM_CREATE正在創建子視窗。

- WM_DESTROY子視窗正在銷毀。

- WM_LBUTTONDOWN 用戶將滑鼠游標放在子視窗上並按下滑鼠左鍵。

- WM_MBUTTONDOWN 用戶將滑鼠游標放在子視窗上並按下滑鼠中間按鈕。

- WM_RBUTTONDOWN 用戶將滑鼠游標放在子視窗上並按下右滑鼠按鈕。

*lParam*<br/>
如果消息的事件(低階字)WM_CREATE或WM_DESTROY,*則 lParam*指定子視窗的視窗句柄;如果*消息*的事件(低階字)WM_CREATE或WM_DESTROY,則指定子視窗的視窗句柄。否則*lParam*包含游標的 x 和 y 座標。 x 座標位於低階單詞中,y 座標位於高階單詞中。

### <a name="remarks"></a>備註

創建子視窗時,系統將在創建視窗的`OnParentNotify`[「創建](#create)成員」函數返回之前調用。 銷毀子視窗時,系統在進行任何處理之前調用`OnParentNotify`以銷毀視窗。

`OnParentNotify`為子視窗的所有祖先視窗(包括頂層視窗)調用。

除具有[WS_EX_NOPARENTNOTIFY](../../mfc/reference/styles-used-by-mfc.md#extended-window-styles)樣子視窗外,所有子視窗都向其父視窗發送此消息。 預設情況下,對話方塊中的子視窗具有WS_EX_NOPARENTNOTIFY樣式,除非透過調用[CreateEx](#createex)成員函數在沒有此樣式的情況下創建子視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonpowerbroadcast"></a><a name="onpowerbroadcast"></a>Cwnd::在電力廣播

當發生電源管理事件時,框架將調用此成員函數。

```
afx_msg UINT OnPowerBroadcast(
    UINT nPowerEvent,
    UINT nEventData);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nPower事件*|[在]電源管理事件。|
|*n 事件資料*|[在]特定於事件的數據。|

### <a name="return-value"></a>傳回值

如果事件是請求,請返回 TRUE 以授予請求,或BROADCAST_QUERY_DENY拒絕請求。

### <a name="remarks"></a>備註

此方法接收[WM_POWERBROADCAST](/windows/win32/Power/wm-powerbroadcast)消息,這在 Windows SDK 中介紹。

*nPowerEvent*參數指定事件,如電池計量不足、電源狀態已更改、請求或拒絕掛起操作許可權、事件發生後操作自動恢復、系統正在暫停操作或掛起後正在恢復操作。 *nEventData*參數通常不使用。 有關詳細資訊,請參閱[WM_POWERBROADCAST](/windows/win32/Power/wm-powerbroadcast)消息的*wParam*和*lParam*參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonquerydragicon"></a><a name="onquerydragicon"></a>Cwnd::上查詢德拉吉肯

框架通過沒有為其類定義的圖示的最小化(標誌性)視窗調用此成員函數。

```
afx_msg HCURSOR OnQueryDragIcon();
```

### <a name="return-value"></a>傳回值

包含低階單詞中的游標或圖示句柄的雙字值。 游標或圖示必須與顯示驅動程式的解析度相容。 如果應用程式返回 NULL,系統將顯示預設游標。 預設返回值為 NULL。

### <a name="remarks"></a>備註

系統進行此調用以獲取在使用者拖動最小化視窗時顯示的游標。 如果應用程式返回圖示或游標的句柄,系統將轉換為黑白。 如果應用程式返回句柄,句柄必須標識與顯示驅動程式解析度相容的單色游標或圖示。 應用程式可以調用[CWinApp::LoadCursor 或](../../mfc/reference/cwinapp-class.md#loadcursor) [CWinApp:LoadIcon](../../mfc/reference/cwinapp-class.md#loadicon)成員函數,以從其可執行檔中的資源載入游標或圖示,並獲取此句柄。

## <a name="cwndonqueryendsession"></a><a name="onqueryendsession"></a>Cwnd::在查詢結束會話

當使用者選擇結束 Windows 作業階段或應用程式呼叫[ExitWindows Windows](/windows/win32/api/winuser/nf-winuser-exitwindows)函數時,架構將調用此成員函數。

```
afx_msg BOOL OnQueryEndSession();
```

### <a name="return-value"></a>傳回值

如果應用程式可以方便地關閉,則非零;否則 0。

### <a name="remarks"></a>備註

如果任何應用程式返回 0,則 Windows 會話不會結束。 一旦一`OnQueryEndSession`個應用程式返回 0,Windows 就會停止調用,並且為任何已返回非零的應用程式發送參數值為 FALSE[的WM_ENDSESSION](#onendsession)消息。

## <a name="cwndonquerynewpalette"></a><a name="onquerynewpalette"></a>Cwnd::打開查詢新調色板

當物件即將接收輸入焦點時,`CWnd`框架將調用此成員函數,`CWnd`從而有機會在接收焦點時實現其邏輯調色板。

```
afx_msg BOOL OnQueryNewPalette();
```

### <a name="return-value"></a>傳回值

如果實現其邏輯`CWnd`調色板,則非零;否則 0。

## <a name="cwndonqueryopen"></a><a name="onqueryopen"></a>Cwnd::打開查詢開啟

當`CWnd`物件最小化,並且使用者要求將 該成員還原到其預最小化的大小`CWnd`和位置 時,框架將調用此成員函數。

```
afx_msg BOOL OnQueryOpen();
```

### <a name="return-value"></a>傳回值

如果可以打開圖示,則為非零,或 0 以防止打開圖示。

### <a name="remarks"></a>備註

在`OnQueryOpen``CWnd`中 時不應執行任何會導致啟動或焦點更改的操作(例如,創建對話方塊)。

## <a name="cwndonqueryuistate"></a><a name="onqueryuistate"></a>Cwnd::在查詢

呼叫以擷取視窗的使用者介面 (UI) 狀態。

```
afx_msg UINT OnQueryUIState();
```

### <a name="return-value"></a>傳回值

如果焦點指示器和鍵盤快速鍵可見,則返回值為 NULL。 否則,返回值可以是以下一個或多個值:

- UISF_HIDEFOCUS焦點指示燈處於隱藏狀態。

- UISF_HIDEACCEL鍵盤加速器是隱藏的。

- UISF_ACTIVE Windows XP:控件應以用於活動控制件的樣式繪製。

### <a name="remarks"></a>備註

此成員函數類比[WM_QUERYUISTATE](/windows/win32/menurc/wm-queryuistate)消息的功能,如 Windows SDK 中所述。

## <a name="cwndonrawinput"></a><a name="onrawinput"></a>Cwnd::OnRawInput

當目前的視窗獲取原始輸入時,框架將呼叫此成員函數。

```
afx_msg void OnRawInput(
    UINT nInputCode,
    HRAWINPUT hRawInput);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nInput代碼*|[在]指示輸入是否發生在應用程式在前臺時發生的輸入代碼。 在這兩種情況下,應用程式都必須調用[CWnd::DefWindowProc,](#defwindowproc)以便系統可以執行清理。<br /><br /> 這裡可以是以下值之一:<br /><br /> - RIM_INPUT - 在應用程式在前臺時發生輸入。<br />- RIM_INPUTSINK - 當應用程式不在前台時發生輸入。|
|*hRawInput*|[在]處理包含設備原始輸入的[RAWINPUT](/windows/win32/api/winuser/ns-winuser-rawinput)結構。|

### <a name="remarks"></a>備註

此方法接收[WM_INPUT](/windows/win32/inputdev/wm-appcommand)通知,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonrbuttondblclk"></a><a name="onrbuttondblclk"></a>克隆::OnRButtonDblClk

當用戶雙擊滑鼠右鍵時,框架將調用此成員函數。

```
afx_msg void OnRButtonDblClk(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,則"設置"。

- MK_MBUTTON 如果滑鼠中鍵已關閉,請設置。

- MK_RBUTTON 如果滑鼠右鍵已關閉,則"設置"。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

只有具有 CS_DBLCLKS [WNDCLASS](/windows/win32/api/winuser/ns-winuser-wndclassw)樣`OnRButtonDblClk`式的視窗才能 接收呼叫。 這是Microsoft基礎類庫中視窗的預設值。 當使用者按下`OnRButtonDblClk`、釋放時,Windows 會調用,然後在系統的按兩鍵限制內再次按下滑鼠右鍵。 按兩下滑鼠右鍵實際上會生成四個事件[:WM_RBUTTONDOWN](#onrbuttondown)和`OnRButtonDblClk`[WM_RBUTTONUP](#onrbuttonup)消息、 呼叫,以及釋放該按鈕時的另一個WM_RBUTTONUP消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonrbuttondown"></a><a name="onrbuttondown"></a>Cwnd::OnRButtonDown

當使用者按下滑鼠右鍵時,框架將調用此成員函數。

```
afx_msg void OnRButtonDown(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,則"設置"。

- MK_MBUTTON 如果滑鼠中鍵已關閉,請設置。

- MK_RBUTTON 如果滑鼠右鍵已關閉,則"設置"。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonrbuttonup"></a><a name="onrbuttonup"></a>Cwnd::OnRButtonUp

當使用者釋放滑鼠右鍵時,框架將調用此成員函數。

```
afx_msg void OnRButtonUp(
    UINT nFlags,
    CPoint point);
```

### <a name="parameters"></a>參數

*nFlags*<br/>
指示各種虛擬金鑰是否關閉。 這裡可以是以下值的任意群組:

- MK_CONTROL 如果 CTRL 金鑰已關閉,則設置。

- MK_LBUTTON 如果滑鼠左鍵已關閉,則"設置"。

- MK_MBUTTON 如果滑鼠中鍵已關閉,請設置。

- MK_SHIFT 如果 SHIFT 鍵已關閉,則設置。

*點*<br/>
指定游標的 x 和 y 座標。 這些座標始終相對於視窗的左上角。

### <a name="remarks"></a>備註

架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonregisteredmousewheel"></a><a name="onregisteredmousewheel"></a>Cwnd::註冊滑鼠輪

當使用者旋轉滑鼠滾輪並遇到車輪的下一個切口時,框架將調用此成員函數。

```
afx_msg LRESULT OnRegisteredMouseWheel(
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*wParam*<br/>
指標的水準位置。

*lParam*<br/>
指標的垂直位置。

### <a name="return-value"></a>傳回值

此時微不足道。 一定是零。

### <a name="remarks"></a>備註

除非重寫,否則`OnRegisteredMouseWheel`將消息路由到相應的視窗(具有焦點的父視窗),並調用該視窗[的WM_MOUSEWHEEL](/windows/win32/inputdev/wm-mousewheel)處理程式。

重寫此成員函數以提供您自己的消息路由或更改滑鼠滾輪滾動行為。

> [!NOTE]
> `OnRegisteredMouseWheel`處理 Windows 95/98 和 Windows NT 3.51 的消息。 對於 Windows NT 4.0 訊息處理,請使用[滑鼠滾輪](#onmousewheel)。

## <a name="cwndonrenderallformats"></a><a name="onrenderallformats"></a>Cwnd::在渲染所有格式

當擁有者應用程式被銷毀時`OnRenderAllFormats`,框架將調用剪貼簿所有者的成員函數。

```
afx_msg void OnRenderAllFormats();
```

### <a name="remarks"></a>備註

剪貼簿擁有者應以它能夠生成所有格式的數據呈現數據,並通過調用[SetClipboard 資料](/windows/win32/api/winuser/nf-winuser-setclipboarddata)Windows 函數將每種格式的數據句柄傳遞給剪貼簿。 這可確保剪貼簿包含有效數據,即使呈現數據的應用程式已銷毀。 應用程式在調用[SetClipboard 數據](/windows/win32/api/winuser/nf-winuser-setclipboarddata)Windows 功能之前應呼叫[OpenClipboard](#openclipboard)成員函數,並在之後調用[CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard) Windows 功能。

## <a name="cwndonrenderformat"></a><a name="onrenderformat"></a>Cwnd::在渲染格式上

當需要渲染具有延遲`OnRenderFormat`呈現的特定格式時,框架將調用剪貼簿所有者的成員函數。

```
afx_msg void OnRenderFormat(UINT nFormat);
```

### <a name="parameters"></a>參數

*nFormat*<br/>
指定剪貼簿格式。

### <a name="remarks"></a>備註

接收方應以該格式呈現數據,並通過調用[SetClipboard 數據](/windows/win32/api/winuser/nf-winuser-setclipboarddata)Windows 功能將其傳遞給剪貼簿。

不要從 呼`OpenClipboard`叫成員函數`CloseClipboard`或 Windows`OnRenderFormat`函數 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsessionchange"></a><a name="onsessionchange"></a>Cwnd::會話更改

框架調用此成員函數以通知應用程式會話狀態的更改。

```
afx_msg void OnSessionChange(
    UINT nSessionState,
    UINT nId);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*n 工作階段狀態*|[在]狀態代碼描述會話狀態更改。|
|*nId*|[在]會話標識碼。|

### <a name="remarks"></a>備註

此方法接收[WM_WTSSESSION_CHANGE](/windows/win32/TermServ/wm-wtssession-change)通知,這在 Windows SDK 中介紹。

*nSessionState*參數指定工作階段已連接或斷開與主控台或遠端終端的連接、使用者登錄或關閉、會話鎖定或解鎖或會話已更改為遠端控制狀態。 有關詳細資訊,請參閱[WM_WTSSESSION_CHANGE](/windows/win32/TermServ/wm-wtssession-change)消息的*wParam*參數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsetcursor"></a><a name="onsetcursor"></a>Cwnd::打開游標

如果未捕獲滑鼠輸入,並且滑鼠導致`CWnd`物件內的游標移動,則框架將調用此成員函數。

```
afx_msg BOOL OnSetCursor(
    CWnd* pWnd,
    UINT nHitTest,
    UINT message);
```

### <a name="parameters"></a>參數

*pwnd*<br/>
指定指向包含游標的視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nHitTest*<br/>
指定[測試](#onnchittest)區域代碼。 命中測試確定游標的位置。

*message*<br/>
指定滑鼠訊息編號。

### <a name="return-value"></a>傳回值

非零停止進一步處理,或 0 繼續。

### <a name="remarks"></a>備註

默認實現在處理`OnSetCursor`之前調用父視窗。 如果父視窗返回 TRUE,則停止進一步處理。 呼叫父視窗可使父視窗控制子視窗中的游標設定。

如果游標不在工作區中,則默認實現將游標設為箭頭,如果游標不在工作區,則將其設為已註冊類游標(如果為)。

如果*nHitTest*是 HTERROR,*並且消息*是`MessageBeep`滑鼠按鈕消息, 則調用成員函數。

進入選單模式時`CWnd`*,消息*參數為 0。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsetfocus"></a><a name="onsetfocus"></a>Cwnd::打開焦點

獲得輸入焦點后,框架將調用此成員函數。

```
afx_msg void OnSetFocus(CWnd* pOldWnd);
```

### <a name="parameters"></a>參數

*普奧德恩德*<br/>
包含遺失`CWnd`輸入焦點的物件(可能是 NULL)。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

要顯示 care,`CWnd`此時應呼叫相應的加貼函數。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsettingchange"></a><a name="onsettingchange"></a>Cwnd::開啟設定變更

當 Win32 系統參數資訊函數更改系統範圍設定時,該框架將`OnSettingChange`調用 所有頂級視窗。

```
afx_msg void OnSettingChange(
    UINT uFlags,
    LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*uFlags*<br/>
當系統通過`SystemParametersInfo`調用發送消息時,此參數是指示已更改的系統參數的標誌。 有關值清單,請參閱 Windows SDK 中的[系統參數資訊](/windows/win32/api/winuser/nf-winuser-systemparametersinfow)。 當應用程式發送消息時,此參數必須為 0。

*lpsz節*<br/>
指定已變更的節的名稱的字串。 (字串不包括包含節名稱的方括弧。

### <a name="remarks"></a>備註

應用程式應在更改系統參數時將消息發送到所有頂級視窗,如果用戶通過"控制面板"更改設置,Windows將發送消息。

ON_WM_SETTINGCHANGE消息類似於ON_WM_WININICHANGE消息,有以下區別:

- 在運行 Windows NT 4.0 或更新時或在 Windows 95/98 下使用ON_WM_SETTINGCHANGE。

- 運行 Windows NT 3.51 或更舊時使用ON_WININICHANGE。 此消息現已過時。

消息映射中應只有其中一個宏。 要編寫適用於 Windows 95/98 和 Windows NT 4.0 的程式,請為ON_WM_SETTINGCHANGE編寫處理程式。 在 Windows NT 3.51`OnSettingChange`下,處理程式 將被和*uFlags*調用,並且始終為零。

## <a name="cwndonshowwindow"></a><a name="onshowwindow"></a>Cwnd::在顯示視窗

當物件即將被隱藏或顯示時`CWnd`,框架將調用此成員函數。

```
afx_msg void OnShowWindow(
    BOOL bShow,
    UINT nStatus);
```

### <a name="parameters"></a>參數

*b 顯示*<br/>
指定是否顯示視窗。 如果顯示視窗,則為 TRUE;如果顯示視窗,則為 TRUE。如果視窗被隱藏,則為 FALSE。

*N 狀態*<br/>
指定顯示的視窗的狀態。 如果消息是因`ShowWindow`成員函數調用而發送的,則為 0;如果消息是因成員函數調用而發送的,則為 0。否則*nStatus*是以下原因之一:

- SW_PARENTCLOSING父視窗正在關閉(成為標誌性視窗)或彈出視窗被隱藏。

- SW_PARENTOPENING父視窗正在打開(正在顯示)或顯示彈出視窗。

### <a name="remarks"></a>備註

當調用`ShowWindow`成員函數時,當重疊視窗最大化或還原時,或者當重疊或彈出視窗關閉(成為標誌性視窗)或打開(顯示在螢幕上)時,視窗將隱藏或顯示。 關閉重疊視窗時,將隱藏與該視窗關聯的所有彈出視窗。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsize"></a><a name="onsize"></a>Cwnd::打開尺寸

視窗大小更改後,框架將調用此成員函數。

```
afx_msg void OnSize(
    UINT nType,
    int cx,
    int cy);
```

### <a name="parameters"></a>參數

*nType*<br/>
指定大小調整請求的類型。 這裡可以是以下值之一:

- SIZE_MAXIMIZED視窗已最大化。

- SIZE_MINIMIZED視窗已最小化。

- SIZE_RESTORED視窗已調整大小,但SIZE_MINIMIZED和SIZE_MAXIMIZED均不適用。

- SIZE_MAXHIDE消息在最大化其他視窗時發送到所有彈出視窗。

- SIZE_MAXSHOW消息將發送到所有彈出視窗時,一些其他視窗已恢復到其以前的大小。

*殘雪*<br/>
指定工作區的新寬度。

*cy*<br/>
指定工作區的新高度。

### <a name="remarks"></a>備註

如果為`OnSize`的子視窗呼叫[SetScrollPos](#setscrollpos)或[MoveWindow](#movewindow)`bRedraw`成員函數 ,`SetScrollPos`則`MoveWindow`中的參數應為 或`CWnd`應為非零,以便重新繪製 。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#109](../../mfc/reference/codesnippet/cpp/cwnd-class_50.cpp)]

## <a name="cwndonsizeclipboard"></a><a name="onsizeclipboard"></a>Cwnd::在尺寸上夾板

當剪貼簿包含具有`OnSizeClipboard``CF_OWNERDISPLAY`屬性的數據且剪貼簿檢視器視窗的工作區大小已更改時,剪貼簿所有者的成員函數由剪貼簿查看器調用。

```
afx_msg void OnSizeClipboard(
    CWnd* pClipAppWnd,
    HGLOBAL hRect);
```

### <a name="parameters"></a>參數

*pClipAppwnd*<br/>
標識剪貼簿應用程式視窗。 指標可能是臨時的,不應存儲。

*hRect*<br/>
標識全域記憶體物件。 記憶體物件包含 RECT 資料結構,該結構指定剪貼簿擁有者要繪製的區域。

### <a name="remarks"></a>備註

當`OnSizeClipboard`剪貼板應用程式即將被銷毀或最小化時,成員函數使用空矩形 (0,0,0,0) 作為新大小調用。 這允許剪貼簿擁有者釋放其顯示資源。

在`OnSizeClipboard`中,應用程式必須使用[GlobalLock](/windows/win32/api/winbase/nf-winbase-globallock) Windows 函數來鎖定包含 RECT 數據結構的記憶體。 讓應用程式在生成或返回控制項之前,使用[全域解鎖](/windows/win32/api/winbase/nf-winbase-globalunlock)Windows 功能解鎖該記憶體。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsizing"></a><a name="onsizing"></a>Cwnd::打開

框架調用此成員函數以指示用戶調整矩形大小。

```
afx_msg void OnSizing(
    UINT nSide,
    LPRECT lpRect);
```

### <a name="parameters"></a>參數

*n側*<br/>
要移動的視窗的邊緣。

*lpRect*<br/>
包含項座標的[CRect](../../atl-mfc-shared/reference/crect-class.md)或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)的位址。

### <a name="remarks"></a>備註

通過處理此消息,應用程式可以監視拖動矩形的大小和位置,並在必要時更改其大小或位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#110](../../mfc/reference/codesnippet/cpp/cwnd-class_51.cpp)]

## <a name="cwndonspoolerstatus"></a><a name="onspoolerstatus"></a>Cwnd::開啟器狀態

每當作業添加到列印管理器佇列或從列印管理器佇列中刪除時,框架都會從列印管理器調用此成員函數。

```
afx_msg void OnSpoolerStatus(
    UINT nStatus,
    UINT nJobs);
```

### <a name="parameters"></a>參數

*N 狀態*<br/>
指定SP_JOBSTATUS標誌。

*n工作*<br/>
指定列印管理員佇列中剩餘的作業數。

### <a name="remarks"></a>備註

此呼叫僅供參考。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonstylechanged"></a><a name="onstylechanged"></a>Cwnd::打開樣式

[在 SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw)函數更改了一個或多個視窗的樣式後,框架將調用此成員函數。

```
afx_msg void OnStyleChanged(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*n 樣式型別*<br/>
指定視窗的延伸樣式或非擴展樣式是否已更改。 這裡可以是以下值的組合:

- GWL_EXSTYLE 視窗的擴展樣式已更改。

- GWL_STYLE 視窗的非擴展樣式已更改。

*lpStylestruct*<br/>
指向包含視窗新樣式的[STYLESTRUCT](/windows/win32/api/winuser/ns-winuser-stylestruct)結構。 應用程式可以檢查樣式,但不能更改它們。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonstylechanging"></a><a name="onstylechanging"></a>Cwnd::打開樣式

當[SetWindowLong](/windows/win32/api/winuser/nf-winuser-setwindowlongw)函數即將更改視窗的一個或多個樣式時,框架將調用此成員函數。

```
afx_msg void OnStyleChanging(
    int nStyleType,
    LPSTYLESTRUCT lpStyleStruct);
```

### <a name="parameters"></a>參數

*n 樣式型別*<br/>
指定視窗的延伸樣式或非擴展樣式是否已更改。 這裡可以是以下值的組合:

- GWL_EXSTYLE 視窗的擴展樣式已更改。

- GWL_STYLE 視窗的非擴展樣式已更改。

*lpStylestruct*<br/>
指向包含視窗新樣式的[STYLESTRUCT](/windows/win32/api/winuser/ns-winuser-stylestruct)結構。 應用程式可以檢查樣式並更改它們。

### <a name="remarks"></a>備註

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyschar"></a><a name="onsyschar"></a>Cwnd::OnSysChar

如果`CWnd`具有輸入焦點並翻譯[WM_SYSKEYUP](#onsyskeyup)和[WM_SYSKEYDOWN](#onsyskeydown)消息,則框架將調用此成員函數。

```
afx_msg void OnSysChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定控制選單鍵的 ASCII 字元金鑰代碼。

*恩雷普森特*<br/>
指定重複計數(由於使用者按住鍵而重複擊鍵的次數)。

*nFlags*<br/>
*nFlags*參數可以具有以下值:

|值|意義|
|-----------|-------------|
|0-15|指定重複計數。 該值是使用者按住鍵而重複擊鍵的次數。|
|16-23|指定掃描代碼。 該值取決於原始裝置製造商 (OEM)|
|24|指定該鍵是否是擴展鍵,例如顯示在增強型 101 鍵或 102 鍵鍵盤上的右側 ALT 和 CTRL 鍵。 如果值是擴展鍵,則值為 1;如果該值是擴展鍵,則該值為 1。否則,它是 0。|
|25-28|Windows 在內部使用。|
|29|指定上下文代碼。 按鍵按住 ALT 鍵,則該值為 1;否則,該值為 0。|
|30|指定以前的鍵狀態。 如果鍵在發送消息之前向下,則值為 1;如果鍵向上,則值為 0。|
|31|指定轉換狀態。 如果釋放鍵,則值為 1;如果按下該鍵,則該值為 0。|

### <a name="remarks"></a>備註

它指定控制功能表鍵的虛擬金鑰代碼。 (有關標準虛擬金鑰代碼的清單,請參閱 Winuser.h)

當上下文代碼為 0 時,WM_SYSCHAR可以將[WM_SYSCHAR](/windows/win32/menurc/wm-syschar)訊息傳遞給[TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函數,該函數將像處理正常鍵消息而不是系統字元鍵一樣處理該函數。 這允許將快速鍵與活動視窗一起使用,即使活動視窗沒有輸入焦點也是如此。

對於 IBM 增強型 101 鍵和 102 鍵鍵盤,增強鍵是鍵盤主部分的正確 ALT 和正確的 CTRL 鍵;數位鍵盤左側的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭頭鍵;和數位鍵盤中的斜杠 (/) 和 ENTER 鍵。 其他一些鍵盤可能支援*nFlags*中的擴展鍵位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyscolorchange"></a><a name="onsyscolorchange"></a>Cwnd::OnSys顏色變化

當系統顏色設置發生更改時,框架會為所有頂級視窗調用此成員函數。

```
afx_msg void OnSysColorChange();
```

### <a name="remarks"></a>備註

Windows`OnSysColorChange`調用受系統顏色更改影響的任何視窗。

具有使用現有系統顏色的畫筆的應用程式應刪除這些畫筆,並使用新的系統顏色重新創建它們。

## <a name="cwndonsyscommand"></a><a name="onsyscommand"></a>Cwnd::OnSys命令

當使用者從「控制」功能表中選擇命令或用戶選擇「最大化」或「最小化」按鈕時,框架將調用此成員函數。

```
afx_msg void OnSysCommand(
    UINT nID,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定請求的系統命令的類型。 這裡可以是以下任一值:

- SC_CLOSE關閉`CWnd`物件。

- SC_HOTKEY啟動與`CWnd`應用程式指定的熱鍵關聯的物件。 *lParam*的低階字標識要啟動的視窗的 HWND。

- SC_HSCROLL水準滾動。

- SC_KEYMENU通過擊鍵檢索功能表。

- SC_MAXIMIZE(或SC_ZOOM)最大化`CWnd`物件。

- SC_MINIMIZE(或SC_ICON)最小化`CWnd`物件。

- SC_MOUSEMENU通過滑鼠按一下檢索功能表。

- SC_MOVE移動`CWnd`物件。

- SC_NEXTWINDOW移動到下一個視窗。

- SC_PREVWINDOW移動到上一個視窗。

- SC_RESTORE 將視窗還原到正常位置和大小。

- SC_SCREENSAVE執行 SYSTEM [啟動] 部分中指定的螢幕保護程式應用程式。INI 檔。

- SC_SIZE大小`CWnd`物件。

- SC_TASKLIST 執行或啟動 Windows 任務管理員應用程式。

- SC_VSCROLL垂直滾動。

*lParam*<br/>
如果使用滑鼠選擇了"控制功能表"命令,則*lParam*包含游標座標。 低階單詞包含 x 座標,高階單詞包含 y 座標。 否則,不使用此參數。

- SC_HOTKEY啟動與應用程式指定的熱鍵關聯的視窗。 *lParam*的低階字標識要啟動的視窗。

- SC_SCREENSAVE執行「控制面板桌面」部分中指定的螢幕保存應用程式。

### <a name="remarks"></a>備註

預設情況下,`OnSysCommand`對上表中指定的預定義操作執行控制功能表請求。

在WM_SYSCOMMAND消息中,Windows 在內部使用*nID*參數的四個低階位。 當應用程式測試*nID*的值時,它必須使用位-AND 運算元將值 0xFFF0 與*nID*值合併,以獲得正確的結果。

可以使用`GetSystemMenu`、、`AppendMenu``InsertMenu`成員`ModifyMenu`函數修改「控制件」功能表項。 變更「控制」選單的應用程式必須處理WM_SYSCOMMAND訊息,並且應用程式未處理的任何WM_SYSCOMMAND訊息都必須傳遞給`OnSysCommand`。 應用程式新增的任何指令值必須由應用程式處理,不能傳遞給`OnSysCommand`。

應用程式可以通過將WM_SYSCOMMAND消息傳遞`OnSysCommand`到 ,隨時執行任何系統命令。

定義為從「控制」功能表中選擇項的加速器(快捷方式)擊鍵將轉換為`OnSysCommand`調用;所有其他加速器擊鍵將轉換為[WM_COMMAND](#oncommand)消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsysdeadchar"></a><a name="onsysdeadchar"></a>Cwnd::OnsysDeadchar

如果調用[OnSysKeyUp 或 OnSysKeyDown](#onsyskeyup)成員函[OnSysKeyDown](#onsyskeydown)數時物件`CWnd`具有輸入焦點, 則框架將調用此成員函數。

```
afx_msg void OnSysDeadChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定死鍵字元值。

*恩雷普森特*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描代碼、金鑰轉換代碼、以前的金鑰狀態和上下文代碼,如以下清單所示:

|值|意義|
|-----------|-------------|
|0-7|掃描代碼(與 OEM 相關的值)。 高階字的低位元組。|
|8|擴展鍵,如功能鍵或數位鍵盤上的鍵(1,如果它是擴展鍵;否則為 0)。|
|9-10|未使用。|
|11-12|Windows 在內部使用。|
|13|上下文代碼(如果按下鍵時按住 ALT 鍵,則為 1;否則為 0)。|
|14|上一個鍵狀態(如果鍵在調用之前關閉,則為 0,如果鍵已打開,則為 0)。|
|15|轉換狀態(如果釋放鍵,為 1,則為 0,如果按下鍵,則為 0)。|

### <a name="remarks"></a>備註

它指定死金鑰的字元值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyskeydown"></a><a name="onsyskeydown"></a>Cwnd::OnsysKeyDown

如果`CWnd`物件具有輸入焦點,則當使用者按`OnSysKeyDown`下 ALT 鍵然後按下另一個鍵時,框架將調用成員函數。

```
afx_msg void OnSysKeyDown(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定要按下的金鑰的虛擬金鑰代碼。 有關標準虛擬金鑰代碼的清單,請參閱 Winuser.h

*恩雷普森特*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描代碼、金鑰轉換代碼、以前的金鑰狀態和上下文代碼,如以下清單所示:

|值|意義|
|-----------|-------------|
|0-7|掃描代碼(與 OEM 相關的值)。 高階字的低位元組。|
|8|擴展鍵,如功能鍵或數位鍵盤上的鍵(1,如果它是擴展鍵;否則為 0)。|
|9-10|未使用。|
|11-12|Windows 在內部使用。|
|13|上下文代碼(如果按下鍵時按住 ALT 鍵,則為 1,否則為 0)。|
|14|以前的鍵狀態(如果密鑰在發送消息之前已關閉,則為 0,如果鍵已打開,則為 0)。|
|15|轉換狀態(如果釋放鍵,為 1,則為 0,如果按下鍵,則為 0)。|

對於`OnSysKeyDown`呼叫,鍵轉換位(位 15)為 0。 如果按鍵時 ALT 鍵關閉,則上下文代碼位(位 13)為 1;如果消息發送到活動視窗,則為 0,因為沒有視窗具有輸入焦點。

### <a name="remarks"></a>備註

如果當前沒有視窗具有輸入焦點,則調用活動視窗的成員`OnSysKeyDown`函數。 接收`CWnd`消息的物件可以通過`nFlags`在 中 檢查上下文代碼來區分這兩個上下文。

當上下文代碼為 0 時`OnSysKeyDown`,接收 WM_SYSKEYDOWN消息可以傳遞到[TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函數,該函數將像處理正常金鑰消息而不是系統鍵消息一樣處理它。 這允許將快速鍵與活動視窗一起使用,即使活動視窗沒有輸入焦點也是如此。

由於自動重複,在收到[WM_SYSKEYUP](#onsyskeyup)消息之前`OnSysKeyDown`,可能會發生多個調用。 以前的鍵狀態(位14)可用於確定`OnSysKeyDown`調用是指示第一個向下轉換還是重複向下轉換。

對於 IBM 增強型 101 鍵和 102 鍵鍵盤,增強鍵是鍵盤主部分的正確 ALT 和正確的 CTRL 鍵;數位鍵盤左側的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭頭鍵;和數位鍵盤中的斜杠 (/) 和 ENTER 鍵。 其他一些鍵盤可能支援*nFlags*中的擴展鍵位。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonsyskeyup"></a><a name="onsyskeyup"></a>Cwnd::onsysKeyup

如果`CWnd`物件具有焦點,則當使用者`OnSysKeyUp`釋放 在 ALT 鍵按住時按下的鍵時,框架將調用成員函數。

```
afx_msg void OnSysKeyUp(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*n查爾*<br/>
指定要按下的金鑰的虛擬金鑰代碼。 有關標準虛擬金鑰代碼的清單,請參閱 Winuser.h

*恩雷普森特*<br/>
指定重複計數。

*nFlags*<br/>
指定掃描代碼、金鑰轉換代碼、以前的金鑰狀態和上下文代碼,如以下清單所示:

|值|意義|
|-----------|-------------|
|0-7|掃描代碼(與 OEM 相關的值)。 高階字的低位元組。|
|8|擴展鍵,如功能鍵或數位鍵盤上的鍵(1,如果它是擴展鍵;否則為 0)。|
|9-10|未使用。|
|11-12|Windows 在內部使用。|
|13|上下文代碼(如果按下鍵時按住 ALT 鍵,則為 1,否則為 0)。|
|14|以前的鍵狀態(如果密鑰在發送消息之前已關閉,則為 0,如果鍵已打開,則為 0)。|
|15|轉換狀態(如果釋放鍵,為 1,則為 0,如果按下鍵,則為 0)。|

對於`OnSysKeyUp`呼叫,金鑰轉換位(位元 15)為 1。 如果按鍵時 ALT 鍵關閉,則上下文代碼位(位 13)為 1;如果消息發送到活動視窗,則為 0,因為沒有視窗具有輸入焦點。

### <a name="remarks"></a>備註

如果當前沒有視窗具有輸入焦點,則調用活動視窗的成員`OnSysKeyUp`函數。 接收`CWnd`調用的物件可以通過在*nFlags*中檢查上下文代碼來區分這兩個上下文。

當上下文代碼為 0 時,`OnSysKeyUp`接收WM_SYSKEYUP 訊息可以傳遞到[TranslateAccelerator](/windows/win32/api/winuser/nf-winuser-translateacceleratorw) Windows 函數,該函數將像處理正常金鑰消息而不是系統鍵消息一樣處理它。 這允許將快速鍵(快捷方式)鍵與活動視窗一起使用,即使活動視窗沒有輸入焦點也是如此。

對於 IBM 增強型 101 鍵和 102 鍵鍵盤,增強鍵是鍵盤主部分的正確 ALT 和正確的 CTRL 鍵;數位鍵盤左側的群集中的 INS、DEL、HOME、END、PAGE UP、PAGE DOWN 和箭頭鍵;和數位鍵盤中的斜杠 (/) 和 ENTER 鍵。 其他一些鍵盤可能支援*nFlags*中的擴展鍵位。

對於非美國增強型 102 鍵鍵盤,正確的 ALT 鍵作為 CTRL_ALT 鍵組合處理。 下面顯示了使用者按下並釋放此密鑰時導致的消息和調用的順序:

|順序|函數已造訪|已傳遞訊息|
|--------------|-----------------------|--------------------|
|1.|[WM_KEYDOWN](#onkeydown)|VK_CONTROL|
|2.|[WM_KEYDOWN](#onkeydown)|VK_MENU|
|3.|[WM_KEYUP](#onkeyup)|VK_CONTROL|
|4.|[WM_SYSKEYUP](/windows/win32/inputdev/wm-syskeyup)|VK_MENU|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndontcard"></a><a name="ontcard"></a>Cwnd::開T卡

當用戶單擊可創作按鈕時,框架將調用此成員函數。

```
afx_msg void OnTCard(
    UINT idAction,
    DWORD dwActionData);
```

### <a name="parameters"></a>參數

*idAction*<br/>
指示使用者已執行的操作。 這裡可以是以下值之一:

- IDABORT 用戶按一下可創作中止按鈕。

- IDCANCEL 用戶按一下可創作的「取消」按鈕。

- IDCLOSE 使用者關閉培訓卡。

- IDHELP 用戶按下可創作的 Windows 説明按鈕。

- IDIGNORE 用戶單擊了可創作的"忽略"按鈕。

- IDOK 使用者按下可創作的"確定"按鈕。

- IDNO 用戶按下可創作的「無」按鈕。

- 用戶按下可創作的重試按鈕。

- HELP_TCARD_DATA用戶按下可創作按鈕。 *dwActionData*參數包含説明作者指定的長整數。

- HELP_TCARD_NEXT用戶按下可創作的下一步按鈕。

- HELP_TCARD_OTHER_CALLER 另一個應用程式已申請培訓卡。

- IDYES 用戶按下可創作"是"按鈕。

*dwActionData*<br/>
如果*idAction*指定HELP_TCARD_DATA,則此參數是説明作者指定的長整數。 否則,此參數為零。

### <a name="remarks"></a>備註

僅當應用程式使用 Windows 幫助啟動培訓卡時,才會調用此功能。 應用程式通過在對[WinHelp](../../mfc/reference/cwinapp-class.md#winhelp)函數的調用中指定HELP_TCARD命令來啟動培訓卡。

## <a name="cwndontimechange"></a><a name="ontimechange"></a>Cwnd::準時更改

更改系統時間後,框架將調用此成員函數。

```
afx_msg void OnTimeChange();
```

### <a name="remarks"></a>備註

讓任何更改系統時間的應用程式將此消息發送到所有頂級視窗。 要將WM_TIMECHANGE訊息發送到所有頂級視窗,應用程式可以使用[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函數,其*hwnd*參數設置為HWND_BROADCAST。

## <a name="cwndontimer"></a><a name="ontimer"></a>Cwnd::開啟計時器

框架在[SetTimer](#settimer)成員函數中指定的每個時間間隔後調用此成員函數,用於安裝計時器。

```
afx_msg void OnTimer(UINT_PTR nIDEvent);
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定計時器的識別碼。

### <a name="remarks"></a>備註

當應用程式的消息佇列中沒有其他消息時[,DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) Windows 函數將發送[WM_TIMER](/windows/win32/winmsg/wm-timer)消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

### <a name="example"></a>範例

  請參閱[CWnd::SetTimer](#settimer)中的範例。

## <a name="cwndontoolhittest"></a><a name="ontoolhittest"></a>Cwnd::在工具命中測試

框架調用此成員函數以確定點是否位於指定工具的邊界矩形中。

```
virtual INT_PTR OnToolHitTest(
    CPoint point,
    TOOLINFO* pTI) const;
```

### <a name="parameters"></a>參數

*點*<br/>
指定游標的 x 座標和 y 座標。 這些座標始終相對於視窗的左上角

*Pti*<br/>
指向[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)結構的指標。 預設設定以下結構值:

- *hwnd* = `m_hWnd`手柄到視窗

- *uId* = `(UINT)hWndChild`片語把子視窗

- *uFlags* &#124;= TTF_IDISHWND工具的手柄

- *lpszText* = LPSTR_TEXTCALLBACK指標指向要顯示在指定視窗中的字串

### <a name="return-value"></a>傳回值

如果找到工具提示控制項,則視窗控制 ID。 如果未找到工具提示控件,則 -1。

### <a name="remarks"></a>備註

如果點位於矩形中,則會檢索有關該工具的資訊。

如果工具提示關聯的區域不是按鈕,則`OnToolHitTest`將結構標誌設置為TTF_NOTBUTTON並TTF_CENTERTIP。

覆蓋`OnToolHitTest`以提供與預設提供的資訊不同的資訊。

有關結構的詳細資訊,請參閱 Windows SDK 中的[TOOLINFO](/windows/win32/api/commctrl/ns-commctrl-tttoolinfoa)。

## <a name="cwndontouchinput"></a><a name="ontouchinput"></a>Cwnd::OnTouch輸入

處理來自 Windows 觸控的單一輸入。

```
virtual BOOL OnTouchInput(
    CPoint pt,
    int nInputNumber,
    int nInputsCount,
    PTOUCHINPUT pInput);
```

### <a name="parameters"></a>參數

*pt*<br/>
觸控螢幕的點(在用戶端座標中)。

*nInput 編號*<br/>
觸摸輸入數。

*n 輸入計數*<br/>
觸摸輸入總數。

*pInput*<br/>
指向觸摸輸入結構的指標。

### <a name="return-value"></a>傳回值

如果應用程式處理 Windows 觸摸輸入,則為 TRUE;如果應用程式處理 Windows 觸摸輸入,則為 TRUE。否則 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndontouchinputs"></a><a name="ontouchinputs"></a>Cwnd::OnTouch輸入

處理來自 Windows 觸摸的輸入。

```
virtual BOOL OnTouchInputs(
    UINT nInputsCount,
    PTOUCHINPUT pInputs);
```

### <a name="parameters"></a>參數

*n 輸入計數*<br/>
Windows 觸摸輸入的總數。

*p輸入*<br/>
觸控圖的陣列。

### <a name="return-value"></a>傳回值

如果應用程式處理 Windows 觸摸輸入,則為 TRUE;否則 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndonunichar"></a><a name="onunichar"></a>Cwnd::OnUniChar

按鍵時,框架將調用此成員函數。 也就是說,當前視窗具有鍵盤焦點,並且[翻譯Message](/windows/win32/api/winuser/nf-winuser-translatemessage)函數將[WM_KEYDOWN](/windows/win32/inputdev/wm-keydown)消息翻譯。

```
afx_msg void OnUniChar(
    UINT nChar,
    UINT nRepCnt,
    UINT nFlags);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*n查爾*|[在]指定按鍵的字元代碼。|
|*恩雷普森特*|[在]指定目前訊息的重複計數。 該值是使用者按住鍵后自動重複擊鍵的次數。 如果擊鍵保持足夠長的時間,則發送多條消息。 但是,重複計數不是累積的。|
|*nFlags*|[在]指定掃描代碼、延伸金鑰、上下文代碼、以前鍵狀態和轉換狀態的標誌,如下表所示:<br /><br /> **0-7:** 指定掃描代碼。 該值取決於原始設備製造商 (OEM)。<br /><br /> **8:** 指定延伸鍵,例如顯示在增強的 101 或 102 鍵鍵盤上的右側 ALT 和 CTRL 鍵。 如果鍵是擴展鍵,則標誌為 1;如果鍵是擴展鍵,則標誌為 1。否則,它是 0。<br /><br /> **9-12:** Windows 在內部使用。<br /><br /> **13:** 指定上下文代碼。 如果按下 ALT 鍵時按住 ALT 鍵,則標誌為 1;如果按下該鍵時,則標誌為 1。否則,該值為 0。<br /><br /> **14:** 指定以前的鍵狀態。 如果鍵在發送消息之前向下,則標誌為 1;如果鍵已打開,則為 0。<br /><br /> **15:** 指定轉換狀態。 如果釋放鍵,則標誌為 1;如果按鍵,則為 0。|

### <a name="remarks"></a>備註

此方法接收[WM_UNICHAR](/windows/win32/inputdev/wm-unichar)通知,這在Windows SDK中介紹。 [WM_UNICHAR](/windows/win32/inputdev/wm-unichar)消息旨在向 ANSI 視窗發送或發布 Unicode 字元。 它等效於[WM_CHAR](/windows/win32/inputdev/wm-char)消息,但使用 Unicode 轉換格式-32 編碼 (UTF-32),而[WM_CHAR](/windows/win32/inputdev/wm-char)消息使用 UTF-16。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonuninitmenupopup"></a><a name="onuninitmenupopup"></a>Cwnd::OninitMenuPopup

當下拉菜單或子功能表被銷毀時,框架將調用此成員函數。

```
afx_msg void OnUnInitMenuPopup(
    CMenu* pPopupMenu,
    UINT nFlags);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*pMenu*|[在]指向表示功能表或子功能表的[CMenu](../../mfc/reference/cmenu-class.md)物件的指標。|
|*nFlags*|[在]已銷毀的功能表。 目前,它只能是視窗功能表,MF_SYSMENU。|

### <a name="remarks"></a>備註

此方法接收[WM_UNINITMENUPOPUP](/windows/win32/menurc/wm-uninitmenupopup)通知,這在Windows SDK中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonupdateuistate"></a><a name="onupdateuistate"></a>Cwnd::更新

呼叫以變更指定的視窗及其所有子視窗的使用者介面 (UI) 狀態。

```
afx_msg void OnUpdateUIState(
    UINT nAction,
    UINT nUIElement);
```

### <a name="parameters"></a>參數

*nAction*<br/>
指定要執行的動作。 可以是下列其中一個值：

- UIS_CLEAR應隱藏 UI 狀態元素(由*nUIElement*指定)。

- UIS_INITIALIZE應基於最後一個輸入事件更改 UI 狀態元素(由*nUIElement*指定)。 有關詳細資訊,請參閱[WM_UPDATEISTATE](/windows/win32/menurc/wm-updateuistate)的**備註**部分。

- UIS_SET UI 狀態元素(由*nUIElement*指定)應可見。

*nUI元素*<br/>
指定受影響的 UI 狀態元素或控制項的樣式。 可以是下列其中一個值：

- UISF_HIDEACCEL鍵盤加速器。

- UISF_HIDEFOCUS焦點指標。

- UISF_ACTIVE Windows XP:控件應以用於活動控制件的樣式繪製。

### <a name="remarks"></a>備註

此成員函數類比[WM_UPDATEUISTATE](/windows/win32/menurc/wm-updateuistate)訊息的功能,如 Windows SDK 中所述。

## <a name="cwndonuserchanged"></a><a name="onuserchanged"></a>Cwnd::打開使用者

當用戶登錄或註銷後,框架將此成員稱為所有視窗。

```
afx_msg void OnUserChanged();
```

### <a name="remarks"></a>備註

此方法接收[WM_USERCHANGED](/windows/win32/winmsg/wm-userchanged)通知消息,這在 Windows SDK 中介紹。 當使用者登錄或註銷時,操作系統將更新特定於用戶的設置。 系統在更新設置后立即發送此消息。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonvkeytoitem"></a><a name="onvkeytoitem"></a>Cwnd::在Vkeyto專案

如果`CWnd`物件擁有具有[LBS_WANTKEYBOARDINPUT](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式的清單框,則列表框將發送WM_VKEYTOITEM消息以回應WM_KEYDOWN消息。

```
afx_msg int OnVKeyToItem(
    UINT nKey,
    CListBox* pListBox,
    UINT nIndex);
```

### <a name="parameters"></a>參數

*N 鍵*<br/>
指定使用者按下的金鑰的虛擬金鑰代碼。 有關標準虛擬金鑰代碼的清單,請參閱 Winuser.h

*pListBox*<br/>
指定指向清單框的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nIndex*<br/>
指定目前位置。

### <a name="return-value"></a>傳回值

指定應用程式為回應消息執行的操作。 返回值 -2 表示應用程式處理了選擇項的所有方面,並且不需要清單框執行進一步操作。 返回值 -1 表示列表框應執行預設操作以回應擊鍵。 返回值 0 或更高指定清單框中項的零基索引,並指示列表框應對給定項執行擊鍵的預設操作。

### <a name="remarks"></a>備註

此成員函數僅由具有[LBS_HASSTRINGS](../../mfc/reference/styles-used-by-mfc.md#list-box-styles)樣式的清單框框架調用。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonvscroll"></a><a name="onvscroll"></a>Cwnd::OnVScroll

當用戶單擊視窗的垂直滾動條時,框架將調用此成員函數。

```
afx_msg void OnVScroll(
    UINT nSBCode,
    UINT nPos,
    CScrollBar* pScrollBar);
```

### <a name="parameters"></a>參數

*nSB代碼*<br/>
指定指示使用者滾動請求的滾動條代碼。 此參數可以是下列其中一項：

- SB_BOTTOM滾動到底部。

- SB_ENDSCROLL 結束滾動。

- SB_LINEDOWN向下滾動一行。

- SB_LINEUP向上滾動一行。

- SB_PAGEDOWN向下滾動一頁。

- SB_PAGEUP向上滾動一頁。

- SB_THUMBPOSITION滾動到絕對位置。 當前位置以*nPos*提供。

- SB_THUMBTRACK將滾動框拖動到指定位置。 當前位置以*nPos*提供。

- SB_TOP滾動到頂部。

*nPos*<br/>
如果滾動條代碼SB_THUMBPOSITION或SB_THUMBTRACK,則包含當前滾動框位置;否則未使用。 根據初始滾動範圍 *,nPos*可能是負的,如有必要,應強制轉換為**int。**

*pScrollBar*<br/>
如果滾動消息來自滾動條控件,則包含指向該控件的指標。 如果使用者按下視窗的滾動條,則此參數為 NULL。 該指標可能是暫時性的，因此不應該儲存供日後使用。

### <a name="remarks"></a>備註

`OnVScroll`通常在拖動滾動框時提供一些反饋的應用程式使用。

如果`OnVScroll`滾`CWnd`動 物件的內容,則還必須使用[SetScrollPos](#setscrollpos)成員函數重置滾動框的位置。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonvscrollclipboard"></a><a name="onvscrollclipboard"></a>Cwnd::OnVScroll剪貼簿

當剪貼簿數據具有`OnVScrollClipboard`CF_OWNERDISPLAY格式且剪貼簿檢視器的垂直滾動欄中有事件時,剪貼簿所有者的成員函數由剪貼簿查看器調用。

```
afx_msg void OnVScrollClipboard(
    CWnd* pClipAppWnd,
    UINT nSBCode,
    UINT nPos);
```

### <a name="parameters"></a>參數

*pClipAppwnd*<br/>
指定指向剪貼簿-查看器視窗的指標。 該指標可能是暫時性的，因此不應該儲存供日後使用。

*nSB代碼*<br/>
指定以下捲軸的項目:

- SB_BOTTOM滾動到底部。

- SB_ENDSCROLL 結束滾動。

- SB_LINEDOWN向下滾動一行。

- SB_LINEUP向上滾動一行。

- SB_PAGEDOWN向下滾動一頁。

- SB_PAGEUP向上滾動一頁。

- SB_THUMBPOSITION滾動到絕對位置。 當前位置以*nPos*提供。

- SB_TOP滾動到頂部。

*nPos*<br/>
如果滾動條代碼為SB_THUMBPOSITION,則包含滾動框位置;否則不使用*nPos。*

### <a name="remarks"></a>備註

擁有者應滾動剪貼簿圖像,使相應部分無效,並更新滾動條值。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwindowmaximizedchanged"></a><a name="onwindowmaximizedchanged"></a>Cwnd::在視窗最大化更改

當目前的視窗最大化且視窗由桌面視窗管理員 (DWM) 組成時,框架將呼叫此成員。

```
afx_msg void OnWindowMaximizedChanged(BOOL bIsMaximized);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*b 最大化*|[在]如果當前視窗最大化,則為 TRUE,如果不是,則為 FALSE。|

### <a name="remarks"></a>備註

此方法接收[WM_DWMWINDOWMAXIMIZEDCHANGE](/windows/win32/dwm/wm-dwmwindowmaximizedchange)通知消息,這在 Windows SDK 中介紹。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwindowposchanged"></a><a name="onwindowposchanged"></a>Cwnd::在WindowPos上

當大小、位置或 Z 順序因呼叫[SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos)成員函數或其他視窗管理功能而發生更改時,框架將調用此成員函數。

```
afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
指向包含視窗新大小和位置資訊的[WINDOWPOS](/windows/win32/api/winuser/ns-winuser-windowpos)資料結構。

### <a name="remarks"></a>備註

預設實現將[WM_SIZE](/windows/win32/winmsg/wm-size)和[WM_MOVE](/windows/win32/winmsg/wm-move)訊息發送到視窗。 如果應用程式在不調用其基類的情況下處理調用`OnWindowPosChanged`,則不會發送這些消息。 在調用`OnWindowPosChanged`期間執行任何移動或大小更改處理而不調用其基類會更有效。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwindowposchanging"></a><a name="onwindowposchanging"></a>Cwnd::在視窗Pos改變

當大小、位置或 Z 順序即將由於對[SetWindowPos](/windows/win32/api/winuser/nf-winuser-setwindowpos)成員函數或其他視窗管理函數的調用而更改時,框架將調用此成員函數。

```
afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
```

### <a name="parameters"></a>參數

*lpwndpos*<br/>
指向包含有關視窗`WINDOWPOS`新大小和位置的資訊的數據結構。

### <a name="remarks"></a>備註

應用程式可以通過設定或清除[WINDOWPOS](/windows/win32/api/winuser/ns-winuser-windowpos)結構**的標誌**成員中的相應位來防止對視窗的更改。

對於具有[WS_OVERLAPPED](styles-used-by-mfc.md#window-styles)或[WS_THICKFRAME](styles-used-by-mfc.md#window-styles)樣式的視窗,預設實現向該視窗發送[WM_GETMINMAXINFO](/windows/win32/winmsg/wm-getminmaxinfo)訊息。 這樣做是為了驗證視窗的新大小和位置,並強制實施CS_BYTEALIGNCLIENT和CS_BYTEALIGN客戶端樣式。 應用程式可以通過不調用其基類來覆蓋此功能。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwininichange"></a><a name="onwininichange"></a>Cwnd::OnWininiChange

對 Windows 初始化檔 WIN 進行更改後,框架將調用此成員函數。Ini。

```
afx_msg void OnWinIniChange(LPCTSTR lpszSection);
```

### <a name="parameters"></a>參數

*lpsz節*<br/>
指定已變更的節的名稱的字串。 (字串不包括包含節名稱的方括弧。

### <a name="remarks"></a>備註

[系統參數資訊](/windows/win32/api/winuser/nf-winuser-systemparametersinfow)Windows 函`OnWinIniChange`數在應用程式使用該函數更改 WIN 中的設置後調用。INI 檔。

要將WM_WININICHANGE消息發送到所有頂級視窗,應用程式可以使用[SendMessage](/windows/win32/api/winuser/nf-winuser-sendmessage) Windows 函數,其*hwnd*參數設置為HWND_BROADCAST。

如果應用程式更改 WIN 中的許多不同的部分。同時,應用程式應發送一條WM_WININICHANGE消息 *,lpszSection*設置為 NULL。 否則,應用程式應在每次更改 WIN 時發送WM_WININICHANGE。Ini。

如果應用程式收到`OnWinIniChange`*lpszSection*設置為 NULL 的呼叫,則應用程式應檢查 WIN 中的所有部分。影響應用程式的 INI。

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonwndmsg"></a><a name="onwndmsg"></a>Cwnd::OnwndMsg

此成員函數由`WindowProc`調用,或在消息反射期間調用。

```
virtual BOOL OnWndMsg(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要發送的消息。

*wParam*<br/>
指定其他與消息相關的資訊。

*lParam*<br/>
指定其他與消息相關的資訊。

*pResult*<br/>
[WindowProc](#windowproc)的傳回值 。 取決於消息;可能是 NULL。

### <a name="return-value"></a>傳回值

如果處理了消息,則為 TRUE;否則 FALSE。

### <a name="remarks"></a>備註

`OnWndMsg`確定消息類型,並調用相應的框架函數(例如,WM_COMMAND [OnCommand),](#oncommand)或在消息映射中尋找相應的消息。

有關消息反射的詳細資訊,請參閱[處理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndonxbuttondblclk"></a><a name="onxbuttondblclk"></a>Cwnd::OnXButtonDblClk

當用戶雙擊 XBUTTON1 或 XBUTTON2 時,當使用者在視窗的工作區中時,框架將調用此成員函數。

```
afx_msg void OnXButtonDblClk(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改鍵的標誌的位組合 (OR)。 例如,MK_CONTROL標誌指示按下 CTRL 鍵。|
|*nButton*|[在]如果按一個 Microsoft 智慧滑鼠 X 按鈕,則值為 XBUTTON1;如果按兩下第二個 X 按鈕,則為 XBUTTON2。|
|*點*|[在]一個[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於工作區左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_XBUTTONDBLCLK](/windows/win32/inputdev/wm-xbuttondblclk)通知,這在 Windows SDK 中介紹。 如果未捕獲滑鼠,則消息將發佈到游標下方的視窗。 否則,消息將發佈到捕獲滑鼠的視窗。

*nFlags*參數可以是下表中列出的修改器鍵的組合。 有關詳細資訊,請參閱[有關滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|變更器鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|按下微軟智慧滑鼠的 XBUTTON1 滑鼠按鈕。|
|MK_XBUTTON2|按下微軟智慧滑鼠的 XBUTTON2 滑鼠按鈕。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonxbuttondown"></a><a name="onxbuttondown"></a>Cwnd::打開按鈕

當使用者在游標位於視窗的工作區中時按下 XBUTTON1 或 XBUTTON2 時,框架將調用此成員函數。

```
afx_msg void OnXButtonDown(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改鍵的標誌的位組合 (OR)。 例如,MK_CONTROL標誌指示按下 CTRL 鍵。|
|*nButton*|[在]如果按一個 Microsoft 智慧滑鼠 X 按鈕,則值為 XBUTTON1;單擊第二個 X 按鈕時為 XBUTTON2。|
|*點*|[在]一個[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於工作區左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_XBUTTONDOWN](/windows/win32/inputdev/wm-xbuttondown)通知,這在 Windows SDK 中介紹。 如果未捕獲滑鼠,則消息將發佈到游標下方的視窗。 否則,消息將發佈到捕獲滑鼠的視窗。

*nFlags*參數可以是下表中列出的修改器鍵的組合。 有關詳細資訊,請參閱[有關滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|變更器鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|按下微軟智慧滑鼠的 XBUTTON1 滑鼠按鈕。|
|MK_XBUTTON2|按下微軟智慧滑鼠的 XBUTTON2 滑鼠按鈕。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndonxbuttonup"></a><a name="onxbuttonup"></a>Cwnd::OnXButtonUp

當使用者釋放 XBUTTON1 或 XBUTTON2 時,當游標位於視窗的工作區中時,框架將調用此成員函數。

```
afx_msg void OnXButtonUp(
    UINT nFlags,
    UINT nButton,
    CPoint point);
```

### <a name="parameters"></a>參數

|參數|描述|
|---------------|-----------------|
|*nFlags*|[在]指示按下哪些修改鍵的標誌的位組合 (OR)。 例如,MK_CONTROL標誌指示按下 CTRL 鍵。|
|*nButton*|[在]如果按一個 Microsoft 智慧滑鼠 X 按鈕,則值為 XBUTTON1;如果按兩下第二個 X 按鈕,則為 XBUTTON2。|
|*點*|[在]一個[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件,它指定游標相對於工作區左上角的*x*和*y*座標。|

### <a name="remarks"></a>備註

此方法接收[WM_XBUTTONUP](/windows/win32/inputdev/wm-xbuttonup)通知,這在 Windows SDK 中介紹。 如果未捕獲滑鼠,則消息將發佈到游標下方的視窗。 否則,消息將發佈到捕獲滑鼠的視窗。

*nFlags*參數可以是下表中列出的修改器鍵的組合。 有關詳細資訊,請參閱[有關滑鼠輸入](/windows/win32/inputdev/about-mouse-input)。

|變更器鍵|描述|
|------------------|-----------------|
|MK_CONTROL|按下 CTRL 鍵。|
|MK_LBUTTON|已按下滑鼠左鍵。|
|MK_MBUTTON|已按下滑鼠中間鍵。|
|MK_RBUTTON|已按下滑鼠右鍵。|
|MK_SHIFT|按下 SHIFT 鍵。|
|MK_XBUTTON1|按下微軟智慧滑鼠的 XBUTTON1 滑鼠按鈕。|
|MK_XBUTTON2|按下微軟智慧滑鼠的 XBUTTON2 滑鼠按鈕。|

> [!NOTE]
> 架構會呼叫此成員函式，以允許您的應用程式處理 Windows 訊息。 傳遞至函式的參數反映收到訊息時架構所收到的參數。 如果您呼叫此函式的基底類別實作，該實作會使用原本隨訊息傳遞的參數，而不是您提供給函式的參數。

## <a name="cwndopenclipboard"></a><a name="openclipboard"></a>CWnd::打開剪板

開啟剪貼簿。

```
BOOL OpenClipboard();
```

### <a name="return-value"></a>傳回值

如果通過`CWnd`打開 剪貼簿,則為非零;如果其他應用程式或窗口打開了剪貼板,則為 0。

### <a name="remarks"></a>備註

在調用[CloseClipboard](/windows/win32/api/winuser/nf-winuser-closeclipboard) Windows 功能之前,其他應用程式將無法修改剪貼簿。

在調用`CWnd`[「空剪貼簿](/windows/win32/api/winuser/nf-winuser-emptyclipboard)」Windows 函數之前,當前物件不會成為剪貼板的擁有者。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#111](../../mfc/reference/codesnippet/cpp/cwnd-class_52.cpp)]

## <a name="cwndoperator-hwnd"></a><a name="operator_hwnd"></a>CWnd::操作員HWND

使用此運算元獲取`CWnd`物件的句柄。

```
operator HWND() const;
```

## <a name="cwndoperator-"></a><a name="operator_neq"></a>CWnd::操作員!*

比較兩`CWnd`個物件以確定它們是否具有相同的[m_hWnd。](#m_hwnd)

```
BOOL operator!=(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd*<br/>
`CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

等於非零;否則 0。

## <a name="cwndoperator-"></a><a name="operator_eq_eq"></a>CWnd::操作員 |

比較兩`CWnd`個物件以確定它們是否具有相同的[m_hWnd](#m_hwnd)。

```
BOOL operator==(const CWnd& wnd) const;
```

### <a name="parameters"></a>參數

*wnd*<br/>
`CWnd` 物件的參考。

### <a name="return-value"></a>傳回值

等於非零;否則 0。

## <a name="cwndpaintwindowlesscontrols"></a><a name="paintwindowlesscontrols"></a>CWnd::P無視窗控制

在控制項容器上繪製無視窗控制項。

```
BOOL PaintWindowlessControls(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
要在其中繪製無視窗控制件的設備上下文。

### <a name="return-value"></a>傳回值

如果有控制項容器,並且已成功繪製無視窗控制項,則返回 TRUE,否則為 FALSE。

## <a name="cwndpostmessage"></a><a name="postmessage"></a>CWnd::Post消息

將消息放在視窗的消息佇列中,然後返回而不等待相應的視窗來處理消息。

```
BOOL PostMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要過帳的消息。

*wParam*<br/>
指定其他消息資訊。 此參數的內容取決於要發佈的消息。

*lParam*<br/>
指定其他消息資訊。 此參數的內容取決於要發佈的消息。

### <a name="return-value"></a>傳回值

如果消息已過帳,則非零;否則 0。

### <a name="remarks"></a>備註

通過調用[GetMessage](/windows/win32/api/winuser/nf-winuser-getmessage)或[PeekMessage](/windows/win32/api/winuser/nf-winuser-peekmessagew) Windows 功能檢索消息佇列中的消息。

Windows [PostMessage](/windows/win32/api/winuser/nf-winuser-postmessagew)功能可用於造訪其他應用程式。

### <a name="example"></a>範例

  請參閱[AfxGetMainwnd 的範例](../../mfc/reference/application-information-and-management.md#afxgetmainwnd)。

## <a name="cwndpostncdestroy"></a><a name="postncdestroy"></a>CWnd::PostNc破壞

在視窗被破壞後,由預設[OnNc銷毀](#onncdestroy)成員函數調用。

```
virtual void PostNcDestroy();
```

### <a name="remarks"></a>備註

派生類可以使用此函數進行自定義清理,例如刪除**此**指標。

## <a name="cwndprecreatewindow"></a><a name="precreatewindow"></a>CWnd::P重新建立視窗

在創建附加到此`CWnd`物件的 Windows 視窗之前,由框架調用。

```
virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
```

### <a name="parameters"></a>參數

*cs*<br/>
[創造結構](/windows/win32/api/winuser/ns-winuser-createstructw)。

### <a name="return-value"></a>傳回值

如果窗口創建應繼續,則非零;0 表示建立失敗。

### <a name="remarks"></a>備註

> [!WARNING]
> `CWnd::PreCreateWindow`現在,如果功能表為 NULL 且樣式包含WS_CHILD,則將*cs*的 hMenu 成員分配給**此**指標。 要獲得正確的功能,請確保對話方塊控制項的 ID 不是 NULL。
>
> 此更改修復了託管/本機互操作方案中的崩潰。 中的`CWnd::Create`TRACE 語句提醒開發人員問題。

切勿直接調用此函數。

此函數的預設實現檢查 NULL 視窗類名稱,並替換適當的預設值。 重寫此成員函數,在`CREATESTRUCT`創建視窗之前修改結構。

派生自 的`CWnd`每個 類都會將自己的功能添加到`PreCreateWindow`其對 的重寫中。 根據設計,這些派生`PreCreateWindow`沒有記錄。 要確定適合每個類的樣式和樣式之間的相互依賴性,可以檢查應用程式的基類的 MFC 原始程式碼。 如果選擇重寫`PreCreateWindow,`,則可以確定應用程式基類中使用的樣式是否通過使用從 MFC 原始程式碼收集的資訊提供所需的功能。

有關變更視窗樣式的詳細資訊,請參閱[變更 MFC 建立的視窗樣式](../../mfc/changing-the-styles-of-a-window-created-by-mfc.md)。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#112](../../mfc/reference/codesnippet/cpp/cwnd-class_53.cpp)]

## <a name="cwndpresubclasswindow"></a><a name="presubclasswindow"></a>CWnd::P重子類視窗

框架調用此成員函數,以便在子類視窗之前進行其他必要的子類。

```
virtual void PreSubclassWindow();
```

### <a name="remarks"></a>備註

重寫此成員函數允許對控制件進行動態子類化。 這是一個先進的超易。

## <a name="cwndpretranslatemessage"></a><a name="pretranslatemessage"></a>CWnd::P重新翻譯訊息

[CWinApp](../../mfc/reference/cwinapp-class.md) 類別用來轉譯分派至 [TranslateMessage](/windows/win32/api/winuser/nf-winuser-translatemessage) 和 [DispatchMessage](/windows/win32/api/winuser/nf-winuser-dispatchmessage) Windows 函式之前的視窗訊息。

```
virtual BOOL PreTranslateMessage(MSG* pMsg);
```

### <a name="parameters"></a>參數

*pMsg*<br/>
指向包含要處理的消息的[MSG](/windows/win32/api/winuser/ns-winuser-msg)結構。

### <a name="return-value"></a>傳回值

如果郵件已翻譯且不應發送,則非零;0 如果郵件未翻譯,則應調度。

## <a name="cwndprint"></a><a name="print"></a>CWnd::P

調用此成員函數以在指定的設備上下文中繪製當前視窗,這在印表機設備上下文中很常見。

```cpp
void Print(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定繪圖選項。 這裡可以是以下一個或多個標誌:

- PRF_CHECKVISIBLE僅當視窗可見時才繪製視窗。

- PRF_CHILDREN繪製所有可見的子視窗。

- PRF_CLIENT繪製視窗的工作區。

- PRF_ERASEBKGND在繪製視窗之前擦除背景。

- PRF_NONCLIENT繪製視窗的非工作區。

- PRF_OWNED繪製所有擁有的視窗。

### <a name="remarks"></a>備註

[CWnd::DefWindowProc](#defwindowproc)函數根據指定繪圖選項處理此消息:

- 如果指定了PRF_CHECKVISIBLE並且視窗不可見,則不執行任何操作。

- 如果指定PRF_NONCLIENT,則在給定設備上下文中繪製非工作區。

- 如果指定了PRF_ERASEBKGND,則向視窗發送[WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd)消息。

- 如果指定了PRF_CLIENT,則向視窗發送[WM_PRINTCLIENT](/windows/win32/gdi/wm-printclient)訊息。

- 如果設置了PRF_CHILDREN,則為每個可見的子窗口發送[一WM_PRINT](/windows/win32/gdi/wm-print)消息。

- 如果設置了PRF_OWNED,則向每個可見擁有的窗口發送一條WM_PRINT消息。

## <a name="cwndprintclient"></a><a name="printclient"></a>CWnd::PrintClient

調用此成員函數以在指定的設備上下文中(通常是印表機設備上下文)中繪製任何視窗。

```cpp
void PrintClient(
    CDC* pDC,
    DWORD dwFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
裝置內容的指標。

*dwFlags*<br/>
指定繪圖選項。 這裡可以是以下一個或多個標誌:

- PRF_CHECKVISIBLE僅當視窗可見時才繪製視窗。

- PRF_CHILDREN繪製所有可見的子視窗。

- PRF_CLIENT繪製視窗的工作區。

- PRF_ERASEBKGND在繪製視窗之前擦除背景。

- PRF_NONCLIENT繪製視窗的非工作區。

- PRF_OWNED繪製所有擁有的視窗。

## <a name="cwndprintwindow"></a><a name="printwindow"></a>CWnd::P林特視窗

將視覺視窗複製到指定的裝置內容，通常是印表機 DC。

```
BOOL PrintWindow(
    CDC* pDC,
    UINT nFlags) const;
```

### <a name="parameters"></a>參數

*pDC*<br/>
指向要列印到的設備上下文的指標。

*nFlags*<br/>
指定繪圖選項。 有關可能值的清單,請參閱[列印視窗](/windows/win32/api/winuser/nf-winuser-printwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[PrintWindow](/windows/win32/api/winuser/nf-winuser-printwindow)的功能,如 Windows SDK 中所述。

## <a name="cwndredrawwindow"></a><a name="redrawwindow"></a>CWnd::重繪視窗

更新給定視窗工作區中的指定矩形或區域。

```
BOOL RedrawWindow(
    LPCRECT lpRectUpdate = NULL,
    CRgn* prgnUpdate = NULL,
    UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
```

### <a name="parameters"></a>參數

*lprect 更新*<br/>
包含更新矩形座標的[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。 如果*prgnUpdate*包含有效的區域句柄,則忽略此參數。

*prgnUpdate*<br/>
標識更新區域。 如果*prgnUpdate*和*lpRectUpdate*均為 NULL,則整個工作區將添加到更新區域。

*flags*<br/>
以下標誌用於使視窗無效:

- RDW_ERASE 使視窗在重新繪製視窗時接收[WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd)消息。 還必須指定RDW_INVALIDATE標誌;否則RDW_ERASE無效。

- RDW_FRAME 使視窗的非工作區與更新區域相交的任何部分接收[WM_NCPAINT](/windows/win32/gdi/wm-ncpaint)消息。 還必須指定RDW_INVALIDATE標誌;否則RDW_FRAME無效。

- RDW_INTERNALPAINT 使[WM_PAINT](/windows/win32/gdi/wm-paint)訊息發佈到視窗,而不考慮視窗是否包含無效區域。

- RDW_INVALIDATE不合法*的 lpRect 更新*或*prgnUpdate(* 只有一個可能不是 NULL)。 如果兩者均為 NULL,則整個視窗將失效。

以下標誌用於驗證視窗:

- RDW_NOERASE禁止任何掛起WM_ERASEBKGND消息。

- RDW_NOFRAME禁止任何掛起的WM_NCPAINT消息。 此標誌必須與RDW_VALIDATE一起使用,通常與RDW_NOCHILDREN一起使用。 此選項應謹慎使用,因為它可以防止視窗的某些部分正確繪製。

- RDW_NOINTERNALPAINT禁止任何掛起的內部WM_PAINT消息。 此標誌不會影響由無效區域產生的WM_PAINT消息。

- RDW_VALIDATE驗證*lpRect 更新*或*prgnUpdate(* 只有一個可能不是 NULL)。 如果兩者均為 NULL,則驗證整個視窗。 此標誌不會影響內部WM_PAINT消息。

重新繪製時,以下標誌控制項。 除非指定了其中一個`RedrawWindow`位,否則函數不會執行繪製。

- RDW_ERASENOW 使受影響的視窗(如RDW_ALLCHILDREN和RDW_NOCHILDREN標誌)在函數返回之前接收WM_NCPAINT和WM_ERASEBKGND消息。 WM_PAINT消息被延遲。

- RDW_UPDATENOW 使受影響的視窗(如RDW_ALLCHILDREN和RDW_NOCHILDREN標誌)在函數返回之前接收WM_NCPAINT、WM_ERASEBKGND和WM_PAINT消息。

默認情況下,受`RedrawWindow`該函數影響的視窗取決於指定的視窗是否具有WS_CLIPCHILDREN樣式。 WS_CLIPCHILDREN視窗的子視窗不受影響。 但是,在遇到WS_CLIPCHILDREN視窗之前,那些不是視窗WS_CLIPCHILDREN的視窗將遞歸驗證或失效。 以下標誌控制哪些視窗受`RedrawWindow`該函數影響:

- RDW_ALLCHILDREN在重新繪製操作中包括子視窗(如果有)。

- RDW_NOCHILDREN 從重新繪製操作中排除子視窗(如果有)。

### <a name="return-value"></a>傳回值

如果視窗已成功重繪,則非零;否則 0。

### <a name="remarks"></a>備註

當`RedrawWindow`成員函數用於使桌面視窗的一部分無效時,該視窗不會收到[WM_PAINT](/windows/win32/gdi/wm-paint)消息。 要重新繪製桌面,應用程式應使用[CWnd::驗證](#validatergn)Rgn,CWnd::驗證Rgn,CWnd::[更新視窗](#updatewindow),或[重繪視窗](/windows/win32/api/winuser/nf-winuser-redrawwindow)[CWnd::InvalidateRgn](#invalidatergn)

## <a name="cwndreflectchildnotify"></a><a name="reflectchildnotify"></a>CWnd::反映兒童通知

此消息函數由[來自 OnChildNotify](#onchildnotify)的框架調用。

```
BOOL ReflectChildNotify(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT* pResult);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要反射的消息。

*wParam*<br/>
指定其他與消息相關的資訊。

*lParam*<br/>
指定其他與消息相關的資訊。

*pResult*<br/>
子視窗生成的結果,由父視窗返回。 可以是 NULL。

### <a name="return-value"></a>傳回值

如果消息被反映為 TRUE;如果消息被反映,則為 TRUE。否則 FALSE。

### <a name="remarks"></a>備註

它是一個説明函數,它反映*消息*到它的源。

反射的消息直接發送到[CWnd::OnwndMsg](#onwndmsg)或[CCmdTarget::OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg)。

有關消息反射的詳細資訊,請參閱[處理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndreflectlastmsg"></a><a name="reflectlastmsg"></a>CWnd::反映

框架調用此成員函數以向子視窗反映最後一條消息。

```
static BOOL PASCAL ReflectLastMsg(
    HWND hWndChild,
    LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*hWndChild*<br/>
子視窗的句柄。

*pResult*<br/>
子視窗生成的結果,由父視窗返回。 可以是 NULL。

### <a name="return-value"></a>傳回值

處理消息時非零;否則 0。

### <a name="remarks"></a>備註

如果*hWndChild*識別的視窗是 OLE 控制件或永久地圖中的視窗,則此成員函數將調用[SendChildNotifyLastMsg。](#sendchildnotifylastmsg)

有關消息反射的詳細資訊,請參閱[處理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndreleasedc"></a><a name="releasedc"></a>CWnd::釋放DC

釋放設備上下文,將其釋放供其他應用程式使用。

```
int ReleaseDC(CDC* pDC);
```

### <a name="parameters"></a>參數

*pDC*<br/>
標識要發佈的設備上下文。

### <a name="return-value"></a>傳回值

如果成功則為非零；否則為 0。

### <a name="remarks"></a>備註

`ReleaseDC`成員函數的效果取決於設備上下文類型。

應用程式必須調用`ReleaseDC`對[GetWindowDC](#getwindowdc)成員函數的每個調用以及對[GetDC](#getdc)成員函數的每個調用的成員函數。

## <a name="cwndrepositionbars"></a><a name="repositionbars"></a>CWnd::重新置放條

呼叫以重新置放和調整視窗工作區中的控制欄的大小。

```cpp
void RepositionBars(UINT nIDFirst,
    UINT nIDLast,
    UINT nIDLeftOver,
    UINT nFlag = reposDefault,
    LPRECT lpRectParam = NULL,
    LPCRECT lpRectClient = NULL,
    BOOL bStretch = TRUE) ;
```

### <a name="parameters"></a>參數

*nID 第一*<br/>
用於重新置放和調整大小的控制列中第一個的 ID。

*nIDLast*<br/>
要重新置放和調整大小的控制欄範圍內最後一個的 ID。

*nID剩下*<br/>
指定填充工作區其餘部分的窗格的 ID。

*nFlag*<br/>
可以具有下列其中一個值：

- `CWnd::reposDefault`執行控制欄的佈局。 *不使用 lpRectParam,* 可以為 NULL。

- `CWnd::reposQuery`控制欄的佈局未完成;未完成控制欄的佈局。相反 *,lpRectParam*會用工作區的大小進行初始化,就像布局實際上已經完成一樣。

- `CWnd::reposExtra`將*lpRectParam*的值添加到*nIDLast*的工作區,並執行佈局。

*lpRectParam*<br/>
指向[RECT 結構](/windows/win32/api/windef/ns-windef-rect);其用法取決於*nFlag*的值。

*lpRectClient*<br/>
包含可用工作區的[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。 如果 NULL,將使用視窗的工作區。

*b 伸*<br/>
指示是否應將條形拉伸到框架的大小。

### <a name="remarks"></a>備註

*nIDFirst*和*nIDLast*參數定義要重新置放在工作區中的控制欄 ID 範圍。 *nIDLeftOver*參數指定子視窗(通常是檢視)的 ID,該 ID 被重新置放並調整大小以填充控制列列未填充的工作區的其餘部分。

## <a name="cwndrunmodalloop"></a><a name="runmodalloop"></a>CWnd::運行模式環

呼叫此成員函數以檢索、翻譯或調度訊息,直到[「繼續模式」](#continuemodal)傳回 FALSE。

```
int RunModalLoop(DWORD dwFlags = 0);
```

### <a name="parameters"></a>參數

*dwFlags*<br/>
指定要發送的 Windows 訊息。 可以是下列其中一個值：

- MLF_NOIDLEMSG不要向父發送[WM_ENTERIDLE](/windows/win32/dlgbox/wm-enteridle)消息。

- MLF_NOKICKIDLE不要向窗口發送WM_KICKIDLE消息。

- MLF_SHOWONIDLE消息佇列空閒時顯示視窗。

### <a name="return-value"></a>傳回值

指定傳遞給[EndModalLoop](#endmodalloop)成員函數的*nResult*參數的值,然後用於結束模式迴圈。

### <a name="remarks"></a>備註

預設情況下,`ContinueModal`在呼叫`EndModalLoop`後傳回 FALSE。 將為*nResult*`EndModalLoop`提供的值傳回到 。

## <a name="cwndscreentoclient"></a><a name="screentoclient"></a>Cwnd::螢幕用戶端

將畫面上指定的點或矩形的螢幕座標，轉換為用戶端座標。

```cpp
void ScreenToClient(LPPOINT lpPoint) const;  void ScreenToClient(LPRECT lpRect) const;
```

### <a name="parameters"></a>參數

*lpPoint*<br/>
包含要轉換的螢幕座標的[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[POINT 結構](/windows/win32/api/windef/ns-windef-point)。

*lpRect*<br/>
包含要轉換的螢幕座標的[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。

### <a name="remarks"></a>備註

成員`ScreenToClient`函數將*lpPoint*或*lpRect*中給出的螢幕座標替換為用戶端座標。 新座標相對於`CWnd`工作區的左上角。

### <a name="example"></a>範例

  請參考[CListCtrl 的範例:抓取項目重新完成](../../mfc/reference/clistctrl-class.md#getitemrect)。

## <a name="cwndscrollwindow"></a><a name="scrollwindow"></a>CWnd::滾動視窗

滾動當前`CWnd`物件的工作區的內容。

```cpp
void ScrollWindow(
    int xAmount,
    int yAmount,
    LPCRECT lpRect = NULL,
    LPCRECT lpClipRect = NULL);
```

### <a name="parameters"></a>參數

*x 數量*<br/>
指定水準滾動的數量(以設備單位為單位)。 此參數必須是向左滾動的負值。

*y 數量*<br/>
指定垂直滾動的數量(以設備單位為單位)。 此參數必須是負值才能向上滾動。

*lpRect*<br/>
指向[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/win32/api/windef/ns-windef-rect),該結構指定要滾動的工作區部分。 如果*lpRect*為 NULL,則滾動整個工作區。 如果游標矩形與滾動矩形相交,則重新置放。

*lpClipRect*<br/>
指向指定要`CRect`滾動`RECT`的裁剪矩形的物件或結構。 僅滾動此矩形內的位。 此矩形外部的位不受影響,即使它們位於*lpRect*矩形中也是如此。 如果*lpClipRect*為 NULL,則滾動矩形上不執行任何剪輯。

### <a name="remarks"></a>備註

如果 care`CWnd`在正在滾動`ScrollWindow`中, 則會自動隱藏 caret 以防止其被擦除,然後在滾動完成後還原 care。 護理位置會相應地調整。

成員函數覆蓋的區域`ScrollWindow`不會重新繪製,而是合併到`CWnd`當前 物件的更新區域中。 應用程式最終將收到[一條WM_PAINT](/windows/win32/gdi/wm-paint)消息,通知它該區域需要重新繪製。 要在滾動完成的同時重新繪製未覆蓋的區域,請調用`ScrollWindow`後立即調用[UpdateWindow](#updatewindow)成員函數。

如果*lpRect*為 NULL,則視窗中任何子視窗的位置都由*x量*和*y量*指定`CWnd`的量偏移,並且 中的任何無效(未上漆)區域也會偏移。 `ScrollWindow`當*lpRect*為 NULL 時,速度更快。

如果*lpRect*不是 NULL,則子視窗的位置不會更改`CWnd`,並且中的無效區域不會偏移。 為了防止*在 lpRect*不是 NULL 時更新問題`UpdateWindow`,`CWnd`請呼叫`ScrollWindow`成員函數 在呼叫 之前重新繪製 。

## <a name="cwndscrollwindowex"></a><a name="scrollwindowex"></a>CWnd::滾動視窗Ex

滾動視窗工作區的內容。

```
int ScrollWindowEx(
    int dx,
    int dy,
    LPCRECT lpRectScroll,
    LPCRECT lpRectClip,
    CRgn* prgnUpdate,
    LPRECT lpRectUpdate,
    UINT flags);
```

### <a name="parameters"></a>參數

*Dx*<br/>
指定水準滾動的數量(以設備單位為單位)。 此參數必須具有負值才能向左滾動。

*Dy*<br/>
指定垂直滾動的數量(以設備單位為單位)。 此參數必須具有負值才能向上滾動。

*lpRectScroll*<br/>
指定要捲軸的工作區部份的[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。 如果此參數為 NULL,則滾動整個工作區。

*lprectClip*<br/>
指向指定要`RECT`滾動的裁剪矩形的結構。 此結構優先於*lpRectScroll*指向的矩形。 僅滾動此矩形內的位。 此矩形外部的位不受影響,即使它們位於*lpRectScroll*矩形中也是如此。 如果此參數為 NULL,則滾動矩形上不執行剪切。

*prgnUpdate*<br/>
標識已修改的區域,以便通過滾動保持區域無效。 此參數可能是 NULL。

*lprect 更新*<br/>
指向將接收`RECT`通過滾動而失效的矩形邊界的結構。 此參數可能是 NULL。

*flags*<br/>
可以具有下列其中一個值：

- SW_ERASE 使用SW_INVALIDATE指定時,通過向視窗發送[WM_ERASEBKGND](/windows/win32/winmsg/wm-erasebkgnd)消息來擦除新失效的區域。

- SW_INVALIDATE在滾動後使*prgnUpdate*標識的區域無效。

- SW_SCROLLCHILDREN滾動所有與*lpRectScroll*指向的矩形相交的子視窗,按*dx*和*dy*中指定的圖元數。 Windows 向所有與*lpRectScroll*相交的子視窗發送[WM_MOVE](/windows/win32/winmsg/wm-move)消息,即使它們不移動也是如此。 當滾動子視窗且游標矩形與滾動矩形相交時,將重新置放該圖。

### <a name="return-value"></a>傳回值

如果函數成功,返回值為 SIMPLEREGION(矩形失效區域)、複雜區域(非矩形失效區域;重疊矩形)或 NULLREGION(無失效區域);否則返回值為錯誤。

### <a name="remarks"></a>備註

此功能類似於[「滾動視窗」](/windows/win32/api/winuser/nf-winuser-scrollwindow)功能,並具有一些附加功能。

如果未指定[SW_INVALIDATE](/windows/win32/api/winuser/nf-winuser-scrollwindowex)和[SW_ERASE,](/windows/win32/api/winuser/nf-winuser-scrollwindowex)`ScrollWindowEx`則成員函數不會使滾動離開的區域無效。 如果設置了這些標誌中的任何一個,`ScrollWindowEx`則使此區域失效。 在應用程式呼叫[UpdateWindow](/windows/win32/api/winuser/nf-winuser-updatewindow)成員函數、調用[重繪視窗](/windows/win32/api/winuser/nf-winuser-redrawwindow)成員函數(指定[RDW_UPDATENOW](/windows/win32/api/winuser/nf-winuser-redrawwindow)或[RDW_ERASENOW)](/windows/win32/api/winuser/nf-winuser-redrawwindow)或從應用程式佇列中檢索[WM_PAINT](/windows/win32/gdi/wm-paint)消息之前,不會更新該區域。

如果視窗具有[WS_CLIPCHILDREN](/windows/win32/api/winuser/nf-winuser-createwindoww)樣式,*則 prgnUpdate*和*lpRectUpdate*指定的返回區域表示必須更新的滾動視窗的總面積,包括子視窗中需要更新的任何區域。

如果指定[了SW_SCROLLCHILDREN](/windows/win32/api/winuser/nf-winuser-scrollwindowex)標誌,則如果滾動了子視窗的一部分,Windows 將無法正確更新螢幕。 位於源矩形外的滾動子視窗部分將不會擦除,也不會在其新目標中正確重繪。 使用[「延遲視窗Pos」](/windows/win32/api/winuser/nf-winuser-deferwindowpos)視窗函數移動未完全位於*lpRectScroll*矩形內的子視窗。 如果設置了SW_SCROLLCHILDREN標誌,並且傾斜矩形與滾動矩形相交,則重新定位游標。

所有輸入和輸出座標(對於 lpRectScroll、lpRectClip、lpRectUpdate 和*prgnUpdate)* 都假定在用戶端座標中,而不考慮視窗具有CS_OWNDC還是CS_CLASSDC*lpRectScroll**lpRectClip**lpRectUpdate*類樣式。 如有必要,使用[LPtoDP](/windows/win32/api/wingdi/nf-wingdi-lptodp)和[DPtoLP](/windows/win32/api/wingdi/nf-wingdi-dptolp) Windows 函數轉換到邏輯座標和從邏輯座標轉換。

## <a name="cwndsendchildnotifylastmsg"></a><a name="sendchildnotifylastmsg"></a>CWnd::發送兒童通知最後Msg

框架呼叫此成員函數,以便從父視窗向子視窗提供通知訊息,以便子視窗可以處理任務。

```
BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);
```

### <a name="parameters"></a>參數

*pResult*<br/>
子視窗生成的結果,由父視窗返回。

### <a name="return-value"></a>傳回值

如果子視窗已處理發送到其父級的消息,則非零;否則 0。

### <a name="remarks"></a>備註

`SendChildNotifyLastMsg`如果當前消息是反映的消息,則將當前消息發送到源。

有關消息反射的詳細資訊,請參閱[處理反射消息](../../mfc/handling-reflected-messages.md)。

## <a name="cwndsenddlgitemmessage"></a><a name="senddlgitemmessage"></a>CWnd::發送DlgItem消息

向控件發送消息。

```
LRESULT SendDlgItemMessage(
    int nID,
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定將接收消息的對話方塊控制項的識別碼。

*message*<br/>
指定要發送的消息。

*wParam*<br/>
指定其他與消息相關的資訊。

*lParam*<br/>
指定其他與消息相關的資訊。

### <a name="return-value"></a>傳回值

指定控制項的視窗過程傳回的值,如果找不到控制項,則指定 0。

### <a name="remarks"></a>備註

在`SendDlgItemMessage`處理消息之前,成員函數不會返回。

使用`SendDlgItemMessage`與獲取給定控制件的`CWnd`*並呼叫[SendMessage](#sendmessage)成員函數相同。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#113](../../mfc/reference/codesnippet/cpp/cwnd-class_54.cpp)]

## <a name="cwndsendmessage"></a><a name="sendmessage"></a>CWnd::發送消息

將指定的消息發送到此視窗。

```
LRESULT SendMessage(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要發送的消息。

*wParam*<br/>
指定其他與消息相關的資訊。

*lParam*<br/>
指定其他與消息相關的資訊。

### <a name="return-value"></a>傳回值

消息處理的結果;其值取決於發送的消息。

### <a name="remarks"></a>備註

成員`SendMessage`函數直接調用視窗過程,直到該視窗過程處理該消息之前不會返回。 這與[PostMessage](#postmessage)成員函數不同,該函數將消息放入視窗的消息佇列並立即返回。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#101](../../mfc/reference/codesnippet/cpp/cwnd-class_41.cpp)]

## <a name="cwndsendmessagetodescendants"></a><a name="sendmessagetodescendants"></a>Cwnd::向後代發送消息

呼叫此成員函數將指定的 Windows 訊息發送到所有後代視窗。

```cpp
void SendMessageToDescendants(
    UINT message,
    WPARAM wParam = 0,
    LPARAM lParam = 0,
    BOOL bDeep = TRUE,
    BOOL bOnlyPerm = FALSE);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要發送的消息。

*wParam*<br/>
指定其他與消息相關的資訊。

*lParam*<br/>
指定其他與消息相關的資訊。

*bDeep*<br/>
指定要搜索到的級別。 如果為 TRUE,則遞歸地搜索所有子級;如果 FALSE,則僅搜索直系子。

*b 只*<br/>
指定是否由臨時視窗接收消息。 如果為 TRUE,臨時視窗可以接收消息;如果為 TRUE,則臨時視窗可以接收消息。如果 FALSE,則只有永久視窗才會收到消息。 有關臨時視窗的詳細資訊,請參閱[技術說明 3](../../mfc/tn003-mapping-of-windows-handles-to-objects.md)。

### <a name="remarks"></a>備註

如果*bDeep*是 FALSE,則消息將僅發送給視窗的直系子級;否則,消息將發送到所有後代視窗。

如果*bDeep*和*bOnlyPerm*為 TRUE,則搜索將繼續在臨時視窗下方。 在這種情況下,搜索期間遇到的永久視窗才會收到消息。 如果*bDeep*是 FALSE,則消息僅發送給視窗的直系子級。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#114](../../mfc/reference/codesnippet/cpp/cwnd-class_55.cpp)]

## <a name="cwndsendnotifymessage"></a><a name="sendnotifymessage"></a>CWnd::發送通知訊息

將指定的消息發送到視窗。

```
BOOL SendNotifyMessage(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要發送的消息。

*wParam*<br/>
指定其他與消息相關的資訊。

*lParam*<br/>
指定其他與消息相關的資訊。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果視窗由呼叫執行緒,`SendNotifyMessage`請呼叫視窗視窗過程,直到視窗程序處理該訊息才傳回。 如果視窗由其他線程建立,`SendNotifyMessage`則將訊息傳遞到視窗過程並立即返回;如果視窗由其他線程創建,則將消息傳遞到視窗過程,然後返回視窗。它不等待視窗過程完成消息的處理。

## <a name="cwndsetactivewindow"></a><a name="setactivewindow"></a>CWnd::設定活動視窗

使`CWnd`活動視窗。

```
CWnd* SetActiveWindow();
```

### <a name="return-value"></a>傳回值

以前處於活動狀態的視窗。

返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

`SetActiveWindow`成員函數應謹慎使用,因為它允許應用程式任意接管活動視窗和輸入焦點。 通常,Windows 負責所有啟動。

## <a name="cwndsetcapture"></a><a name="setcapture"></a>CWnd::設置捕獲

導致所有後續滑鼠輸入發送到當前`CWnd`物件,而不考慮游標的位置。

```
CWnd* SetCapture();
```

### <a name="return-value"></a>傳回值

指向以前接收所有滑鼠輸入的視窗物件的指標。 如果沒有這樣的視窗,則為 NULL。 返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

當`CWnd`不再需要所有滑鼠輸入時,應用程式應呼叫[ReleaseCapture](/windows/win32/api/winuser/nf-winuser-releasecapture)函數,以便其他視窗可以接收滑鼠輸入。

捕獲滑鼠輸入時,不會向活動視窗發送WM_NCHITTEST或WM_SETCURSOR消息。

## <a name="cwndsetcaretpos"></a><a name="setcaretpos"></a>CWnd::SetCaretPos

設置卡便的位置。

```
static void PASCAL SetCaretPos(POINT point);
```

### <a name="parameters"></a>參數

*點*<br/>
指定 caret 的新 x 和 y 座標(在客戶端座標中)。

### <a name="remarks"></a>備註

僅當`SetCaretPos`該圖由當前任務中的窗口擁有時,成員函數才會移動該 caret。 `SetCaretPos`移動護理是否隱藏。

care是共用資源。 如果窗口不擁有該圖子,則不應移動該圖。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#115](../../mfc/reference/codesnippet/cpp/cwnd-class_56.cpp)]

## <a name="cwndsetclipboardviewer"></a><a name="setclipboardviewer"></a>CWnd::設定剪貼簿檢視器

每當剪貼簿的內容發生更改時,都會將此視窗添加到通知(通過WM_DRAWCLIPBOARD消息)的窗口鏈中。

```
HWND SetClipboardViewer();
```

### <a name="return-value"></a>傳回值

如果成功,則對剪貼簿-查看器鏈中下一個視窗的句柄。 應用程式應保存此句柄(它可以作為成員變數存儲),並在回應剪貼板-查看器鏈消息時使用它。

### <a name="remarks"></a>備註

作為剪貼簿檢視器鏈一部分的窗口必須回應[WM_DRAWCLIPBOARD、WM_CHANGECBCHAIN](#onchangecbchain)[WM_DRAWCLIPBOARD](#ondrawclipboard)和[消息WM_DESTROY,](#ondestroy)並將消息傳遞到鏈中的下一個視窗。

此成員函數向視窗發送WM_DRAWCLIPBOARD消息。 由於尚未返回 Clipboard-查看器鏈中下一個視窗的句柄,因此應用程式不應傳遞它在調用 期間接收到`SetClipboardViewer`的消息WM_DRAWCLIPBOARD 消息。

要從剪貼簿檢視器鏈中刪除自身,應用程式必須調用[ChangeClipboard 鏈](#changeclipboardchain)成員函數。

## <a name="cwndsetdlgctrlid"></a><a name="setdlgctrlid"></a>CWnd::SetDlgCtrlID

將視窗的視窗 ID 或控制項 ID 設定為新值。

```
int SetDlgCtrlID(int nID);
```

### <a name="parameters"></a>參數

*nID*<br/>
要為控制項的標識碼設定的新值。

### <a name="return-value"></a>傳回值

視窗的上一個標識符(如果成功);否則 0。

### <a name="remarks"></a>備註

視窗可以是任何子視窗,而不僅僅是對話框中的控制項。 視窗不能是頂級視窗。

## <a name="cwndsetdlgitemint"></a><a name="setdlgitemint"></a>Cwnd::塞特德格·特斯特

在對話框中設置給定控制件的文本到指定整數值的字串表示形式。

```cpp
void SetDlgItemInt(
    int nID,
    UINT nValue,
    BOOL bSigned = TRUE);
```

### <a name="parameters"></a>參數

*nID*<br/>
指定要更改的控制項的整數 ID。

*n值*<br/>
指定用於生成項文本的整數值。

*b簽章*<br/>
指定整數值是簽名還是未簽名。 如果此參數為 TRUE,則*對 nValue*進行簽名。 如果此參數為*TRUE,nValue*小於 0,則在字串中的第一個數位之前放置一個減號。 如果此參數為 FALSE,*則 nValue*是無符號的。

### <a name="remarks"></a>備註

`SetDlgItemInt`向給定控制件發送[WM_SETTEXT](/windows/win32/winmsg/wm-settext)訊息。

### <a name="example"></a>範例

  請參考[CWnd 的範例:setDlgItemText](#setdlgitemtext)。

## <a name="cwndsetdlgitemtext"></a><a name="setdlgitemtext"></a>Cwnd::SetDlgItemText

設置視窗或對話方塊擁有的控制項的標題或文本。

```cpp
void SetDlgItemText(
    int nID,
    LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*nID*<br/>
標識要設置其文本的控制項。

*lpszString*<br/>
指向包含要複製到控制項的文字的[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或空端接字串。

### <a name="remarks"></a>備註

`SetDlgItemText`向給定控制件發送[WM_SETTEXT](/windows/win32/winmsg/wm-settext)訊息。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#116](../../mfc/reference/codesnippet/cpp/cwnd-class_57.cpp)]

## <a name="cwndsetforegroundwindow"></a><a name="setforegroundwindow"></a>CWnd::設定前景視窗

將建立視窗的執行緒放置到前景並啟動視窗。

```
BOOL SetForegroundWindow();
```

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

鍵盤輸入定向到視窗,並更改使用者的各種視覺提示。 前景視窗是使用者當前正在使用的視窗。 前景視窗僅適用於頂級視窗(框架視窗或對話框)。

### <a name="example"></a>範例

  請參閱[CWnd 的範例:尋找視窗](#findwindow)。

## <a name="cwndsetfocus"></a><a name="setfocus"></a>CWnd::設定焦點

宣告輸入焦點。

```
CWnd* SetFocus();
```

### <a name="return-value"></a>傳回值

指向以前具有輸入焦點的視窗物件的指標。 如果沒有這樣的視窗,則為 NULL。 返回的指標可能是臨時的,不應存儲。

### <a name="remarks"></a>備註

輸入焦點將所有後續鍵盤輸入定向到此視窗。 以前具有輸入焦點的任何視窗都丟失它。

成員`SetFocus`函數向遺失輸入焦點的視窗發送[WM_KILLFOCUS](/windows/win32/inputdev/wm-killfocus)訊息,向接收輸入焦點的視窗發送[WM_SETFOCUS](/windows/win32/inputdev/wm-setfocus)訊息。 它還激活視窗或其父級。

如果目前的視窗處於作用狀態但沒有焦點(即沒有視窗具有焦點),則按下的任何鍵都會產生[訊息WM_SYSCHAR、WM_SYSKEYDOWN](#onsyschar)[WM_SYSKEYUP](#onsyskeyup)或[WM_SYSKEYDOWN](#onsyskeydown)WM_SYSKEYUP 。

## <a name="cwndsetfont"></a><a name="setfont"></a>CWnd::SetFont

將WM_SETFONT訊息發送到視窗以使用指定的字體。

```cpp
void SetFont(
    CFont* pFont,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*pFont*<br/>
指向 `CFont` 物件的指標。

*bredraw*<br/>
如果視窗在處理WM_SETFONT消息后立即重繪,則為 TRUE;否則 FALSE。

### <a name="remarks"></a>備註

除非窗口處理WM_SETFONT消息,否則此方法無效。 許多 MFC`CWnd`類從 處理此消息派生,因為它們附加到預定義的視窗類,該類包含WM_SETFONT消息的消息處理程式。 要使用此方法,派生自的`CWnd`類必須為WM_SETFONT消息定義方法處理程式。

## <a name="cwndseticon"></a><a name="seticon"></a>CWnd::SetIcon

調用此成員函數將句柄設置為特定圖示,由*hIcon*標識。

```
HICON SetIcon(
    HICON hIcon,
    BOOL bBigIcon);
```

### <a name="parameters"></a>參數

*hIcon*<br/>
前一個圖示的句柄。

*bBigIcon*<br/>
如果為 TRUE,則指定 32 圖元 x 32 像素圖示;如果 FALSE,則指定 16 圖元 x 16 像素圖示。

### <a name="return-value"></a>傳回值

圖示的控制代碼。

### <a name="remarks"></a>備註

註冊視窗類時,它將選擇一個圖示。

### <a name="example"></a>範例

  請參閱[CWnd 的範例:取得系統選單](#getsystemmenu)。

## <a name="cwndsetlayeredwindowattributes"></a><a name="setlayeredwindowattributes"></a>CWnd::設定分層視窗屬性

設定分層視窗的不透明和透明色鍵。

```
BOOL SetLayeredWindowAttributes(
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*crKey*<br/>
指向 COLORREF 值的指標,該值指定在組合分層視窗時要使用的透明度顏色鍵。 此顏色的視窗繪製的所有圖元都將是透明的。 要生成 COLORREF,請使用 RGB 宏。

*b阿爾法*<br/>
用於描述分層視窗的不恰當性的 Alpha 值。 有關詳細資訊,請參閱`SourceConstantAlpha`[BLENDFUNCTION](/windows/win32/api/wingdi/ns-wingdi-blendfunction)結構的成員。 當*bAlpha*為 0 時,視窗是完全透明的。 當*bAlpha*為 255 時,視窗是不透明的。

*dwFlags*<br/>
指定要執行的操作。 此參數可以是以下一個或多個值。 有關可能值的清單,請參閱[設定分層視窗屬性](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[SetLayeredWindowattributes](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes)的功能,如 Windows SDK 中所述。

## <a name="cwndsetmenu"></a><a name="setmenu"></a>CWnd::SetMenu

將當前功能表設置到指定的菜單。

```
BOOL SetMenu(CMenu* pMenu);
```

### <a name="parameters"></a>參數

*pMenu*<br/>
標識新功能表。 如果此參數為 NULL,則刪除當前選單。

### <a name="return-value"></a>傳回值

如果功能表已更改,則非零;否則 0。

### <a name="remarks"></a>備註

使視窗重新繪製以反映功能表更改。

`SetMenu`不會破壞以前的功能表。 應用程式應調用[CMenu::DestroyMenu](../../mfc/reference/cmenu-class.md#destroymenu)成員函數來完成此任務。

### <a name="example"></a>範例

  請參閱[CMenu::LoadMenu](../../mfc/reference/cmenu-class.md#loadmenu)的範例。

## <a name="cwndsetowner"></a><a name="setowner"></a>CWnd::SetOwner

將目前的視窗的所有者設置到指定的視窗物件。

```cpp
void SetOwner(CWnd* pOwnerWnd);
```

### <a name="parameters"></a>參數

*普恩·恩德*<br/>
標識視窗物件的新擁有者。 如果此參數為 NULL,則視窗物件沒有擁有者。

### <a name="remarks"></a>備註

然後,此擁有者可以從當前視窗物件接收命令消息。 預設情況下,當前視窗的父視窗是其擁有者。

在視窗層次結構無關的視窗對象之間建立連接通常很有用。 例如[,CToolBar](../../mfc/reference/ctoolbar-class.md)會向其擁有者發送通知,而不是向其父級發送通知。 這允許工具列成為一個視窗(如 OLE 容器應用程式視窗)的子視窗,同時向另一個視窗(如就地框架視窗)發送通知。 此外,當伺服器視窗在就地編輯期間停用或啟動時,幀窗口擁有的任何視窗將隱藏或顯示。 此擁有權與 調`SetOwner`用 顯式設置。

該函數的所有權概念不同於[GetWindow](/windows/win32/api/winuser/nf-winuser-getwindow)的擁有權概念。

## <a name="cwndsetparent"></a><a name="setparent"></a>CWnd::設置父級

更改子視窗的父視窗。

```
CWnd* SetParent(CWnd* pWndNewParent);
```

### <a name="parameters"></a>參數

*pWnd 新家長*<br/>
標識新的父視窗。

### <a name="return-value"></a>傳回值

如果成功,指向前一個父視窗物件的指標。 返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

如果子窗口可見,Windows 將執行相應的重繪和重繪。

## <a name="cwndsetproperty"></a><a name="setproperty"></a>CWnd::Set屬性

調用此成員函數以設置*dwDispID*指定的 OLE 控件屬性。

```cpp
void AFX_CDECL SetProperty(
    DISPID dwDispID,
    VARTYPE vtProp, ...);
```

### <a name="parameters"></a>參數

*dwDispID*<br/>
識別要設定的屬性。

*vtProp*<br/>
指定要設定的屬性類型。 如需可能的值，請參閱 [COleDispatchDriver::InvokeHelper](../../mfc/reference/coledispatchdriver-class.md#invokehelper)的＜備註＞一節。

*...*<br/>
*vtProp*指定的類型的單個參數。

### <a name="remarks"></a>備註

> [!NOTE]
> 此函數應僅在表示 OLE`CWnd`控制件的物件上調用。

有關將此成員函數與 OLE 控制容器一起使用的詳細資訊,請參閱文章[ActiveX 控制容器:在 ActiveX 控制件容器中程式設計 ActiveX 控制項](../../mfc/programming-activex-controls-in-a-activex-control-container.md)。

## <a name="cwndsetredraw"></a><a name="setredraw"></a>CWnd::設定重新繪製

應用程式呼叫`SetRedraw`以允許重繪更改或防止重繪更改。

```cpp
void SetRedraw(BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*bredraw*<br/>
指定重繪標誌的狀態。 如果此參數為 TRUE,則設置重繪標誌;如果此參數為 TRUE,則重新繪製標誌將設置為 TRUE。如果 FALSE,則清除標誌。

### <a name="remarks"></a>備註

此成員函數設置或清除重繪標誌。 清除重繪標誌時,每次更改後不會更新內容,在設置重繪標誌之前不會重新繪製。 例如,需要向清單框添加多個項的應用程式可以清除重繪標誌、添加項,然後設置重繪標誌。 最後,應用程式可以調用[無效](#invalidate)或[無效 Rect](#invalidaterect)成員函數,以便重新繪製列表框。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#117](../../mfc/reference/codesnippet/cpp/cwnd-class_58.cpp)]

## <a name="cwndsetscrollinfo"></a><a name="setscrollinfo"></a>CWnd::SetScrollInfo

調用此成員函數以設置`SCROLLINFO`結構維護有關滾動條的資訊。

```
BOOL SetScrollInfo(
    int nBar,
    LPSCROLLINFO lpScrollInfo,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定滾動條是控件還是視窗的非工作區的一部分。 如果它是非工作區的一部分,nBar 還會指示滾動條是水準、垂直還是兩者兼而有之。 它必須是以下項之一:

- SB_CTL包含滾動條控件的參數。 數據`m_hWnd`成員必須是滾動條控制的句柄。

- SB_HORZ 指定視窗是水平滾動條。

- SB_VERT 指定視窗是垂直滾動條。

*lpScrollInfo*<br/>
指向[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構的指標。 有關此結構的詳細資訊,請參閱 Windows SDK。

*bredraw*<br/>
指定是否應重繪滾動條以反映新位置。 如果*bRedraw*為 TRUE,則重繪滾動條。 如果是 FALSE,則不重繪。 默認情況下,滾動條將重繪。

### <a name="return-value"></a>傳回值

如果成功,則返回為 TRUE。 否則,它是 FALSE。

### <a name="remarks"></a>備註

[SCROLLINFO](/windows/win32/api/winuser/ns-winuser-scrollinfo)結構包含有關滾動條的資訊,包括最小和最大滾動位置、頁面大小和滾動框(拇指)的位置。 有關更改`SCROLLINFO`結構預設值的詳細資訊,請參閱 Windows SDK 中的結構主題。

指示滾動條位置的 MFC Windows 消息處理程式[,CWnd:onHScroll](#onhscroll)和[CWnd::onVScroll,](#onvscroll)僅提供 16 位元位置數據。 [GetScrollInfo](#getscrollinfo)`SetScrollInfo`並提供 32 位滾動條位置數據。 因此,應用程式可以在處理或`GetScrollInfo``CWnd::OnHScroll``CWnd::OnVScroll`獲取 32 位滾動條位置數據時調用。

> [!NOTE]
> [CWnd:getScrollInfo](#getscrollinfo)使應用程式能夠使用 32 位滾動條位置。

## <a name="cwndsetscrollpos"></a><a name="setscrollpos"></a>CWnd::SetScrollPos

設置滾動框的當前位置,如果請求,請重繪滾動條以反映滾動框的新位置。

```
int SetScrollPos(
    int nBar,
    int nPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要設置的滾動條。 這個參數可以是以下任一參數:

- SB_HORZ設置視窗水平滾動條中的滾動框的位置。

- SB_VERT 設置視窗垂直滾動欄中的滾動框的位置。

*nPos*<br/>
指定捲軸框的新位置。 它必須在滾動範圍內。

*bredraw*<br/>
指定是否應重新繪製滾動條以反映新的滾動框位置。 如果此參數為 TRUE,則重新繪製滾動條;如果此參數為 TRUE,則重新繪製滾動條。如果 FALSE,則滾動條不會重新繪製。

### <a name="return-value"></a>傳回值

滾動框的上一個位置。

### <a name="remarks"></a>備註

每當滾動條由後續調用到另一個函數重新繪製時,將*bredraw*設置為 FALSE 非常有用。

## <a name="cwndsetscrollrange"></a><a name="setscrollrange"></a>CWnd::SetScrollRange

設定給定捲軸的最小和最大位置值。

```cpp
void SetScrollRange(
    int nBar,
    int nMinPos,
    int nMaxPos,
    BOOL bRedraw = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定要設置的滾動條。 這裡可以是以下值之一:

- SB_HORZ設置視窗的水準滾動條的範圍。

- SB_VERT 設置視窗垂直滾動條的範圍。

*nMinPos*<br/>
指定最小滾動位置。

*nMaxPos*<br/>
指定最大滾動位置。

*bredraw*<br/>
指定是否應重繪滾動條以反映更改。 如果 bRedraw 為 TRUE,則重繪滾動條;如果*bredraw*為 TRUE,則重新繪製滾動條。如果 FALSE,則滾動條不會重繪。

### <a name="remarks"></a>備註

它還可用於隱藏或顯示標準滾動條。

應用程式在處理滾動條通知消息時不應調用此函數來隱藏滾動條。

如果調用`SetScrollRange`後立即調用[SetScrollPos](#setscrollpos)成員函`SetScrollPos`數,則成員函數中的*bRedraw*參數應為 0,以防止滾動條繪製兩次。

標準滾動條的預設範圍為 0 到 100。 滾動條控制項的預設範圍為空 *(nMinPos*和*nMaxPos*值均為 0)。 *nMinPos*和*nMaxPos*指定的值之間的差異不得大於INT_MAX。

## <a name="cwndsettimer"></a><a name="settimer"></a>CWnd::SetTimer

安裝系統計時器。

```
UINT_PTR SetTimer(
    UINT_PTR nIDEvent,
    UINT nElapse,
    void (CALLBACK* lpfnTimer)(HWND,
    UINT,
    UINT_PTR,
    DWORD));
```

### <a name="parameters"></a>參數

*nIDEvent*<br/>
指定非零計時器識別碼。 如果計時器識別碼是唯一的,則此值由傳`SetTimer`回 。 否則,`SetTimer`確定一個新的唯一值,並返回該值。 對於具有 NULL 回檔函數的視窗計時器,該值必須僅對與當前視窗關聯的其他視窗計時器是唯一的。 對於回調計時器,該值對於所有進程中的所有計時器都必須是唯一的。 因此,在創建回調計時器時,返回的值很可能與您指定的值不同。

*脫位*<br/>
指定超時值或間隔(以毫秒為單位)。

*lpfnTimer*<br/>
指定處理`TimerProc`[WM_TIMER](/windows/win32/winmsg/wm-timer)消息的應用程式提供的回調函數的位址。 如果此參數為 NULL,則WM_TIMER消息將放置在應用程式的消息佇列中並`CWnd`由 物件處理。

### <a name="return-value"></a>傳回值

如果函數成功,則新計時器的計時器標識符。 此值可能等於也可能不等於通過*nIDEvent*參數傳入的值。 應用程式應始終將返回值傳遞給[KillTimer](#killtimer)成員函數以終止計時器。 如果成功,則非零;否則,0。

### <a name="remarks"></a>備註

指定間隔值,每次間隔過去時,系統都會將WM_TIMER消息發佈到安裝應用程式的安裝消息佇列,或將消息傳遞給應用程式定義的`TimerProc`回調功能。

*lpfnTimer*回檔函數`TimerProc`不需要命名 ,但必須聲明為靜態函數,並定義如下。

```cpp
void CALLBACK TimerProc(
    HWND hWnd,   // handle of CWnd that called SetTimer
    UINT nMsg,   // WM_TIMER
    UINT_PTR nIDEvent,   // timer identification
    DWORD dwTime    // system time);
```

### <a name="example"></a>範例

此示例使用`CWnd::SetTimer``CWnd::OnTimer`和`CWnd::KillTimer`來處理WM_TIMER消息。 第一個計時器設置為在`OnStartTimer`中 每 2 秒向主幀視窗發送WM_TIMER消息。 事件`OnTimer`處理程式處理主框架視窗WM_TIMER消息。 此方法使 PC 揚聲器每 2 秒發出一次蜂鳴音。 第二個計時器每 3.75 秒向回調功能發送消息。 `OnStopTimer`將通過調用`CWnd::KillTimer`每個計時器 ID 停止兩個計時器。

[!code-cpp[NVC_MFCWindowing#118](../../mfc/reference/codesnippet/cpp/cwnd-class_59.cpp)]

## <a name="cwndsetwindowcontexthelpid"></a><a name="setwindowcontexthelpid"></a>CWnd::設定視窗上下文幫助Id

調用此成員函數將説明上下文標識符與指定的窗口相關聯。

```
BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
```

### <a name="parameters"></a>參數

*dwContextHelpId*<br/>
説明上下文標識碼。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

如果子視窗沒有説明上下文標識符,它將繼承其父窗口的標識符。 同樣,如果擁有的窗口沒有説明上下文標識符,它將繼承其擁有者窗口的標識符。 説明上下文標識碼的這種繼承允許應用程式僅為對話方塊及其所有控制項設置一個標識符。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#119](../../mfc/reference/codesnippet/cpp/cwnd-class_60.cpp)]

## <a name="cwndsetwindowplacement"></a><a name="setwindowplacement"></a>CWnd::設定視窗放置

設定視窗的顯示狀態和一般 (還原)、最小化和最大化位置。

```
BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);
```

### <a name="parameters"></a>參數

*普爾溫德普爾*<br/>
指向指定新顯示狀態和位置的[WINDOW 放置](/windows/win32/api/winuser/ns-winuser-windowplacement)結構。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

## <a name="cwndsetwindowpos"></a><a name="setwindowpos"></a>CWnd::設定視窗Pos

更改子視窗、彈出視窗和頂級視窗的大小、位置和 Z 順序。

```
BOOL SetWindowPos(
    const CWnd* pWndInsertAfter,
    int x,
    int y,
    int cx,
    int cy,
    UINT nFlags);
```

### <a name="parameters"></a>參數

*pWndInsert 後*<br/>
標識將在`CWnd`Z 順序中`CWnd`在此 物件之前(高於)的物件。 這個參數可以是指向`CWnd`或指向以下值之一的指標:

- `wndBottom`將視窗放在 Z 順序的底部。 如果這是最`CWnd`頂層的視窗,則視窗將失去其最上面狀態;如果該視窗是最頂層視窗。"系統將視窗放在所有其他視窗的底部。

- `wndTop`將視窗放在 Z 順序的頂部。

- `wndTopMost`將視窗置於所有非頂部視窗之上。 即使該視窗已停用,該視窗也能保持其最頂層位置。

- `wndNoTopMost`將視窗重新置放到所有非最頂層視窗的頂部(即所有最頂層視窗後面)。 如果視窗已經是非最頂層的視窗,則此標誌不起作用。

有關如何使用此參數的規則,請參閱本主題的「備註」部分。

*x*<br/>
指定視窗左側的新位置。

*Y*<br/>
指定視窗頂部的新位置。

*殘雪*<br/>
指定視窗的新寬度。

*cy*<br/>
指定視窗的新高度。

*nFlags*<br/>
指定大小調整和定位選項。 這裡可以是以下旗標的組合:

- SWP_DRAWFRAME在視窗周圍繪製框架(在創建視窗時定義)。

- SWP_FRAMECHANGED向視窗發送WM_NCCALCSIZE消息,即使視窗的大小未更改也是如此。 如果未指定此標誌,則僅在更改視窗大小時發送WM_NCCALCSIZE。

- SWP_HIDEWINDOW隱藏視窗。

- SWP_NOACTIVATE不激活視窗。 如果未設置此標誌,則視窗將啟動並移動到最頂層或最頂層組的頂部(具體取決於*pWndInsert 後*參數的設置)。

- SWP_NOCOPYBITS丟棄工作區的全部內容。 如果未指定此標誌,則在視窗調整大小或重新置放後,將保存工作區的有效內容並複製回工作區。

- SWP_NOMOVE 保留目前位置(忽略*x*和*y*參數)。

- SWP_NOOWNERZORDER不更改所有者視窗在 Z 順序中的位置。

- SWP_NOREDRAW不重繪更改。 如果設置了此標誌,則不進行任何重新繪製。 這適用於工作區、非工作區(包括標題和滾動條)以及因移動視窗而打開的父視窗的任何部分。 設置此標誌時,應用程式必須顯式無效或重繪視窗和父窗口必須重繪的任何部分。

- SWP_NOREPOSITION與SWP_NOOWNERZORDER相同。

- SWP_NOSENDCHANGING防止視窗接收WM_WINDOWPOSCHANGING消息。

- SWP_NOSIZE 保留目前的大小(忽略*cx*和*cy*參數)。

- SWP_NOZORDER 保留當前排序(忽略*pWndInsert 後*)。

- SWP_SHOWWINDOW顯示視窗。

### <a name="return-value"></a>傳回值

如果函數成功,則非零;否則,0。

### <a name="remarks"></a>備註

視窗按 Z 順序在螢幕上訂購;Z 順序頂部的視窗顯示在順序中所有其他視窗的頂部。

子視窗的所有座標都是客戶端座標(相對於父視窗工作區的左上角)。

視窗可以通過將*pWndInsertAfter*參數設置為 **&wndTopMost**並確保未設置SWP_NOZORDER標誌或設置視窗的 Z 順序,使其位於任何現有最頂層視窗之上,從而將視窗移動到 Z 順序的頂部。 當非最頂層視窗位於最上面時,其擁有的視窗也會成為最頂端的視窗。 其擁有者不會更改。

如果最頂層視窗重新置放到 Z 順序的底部 **(&wndBottom)** 或任何非最頂層視窗之後,則該視窗將不再最頂端。 當最頂層的視窗非頂部時,其所有擁有者及其擁有的視窗也創建非最頂端視窗。

如果未指定SWP_NOACTIVATE或SWP_NOZORDER(即,當應用程式請求同時啟動視窗並將其置於指定的 Z 順序中時),則僅在以下情況下使用*pWndInsert 後*指定的值:

- **&wndTopMost**或 **&wndNoTopMost**在*pwndInsert 後參數*中指定。

- 此視窗不是活動視窗。

應用程式無法啟動非活動視窗,而不將其帶到 Z 順序的頂部。 應用程式可以不受限制地更改啟動視窗的 Z 順序。

非最頂層視窗可能擁有最頂層視窗,但反之亦然。 最頂層視窗擁有的任何視窗(例如,對話框)本身都是最頂層的視窗,以確保所有擁有的視窗都位於其擁有者之上。

使用 Windows 版本 3.1 及更高版本時,視窗可以移動到 Z 順序的頂部,並通過設置其WS_EX_TOPMOST樣式將其鎖定在那裡。 即使停用,這種最頂層的視窗也能保持其最頂層的位置。 例如,選擇「WinHelp 始終位於頂部」命令使「幫助」視窗成為最頂層,然後在返回到應用程式時保持可見。

若要創建最頂層視窗,請在創建`SetWindowPos`視窗時使用*pWndInsert 後參數*&**wndTopMost**調用,或在創建視窗時設置WS_EX_TOPMOST樣式。

如果 Z 順序包含具有WS_EX_TOPMOST樣式的任何視窗,則使用 **&wndTopMost**值移動的視窗將放置在所有非最頂層視窗的頂部,但位於任何最頂層視窗的下方。 當應用程式啟動沒有WS_EX_TOPMOST位的非活動視窗時,該視窗將移動到所有非最頂層視窗之上,但位於任何最頂層視窗下方。

如果在`SetWindowPos` *pwndInsert 後一個*參數 **&wndBottom**`CWnd`並且是最頂端視窗時調用,則視窗將失去其最上面狀態(WS_EX_TOPMOST清除),並且系統將視窗置於 Z 順序的底部。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#120](../../mfc/reference/codesnippet/cpp/cwnd-class_61.cpp)]

## <a name="cwndsetwindowrgn"></a><a name="setwindowrgn"></a>Cwnd::SetWindowRgn

調用此成員函數以設置視窗的區域。

```
int SetWindowRgn(
    HRGN hRgn,
    BOOL bRedraw);
```

### <a name="parameters"></a>參數

*hRgn*<br/>
區域句柄。

*bredraw*<br/>
如果為 TRUE,操作系統在設置區域後重繪視窗;如果為 TRUE,則在設置區域後重新繪製視窗。否則,它不。 通常,如果視窗可見,則將*bredraw*設置為 TRUE。 如果設置為 TRUE,系統會向視窗發送WM_WINDOWPOSCHANGING並WM_WINDOWPOSCHANGED消息。

### <a name="return-value"></a>傳回值

如果函數成功,則返回值為非零。 如果此函式失敗，則傳回值為零。

### <a name="remarks"></a>備註

視窗視窗區域的座標相對於視窗的左上角,而不是視窗的工作區。

成功呼叫`SetWindowRgn`後, 作業系統擁有區域句柄*hRgn*指定的區域。 操作系統不創建區域的副本,因此不要使用此區域句柄進行任何進一步的函數調用,也不會關閉此區域句柄。

## <a name="cwndsetwindowtext"></a><a name="setwindowtext"></a>CWnd::設定視窗文字

將視窗的標題設定為指定的文字。

```cpp
void SetWindowText(LPCTSTR lpszString);
```

### <a name="parameters"></a>參數

*lpszString*<br/>
指向[CString](../../atl-mfc-shared/reference/cstringt-class.md)物件或 null 終止字串,以用作新標題或控制項文字。

### <a name="remarks"></a>備註

如果視窗是控制項,則設置控制件中的文本。

此功能會導致[將WM_SETTEXT](/windows/win32/winmsg/wm-settext)消息發送到此視窗。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#121](../../mfc/reference/codesnippet/cpp/cwnd-class_62.cpp)]

## <a name="cwndshowcaret"></a><a name="showcaret"></a>CWnd::秀卡丁

在護台的當前位置顯示螢幕上的護台。

```cpp
void ShowCaret();
```

### <a name="remarks"></a>備註

顯示後，插入號會開始自動閃爍。

僅當`ShowCaret`該圖具有當前形狀且未連續隱藏兩次或更多次時,成員函數才會顯示該 care。 如果該護圖不歸此視窗所有,則不顯示該護圖。

隱藏隱匿是累積的。 如果連續調用了五次[HideCaret](#hidecaret)成員函`ShowCaret`數, 則必須調用五次才能顯示該圖。

care是共用資源。 僅當具有輸入焦點或處於活動狀態時,視窗才應顯示該說明。

### <a name="example"></a>範例

  請參閱[CWnd 示例:createCare。](#createcaret)

## <a name="cwndshowownedpopups"></a><a name="showownedpopups"></a>CWnd::顯示擁有的Popups

顯示或隱藏此視窗擁有的所有彈出視窗。

```cpp
void ShowOwnedPopups(BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*b 顯示*<br/>
指定彈出視窗是顯示還是隱藏。 如果此參數為 TRUE,則顯示所有隱藏的彈出視窗。 如果此參數為 FALSE,則所有可見的彈出視窗都將隱藏。

### <a name="example"></a>範例

  請參閱[CWnd 的範例::SetWindowPos](#setwindowpos)。

## <a name="cwndshowscrollbar"></a><a name="showscrollbar"></a>CWnd::顯示滾動欄

顯示或隱藏滾動條。

```cpp
void ShowScrollBar(
    UINT nBar,
    BOOL bShow = TRUE);
```

### <a name="parameters"></a>參數

*nBar*<br/>
指定滾動條是控件還是視窗的非工作區的一部分。 如果它是非工作區的一部分 *,nBar*還會指示滾動條是水準、垂直還是兩者兼而有之。 它必須是以下項之一:

- SB_BOTH 指定視窗的水準和垂直滾動條。

- SB_HORZ 指定視窗是水平滾動條。

- SB_VERT 指定視窗是垂直滾動條。

*b 顯示*<br/>
指定 Windows 是顯示還是隱藏滾動條。 如果此參數為 TRUE,將顯示滾動條;如果此參數為 TRUE,則顯示滾動條。否則滾動條將隱藏。

### <a name="remarks"></a>備註

在處理滾動條通知消息`ShowScrollBar`時,應用程式不應調用以隱藏滾動條。

## <a name="cwndshowwindow"></a><a name="showwindow"></a>CWnd::顯示視窗

設置視窗的可見性狀態。

```
BOOL ShowWindow(int nCmdShow);
```

### <a name="parameters"></a>參數

*nCmdShow*<br/>
指定如何顯示`CWnd`。 它必須是以下值之一:

- SW_HIDE隱藏此視窗並將啟動傳遞到另一個視窗。

- SW_MINIMIZE最小化視窗並啟動系統清單中的頂級視窗。

- SW_RESTORE啟動並顯示視窗。 如果視窗最小化或最大化,Windows 會將其還原到其原始大小和位置。

- SW_SHOW啟動視窗,並將其以當前大小和位置顯示。

- SW_SHOWMAXIMIZED啟動視窗並將其顯示為最大化視窗。

- SW_SHOWMINIMIZED啟動視窗並將其顯示為圖示。

- SW_SHOWMINNOACTIVE將窗口顯示為圖示。 當前處於活動狀態的視窗保持活動狀態。

- SW_SHOWNA 顯示視窗當前狀態。 當前處於活動狀態的視窗保持活動狀態。

- SW_SHOWNOACTIVATE 以最新的大小和位置顯示視窗。 當前處於活動狀態的視窗保持活動狀態。

- SW_SHOWNORMAL 啟動並顯示視窗。 如果視窗最小化或最大化,Windows 會將其還原到其原始大小和位置。

### <a name="return-value"></a>傳回值

如果視窗以前可見,則非零;0,`CWnd`如果以前隱藏。

### <a name="remarks"></a>備註

`ShowWindow`對於[CWinApp::m_nCmdShow](../../mfc/reference/cwinapp-class.md#m_ncmdshow)的主視窗,每個應用程式只能調用一次。 後續調用`ShowWindow`必須使用上面列出的值之一,而不是指定`CWinApp::m_nCmdShow`的 值之一。

### <a name="example"></a>範例

  請參閱[CWnd::CalcWindowRect 的範例](#calcwindowrect)。

## <a name="cwndsubclassdlgitem"></a><a name="subclassdlgitem"></a>Cwnd::子類Dlg專案

將此成員函數調用"動態子類"從對話框範本創建的控制項並將其附加到此`CWnd`物件。

```
BOOL SubclassDlgItem(
    UINT nID,
    CWnd* pParent);
```

### <a name="parameters"></a>參數

*nID*<br/>
控件的識別碼。

*pParent*<br/>
控件的父級(通常是對話框)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

當控件動態下課時,視窗消息將路由通過`CWnd`''的消息映射和調用消息處理程式`CWnd`在 ''類第一。 傳遞給基類的消息將傳遞到控制項中的預設消息處理程式。

此成員函數將 Windows 控制件`CWnd`附加到 物件,並替換`WndProc``AfxWndProc`控制件和函數。 該函數將舊存儲在`WndProc``GetSuperWndProcAddr`成員函數返回的位置中。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#122](../../mfc/reference/codesnippet/cpp/cwnd-class_63.cpp)]

## <a name="cwndsubclasswindow"></a><a name="subclasswindow"></a>CWnd::子類視窗

將此成員函數調用為"動態子類"視窗並將其附加到此`CWnd`物件。

```
BOOL SubclassWindow(HWND hWnd);
```

### <a name="parameters"></a>參數

*hWnd*<br/>
視窗的句柄。

### <a name="return-value"></a>傳回值

如果函式成功則為非零，否則為 0。

### <a name="remarks"></a>備註

動態子分類視窗時,視窗消息將路由通過`CWnd`『的消息映射和調用消息處理程式`CWnd`在 』『類第一。 傳遞給基類的消息將傳遞到視窗中的預設消息處理程式。

此成員函數將 Windows 控制件`CWnd`附加到 物件,並`WndProc``AfxWndProc`替換視窗和函數。 函數在物件中存儲指向舊`WndProc`項`CWnd`的指標。

> [!NOTE]
> 調用此函數時,視窗不能已附加到 MFC 物件。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#123](../../mfc/reference/codesnippet/cpp/cwnd-class_64.cpp)]

## <a name="cwndunlockwindowupdate"></a><a name="unlockwindowupdate"></a>CWnd::解鎖視窗更新

調用此成員函數以解鎖與`CWnd::LockWindowUpdate`鎖定的視窗。

```cpp
void UnlockWindowUpdate();
```

### <a name="remarks"></a>備註

一次只能使用鎖定一個視窗`LockWindowUpdate`。 有關鎖定視窗的詳細資訊,請參閱[CWnd:鎖視窗更新](#lockwindowupdate)或 Win32 功能[鎖定 Window 更新](/windows/win32/api/winuser/nf-winuser-lockwindowupdate)。

## <a name="cwndunsubclasswindow"></a><a name="unsubclasswindow"></a>CWnd::取消子類視窗

調用此成員函數以將其`WndProc`設置回其原始值,並將HWND標識的視窗`CWnd`從物件中分離出來。

```
HWND UnsubclassWindow();
```

### <a name="return-value"></a>傳回值

未下分類視窗的句柄。

### <a name="example"></a>範例

  請參閱[CWnd::子類視窗](#subclasswindow)的範例。

## <a name="cwndupdatedata"></a><a name="updatedata"></a>CWnd::更新數據

調用此成員函數以在對話框中初始化數據,或檢索和驗證對話框數據。

```
BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
```

### <a name="parameters"></a>參數

*b 儲存與驗證*<br/>
指示正在初始化對話方塊 (FALSE) 還是正在檢索資料 (TRUE) 的標誌。

### <a name="return-value"></a>傳回值

如果操作成功,則非零;否則 0。 如果*bSaveAndValidat*e 為 TRUE,則非零的返回值表示已成功驗證數據。

### <a name="remarks"></a>備註

當在`UpdateData`[CDialog::OnitDialog](../../mfc/reference/cdialog-class.md#oninitdialog)的預設實現中建立模式對話方塊時,框架會自動調用*bSaveAndValidate*設置為 FALSE。 調用在對話框可見之前進行。 [CDialog:onOK](../../mfc/reference/cdialog-class.md#onok)的預設實現呼叫此成員函數 *,bSaveAndValidate*設置為 TRUE 以檢索資料,如果成功,將關閉該對話方塊。 (如果在對話框中按一下"取消"按鈕,則對話框將關閉,而不會檢索數據。

## <a name="cwndupdatedialogcontrols"></a><a name="updatedialogcontrols"></a>CWnd::更新對話控制

調用此成員函數以更新對話框或視窗中使用[ON_UPDATE_COMMAND_UI](message-map-macros-mfc.md#on_update_command_ui)回調機制的對話方塊或視窗中的對話方塊或其他控制器的狀態。

```cpp
void UpdateDialogControls(
    CCmdTarget* pTarget,
    BOOL bDisableIfNoHndler);
```

### <a name="parameters"></a>參數

*p 目標*<br/>
指向應用程式的主框架視窗,用於路由更新消息。

*b 關閉IfNoHndler*<br/>
指示是否應自動顯示為禁用的控制件的標誌。

### <a name="remarks"></a>備註

如果子控制式未處理程式,並且*bDisableIfNohndler*為 TRUE,則子控制項將被禁用。

框架調用此成員函數用於對話方塊列或工具列中的控制項,作為應用程式空閒處理的一部分。

## <a name="cwndupdatelayeredwindow"></a><a name="updatelayeredwindow"></a>CWnd::更新分層視窗

更新分層視窗的位置、大小、形狀、內容和透明度。

```
BOOL UpdateLayeredWindow(
    CDC* pDCDst,
    POINT* pptDst,
    SIZE* psize,
    CDC* pDCSrc,
    POINT* pptSrc,
    COLORREF crKey,
    BLENDFUNCTION* pblend,
    DWORD dwFlags);
```

### <a name="parameters"></a>參數

*pDCDst*<br/>
指向螢幕的設備上下文的指標。 它用於更新視窗內容時的調色板顏色匹配。 如果*pDCDst*為 NULL,將使用預設調色板。

如果*pDCSrc*為 NULL,*則 pDCDst*必須為 NULL。

*普特德斯特*<br/>
指向指定分層視窗`POINT`的新螢幕位置的結構的指標。 如果目前位置未更改,則*pptDst*可以是 NULL。

*psize*<br/>
指向指定分層`SIZE`視窗的新大小的結構的指標。 如果視窗的大小沒有變化,*則大小*可以為 NULL。

如果*pDCSrc*為 NULL,*則大小*必須為 NULL。

*pDCSrc*<br/>
指向定義分層視窗的曲面的 DC 的指標。 如果視窗的形狀和可視上下文未更改 *,pDCSrc*可以為 NULL。

*pptSrc*<br/>
指向`POINT`指定圖層在設備上下文中位置的結構的指標。

如果*pDCSrc*為 NULL,則*pptSrc*應為 NULL。

*crKey*<br/>
指向 COLORREF 值的指標,該值指定在組合分層視窗時要使用的透明度顏色鍵。 此顏色的視窗繪製的所有圖元都將是透明的。 要生成 COLORREF,請使用 RGB 宏。

*pblend*<br/>
指向[BLEND工作](/windows/win32/api/wingdi/ns-wingdi-blendfunction)結構的指標,該結構指定在組合分層視窗時要使用的透明度值。

*dwFlags*<br/>
指定要執行的操作。 此參數可以是以下一個或多個值。 有關可能值的清單,請參閱[更新分層視窗](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)。

### <a name="return-value"></a>傳回值

如果函式成功則為非零值，否則為 0。

### <a name="remarks"></a>備註

此成員函數類比函數[UpdateLayeredWindow](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow)的功能,如 Windows SDK 中所述。

## <a name="cwndupdatewindow"></a><a name="updatewindow"></a>CWnd::更新視窗

如果更新區域不為空,則通過發送[WM_PAINT](/windows/win32/gdi/wm-paint)消息更新工作區。

```cpp
void UpdateWindow();
```

### <a name="remarks"></a>備註

成員`UpdateWindow`函數繞過應用程式佇列直接發送WM_PAINT消息。 如果更新區域為空,則不發送WM_PAINT。

### <a name="example"></a>範例

[!code-cpp[NVC_MFCWindowing#124](../../mfc/reference/codesnippet/cpp/cwnd-class_65.cpp)]

## <a name="cwndvalidaterect"></a><a name="validaterect"></a>CWnd::驗證雷ct

通過從視窗的更新區域中刪除矩形,驗證給定矩形中的工作區。

```cpp
void ValidateRect(LPCRECT lpRect);
```

### <a name="parameters"></a>參數

*lpRect*<br/>
包含包含要從更新區域中移除的矩形的客戶端座標的[CRect](../../atl-mfc-shared/reference/crect-class.md)物件或[RECT 結構](/windows/win32/api/windef/ns-windef-rect)。 如果*lpRect*為 NULL,則驗證整個視窗。

### <a name="remarks"></a>備註

[BeginPaint](#beginpaint)成員函數會自動驗證整個工作區。 `ValidateRect`如果在下次生成[WM_PAINT](/windows/win32/gdi/wm-paint)之前需要驗證更新區域的一部分,則不應調用[驗證和驗證 Rgn](#validatergn)成員函數。

Windows將繼續生成WM_PAINT消息,直到驗證當前更新區域。

## <a name="cwndvalidatergn"></a><a name="validatergn"></a>CWnd:驗證Rgn

通過從視窗的當前更新區域中刪除區域來驗證給定區域內的工作區。

```cpp
void ValidateRgn(CRgn* pRgn);
```

### <a name="parameters"></a>參數

*pRgn*<br/>
指向[CRgn](../../mfc/reference/crgn-class.md)物件的指標,用於標識定義要從更新區域中刪除的區域的區域。 如果此參數為 NULL,則刪除整個工作區。

### <a name="remarks"></a>備註

給定區域以前必須由區域函數創建。 區域座標假定為客戶端座標。

[BeginPaint](#beginpaint)成員函數會自動驗證整個工作區。 如果在生成下一[WM_PAINT](/windows/win32/gdi/wm-paint)`ValidateRgn`消息之前 必須驗證更新區域的一部分,則不應調用[驗證雷Ct](#validaterect)或成員函數。

## <a name="cwndwindowfrompoint"></a><a name="windowfrompoint"></a>Cwnd::視窗從點

檢索包含指定點的視窗;*點*必須指定螢幕上點的螢幕座標。

```
static CWnd* PASCAL WindowFromPoint(POINT point);
```

### <a name="parameters"></a>參數

*點*<br/>
指定定義要檢查的點的[CPoint](../../atl-mfc-shared/reference/cpoint-class.md)物件或[POINT](/windows/win32/api/windef/ns-windef-point)資料結構。

### <a name="return-value"></a>傳回值

指向點所在的視窗物件的指標。 如果給定點上不存在視窗,則為 NULL。 返回的指標可能是臨時的,不應存儲以供以後使用。

### <a name="remarks"></a>備註

`WindowFromPoint`不會檢索隱藏或禁用的視窗,即使該點位於視窗中也是如此。 應用程式應使用[子視窗從點](#childwindowfrompoint)成員函數進行非限制性搜索。

## <a name="cwndwindowproc"></a><a name="windowproc"></a>CWnd::視窗Proc

為`CWnd`物件提供`WindowProc`Windows 過程 ( ) 。

```
virtual LRESULT WindowProc(
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
```

### <a name="parameters"></a>參數

*message*<br/>
指定要處理的 Windows 訊息。

*wParam*<br/>
提供用於處理消息的其他資訊。 參數值取決於消息。

*lParam*<br/>
提供用於處理消息的其他資訊。 參數值取決於消息。

### <a name="return-value"></a>傳回值

返回值取決於消息。

### <a name="remarks"></a>備註

它通過視窗的消息映射調度消息。

## <a name="cwndwinhelp"></a><a name="winhelp"></a>CWnd::贏説明

呼叫以初始化 WinHelp 應用程式。

```
virtual void WinHelp(
    DWORD_PTR dwData,
    UINT nCmd = HELP_CONTEXT);
```

### <a name="parameters"></a>參數

*dwData*<br/>
指定其他數據。 使用的值取決於*nCmd*參數的值。

*nCmd*<br/>
指定要求的說明類型。 有關可能值的清單及其如何影響*dwData*參數,請參閱 Windows SDK 中的[WinHelp](/windows/win32/api/winuser/nf-winuser-winhelpw) Windows 功能。

### <a name="remarks"></a>備註

有關詳細資訊[,請參閱 CWinApp:WinHelp。](../../mfc/reference/cwinapp-class.md#winhelp)

## <a name="cwndregistertouchwindow"></a><a name="registertouchwindow"></a>CWnd::註冊觸摸視窗

註冊或取消註冊 Windows 觸摸支援。

```
BOOL RegisterTouchWindow(
    BOOL bRegister = TRUE,
    ULONG ulFlags = 0);
```

### <a name="parameters"></a>參數

*b 註冊*<br/>
TRUE 表示註冊 Windows 觸摸支援;否則。

*ulFlags*<br/>
指定可選修改的一組位標誌。 此欄位可能包含 0 或以下值之一:TWF_FINETOUCH,TWF_WANTPALM。

### <a name="return-value"></a>傳回值

如果成功，則為 TRUE，否則為 FALSE。

### <a name="remarks"></a>備註

## <a name="cwndresizedynamiclayout"></a><a name="resizedynamiclayout"></a>CWnd::調整動態佈局

如果已啟用視窗的動態配置，則會在視窗大小變更以調整子視窗的版面配置時由架構呼叫。

```
virtual void ResizeDynamicLayout();
```

### <a name="remarks"></a>備註

## <a name="see-also"></a>另請參閱

[CCmdTarget 類別](../../mfc/reference/ccmdtarget-class.md)<br/>
[階層架構圖表](../../mfc/hierarchy-chart.md)<br/>
[CFrameWnd 類別](../../mfc/reference/cframewnd-class.md)<br/>
[CView 類別](../../mfc/reference/cview-class.md)
