---
title: "1.3 Execution Model | Microsoft Docs"
ms.custom: ""
ms.date: "12/05/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
caps.latest.revision: 5
caps.handback.revision: 5
author: "mikeblome"
ms.author: "mblome"
manager: "ghogen"
---
# 1.3 Execution Model
[!INCLUDE[vs2017banner](../../assembler/inline/includes/vs2017banner.md)]

OpenMP 會使用分叉\-聯結平行執行模型。  雖然這個分叉\-聯結模型可以用於解決各種問題，它比較適合大型陣列為基礎的應用程式。  OpenMP 的目的在於將正確執行兩者都像平行程式 \(多執行緒的執行和完整的 OpenMP 支援程式庫\) 的支援程式，並為循序程式 \(忽略指示詞和簡單的 OpenMP stub 程式庫\)。  不過，它有可能，並允許開發並不會無法正確運作時循序執行的程式。  此外，不同程度的平行處理原則可能會導致不同的數字結果由於的數字的操作關聯中的變更。  比方說，序列加法減少可能有不同的模式比平行降低加入關聯。  這些不同的關聯可能會變更浮點數加法的結果。  
  
 OpenMP C\/C\+\+ 的 api 撰寫的程式開始執行做為單一執行緒執行呼叫的*主執行緒*。  序列的區域中的主執行緒執行，直到遇到第一個平行建構。  在 OpenMP C\/C\+\+ 的 API， **平行**指示詞會構成平行建構。  發生的平行建構函式時，主執行緒會建立執行緒，一群，並在母片會成為小組的主版。  在小組中的每一個執行緒執行的陳述式，在平行區域，除了工作共用的結構的動態範圍內。  工作共用的結構必須發生在相同的順序，小組中的所有執行緒，以及相關聯的結構化區塊內的陳述式會執行下列一或多個執行緒。  最後的工作共用的建構，但不暗示障盾`nowait`子句小組中的所有執行緒執行。  
  
 如果執行緒會修改共用的物件，它會影響不僅它自己的執行環境，而且還在程式中的其他執行緒。  所作的修改保證物件宣告為動態時，才會完成，從其他執行緒，在下一步的序列點之一的觀點 \(如圖所定義的基本語言\)。  否則，所作的修改會保證完成後第一次修改執行緒，並再 \(或同時\) 其他執行緒，會遇到**排清**指示詞所指定的物件 \(隱含或明確\)。  請注意，當**排清** 以其他 OpenMP 指示詞隱含的指示詞並不完全保證您想要排序的副作用，是提供詳細、 明確的程式設計人員的責任 **排清**指示詞。  
  
 完成平行建構的詳細資訊，隱含的防護機制，在同步處理小組中的執行緒，並只有主要執行緒會繼續執行。  在單一程式中，可以指定任意數目的平行建構。  如此一來，程式可能會分叉，加入 \[在執行期間多次。  
  
 OpenMP C\/C\+\+ 的 API 可讓程式設計人員使用平行建構中呼叫的函式中的指示詞。  指示詞並不會出現在平行建構的語彙範圍，但可能會碰到的動態範圍稱為*孤兒*指示詞。  失去關聯的指示詞讓程式設計人員能夠僅只需稍微變更循序程式的平行地執行他們的程式的主要部份。  使用這項功能，使用者可以撰寫程式碼的程式在呼叫樹狀圖最高的層級的平行建構，並使用指示詞來控制在呼叫的函式任一執行。  
  
 未同步處理的呼叫 c 和 C\+\+ 將輸出寫入相同檔案中的函式可能會導致的輸出其中不同的執行緒所寫入的資料會出現在不具決定性的順序。  同樣地，未同步處理輸入相同的檔案中讀取的函式的呼叫可能會讀取不具決定性的順序中的資料。  不同步的 I\/O、 使用的每個執行緒存取不同的檔案，會產生序列執行的 I\/O 函式與相同的結果。