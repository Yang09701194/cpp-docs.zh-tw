---
title: "1.3 執行模式 |Microsoft 文件"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: cpp-windows
ms.tgt_pltfrm: 
ms.topic: article
dev_langs: C++
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
caps.latest.revision: "5"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.openlocfilehash: dddc4c10a77ca5dd277435837169478e0d5daca5
ms.sourcegitcommit: ebec1d449f2bd98aa851667c2bfeb7e27ce657b2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/24/2017
---
# <a name="13-execution-model"></a>1.3 執行模式
OpenMP 使用分岔 / 聯結模型的平行執行。 雖然這個分岔 / 聯結模型適合用來解決各種問題是，它是稍微適合大型陣列為基礎的應用程式。 OpenMP 的目的，將會正確執行兩者都為平行程式 （執行多個執行緒和完整的 OpenMP 支援程式庫） 的支援程式並為 （忽略指示詞和簡單的 OpenMP 虛設常式程式庫） 的循序程式。 不過，有可能，允許開發不會無法正確運作時循序執行的程式。 此外，不同程度的平行處理原則可能會導致不同的數值結果因為關聯的數字的操作中的變更。 例如，序列加法減少可能有不同的模式比平行減少加法關聯。 這些不同的關聯可能會變更浮點加法的結果。  
  
 OpenMP C/c + + api 撰寫的程式開始執行呼叫視為單一執行緒執行*主要執行緒*。 序列的區域中的主要執行緒執行，直到遇到第一個平行建構。 OpenMP C/c + + 應用程式開發介面，在**平行**指示詞會構成平行建構。 發生平行建構時，主要執行緒會建立的執行緒，小組，主機會成為主要的小組。 在小組中的每個執行緒的平行區域，除了工作共用建構動態的範圍中執行的陳述式。 工作共用建構必須發生在相同的順序，小組中的所有執行緒，並由一個或多個執行緒執行相關聯的結構化區塊內的陳述式。 屏障沒有工作共用建構結尾隱含`nowait`子句在小組中的所有執行緒執行。  
  
 如果執行緒修改共用的物件，它會影響而不是只是它自己的執行環境，這些程式中的其他執行緒。 修改保證完成時，從其他執行緒，在下一個序列點的其中一個的觀點來看 （如基本語言所定義），只有當物件宣告為變動性。 否則，保證所作的修改之後第一次修改執行緒，在完成，然後 （或同時） 遇到其他執行緒，**排清**指示詞，指定的物件 （隱含或明確）。 請注意，當**排清**由其他 OpenMP 指示詞隱含的指示詞不足以確保所需排序的副作用，程式設計人員必須負責提供其他的明確**排清**指示詞。  
  
 平行建構完成，在小組中的執行緒同步處理在隱含的障礙，並只在主要執行緒會繼續執行。 在單一程式中，就可以指定任意數目的平行建構。 如此一來，程式可能會分岔，加入在執行期間的許多次。  
  
 OpenMP C/c + + 應用程式開發介面可讓程式設計人員使用指示詞從平行建構內呼叫的函式中。 指示詞不會出現在平行建構的語彙範圍，但可能會在動態範圍稱為*孤立*指示詞。 被遺棄的指示詞可讓程式設計人員以平行方式只有最少變更的循序程式執行其程式的主要部分。 利用此功能，使用者可以在程式呼叫樹狀圖最上層的層級的平行建構程式碼和使用指示詞控制任何呼叫的函式中執行。  
  
 未同步處理對 C 和 c + + 呼叫輸出寫入至相同檔案的函式可能會導致不同的執行緒所撰寫的資料出現在不具決定性的順序中的輸出。 同樣地，未同步處理的呼叫，輸入從相同的檔案讀取的函式可以讀取順序不具決定性的資料。 未同步處理的 I/O，使用的每個執行緒存取不同的檔案，會產生與序列執行 I/O 函式相同的結果。