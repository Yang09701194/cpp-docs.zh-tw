---
title: 1.3 執行模式 |Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: 85ae8bc4-5bf0-45e0-a45f-02de9adaf716
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: c284563a47d21abc9a1dacf045238449d64205d5
ms.sourcegitcommit: 799f9b976623a375203ad8b2ad5147bd6a2212f0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/19/2018
ms.locfileid: "46394006"
---
# <a name="13-execution-model"></a>1.3 執行模式

OpenMP 會使用平行執行的分岔 / 聯結模型。 雖然此分岔 / 聯結模型很適合用來解決各種問題，它有點量身打造的大型陣列為基礎的應用程式。 OpenMP 的目的在於將會正確執行兩者都為平行程式 （多執行緒的執行和完整的 OpenMP 支援程式庫） 的支援計劃，並與 （忽略指示詞和簡單的 OpenMP 虛設常式程式庫） 的循序程式一樣。 不過，它可能會允許開發行為不正確時循序執行的程式。 此外，不同程度的平行處理原則可能會導致不同的數字結果由於關聯的數值運算中的變更。 比方說，序列加法減少可能有不同的模式比平行約化新增關聯性。 這些不同的關聯可能會變更浮點加法的結果。

OpenMP C/c + + api 撰寫的程式開始執行以單一執行緒的方式執行稱為*主要執行緒*。 序列的區域中的主要執行緒執行，直到遇到的第一個平行建構。 在 OpenMP C/c + + API 中，**平行**指示詞會構成平行建構。 發生平行建構時，主要執行緒建立的執行緒，團隊，主機會成為主要的小組。 在小組中的每個執行緒的平行區域，除了工作共用建構動態的範圍中執行的陳述式。 工作共用建構必須發生在相同的順序，小組中的所有執行緒，並由一個或多個執行緒執行相關聯的結構化區塊中的陳述式。 隱含工作共用建構不含結尾屏障`nowait`子句在小組中的所有執行緒執行。

如果執行緒修改共用的物件，它會影響其本身的執行環境，不僅那些程式中的其他執行緒。 修改保證完成時，從觀點來看，其他執行緒，在下一個序列點之一 （如基底的語言所定義），只有當物件宣告為 volatile。 修改後第一次修改執行緒，要完成的保證，否則為，然後 （或同時） 其他執行緒，會遇到**排清**（隱含或明確） 指定的物件的指示詞。 請注意，當**排清**隱含其他 OpenMP 指示詞的指示詞不敷使用可確保所需的排序的副作用，程式設計人員必須負責提供其他的明確**排清**指示詞。

平行建構完成，小組中的執行緒同步處理在隱含的障礙，並只在主要執行緒會繼續執行。 在單一程式中，就可以指定任意數目的平行建構。 如此一來，程式可能會建立分支，加入在執行期間的許多次。

OpenMP C/c + + API 可讓程式設計人員使用指示詞，從平行建構內呼叫的函式中。 呼叫不會出現在平行建構的語彙範圍，但可能位於動態範圍中的指示詞*孤立*指示詞。 被遺棄的指示詞可讓程式設計人員很少變更的平行循序程式執行其程式的主要部分。 透過這項功能，使用者可以在程式呼叫樹狀圖中最上層的層級的平行建構的程式碼和使用指示詞，來控制執行任何呼叫的函式中。

對 C 和 c + + 的未同步處理的呼叫的輸出寫入至相同檔案的函式可能會導致不同的執行緒所撰寫的資料出現不具決定性的順序中的輸出。 同樣地，輸入從相同的檔案讀取的函式的未同步處理的對可讀取資料不具決定性的順序。 未同步處理的使用的 I/O，使每個執行緒存取不同的檔案，會產生與 I/O 函式的序列執行相同的結果。