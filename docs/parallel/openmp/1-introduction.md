---
title: 1. 簡介
ms.date: 01/16/2019
ms.assetid: c42e72bc-0e31-4b1c-b670-cd82673c0c5a
ms.openlocfilehash: 8c735408bdf9f9a13693bd0ad25df185bb1db42a
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2019
ms.locfileid: "62236446"
---
# <a name="1-introduction"></a>1.簡介

這份文件指定的編譯器指示詞、 程式庫函式，並可用來指定在 C 中的共用記憶體平行處理原則的環境變數集合和C++程式。 這份文件中所述的功能通稱為*OpenMP C /C++應用程式介面 (API)*。 此規格的目標是提供進行平行程式設計的模型可讓程式能夠移植到不同廠商的共用記憶體架構不同。 從許多廠商的編譯器都支援 OpenMP C /C++ API。 OpenMP 的詳細資訊包括*OpenMP Fortran 應用程式開發介面*，請參閱下列網站：

[https://www.openmp.org](https://www.openmp.org)

指示詞、 程式庫函式和此文件中定義的環境變數可讓您建立和管理平行處理程式，同時允許可攜性。 指示詞會擴充 C 和C++多個資料 (SPMD) 建構、 工作共用建構和同步處理建構，循序的程式設計模型與單一的程式。 它們也支援的 「 共用 」 和 「 私有化 」 的資料。 編譯器支援 OpenMP C 和C++API 包含編譯器就會啟動，並允許所有 OpenMP 編譯器指示詞的轉譯工作的命令列選項。

## <a name="11-scope"></a>1.1 範圍

此規格涵蓋只有使用者導向平行化作業，其中您明確地定義哪些動作編譯器，並執行階段系統會以平行方式執行程式。 OpenMP C 和C++的實作不一定要檢查是否有相依性、 衝突、 死結、 競爭條件，或其他導致不正確的問題程式執行。 您必須負責確保使用 OpenMP C 的應用程式和C++API 建構正確執行。 編譯器所產生的自動平行處理和可協助這類的平行處理編譯器指示詞未涵蓋在本文件中。

## <a name="12-definition-of-terms"></a>1.2 詞彙定義

本文件中使用下列詞彙：

- barrier

  在小組中的所有執行緒都到達同步處理點。  在小組中的所有執行緒都到達這個時候，就會等到每個執行緒。 有明確指示詞和實作所建立的隱含阻礙所識別的障礙。

- 建構

  建構是在陳述式。 它包含一個指示詞，後面接著結構化區塊。 某些指示詞不是一種建構的一部分。 (請參閱*openmp 指示詞*中[附錄 C](c-openmp-c-and-cpp-grammar.md))。

- 指示詞

  C 或C++`#pragma`後面接著`omp`識別項、 其他文字和新的一行。 指示詞會指定程式行為。

- 動態範圍

  中的所有陳述式*語彙範圍*，再加上語彙範圍內的陳述式的執行結果執行的函式內的任何陳述式。 動態範圍也稱為*地區*。

- 語彙範圍

  陳述式語彙內含*結構化的區塊*。

- 主要執行緒

  建立小組的執行緒時*平行區域*輸入。

- 平行區域

  繫結至 OpenMP 平行建構，並可能由多個執行緒執行的陳述式。

- private

  私用變數的名稱是唯一的執行緒在製作該參考的儲存體的區塊。 有數種方式來指定變數為私用： 在平行區域內，定義`threadprivate`指示詞`private`， `firstprivate`， `lastprivate`，或`reduction`子句或做為變數使用`for`迴圈中的控制變數`for`迴圈緊接`for`或`parallel for`指示詞。

- region

  動態的範圍。

- 序列地區

  只有執行的陳述式*主要執行緒*以外的任何動態範圍*平行區域*。

- 序列化

  若要執行與平行建構：

  - 一群組成單一執行緒 （也就是該平行建構的主要執行緒），執行緒

  - （相同排序如同區塊不是平行建構的一部分） 的結構化區塊中的陳述式執行的序列的順序和

  - 所傳回的值不會影響`omp_in_parallel()`（除了任何效果，巢狀平行建構）。

- 共用

  共用的變數名稱儲存體的單一的區塊。 小組中存取這個變數的所有執行緒也會都存取此儲存體的單一區塊。

- 結構化的區塊

  結構化的區塊是具有單一項目和單一結束陳述式 （單一或複合）。 如果沒有跳入或移出陳述式，該陳述式就會是結構化的區塊。 (此規則會包含呼叫`longjmp`(3 C) 或使用`throw`，但呼叫`exit`允許。)如果執行一定開始於開頭`{`一律結束結尾`}`，複合陳述式是結構化的區塊。 運算式陳述式、 選取範圍陳述式、 反覆項目陳述式，或`try`區塊是結構化的區塊，如果對應的複合陳述式取得方法中括住`{`和`}`會結構化的區塊。 跳躍陳述式，加上標籤的陳述式或宣告陳述式不是結構化的區塊。

- 小組

  一或多個執行緒執行中的一種建構合作。

- thread

  執行實體具有序列具有控制流程、 一組私用變數，以及對共用變數的存取。

- 變數

  識別項，選擇性地限定命名空間名稱所命名的物件。

## <a name="13-execution-model"></a>1.3 執行模式

OpenMP 會使用平行執行的分岔 / 聯結模型。 雖然此分岔 / 聯結模型很適合用來解決各種問題，它是針對大型陣列為基礎的應用程式量身打造。 OpenMP 被要支援正確執行兩種形式 （多執行緒的執行與完整的 OpenMP 支援程式庫） 的平行處理程式的程式。 它也會執行 （已忽略指示詞和簡單的 OpenMP 虛設常式程式庫） 的正確循序程式的程式。 不過，它可能是，並允許開發的程式，並不會循序執行時正常運作。 此外，不同程度的平行處理原則可能會導致不同的數字結果由於關聯的數值運算中的變更。 比方說，序列加法減少可能有不同的模式比平行約化新增關聯性。 這些不同的關聯可能會變更浮點加法的結果。

使用 OpenMP c# 撰寫的程式 /C++ API 開始執行以單一執行緒的方式執行稱為*主要執行緒*。 序列的區域中的主要執行緒執行，直到遇到的第一個平行建構。 OpenMP c /C++ API`parallel`指示詞會構成平行建構。 發生平行建構時，主要執行緒建立的執行緒，團隊，主機會成為主要的小組。 在小組中的每個執行緒的平行區域，除了工作共用建構動態的範圍中執行的陳述式。 在小組中的所有執行緒一定會都遇到相同的順序中的工作共用建構和一或多個執行緒執行相關聯的結構化區塊中的陳述式。 隱含工作共用建構不含結尾屏障`nowait`子句在小組中的所有執行緒執行。

如果執行緒修改共用的物件，它會影響其本身的執行環境，不僅那些程式中的其他執行緒。 修改保證完成，從另一個執行緒，在下一個序列點的觀點 （定義於基底的語言），只有當物件宣告為 volatile。 否則修改保證會完成之後第一次修改執行緒。 請參閱其他執行緒然後 （或同時） `flush` （隱含或明確） 指定的物件的指示詞。 當`flush`由其他 OpenMP 指示詞隱含的指示詞不保證副作用的正確順序，而是提供額外、 明確的程式設計人員的責任`flush`指示詞。

平行建構完成，小組中的執行緒同步處理在隱含的障礙，並只在主要執行緒會繼續執行。 在單一程式中，就可以指定任意數目的平行建構。 如此一來，程式可能會建立分支，加入在執行期間的許多次。

OpenMP C /C++ API 可讓程式設計人員使用指示詞，從平行建構內呼叫的函式中。 呼叫不會出現在平行建構的語彙範圍，但可能位於動態範圍中的指示詞*孤立*指示詞。 被遺棄的指示詞，程式設計人員可以平行的只有最少變更的循序程式與執行其程式的主要部分。 透過這項功能，您可以程式碼會在程式呼叫樹狀圖中最上層的層級的平行建構和使用指示詞，來控制執行任何呼叫的函式。

個未同步處理到 C 呼叫和C++寫入至相同檔案的輸出函式可能會導致不同的執行緒所撰寫的資料出現不具決定性的順序中的輸出。 同樣地，輸入從相同的檔案讀取的函式的未同步處理的對可讀取資料不具決定性的順序。 未同步處理的使用的 I/O，使每個執行緒存取不同的檔案，會產生與 I/O 函式的序列執行相同的結果。

## <a name="14-compliance"></a>1.4 符合標準

實作的 OpenMP C /C++ api *OpenMP 相容*它會辨識並 1、 2、 3、 4 和附錄 c 附錄 A、 B、 D、 E 和 F，制定章節中，會保留這個規格中，所有項目的語意會為資訊之用，且不規格的一部分。 包含的 API 子集的實作不 OpenMP 符合項目。

OpenMP C 和C++API 會受到所實作的基底語言擴充功能。 如果基底的語言不支援的語言建構或延伸模組，會出現在這份文件中，OpenMP 實作不必要的支援。

所有標準 C 和C++程式庫函式和內建函數 （也就是函式的編譯器有特定的知識） 必須是安全執行緒。 未同步處理的使用由不同的執行緒在平行區域內的安全執行緒的函式不會產生未定義的行為。 不過，行為可能不會如所示的序列的區域相同。 （數字產生隨機的函式是舉例）。

OpenMP C /C++ API 可讓您指定的特定行為*實作定義。* 若要定義並記錄其行為在這些情況下需要合格的 OpenMP 實作。 如需實作定義行為的清單，請參閱 <<c0> [ 附錄 E](e-implementation-defined-behaviors-in-openmp-c-cpp.md)。

## <a name="15-normative-references"></a>1.5 規範參考

- ISO/IEC 9899:1999*資訊技術-程式設計語言-C*。此 OpenMP API 規格會將稱為 C99 的 ISO/IEC 9899:1999。

- ISO/IEC 9899:1990*資訊技術-程式設計語言-C*。此 OpenMP API 規格會將稱為 C90 的 ISO/IEC 9899:1990。

- ISO/IEC 14882:1998*資訊技術-程式設計語言- C++* 。 此 OpenMP API 規格 」 指的是 ISO/IEC 14882:1998 做為C++。

在此 OpenMP API 規格 」 指的是 C，是對參考實作所支援的基底語言。

## <a name="16-organization"></a>1.6 組織

- [執行階段程式庫函式](3-run-time-library-functions.md)
- [環境變數](4-environment-variables.md)
- [OpenMP C/C++ 中的實作定義行為](e-implementation-defined-behaviors-in-openmp-c-cpp.md)
- [OpenMP C 中的新功能 /C++ 2.0 版](f-new-features-and-clarifications-in-version-2-0.md)
