---
title: D. 排程子句
ms.date: 01/22/2019
ms.assetid: bf3d8f51-ea05-4803-bf55-657c12e91efe
ms.openlocfilehash: 89e011784c5cccedc4a75f38d553458ea2e5d7e0
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2019
ms.locfileid: "62362877"
---
# <a name="d-the-schedule-clause"></a>D. 排程子句

在平行區域有至少一個屏障，其結尾，且可能有額外的障礙，其內。 每個障礙物，其他小組成員必須等到抵達的最後一個執行緒。 這個等候時間降到最低，使所有執行緒都到達在屏障的同時，應該會散佈共用的工作。 如果共用的某些工作都包含在`for`建構，`schedule`子句可用於此目的。

當有相同的物件，而選擇的排程的重複的參考`for`建構可由主要記憶體系統，例如的目前狀態和大小的快取，以及是否統一記憶體存取時間的特性，或nonuniform。 這類考量可能會讓最好有相同的一系列迴圈，在陣列中項目的一組一致的方式參考每個執行緒，即使某些執行緒指派相對較少的工作，在某些迴圈。 此設定可藉由使用`static`排程，以針對所有迴圈相同的界限。 在下列範例中，零做為下限，在第二個迴圈中，即使`k`會是更自然，如果排程不重要。

```cpp
#pragma omp parallel
{
#pragma omp for schedule(static)
  for(i=0; i<n; i++)
    a[i] = work1(i);
#pragma omp for schedule(static)
  for(i=0; i<n; i++)
    if(i>=k) a[i] += work2(i);
}
```

在其餘的範例中，它都假設記憶體存取不是主要的考量。 除非另有指明，所有執行緒會都收到類似的計算資源。 在這些情況下，選擇排程`for`建構取決於前方最接近之間要執行的所有共用工作障礙與隱含的結尾屏障或即將推出的障礙，如果沒有接近`nowait`子句。 排程的每種類型，簡短的範例會示範如何排程該類是可能是最好的選擇。 簡短討論遵循每個範例。

`static`排程也是適用於簡單的情況下，包含一個平行區域`for`建構，每次反覆運算時需要相同數量的工作。

```cpp
#pragma omp parallel for schedule(static)
for(i=0; i<n; i++) {
  invariant_amount_of_work(i);
}
```

`static`排程以屬性的每個執行緒取得大約相同數目的反覆項目為任何其他的執行緒，以及每個執行緒可以獨立判斷指派給它的反覆項目。 因此任何同步處理，才能發佈工作，並假設每個反覆項目需要相同數量的工作，所有執行緒應該在都完成大約相同的時間。

小組*p*執行緒，讓*ceiling(n/p)* 是整數*q*，這符合*n = p\*q-r*與*0 < = r < p*。 其中一個實作`static`排程的這個範例會指派給*q*的第一個反覆項目*p-1*執行緒，和*q r*反覆項目到最後一個執行緒。  另一個可接受的實作會指派給*q*的第一個反覆項目*p-r*執行緒，和*q-1*剩餘的反覆項目*r*執行緒。 此範例會說明為什麼程式不應依賴特定的實作詳細資料。

`dynamic`排程適合的大小寫`for`建構包含要求工作的不同，或甚至是無法預期，數量的反覆項目。

```cpp
#pragma omp parallel for schedule(dynamic)
  for(i=0; i<n; i++) {
    unpredictable_amount_of_work(i);
}
```

`dynamic`排程的特點在於任何執行緒等待屏障的長度超過它採用另一個執行緒來執行其最後一個反覆項目屬性。 此需求表示反覆項目必須被指派一次一個為可用，同步處理每個指派的執行緒。 藉由指定的最小的區塊大小可縮減同步處理額外負荷*k*小於或等於 1，以便指派執行緒*k*才少於一次*k*保留。 這可確保沒有任何執行緒等待時間 （最多） 執行其最後一個區塊的另一個執行緒所花費超過屏障*k*反覆項目。

`dynamic`排程可以是很有用，如果執行緒都會收到不同的計算資源，其具有不同的量，每個反覆項目的工作的許多相同的效果。 同樣地，動態排程也可以是很有用，如果執行緒抵達`for`建構在不同的時間，即使在這些部分情況下`guided`排程可能較合適。

`guided`排程的執行緒可能會到達不同時間的情況適合`for`建構包含每個反覆項目需要大約相同數量的工作。 如果，就會發生這種情況，例如`for`建構會加上一個或多個區段或`for`建構取代`nowait`子句。

```cpp
#pragma omp parallel
{
  #pragma omp sections nowait
  {
    // ...
  }
  #pragma omp for schedule(guided)
  for(i=0; i<n; i++) {
    invariant_amount_of_work(i);
  }
}
```

像是`dynamic`，則`guided`排程沒有任何執行緒等待屏障超過需要另一個執行緒來執行其最後一個反覆項目，或最後一個可確保*k*反覆項目，如果的區塊大小*k*指定。 在這類排程之間`guided`排程的特點屬性，它需要最少的同步處理。 區塊大小*k*的一般實作會將指派*q = ceiling(n/p)* 反覆項目到第一個可用的執行緒，設定*n*較大的*n-q*並*p\*k*，並重複，直到所有反覆項目指派。

選擇最佳的排程不因為它是針對這些範例中，以純`runtime`排程是方便而不需修改並重新編譯程式試驗不同的排程和區塊大小。 它也可用時的最佳排程 （以可預測的方式） 視程式套用到輸入資料。

若要查看的不同排程之間的取捨範例，請考慮共用八個執行緒之間的 1000年次反覆運算。 假設每個反覆項目，可用於非變異數量並使用它作為時間單位。

如果在此同時開始的所有執行緒`static`排程會導致執行單位為 125，沒有同步處理的建構。 但是，假設有一個執行緒是在抵達的後續階段中的 100 個單位。 然後剩餘的 7 個執行緒等待在屏障，100 個單位，整個建構執行的時間會增加到 225。

因為同時`dynamic`和`guided`排程確定沒有任何執行緒等待在屏障的多個單位，延遲的執行緒會導致增加只以 138 單位，可能會增加延遲，從建構其執行時間同步處理。 如果這類延遲不顯著，變得重要進行同步處理的數目是 1000年`dynamic`，但針對唯一 41 `guided`，假設其中一個預設區塊大小。 區塊大小的 25`dynamic`和`guided`兩者分別在 150 單位，再加上必要的同步處理，現在數字只有 40，20，從任何延遲完成。
