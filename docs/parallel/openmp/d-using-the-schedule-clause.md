---
title: D. 使用排程子句 |Microsoft 文件
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- cpp-parallel
ms.topic: conceptual
dev_langs:
- C++
ms.assetid: bf3d8f51-ea05-4803-bf55-657c12e91efe
author: mikeblome
ms.author: mblome
ms.workload:
- cplusplus
ms.openlocfilehash: 8987c4505adfde8534d57346cd6725231efa022f
ms.sourcegitcommit: 7019081488f68abdd5b2935a3b36e2a5e8c571f8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/07/2018
ms.locfileid: "33694936"
---
# <a name="d-using-the-schedule-clause"></a>D. 使用排程子句
在平行區域有至少一個障礙，其結尾並且可能有其他障礙內。 在每個障礙，其他小組成員必須等到抵達的最後一個執行緒。 這個等候時間降到最低，使所有執行緒都到達屏障在同一時間應該發佈共用的工作。 如果共用部分工作包含在**如**建構，`schedule`子句可用於此用途。  
  
 有重複的參考同一個物件的排程選擇當**如**建構可由主要記憶體系統，例如的目前狀態和大小的快取和記憶體的存取是否的特性時間是統一或統一。 這類考量可能會使最好讓每個執行緒以一致的方式是指一系列迴圈，在陣列中項目的一組相同，即使有些執行緒指派較低的某些資料在迴圈的工作。 這可以經由使用**靜態**排程的所有迴圈相同的界限。 在下列範例中，請注意，零作為下限，在第二個迴圈中，即使**k**會更為自然，如果排程不重要。  
  
```  
#pragma omp parallel  
{  
#pragma omp for schedule(static)  
  for(i=0; i<n; i++)  
    a[i] = work1(i);  
#pragma omp for schedule(static)  
  for(i=0; i<n; i++)  
    if(i>=k) a[i] += work2(i);  
}  
```  
  
 在剩餘的範例中，它會假設該記憶體存取不是主要的考量，而且，除非另有指明，所有執行緒都收到可比較的計算資源。 在這些情況下，選擇的排程**如**建構取決於要執行接近之間的所有共用工作屏障和隱含的右屏障或最接近的後續屏障，如果沒有`nowait`子句。 針對排程的每個類型，簡短的範例示範如何排程該類可能是最好的選擇。 簡短討論遵循每個範例。  
  
 **靜態**排程也是適用於簡單的情況下，在平行區域包含單一**如**建構，每次反覆運算時需要相同數量的工作。  
  
```  
#pragma omp parallel for schedule(static)  
for(i=0; i<n; i++) {  
  invariant_amount_of_work(i);  
}  
```  
  
 **靜態**排程的特點在於屬性的每個執行緒取得大約相同數目的反覆項目做為其他任何執行緒和每個執行緒可獨立判斷指派給它的反覆項目。 發佈工作，因此需要無同步處理，並假設每個反覆項目需要相同的工作量，所有執行緒應在都完成大約相同的時間。  
  
 小組的`p`執行緒，讓*ceiling(n/p)* 是整數*q*，符合*n = p\*q-r*與*0 < = r < p*. 實作一種做法**靜態**針對此範例中所要指派的排程*q*第一個反覆項目*p-1*執行緒和*q r*最後一個執行緒反覆項目。  另一個可接受的實作會指派*q*第一個反覆項目*p-r*執行緒，和*q-1*剩餘的反覆項目*r*執行緒。 這說明為什麼程式不應依賴以特定實作的詳細資料。  
  
 **動態**排程適合的大小寫**如**建構包含要求工作的不同，或甚至無法預測，數量的反覆項目。  
  
```  
#pragma omp parallel for schedule(dynamic)  
  for(i=0; i<n; i++) {  
    unpredictable_amount_of_work(i);  
}  
```  
  
 **動態**排程的特點在於任何執行緒等候屏障在超過其採用另一個執行緒來執行其最後一個反覆項目屬性。 這需要的反覆項目要有指派一次一個執行緒可用時，同步處理的每個指派。 藉由指定的最小的區塊大小，可降低的同步處理額外負荷*k*大於 1，以便指派執行緒*k*一次之前少於*k*保留。 這樣可保證沒有執行緒等待時間 （最多） 執行其最後一個區塊的另一個執行緒所花費超過屏障*k*反覆項目。  
  
 **動態**排程可以是很有用，如果執行緒會收到不同的計算資源，其中包含針對每個反覆項目工作的資訊量很多相同的效果。 同樣地，動態排程也很有用如果執行緒到達**如**建構在不同的時間，即使在這些案例**指引**排程可能較適合。  
  
 **指引**排程執行緒可能會到達在不同時間的情況適合**如**建構包含每個反覆項目需要大約相同數量的工作。 這種情況，例如**的**建構一個或多個區段的開頭或**如**建構`nowait`子句。  
  
```  
#pragma omp parallel  
{  
  #pragma omp sections nowait  
  {  
    // ...  
  }  
  #pragma omp for schedule(guided)  
  for(i=0; i<n; i++) {  
    invariant_amount_of_work(i);  
  }  
}  
```  
  
 像**動態**、**指引**排程任何執行緒等待屏障超過花費另一個執行緒來執行其最後一個反覆項目，或最後一個可確保*k*如果區塊大小，為反覆項目*k*指定。 在這類排程之間**指引**排程的特點在於屬性，它需要最少同步處理。 區塊大小*k*，將會指派一般實作*q = ceiling(n/p)* 反覆項目至第一個可用的執行緒，設定*n*較大的*n-q*和*p\*k*，然後重複，直到所有反覆項目指派。  
  
 無法為清除，因為其適用於這些範例中，選擇的最佳排程時**執行階段**排程是方便而不必修改和重新編譯程式試驗不同的排程和區塊大小。 可能也很有用的最佳排程依存 （某種方式可預測） 套用到程式的輸入資料時。  
  
 若要查看的不同排程之間的取捨範例，請考慮共用 8 個執行緒之間的 1000 個反覆運算。 假設每個反覆項目中的工作而異的數量和用來做為時間單位。  
  
 如果在相同的時間啟動的所有執行緒**靜態**排程會導致 125 單位，無同步處理中執行建構。 但假設一個執行緒會在抵達 100 為單位。 然後其餘的七個執行緒等候屏障，在 100 為單位，所整個建構的執行時間增加至 225。  
  
 因為同時**動態**和**指引**排程確保沒有執行緒等待在屏障的多個單位，延遲的執行緒會使它們只增加 138 建構的執行時間單位，從同步處理的延遲可能增加。 如果可以忽略這種延遲，它變得很重要的同步處理的數目是 1000年**動態**，但只有 41 的**引導式**，假設其中一個預設區塊大小。 區塊大小為 25，**動態**和**指引**兩者分別完成 150 單位，加上必要的同步處理，只有 40 和 20，哪一個現在號碼從任何延遲。