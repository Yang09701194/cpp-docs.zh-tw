---
title: D. 使用 schedule 子句
ms.date: 11/04/2016
ms.assetid: bf3d8f51-ea05-4803-bf55-657c12e91efe
ms.openlocfilehash: 85386c913a6e447ba9e71231be8b951eef504fea
ms.sourcegitcommit: 6052185696adca270bc9bdbec45a626dd89cdcdd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/31/2018
ms.locfileid: "50627522"
---
# <a name="d-using-the-schedule-clause"></a>D. 使用 schedule 子句

在平行區域有至少一個屏障，其結尾，且可能有額外的障礙，其內。 每個障礙物，其他小組成員必須等到抵達的最後一個執行緒。 這個等候時間降到最低，使所有執行緒都到達在屏障的同時，應該會散佈共用的工作。 如果共用的某些工作都包含在**for**建構，`schedule`子句可用於此目的。

有重複的參考相同物件，也就是選擇的排程時**針對**建構可由主要記憶體系統，例如大小的快取和記憶體的存取是否與目前狀態的特性時間都是統一或統一。 這類考量可能會讓最好有相同的一系列迴圈，在陣列中項目的一組一致的方式參考每個執行緒，即使某些執行緒指派相對較少的工作，在某些迴圈。 做法是使用**靜態**排程，以針對所有迴圈相同的界限。 在下列範例中，請注意，零作為下限，在第二個迴圈中，即使**k**會是更自然，如果排程不重要。

```
#pragma omp parallel
{
#pragma omp for schedule(static)
  for(i=0; i<n; i++)
    a[i] = work1(i);
#pragma omp for schedule(static)
  for(i=0; i<n; i++)
    if(i>=k) a[i] += work2(i);
}
```

在其餘的範例中，它會假設該記憶體存取不是主要的考量，而且，除非另有指明，所有執行緒會都收到類似的計算資源。 在這些情況下，選擇排程**針對**建構取決於前方最接近之間要執行的所有共用工作障礙與隱含的結尾屏障或最接近的後續屏障，如果沒有`nowait`子句。 排程的每種類型，簡短的範例會示範如何排程該類是可能是最好的選擇。 簡短討論遵循每個範例。

**靜態**排程也是適用於簡單的情況下，包含一個平行區域**如**建構，每次反覆運算時需要相同數量的工作。

```
#pragma omp parallel for schedule(static)
for(i=0; i<n; i++) {
  invariant_amount_of_work(i);
}
```

**靜態**排程以屬性的每個執行緒取得大約相同數目的反覆項目為任何其他的執行緒，以及每個執行緒可以獨立判斷指派給它的反覆項目。 因此任何同步處理，才能發佈工作，並假設每個反覆項目需要相同數量的工作，所有執行緒應該在都完成大約相同的時間。

小組`p`執行緒，讓*ceiling(n/p)* 是整數*q*，這符合*n = p\*q-r*使用*0 < = r < p*. 其中一個實作**靜態**排程針對此範例會指派給*q*的第一個反覆項目*p-1*執行緒和*q r*在最後一個執行緒重複項目。  另一個可接受的實作會指派給*q*的第一個反覆項目*p-r*執行緒，和*q-1*剩餘的反覆項目*r*執行緒。 這說明為什麼程式不應依賴特定的實作詳細資料。

**動態**排程適合的大小寫**如**建構包含要求工作的不同，或甚至是無法預期，數量的反覆項目。

```
#pragma omp parallel for schedule(dynamic)
  for(i=0; i<n; i++) {
    unpredictable_amount_of_work(i);
}
```

**動態**排程的特點在於任何執行緒等待屏障的長度超過它採用另一個執行緒來執行其最後一個反覆項目屬性。 這需要，反覆項目指派一次一個往來文章推出時，每個指派的同步處理。 藉由指定的最小的區塊大小可縮減同步處理額外負荷*k*小於或等於 1，以便指派執行緒*k*才少於一次*k*保留。 這可確保沒有任何執行緒等待時間 （最多） 執行其最後一個區塊的另一個執行緒所花費超過屏障*k*反覆項目。

**動態**排程可以是很有用，如果執行緒都會收到不同的計算資源，其具有不同的量，每個反覆項目的工作的許多相同的效果。 同樣地，動態排程也可以是很有用，如果執行緒抵達**for**建構在不同的時間，即使在這些情況下的一些**引導式**可能會偏好使用排程。

**指引**排程適合所在的執行緒可能會同時在不同時間的情況**如**建構包含每個反覆項目需要大約相同數量的工作。 就可能發生此，例如**for**建構會加上一個或多個區段或**如**建構取代`nowait`子句。

```
#pragma omp parallel
{
  #pragma omp sections nowait
  {
    // ...
  }
  #pragma omp for schedule(guided)
  for(i=0; i<n; i++) {
    invariant_amount_of_work(i);
  }
}
```

像是**動態**，則**指引**排程沒有任何執行緒等待屏障超過需要另一個執行緒來執行其最後一個反覆項目，或最後一個可確保*k*如果區塊大小，為反覆項目*k*指定。 在這類排程之間**引導式**排程的特點屬性，它需要最少的同步處理。 區塊大小*k*的一般實作會將指派*q = ceiling(n/p)* 反覆項目到第一個可用的執行緒，設定*n*較大的*n-q*並*p\*k*，並重複，直到所有反覆項目指派。

當選擇最佳的排程不是因為它是針對這些範例中，以純**執行階段**排程是方便而不需修改並重新編譯程式試驗不同的排程和區塊大小。 它也可用時的最佳排程 （以可預測的方式） 視程式套用到輸入資料。

若要查看的不同排程之間的取捨範例，請考慮共用 8 個執行緒之間的 1000年次反覆運算。 假設每個反覆項目，可用於非變異數量並使用它作為時間單位。

如果在此同時開始的所有執行緒**靜態**排程會導致執行單位為 125，沒有同步處理的建構。 但是，假設有一個執行緒是在抵達的後續階段中的 100 個單位。 然後剩餘的 7 個執行緒等待在屏障，100 個單位，整個建構執行的時間會增加到 225。

因為同時**動態**並**引導式**排程確保沒有任何執行緒等待在屏障的多個單位，延遲的執行緒會導致增加只以 138 建構其執行時間單位，可能是從同步處理的延遲增加。 如果這類延遲不是可忽略的就一定進行同步處理的數目是 1000年**動態**但的唯一 41**引導式**，假設其中一個預設區塊大小。 區塊大小的 25**動態**並**引導式**兩者分別在 150 單位，再加上必要的同步處理，現在數字只有 40，20，從任何延遲完成。