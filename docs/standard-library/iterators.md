---
title: 迭代器
ms.date: 11/04/2016
helpviewer_keywords:
- iterator conventions
- C++ Standard Library, iterator conventions
ms.assetid: 2f746be7-b37d-4bfc-bf05-be4336ca982f
ms.openlocfilehash: ae4193b8e6edf94ab0f8d839ac36fc1addfd8d04
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/07/2019
ms.locfileid: "65220324"
---
# <a name="iterators"></a>迭代器

迭代器是一種物件，可逐一查看「C++ 標準程式庫」容器中的元素，並提供個別元素的存取途徑。 「C++ 標準程式庫」容器都有提供迭代器，因此演算法能以標準方式存取其元素，而不需要考慮元素儲存所在容器的類型。

您可以使用迭代器使用明確成員和全域函式這類`begin()`並`end()`和運算子，例如 **++** 並 **--** 向前移動，或回溯。 您也可以使用迭代器會隱含地具有範圍為 for 迴圈或 （對於某些迭代器型別） 註標運算子 **\[]**。

在「C++ 標準程式庫」中，序列或範圍的開頭是第一個元素。 序列或範圍的結尾一律定義為最後一個元素之後的元素。 全域函式`begin`和`end`迭代器傳回至指定的容器。 一般明確迭代器會以迴圈方式處理容器中的所有元素，如下所示：

```cpp
vector<int> vec{ 0,1,2,3,4 };
for (auto it = begin(vec); it != end(vec); it++)
{
    // Access element using dereference operator
    cout << *it << " ";
}
```

使用 range-for 迴圈：

```cpp
for (auto num : vec)
{
    // no deference operator
    cout << num << " ";
}
```

迭代器有五種分類。 為了增加能力，在這裡將分類為：

- **輸出**。 *輸出迭代器* `X`可以逐一執行序列透過 **++** 運算子，而且可以使用一次，寫入項目 __\*__ 運算子。

- **輸入**。 *輸入迭代器* `X`可以逐一執行序列使用 + + 運算子，並可以元素無數次使用讀取 **&ast;** 運算子。 您可以使用，以便比較輸入迭代器 **++** 並 **！ =** 運算子。 遞增輸入迭代器的任何複本之後，就沒有其他複本可以安全地進行比較、取值 (Dereference) 或在以後遞增。

- **正向**。 A*正向迭代器* `X`可以逐一執行序列使用 + + 運算子和可讀取的任何項目，或使用寫入非常數元素無數次 **&ast;** 運算子。 您可以使用來存取元素成員 **->** 運算子和比較的迭代器則會藉由使用向前 **==** 並 **！ =** 運算子。 您可以建立正向迭代器的多個複本，每個都可以取值 (Dereference)，而且獨立遞增。 正向迭代器，初始化沒有參考任何容器稱為*null 正向迭代器*。 Null 正向迭代器一律會以相等方式比較。

- **雙向**。 A*雙向迭代器* `X`可以取代正向迭代器。 您可以不過，也遞減雙向迭代器，如`--X`， `X--`，或`(V = *X--)`。 您可以使用與正向迭代器相同的方式來存取元素成員，以及比較雙向迭代器。

- **隨機存取**。 A*隨機存取迭代器* `X`可以進行的雙向迭代器。 隨機存取迭代器，您可以使用註標運算子 **\[]** 來存取元素。 您可以使用 **+**， **-**， **+=** 並 **-=** 移動的運算子向前或向後指定的數目的項目，以及計算迭代器之間的距離。 您可以使用來比較雙向迭代器 **==**， **！ =**，  **\<**， **>**， **\<=**，以及 **>=**。

所有迭代器可以指派或複製。 它們被假設為輕量級物件，通常依據值傳遞和傳回，而不是依據參考。 另請注意，當在有效的迭代器上執行時，上述的作業均無法擲回例外狀況。

可以藉由顯示三個序列來摘要迭代器分類的階層。 對於序列的唯寫存取，您可以使用任一項：

> 輸出迭代器<br/>
> ]-> [正向迭代器<br/>
> -> 雙向迭代器<br/>
> -> 隨機存取迭代器<br/>

向右箭號表示「可以取代」。 舉例來說，任何需要輸出迭代器的演算法應該都可與正向迭代器妥善地搭配運作，但是反之則「不」然。

對於序列的唯讀存取，您可以使用任一項：

> 輸入迭代器<br/>
> ]-> [正向迭代器<br/>
> -> 雙向迭代器<br/>
> -> 隨機存取迭代器<br/>

在此案例中，輸入迭代器是所有分類中最薄弱的。

最後，對於序列的讀取/寫入存取，您可以使用任一項：

> 正向迭代器<br/>
> -> 雙向迭代器<br/>
> -> 隨機存取迭代器<br/>

物件指標一律可以當做隨機存取迭代器，所以如果它對於指定的序列支援讀取/寫入存取，則可以做為任何分類的迭代器。

物件指標以外的迭代器 `Iterator` 也必須定義特製化 `iterator_traits<Iterator>` 所需的成員類型。 請注意，只要藉由從公用基底類別 [iterator](../standard-library/iterator-struct.md) 衍生 `Iterator`，即可符合這些需求。

請務必了解每個迭代器分類的承諾和限制，以了解「C++ 標準程式庫」中的容器和演算法如何使用迭代器。

> [!NOTE]
> 您可以透過使用 range-for 迴圈來避免使用迭代器。 如需詳細資訊，請參閱 <<c0> [ 範圍架構 for 陳述式](../cpp/range-based-for-statement-cpp.md)。

MicrosoftC++現在提供已檢查的迭代器和偵錯迭代器，以確保您不覆寫容器的界限。 如需詳細資訊，請參閱[已檢查的迭代器](../standard-library/checked-iterators.md)和[偵錯迭代器支援](../standard-library/debug-iterator-support.md)。

## <a name="see-also"></a>另請參閱

[C++ 標準程式庫參考](../standard-library/cpp-standard-library-reference.md)<br/>
[C++ 標準程式庫中的執行緒安全](../standard-library/thread-safety-in-the-cpp-standard-library.md)<br/>
