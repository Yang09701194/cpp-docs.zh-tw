---
title: "What&#39;s New for Visual C++ in Visual Studio 2015 | Microsoft Docs"
ms.custom: ""
ms.date: "12/16/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "devlang-cpp"
ms.tgt_pltfrm: ""
ms.topic: "article"
dev_langs: 
  - "C++"
ms.assetid: 1cc09fad-85a2-43c2-b022-bb99f5fe0ad7
caps.latest.revision: 101
caps.handback.revision: 101
author: "ghogen"
ms.author: "ghogen"
manager: "ghogen"
---
# What&#39;s New for Visual C++ in Visual Studio 2015
[!INCLUDE[vs2017banner](../assembler/inline/includes/vs2017banner.md)]

在 Visual Studio 2015 中，C\+\+ 編譯器和標準程式庫已隨 C\+\+11 的增強支援和特定 C \+\+14 功能的初始支援而更新。  其中也包括 C\+\+17 標準預期會有的特定功能之初步支援。  
  
 我們也在 [Android 及 iOS](../Topic/Visual%20C++%20for%20Cross-Platform%20Mobile%20Development.md) 上加入了跨平台多重裝置開發的專案範本，同時改進了多項[診斷](#BK_Diagnostics)與[產能](#BK_IDE)功能，並大幅改進[建置時間](#BK_FasterBuildTimes)。  
  
> [!WARNING]
>  根據預設，在 Visual Studio 2015 中不會安裝 Visual C\+\+。  在安裝時，請務必選擇 \[自訂\] 安裝，然後選擇您需要的 C\+\+ 元件。  或是如果已安裝 Visual Studio，則請選擇 \[檔案\] &#124;\[新增\] &#124; \[專案\] &#124; \[C\+\+\]，然後將會提示您安裝必要元件。  
  
 如需其他 Visual Studio 2015 新增功能的詳細資訊，請參閱 [Visual Studio 2015 的新功能](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)。  
  
 本主題內容：  
  
1.  [編譯器](#BK_Compiler)  
  
2.  [C++ 標準程式庫](#BK_CppStdLib)  
  
3.  [C 執行階段程式庫](#BK_CRT)  
  
4.  [建置時間更短](#BK_FasterBuildTimes)  
  
5.  [效能和程式碼品質](#BK_PerfCodeQuality)  
  
6.  [產能、偵錯和診斷](#BK_IDE)  
  
    1.  [單一檔案 IntelliSense](#BK_SingleFileIntelliSense)  
  
    2.  [重構](#BK_Refactoring)  
  
    3.  [程式資料庫的增強功能](#BK_PDB)  
  
    4.  [診斷](#BK_Diagnostics)  
  
7.  [以 Windows 10 為目標](#BK_Win10)  
  
8.  [圖形診斷](#BK_GraphicsDiagnostics)  
  
9. [新的 GPU 使用量工具](#BK_GPUUsage)  
  
10. [MFC 的新功能](#BK_MFC)  
  
## ISO C\/C\+\+ 標準支援  
  
###  <a name="BK_Compiler"></a> 編譯器  
  
-   **可繼續函式 \(resume\/await\)** resume 和 await 關鍵字提供非同步程式設計的語言層級支援，並啟用可繼續函式。  此功能目前仍屬實驗性質，並只適用於 x64 目標。  **\(提議的 C\+\+17 \[N3858\]\)**  
  
-   **泛型 \(多型\) Lambda 運算式** 現在可以使用 auto 指定 Lambda 函式參數類型；編譯器會把此內容的 auto 解譯為 Closure 函式呼叫運算子是成員函式範本，而且在 Lambda 運算式中每次使用的 auto 都對應至不同的範本類型參數。  **\(C\+\+14\)**  
  
-   **通用 Lambda 擷取運算式** 也稱為 init\-capture。  現在可以將任意一個運算式的結果指派給 Lambda 擷取子句中的變數。  這可用傳值方式擷取 move\-only 類型，並讓 Lambda 運算式定義其 Closure 物件中的任意資料成員。  **\(C\+\+14\)**  
  
-   **二進位常值** 現在支援二進位常值。  這類常值前面會加上 0B 或 0b，而且只能由數字 0 和 1 組成。  **\(C\+\+14\)**  
  
-   **傳回類型推斷** 現在可以推算一般函式的傳回類型，包括具有多個傳回陳述式的函式和遞迴函式。  這類函式定義之前有 auto 關鍵字，如同有尾端傳回類型的函式定義，但省略尾端傳回類型。  **\(C\+\+14\)**  
  
-   **decltype\(auto\)** 類型推斷使用 auto 關鍵字，從運算式中初始化刪除運算式的 ref 限定詞和最上層的 cv 限定詞。  decltype\(auto\) 保留 ref 和 cv 限定詞，除了要引進有推斷的或尾端傳回類型的函式以外，可立即在能用 auto 的任何地方使用。  **\(C\+\+14\)**  
  
-   **移動特殊成員函式的隱含產生** 若條件允許時，移動建構函式和移動指派運算子會立即以隱含方式產生，因此讓編譯器能完全符合 C\+\+11 右值參考。  **\(C\+\+11\)**  
  
-   **繼承建構函式** 藉由將使用 Base::Base 的陳述式列入其定義中，一項衍生的類別可立即指定為將繼承其基底類別建構函式 Base。  衍生的類別只可以繼承其基底類別的所有建構函式，而沒有辦法繼承只有特定基底的建構函式。  如果衍生的類別具有相同簽章的建構函式，會無法從多個基底類別繼承；衍生的類別也無法定義具有任何它所繼承的建構函式相同簽章的建構函式。  **\(C\+\+11\)**  
  
-   **對齊方式查詢和控制項** 可以使用 alignof\(\) 運算子查詢變數的對齊方式，並使用 alignas\(\) 規範來控制。  alignof\(\) 會傳回位元組界限，其中該類型的執行個體必須加以配置；如為參考，它會傳回參考類型的對齊方式；如為陣列，它會傳回項目類型的對齊方式。  alignas\(\) 控制變數的對齊方式，會採用常數或類型，其中的類型是 alignas\(alignof\(type\)\) 的縮寫。  **\(C\+\+11\)**  
  
-   **調整大小的解除配置**全域  `void operator delete(void *, std::size_t) noexcept` 和 `void operator delete[](void *, std::size_t) noexcept` 現在可以多載  
  
-   **擴充 sizeof** 使用 sizeof\(\) 可立即判斷類別或結構的成員變數大小，而不需該類別或結構的執行個體。**\(C\+\+11\)**  
  
-   **屬性**提供一種方法，讓您無須定義新的關鍵字，即可擴充函式、變數、類型及其他程式元素的語法。**\(C\+\+11\)**  
  
-   **constexpr** 建立編譯時期常數變數、 函式和使用者定義類型。  **\(C\+\+11\)**  
  
-   **使用者定義常值 \(UDL\)** 現在可以附加有意義的後置字元至數字和字串常值，為其提供特定語意。  編譯器會將尾碼常值解譯為適當的 UDL 運算子呼叫。  **\(C\+\+11\)**  
  
-   **安全執行緒的 "Magic" 靜態變數** 現在會以執行緒安全的方式初始化靜態區域變數，而不必手動同步處理。  只有初始化是安全執行緒，以多個執行緒使用靜態區域變數仍必須以手動方式同步處理。  若要避免採用 CRT 相依性，使用 \/Zc:threadSafeInit\- 旗標可停用安全執行緒的靜態變數功能。  **\(C\+\+11\)**  
  
-   **執行緒區域儲存區** 使用 thread\_local 關鍵字來宣告應該為每個執行緒建立獨立的物件。  **\(C\+\+11\)**  
  
-   **noexcept** 現在可用 noexcept 運算子來檢查運算式是否可能會擲回例外狀況。  現在可用 noexcept 規範指定讓函式不擲回例外狀況。  **\(C\+\+11\)**  
  
-   **內嵌命名空間** 現在可指定命名空間為內嵌，將內容放進封入的命名空間。  根據預設，內嵌命名空間可用來建立會公開其最新版本的版本化程式庫，同時仍讓舊版應用程式開發介面的版本明確。  **\(C\+\+11\)**  
  
-   **無限制的等位** 現在等位類型包含具有非一般建構函式的類型。  這類等位的建構函式必須加以定義。  **\(C\+\+11\)**  
  
-   **新字元類型和 Unicode 常值** 現在支援 UTF\-8、 UTF\-16 和 UTF\-32 字元和字串常值，並引進新的字元類型 char16\_t 和 char32\_t。  字元常值前面可加上如 U'a' 中的 u8 \(UTF\-8\)，u \(UTF\-16\) 或 U \(UTF\-32\)，而字串常值前面可另外加上原始字串對等項目 u8R \(UTF\-8 原始字串\)，uR \(UTF\-16 原始字串\) 或 UR \(UTF\-32 原始字串\)。  通用字元名稱可以自由地用於 unicode 常值，如同 u'\\u00EF'、u8"\\u00EF is i" 及 u"\\U000000ef is I" 所示。  **\(C\+\+11\)**  
  
-   **數字分隔符號**可以在固定間隔插入單引號，以讓長數值常值更方便閱讀： `int x = 1'000'000;` **C\+\+14**  
  
-   **\_\_func\_\_** 預先定義的識別項 \_\_func\_\_ 以隱含方式定義為字串，其中包含封入函式不合格的及未修飾的名稱。  
  
-   **\_\_restrict \_\_** 現在可套用 restrict 至參考。  
  
###  <a name="BK_CppStdLib"></a> C\+\+ 標準程式庫  
  
-   **標準程式庫類型的使用者定義常值 \(UDL\)** 現在 \<chrono\>、\<string\> 和 \<complex\> 標頭會提供 UDL 運算子，方便您使用。  例如，123ms 表示 std::chrono::milliseconds\(123\)、"hello"s 表示 std::string\("hello"\) 和 3.14i 表示 std::complex\(0.0, 3.14\)。  
  
-   **Null 正向迭代器** 現在標準程式庫可建立不參考容器執行個體的正向迭代器。  已將這類迭代器初始化為值，並比較是否與特定容器類型相等。  將已初始化為值的迭代器和未初始化為值的另一個相比較尚未定義。  **\(C\+\+14\)**  
  
-   **quoted\(\)** 標準程式庫現在支援 quoted\(\) 函式，以方便使用引號括住的字串值和 I\/O。  在使用 quoted\(\) 的情況下，會把整個加引號的字串視為單一實體 \(如同非空格字元的字串是 I\/O 資料流\)；此外透過 I\/O 作業，逸出序列會保留下來。  **\(C\+\+14\)**  
  
-   **異質關聯查閱** 標準程式庫現在支援關聯容器的異質查閱函式。  只要類型與 key\_type 相當，這類函式可讓 key\_type 以外的類型查閱。  **\(C\+\+14\)**  
  
-   **編譯時期整數序列** 標準程式庫現在支援表示整數值序列的 integer\_sequence 類型，可以在編譯時期評估，讓使用參數封裝更方便，以及簡化特定範本的程式設計模式。  **\(C\+\+14\)**  
  
-   **exchange\(\)** 標準程式庫現在支援 std::exchange\(\) 公用程式函式，以指派新值給物件，並傳回其舊值。  對於複雜類型，當移動建構函式可用時，exchange\(\) 可避免複製舊值，如果它是暫存的或已移動，則可避免複製新值，以及在利用任何轉換指派運算子的新值時接受任何類型。  **\(C\+\+14\)**  
  
-   **雙重範圍 equal\(\)、is\_permutation\(\)、mismatch\(\)** 標準程式庫現在支援接受兩個範圍的 std::equal\(\)、std::is\_permutation\(\)，及 std::mismatch\(\) 的多載。  這些多載可讓您檢查兩個序列是否為相同的長度，免除呼叫程式碼對此的責任；若為不支援隨機迭代器需求的序列，這些多載會在比較項目時檢查長度，這會更有效率。  **\(C\+\+14\)**  
  
-   **get\<T\>\(\)** 標準程式庫現在支援 get\<T\>\(\) 樣板函式，以允許依其類型處理 tuple 項目。  如果 tuple 包含 2 個或多個相同類型的 get\<T\>\(\) 項目，則該類型無法由此 tuple 處理，但仍可處理類型是唯一的其他項目。  **\(C\+\+14\)**  
  
-   **tuple\_element\_t** 標準程式庫現在支援 tuple\_element\_t\<I, T\> 類型的別名，這是 typename tuple\_element\<I, T\>::type 的別名。  這會提供範本程式設計人員一些便利，類似於 \<type\_traits\> 中的其他 metafunction 類型別名。  **\(C\+\+14\)**  
  
-   **檔案系統 "V3" 技術規格** 檔案系統技術規格包含的實作已更新為此規格的第 3 版。  \[N3940\]  
  
-   **最小配置器** 標準程式庫現在全面支援最小配置器介面；值得注意的修正包含 std:: function、shared\_ptr、allocate\_shared\(\) 和 basic\_string。  **\(C\+\+11\)**  
  
-   **\<chrono\>** 已修正 high\_resolution\_clock 和 steady\_clock 的 chrono 類型。  **\(C\+\+11\)**  
  
-   **N2761 訊號處理常式中的原子 \(C\+\+11\)**  
  
-   **N3922 的新自動化規則附有括以大括號的初始清單。 \(C\+\+17\)**  
  
-   **N4051 範本之範本參數中的 typename， \(C\+\+17\)**  
  
-   **N4259 std::uncaught\_exceptions\(\)**  
  
-   **命名空間和列舉程式的 N4266 屬性**  
  
-   **N4267 u8 字元常值**  
  
###  <a name="BK_CRT"></a> C 執行階段程式庫  
 **CRT 程式庫重構**CRT 已重構為兩個部分。  **Universal CRT** 所含的程式碼會實作標準 C 執行階段程式庫。  Vcruntime140.dll \(或 .lib\) 包含特定版本之處理序啟動及例外狀況處理的程式碼。  Universal CRT 的 API 極為穩定，因此無須變更每版 Visual Studio 中的版本號碼，就能使用。  Universal CRT 目前是 Windows 作業系統元件，由 Windows Update 負責服務。  其已安裝在 Windows 10 中。  您可以利用 Visual C\+\+ 可轉散發套件 \(vcredist\)，將其與舊版 Windows 的應用程式一起散發。  
  
 **C99 一致性**除了任何相依於未受 Visual C\+\+ 編譯器支援之編譯器功能的程式庫功能之外 \(例如 \<tgmath.h\> 即未實作\)，[!INCLUDE[vs_dev14](../ide/includes/vs_dev14_md.md)] 會全面實作 C99 標準程式庫。  
  
 **效能**大部分的程式庫已經過重構，以簡化標頭檔巨集使用方式。  這會加快編譯和 IntelliSense，並改進可讀性。  此外，為了標準相容性及更佳的效能，許多 stdio 函式均已改寫。  
  
### 重大變更  
 這項 ISO C\/C\+\+ 標準改良支援可能需要變更現有的程式碼，以便其能夠符合 C\+\+11 與 C99 的規定，並能在 Visual Studio 2015 中正確編譯。  如需詳細資訊，請參閱[Visual C\+\+ 2015 的重大變更](../porting/visual-cpp-change-history-2003-20151.md)。  
  
 在 ppltasks.h 中，concurrency:: task 類型和相關的類型不再以 ConcRT 執行階段為基礎。  他們現在可以使用 Windows Threadpool 做為其排程器。  這只會影響 concurrency:: task 作業中使用 ConcRT 同步處理原始物件的程式碼。  這類程式碼應該改用 Windows 同步處理原始物件。  
  
 STL 的同步處理原始物件也不再以 ConcRT 為基礎。  若要避免死結，不要在像 **concurrency::parallel\_for** 的函式中或搭配 PPL 非同步代理程式類型時使用 STL 同步處理原始物件。  
  
##  <a name="BK_FasterBuildTimes"></a> 建置時間更短  
  
-   **累加連結時間程式碼產生 \(LTCG\)** 現在可一起使用累加連結及 LTCG 來減少應用程式使用 LTCG 的連結時間。  使用 \/LTCG 啟用這項功能：累加和 \/LTCG:incremental\_rebuild 連結器參數。  \\  
  
-   **對靜態程式庫的累加連結** 現在由其他程式碼模組所參考的靜態程式庫之變更會以累加方式連結。  
  
-   **\/Debug:FastLink** 藉由使用新的 PDB 建立技巧大幅減少連結時間。  
  
-   連結器的演算法已改良，以減少連結時間。  
  
-   已有更快建置範本大量程式碼的改良。  
  
-   **快速特性指引最佳化 \(PGO\) 檢測** PGO 中已經導入新的輕量型檢測模式來打造遊戲和即時的系統。  搭配其他在 \/GENPROFILE 和 \/FASTGETPROFILE 連結器參數中的新功能，當您使用 PGO 時，現在您可以在程式碼品質和建置速度之間取得平衡。  
  
-   **減少目的檔大小** 編譯器和 C\+\+ 標準程式庫增強功能會使目的檔和靜態程式庫大幅變小。  這些增強功能不會影響動態連結程式庫 \(DLL\) 或可執行檔 \(EXE\) 的大小，因為在過去已由連結器移除多餘的程式碼。  
  
##  <a name="BK_PerfCodeQuality"></a> 效能和程式碼品質  
  
-   **自動向量化的增強功能** 現在包含控制流程 \(if\-then\-else\) 的向量化、在 \/O1 \(最小大小\) 編譯時的向量化，並改進整體向量程式碼品質，包括支援平行 STL、向量化更大範圍架構下的 for 迴圈，以及支援 \#pragma loop\(ivdep\)。  
  
-   **純量最佳化的增強功能** 較佳的位元測試作業程式碼產生、控制流程合併和最佳化 \(loop\-if 切換\)，及其他純量的最佳化 \(例如，較佳的 std::min 和 std::max 程式碼產生\)。  
  
-   **特性指引最佳化 \(PGO\)** PGO 已有眾多的增強功能，包括改良的參考集，較佳的資料版面配置功能，以及能夠重複使用先前所做的 speed vs 內嵌。  大小和配置的決策。  
  
##  <a name="BK_IDE"></a> 產能、偵錯和診斷  
  
###  <a name="BK_SingleFileIntelliSense"></a> 單一檔案 IntelliSense  
 當您在編輯器中開啟單一原始程式碼檔案時，現在可以使用 IntelliSense，不需要開啟任何專案檔。  
  
###  <a name="BK_Refactoring"></a> 重構  
 藉由下列功能，我們已加入 C\+\+ 的重構支援：  
  
-   **重新命名符號** 變更一個符號的所有項目為新名稱。  
  
-   **函式擷取** 將選取的程式碼移入至它自己的函式。  這項重構功能可做為 Visual Studio Gallery 上的 Visual Studio 擴充功能。  
  
-   **實作純虛擬函式** 產生類別或結構繼承的純虛擬函式的函式定義。  支援多個與遞迴的繼承。  從繼承的類別定義啟用這項重構功能，以實作所有繼承的純虛擬函式，或只從基底類別規範實作該基底類別的純虛擬函式。  
  
-   **建立宣告或定義** 從現有的定義或現有宣告中的預設定義產生宣告。  從現有的宣告或定義，或從 LightBulb 指標存取這項重構。  
  
-   **移動函式定義** 在原始程式碼和標頭檔之間移動函式的主體。  從該函式的簽章啟用這項重構。  
  
-   **轉換成原始字串常值** 轉換包含逸出序列的字串成原始字串常值。  支援的逸出序列為 \\\\ \(反斜線\)、\\n \(新行\)、\\t \(定位字元\)、\\' \(單引號\)、\\" \(雙引號\) 和 \\?。  \(問號\)。  在字串內的任何位置按一下滑鼠右鍵，啟用這項功能。  
  
 已藉由讓後續的結果附加至先前的結果來改善檔案中尋找；可刪除累積的結果。  
  
 **IntelliSense 可讀性改進** 在參數說明及 QuickInfo 中的複雜樣板具現化和 typedef 已簡化，使其更容易閱讀。  
  
###  <a name="BK_PDB"></a> 程式資料庫的增強功能  
  
-   方案掃描速度已改進，特別是針對大型方案。  
  
-   除了在第一次開啟新方案時的初始方案掃描期間以外，在方案掃描期間，像是移至定義等的作業不會再受到封鎖。  
  
##  <a name="BK_Diagnostics"></a> 診斷  
  
1.  **偵錯工具視覺化** 加入 Natvis 偵錯工具視覺化到您的 Visual Studio 專案中，使管理和原始檔控制整合更輕鬆。  在偵錯工作階段期間，可編輯和儲存 Natvis 檔案，偵錯工具會自動選取變更。  如需詳細資訊，請參閱此[部落格文章](http://blogs.msdn.com/b/vcblog/archive/2014/06/12/project-support-for-natvis.aspx)。  
  
2.  **原生記憶體診斷**  
  
    1.  **記憶體診斷工作階段** \(Ctrl\+Alt\+F2\) 讓您能在偵錯工作階段期間，監視原生應用程式的即時記憶體使用。  
  
    2.  **記憶體快照** 擷取應用程式堆積內容的瞬間影像。  藉由比較兩個記憶體快照，可檢查堆積狀態中的差異。  在停止應用程式之後，檢視物件類型、 執行個體值和每個執行個體的呼叫堆疊配置。  依每個快照集的堆疊框架檢視呼叫樹狀圖。  
  
3.  **改善死結偵錯與復原** 當從監看式和即時運算視窗中呼叫 C\+\+ 函式之時。  
  
4.  **改善編譯器診斷** 編譯器會提供有關可疑程式碼的增強警告。  已加入新的警告 \(例如已遮蔽的變數和不相符的 printf 格式字串\)。  現有的警告訊息已更加清楚。  
  
5.  **\/Wv 旗標** 在特定的編譯器版本 XX.YY.ZZZZ 之後導入的警告可由 \/Wv:XX.YY.ZZZZ 旗標停用。  除了透過 \/Wv 旗標指定的警告以外，亦可特別停用其他警告。  
  
6.  **改善偵錯最佳化程式碼的支援** 已可用 \/Zi、 \/Zo 或 \/Z7 旗標偵錯程式碼。  
  
##  <a name="BK_Win10"></a> 以 Windows 10 為目標  
 現在 Visual Studio 支援在 C\+\+ 中以 Windows 10 為目標。  開發通用 Windows 應用程式的新專案範本支援以 Windows 10 裝置為目標，例如桌上型電腦、行動電話、平板電腦、HoloLens 和其他裝置。  如需詳細資訊，請參閱[在 Windows 10 中建立 "hello world" 應用程式](https://msdn.microsoft.com/en-us/library/windows/apps/dn996906.aspx)。  
  
##  <a name="BK_GraphicsDiagnostics"></a> 圖形診斷  
 已藉由下列功能改善圖形診斷：  
  
-   **DirectX12 的圖形診斷支援。** Visual Studio 圖形診斷工具現在支援偵錯 DirectX12 應用程式中的轉譯問題。  
  
-   **連續擷取** 在一次擷取中，擷取最多 30 個連續的畫面格。  
  
-   **程式設計擷取**啟動以程式設計方式擷取畫面格。  程式設計擷取特別適用於偵錯絕不呼叫存在的程式之計算著色器，或適用於當呈現問題很難手動擷取，但可透過程式設計方式從執行階段的應用程式狀態進行預測時。  
  
-   **增強圖形事件清單**已加入新的繪製呼叫檢視，可顯示階層架構組織過的繪製呼叫擷取事件和其狀態。  您可以展開繪製呼叫，以顯示繪製呼叫時的目前裝置狀態，而且可以進一步展開每種狀態類型，以顯示設定其值的事件。  
  
-   **適用於 Windows Phone 8.1 的支援** 現在圖形診斷完全支援在 Phone 模擬器中或在有行動網卡的電話中之 Windows Phone 8.1 應用程式偵錯。  
  
-   **圖形框架分析** 這項工具在擷取的框架上收集效能測量資料；另外它也會執行一組預先定義的實驗，可深入了解在套用各種不同的紋理技術時，效能會如何受影響。  畫面格分析也會從硬體收集效能計數器。  
  
-   **圖形分析的專用 UI** 新的 Visual Studio 圖形分析器視窗是分析圖形畫面格專用的工作區。  
  
-   **編輯及套用著色器** 不需重新執行應用程式，即可檢視在擷取記錄檔中的著色器程式碼變更之影響。  
  
-   在 \[工具\] \-\> \[選項\] \-\> \[圖形診斷\] 中設定擷取選項。  
  
-   擷取和重播畫面格的命令列工具。  
  
 如需詳細資訊，請參閱[圖形診斷 \(偵錯 DirectX 圖形\)](../Topic/Visual%20Studio%20Graphics%20Diagnostics.md)。  
  
##  <a name="BK_GPUUsage"></a> 新的 GPU 使用量工具  
 Visual Studio 2015 中的 GPU 使用量工具可用來了解 DirectX 應用程式的 GPU 使用量。  即時執行應用程式時，可使用畫面格時間、 畫面播放速率和 GPU 使用率圖表。  此外，藉由收集和分析詳細的 GPU 使用量資料，此工具可深入了解個別的 DirectX 事件之 CPU 和 GPU 執行時間，因此可用來判斷 CPU 或 GPU 是否為效能瓶頸。  請參閱 [GPU 使用量](../Topic/GPU%20Usage.md)。  
  
##  <a name="BK_MFC"></a> MFC 的新功能  
 您現在可以指定當使用者變更對話方塊的大小時，控制項如何自動調整大小並移動。  如需詳細資訊，請參閱[動態版面配置](../mfc/dynamic-layout.md)。  
  
## 請參閱  
 [Visual Studio 2015 的新功能](../Topic/What's%20New%20in%20Visual%20Studio%202015.md)   
 [Visual C\+\+ Team 部落格](http://blogs.msdn.com/b/vcblog/)